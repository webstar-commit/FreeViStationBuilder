(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["claraplayer"] = factory();
	else
		root["claraplayer"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp_name_"];
/******/ 	window["webpackJsonp_name_"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		1: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + ({"0":"configuratorui"}[chunkId]||chunkId) + "." + {"0":"70bb175c179316354c58"}[chunkId] + ".js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 720);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _epsilon = __webpack_require__(259);

var _epsilon2 = _interopRequireDefault(_epsilon);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

function Vector2(x, y) {

  this.x = x || 0;
  this.y = y || 0;
}

Vector2.prototype = {

  constructor: Vector2,

  isVector2: true,

  get width() {

    return this.x;
  },

  set width(value) {

    this.x = value;
  },

  get height() {

    return this.y;
  },

  set height(value) {

    this.y = value;
  },

  //

  set: function set(x, y) {

    this.x = x;
    this.y = y;

    return this;
  },

  setScalar: function setScalar(scalar) {

    this.x = scalar;
    this.y = scalar;

    return this;
  },

  setX: function setX(x) {

    this.x = x;

    return this;
  },

  setY: function setY(y) {

    this.y = y;

    return this;
  },

  setComponent: function setComponent(index, value) {

    switch (index) {

      case 0:
        this.x = value;break;
      case 1:
        this.y = value;break;
      default:
        throw new Error('index is out of range: ' + index);

    }

    return this;
  },

  getComponent: function getComponent(index) {

    switch (index) {

      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error('index is out of range: ' + index);

    }
  },

  clone: function clone() {

    return new this.constructor(this.x, this.y);
  },

  copy: function copy(v) {

    this.x = v.x;
    this.y = v.y;

    return this;
  },

  add: function add(v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;

    return this;
  },

  addScalar: function addScalar(s) {

    this.x += s;
    this.y += s;

    return this;
  },

  addVectors: function addVectors(a, b) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;

    return this;
  },

  addScaledVector: function addScaledVector(v, s) {

    this.x += v.x * s;
    this.y += v.y * s;

    return this;
  },

  sub: function sub(v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;

    return this;
  },

  subScalar: function subScalar(s) {

    this.x -= s;
    this.y -= s;

    return this;
  },

  subVectors: function subVectors(a, b) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;
  },

  multiply: function multiply(v) {

    this.x *= v.x;
    this.y *= v.y;

    return this;
  },

  multiplyScalar: function multiplyScalar(scalar) {

    if (isFinite(scalar)) {

      this.x *= scalar;
      this.y *= scalar;
    } else {

      this.x = 0;
      this.y = 0;
    }

    return this;
  },

  divide: function divide(v) {

    this.x /= v.x;
    this.y /= v.y;

    return this;
  },

  divideScalar: function divideScalar(scalar) {

    return this.multiplyScalar(1 / scalar);
  },

  min: function min(v) {

    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);

    return this;
  },

  max: function max(v) {

    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);

    return this;
  },

  clamp: function clamp(min, max) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));

    return this;
  },

  clampScalar: function () {

    var min, max;

    return function clampScalar(minVal, maxVal) {

      if (min === undefined) {

        min = new Vector2();
        max = new Vector2();
      }

      min.set(minVal, minVal);
      max.set(maxVal, maxVal);

      return this.clamp(min, max);
    };
  }(),

  clampLength: function clampLength(min, max) {

    var length = this.length();

    return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
  },

  floor: function floor() {

    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);

    return this;
  },

  ceil: function ceil() {

    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);

    return this;
  },

  round: function round() {

    this.x = Math.round(this.x);
    this.y = Math.round(this.y);

    return this;
  },

  roundToZero: function roundToZero() {

    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);

    return this;
  },

  negate: function negate() {

    this.x = -this.x;
    this.y = -this.y;

    return this;
  },

  dot: function dot(v) {

    return this.x * v.x + this.y * v.y;
  },

  lengthSq: function lengthSq() {

    return this.x * this.x + this.y * this.y;
  },

  length: function length() {

    return Math.sqrt(this.x * this.x + this.y * this.y);
  },

  lengthManhattan: function lengthManhattan() {

    return Math.abs(this.x) + Math.abs(this.y);
  },

  normalize: function normalize() {

    return this.divideScalar(this.length());
  },

  angle: function angle() {

    // computes the angle in radians with respect to the positive x-axis

    var angle = Math.atan2(this.y, this.x);

    if (angle < 0) angle += 2 * Math.PI;

    return angle;
  },

  distanceTo: function distanceTo(v) {

    return Math.sqrt(this.distanceToSquared(v));
  },

  distanceToSquared: function distanceToSquared(v) {

    var dx = this.x - v.x,
        dy = this.y - v.y;
    return dx * dx + dy * dy;
  },

  distanceToManhattan: function distanceToManhattan(v) {

    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  },

  setLength: function setLength(length) {

    return this.multiplyScalar(length / this.length());
  },

  lerp: function lerp(v, alpha) {

    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;

    return this;
  },

  lerpVectors: function lerpVectors(v1, v2, alpha) {

    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },

  equals: function equals(v) {

    return v.x === this.x && v.y === this.y;
  },

  fromArray: function fromArray(array, offset) {

    if (offset === undefined) offset = 0;

    this.x = array[offset];
    this.y = array[offset + 1];

    return this;
  },

  toArray: function toArray(array, offset) {

    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;

    array[offset] = this.x;
    array[offset + 1] = this.y;

    return array;
  },

  fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {

    if (offset !== undefined) {

      console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);

    return this;
  },

  rotateAround: function rotateAround(center, angle) {

    var c = Math.cos(angle),
        s = Math.sin(angle);

    var x = this.x - center.x;
    var y = this.y - center.y;

    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;

    return this;
  }

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _Math = {

  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,

  generateUUID: function () {

    // http://www.broofa.com/Tools/Math.uuid.htm

    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
    var uuid = new Array(36);
    var rnd = 0,
        r;

    return function generateUUID() {

      for (var i = 0; i < 36; i++) {

        if (i === 8 || i === 13 || i === 18 || i === 23) {

          uuid[i] = '-';
        } else if (i === 14) {

          uuid[i] = '4';
        } else {

          if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;
          r = rnd & 0xf;
          rnd = rnd >> 4;
          uuid[i] = chars[i === 19 ? r & 0x3 | 0x8 : r];
        }
      }

      return uuid.join('');
    };
  }(),

  clamp: function clamp(value, min, max) {

    return Math.max(min, Math.min(max, value));
  },

  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation

  euclideanModulo: function euclideanModulo(n, m) {

    return (n % m + m) % m;
  },

  // Linear mapping from range <a1, a2> to range <b1, b2>

  mapLinear: function mapLinear(x, a1, a2, b1, b2) {

    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },

  // https://en.wikipedia.org/wiki/Linear_interpolation

  lerp: function lerp(x, y, t) {

    return (1 - t) * x + t * y;
  },

  // http://en.wikipedia.org/wiki/Smoothstep

  smoothstep: function smoothstep(x, min, max) {

    if (x <= min) return 0;
    if (x >= max) return 1;

    x = (x - min) / (max - min);

    return x * x * (3 - 2 * x);
  },

  smootherstep: function smootherstep(x, min, max) {

    if (x <= min) return 0;
    if (x >= max) return 1;

    x = (x - min) / (max - min);

    return x * x * x * (x * (x * 6 - 15) + 10);
  },

  // Random integer from <low, high> interval

  randInt: function randInt(low, high) {

    return low + Math.floor(Math.random() * (high - low + 1));
  },

  // Random float from <low, high> interval

  randFloat: function randFloat(low, high) {

    return low + Math.random() * (high - low);
  },

  // Random float from <-range/2, range/2> interval

  randFloatSpread: function randFloatSpread(range) {

    return range * (0.5 - Math.random());
  },

  degToRad: function degToRad(degrees) {

    return degrees * _Math.DEG2RAD;
  },

  radToDeg: function radToDeg(radians) {

    return radians * _Math.RAD2DEG;
  },

  isPowerOfTwo: function isPowerOfTwo(value) {

    return (value & value - 1) === 0 && value !== 0;
  },

  nearestPowerOfTwo: function nearestPowerOfTwo(value) {

    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
  },

  nextPowerOfTwo: function nextPowerOfTwo(value) {

    value--;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value++;

    return value;
  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {

  this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

  if (arguments.length > 0) {

    console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
  }
}

Matrix4.prototype = {

  constructor: Matrix4,

  isMatrix4: true,

  set: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {

    var te = this.elements;

    te[0] = n11;te[4] = n12;te[8] = n13;te[12] = n14;
    te[1] = n21;te[5] = n22;te[9] = n23;te[13] = n24;
    te[2] = n31;te[6] = n32;te[10] = n33;te[14] = n34;
    te[3] = n41;te[7] = n42;te[11] = n43;te[15] = n44;

    return this;
  },

  identity: function identity() {

    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

    return this;
  },

  clone: function clone() {

    return new Matrix4().fromArray(this.elements);
  },

  copy: function copy(m) {

    this.elements.set(m.elements);

    return this;
  },

  copyPosition: function copyPosition(m) {

    var te = this.elements;
    var me = m.elements;

    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];

    return this;
  },

  extractBasis: function extractBasis(xAxis, yAxis, zAxis) {

    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);

    return this;
  },

  makeBasis: function makeBasis(xAxis, yAxis, zAxis) {

    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);

    return this;
  },

  extractRotation: function () {

    var v1;

    return function extractRotation(m) {

      if (v1 === undefined) v1 = new Vector3();

      var te = this.elements;
      var me = m.elements;

      var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
      var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
      var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();

      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;

      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;

      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;

      return this;
    };
  }(),

  makeRotationFromEuler: function makeRotationFromEuler(euler) {

    if ((euler && euler.isEuler) === false) {

      console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }

    var te = this.elements;

    var x = euler.x,
        y = euler.y,
        z = euler.z;
    var a = Math.cos(x),
        b = Math.sin(x);
    var c = Math.cos(y),
        d = Math.sin(y);
    var e = Math.cos(z),
        f = Math.sin(z);

    if (euler.order === 'XYZ') {

      var ae = a * e,
          af = a * f,
          be = b * e,
          bf = b * f;

      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;

      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;

      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {

      var ce = c * e,
          cf = c * f,
          de = d * e,
          df = d * f;

      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;

      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;

      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {

      var ce = c * e,
          cf = c * f,
          de = d * e,
          df = d * f;

      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;

      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;

      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {

      var ae = a * e,
          af = a * f,
          be = b * e,
          bf = b * f;

      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;

      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;

      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {

      var ac = a * c,
          ad = a * d,
          bc = b * c,
          bd = b * d;

      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;

      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;

      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {

      var ac = a * c,
          ad = a * d,
          bc = b * c,
          bd = b * d;

      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;

      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;

      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }

    // last column
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;

    // bottom row
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;

    return this;
  },

  makeRotationFromQuaternion: function makeRotationFromQuaternion(q) {

    var te = this.elements;

    var x = q.x,
        y = q.y,
        z = q.z,
        w = q.w;
    var x2 = x + x,
        y2 = y + y,
        z2 = z + z;
    var xx = x * x2,
        xy = x * y2,
        xz = x * z2;
    var yy = y * y2,
        yz = y * z2,
        zz = z * z2;
    var wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    te[0] = 1 - (yy + zz);
    te[4] = xy - wz;
    te[8] = xz + wy;

    te[1] = xy + wz;
    te[5] = 1 - (xx + zz);
    te[9] = yz - wx;

    te[2] = xz - wy;
    te[6] = yz + wx;
    te[10] = 1 - (xx + yy);

    // last column
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;

    // bottom row
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;

    return this;
  },

  lookAt: function () {

    var x, y, z;

    return function lookAt(eye, target, up) {

      if (x === undefined) {

        x = new Vector3();
        y = new Vector3();
        z = new Vector3();
      }

      var te = this.elements;

      z.subVectors(eye, target).normalize();

      if (z.lengthSq() === 0) {

        z.z = 1;
      }

      x.crossVectors(up, z).normalize();

      if (x.lengthSq() === 0) {

        z.z += 0.0001;
        x.crossVectors(up, z).normalize();
      }

      y.crossVectors(z, x);

      te[0] = x.x;te[4] = y.x;te[8] = z.x;
      te[1] = x.y;te[5] = y.y;te[9] = z.y;
      te[2] = x.z;te[6] = y.z;te[10] = z.z;

      return this;
    };
  }(),

  multiply: function multiply(m, n) {

    if (n !== undefined) {

      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }

    return this.multiplyMatrices(this, m);
  },

  premultiply: function premultiply(m) {

    return this.multiplyMatrices(m, this);
  },

  multiplyMatrices: function multiplyMatrices(a, b) {

    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;

    var a11 = ae[0],
        a12 = ae[4],
        a13 = ae[8],
        a14 = ae[12];
    var a21 = ae[1],
        a22 = ae[5],
        a23 = ae[9],
        a24 = ae[13];
    var a31 = ae[2],
        a32 = ae[6],
        a33 = ae[10],
        a34 = ae[14];
    var a41 = ae[3],
        a42 = ae[7],
        a43 = ae[11],
        a44 = ae[15];

    var b11 = be[0],
        b12 = be[4],
        b13 = be[8],
        b14 = be[12];
    var b21 = be[1],
        b22 = be[5],
        b23 = be[9],
        b24 = be[13];
    var b31 = be[2],
        b32 = be[6],
        b33 = be[10],
        b34 = be[14];
    var b41 = be[3],
        b42 = be[7],
        b43 = be[11],
        b44 = be[15];

    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    return this;
  },

  multiplyToArray: function multiplyToArray(a, b, r) {

    var te = this.elements;

    this.multiplyMatrices(a, b);

    r[0] = te[0];r[1] = te[1];r[2] = te[2];r[3] = te[3];
    r[4] = te[4];r[5] = te[5];r[6] = te[6];r[7] = te[7];
    r[8] = te[8];r[9] = te[9];r[10] = te[10];r[11] = te[11];
    r[12] = te[12];r[13] = te[13];r[14] = te[14];r[15] = te[15];

    return this;
  },

  multiplyScalar: function multiplyScalar(s) {

    var te = this.elements;

    te[0] *= s;te[4] *= s;te[8] *= s;te[12] *= s;
    te[1] *= s;te[5] *= s;te[9] *= s;te[13] *= s;
    te[2] *= s;te[6] *= s;te[10] *= s;te[14] *= s;
    te[3] *= s;te[7] *= s;te[11] *= s;te[15] *= s;

    return this;
  },

  applyToBufferAttribute: function () {

    var v1;

    return function applyToBufferAttribute(attribute) {

      if (v1 === undefined) v1 = new Vector3();

      for (var i = 0, l = attribute.count; i < l; i++) {

        v1.x = attribute.getX(i);
        v1.y = attribute.getY(i);
        v1.z = attribute.getZ(i);

        v1.applyMatrix4(this);

        attribute.setXYZ(i, v1.x, v1.y, v1.z);
      }

      return attribute;
    };
  }(),

  determinant: function determinant() {

    var te = this.elements;

    var n11 = te[0],
        n12 = te[4],
        n13 = te[8],
        n14 = te[12];
    var n21 = te[1],
        n22 = te[5],
        n23 = te[9],
        n24 = te[13];
    var n31 = te[2],
        n32 = te[6],
        n33 = te[10],
        n34 = te[14];
    var n41 = te[3],
        n42 = te[7],
        n43 = te[11],
        n44 = te[15];

    //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },

  transpose: function transpose() {

    var te = this.elements;
    var tmp;

    tmp = te[1];te[1] = te[4];te[4] = tmp;
    tmp = te[2];te[2] = te[8];te[8] = tmp;
    tmp = te[6];te[6] = te[9];te[9] = tmp;

    tmp = te[3];te[3] = te[12];te[12] = tmp;
    tmp = te[7];te[7] = te[13];te[13] = tmp;
    tmp = te[11];te[11] = te[14];te[14] = tmp;

    return this;
  },

  setPosition: function setPosition(v) {

    var te = this.elements;

    te[12] = v.x;
    te[13] = v.y;
    te[14] = v.z;

    return this;
  },

  getInverse: function getInverse(m, throwOnDegenerate) {

    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    var te = this.elements,
        me = m.elements,
        n11 = me[0],
        n21 = me[1],
        n31 = me[2],
        n41 = me[3],
        n12 = me[4],
        n22 = me[5],
        n32 = me[6],
        n42 = me[7],
        n13 = me[8],
        n23 = me[9],
        n33 = me[10],
        n43 = me[11],
        n14 = me[12],
        n24 = me[13],
        n34 = me[14],
        n44 = me[15],
        t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
        t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
        t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
        t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    if (det === 0) {

      var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

      if (throwOnDegenerate === true) {

        throw new Error(msg);
      } else {

        console.warn(msg);
      }

      return this.identity();
    }

    var detInv = 1 / det;

    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;

    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;

    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;

    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;

    return this;
  },

  scale: function scale(v) {

    var te = this.elements;
    var x = v.x,
        y = v.y,
        z = v.z;

    te[0] *= x;te[4] *= y;te[8] *= z;
    te[1] *= x;te[5] *= y;te[9] *= z;
    te[2] *= x;te[6] *= y;te[10] *= z;
    te[3] *= x;te[7] *= y;te[11] *= z;

    return this;
  },

  getMaxScaleOnAxis: function getMaxScaleOnAxis() {

    var te = this.elements;

    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  },

  makeTranslation: function makeTranslation(x, y, z) {

    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);

    return this;
  },

  makeRotationX: function makeRotationX(theta) {

    var c = Math.cos(theta),
        s = Math.sin(theta);

    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);

    return this;
  },

  makeRotationY: function makeRotationY(theta) {

    var c = Math.cos(theta),
        s = Math.sin(theta);

    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);

    return this;
  },

  makeRotationZ: function makeRotationZ(theta) {

    var c = Math.cos(theta),
        s = Math.sin(theta);

    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

    return this;
  },

  makeRotationAxis: function makeRotationAxis(axis, angle) {

    // Based on http://www.gamedev.net/reference/articles/article1199.asp

    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = 1 - c;
    var x = axis.x,
        y = axis.y,
        z = axis.z;
    var tx = t * x,
        ty = t * y;

    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);

    return this;
  },

  makeScale: function makeScale(x, y, z) {

    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);

    return this;
  },

  makeShear: function makeShear(xy, xz, yz, reserveStyle) {

    this.set(1, xy, xz, 0, 0, 1, yz, 0, 0, 0, 1, 0, 0, 0, 0, 1);

    if (reserveStyle) this.transpose();

    return this;
  },

  compose: function compose(position, quaternion, scale, shear) {

    this.makeRotationFromQuaternion(quaternion);
    if (shear) {
      this.multiply(new Matrix4().makeShear(shear.x, shear.y, shear.z));
    }
    this.scale(scale);
    this.setPosition(position);

    return this;
  },

  decompose: function () {

    var vector, matrix;

    return function decompose(position, quaternion, scale, shear) {

      if (shear) {
        return this.decompose2(position, quaternion, scale, shear);
      }

      if (vector === undefined) {

        vector = new Vector3();
        matrix = new Matrix4();
      }

      var te = this.elements;

      var sx = vector.set(te[0], te[1], te[2]).length();
      var sy = vector.set(te[4], te[5], te[6]).length();
      var sz = vector.set(te[8], te[9], te[10]).length();

      // if determinant is negative, we need to invert one scale
      var det = this.determinant();
      if (det < 0) {

        sx = -sx;
      }

      position.x = te[12];
      position.y = te[13];
      position.z = te[14];

      // scale the rotation part

      matrix.elements.set(this.elements); // at this point matrix is incomplete so we can't use .copy()

      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;

      matrix.elements[0] *= invSX;
      matrix.elements[1] *= invSX;
      matrix.elements[2] *= invSX;

      matrix.elements[4] *= invSY;
      matrix.elements[5] *= invSY;
      matrix.elements[6] *= invSY;

      matrix.elements[8] *= invSZ;
      matrix.elements[9] *= invSZ;
      matrix.elements[10] *= invSZ;

      quaternion.setFromRotationMatrix(matrix);

      scale.x = sx;
      scale.y = sy;
      scale.z = sz;

      return this;
    };
  }(),

  // Transformations.py, decompose_matrix
  // Source code also handles perspective partition of matrix
  // Laboratory for Fluorescence Dynamics, University of California, Irvine
  // Reference: http://www.lfd.uci.edu/~gohlke/code/transformations.py.html
  decompose2: function () {

    return function decompose2(position, quaternion, scale, shear) {

      var p = this.clone();
      p[3] = 0;p[7] = 0;p[11] = 0;
      p[15] = 1;
      var det = p.determinant();

      if (det === 0) {

        console.error("THREE.Matrix4.decompose2(): Cannot apply decompose2 on singular matrix");
        return this;
      }

      var matrix = new Matrix4().copy(this);
      var me = matrix.elements;

      position.set(me[12], me[13], me[14]);
      me[12] = me[13] = me[14] = 0;

      var xAxis = new Vector3(me[0], me[1], me[2]);
      var yAxis = new Vector3(me[4], me[5], me[6]);
      var zAxis = new Vector3(me[8], me[9], me[10]);

      scale.setX(xAxis.length());
      xAxis.divideScalar(scale.x);
      shear.setX(xAxis.dot(yAxis));
      yAxis.sub(xAxis.clone().multiplyScalar(shear.x));
      scale.setY(yAxis.length());
      yAxis.divideScalar(scale.y);
      shear.setX(shear.x / scale.y);
      shear.setY(xAxis.dot(zAxis));
      zAxis.sub(xAxis.clone().multiplyScalar(shear.y));
      shear.setZ(yAxis.dot(zAxis));
      zAxis.sub(yAxis.clone().multiplyScalar(shear.z));
      scale.setZ(zAxis.length());
      zAxis.divideScalar(scale.z);
      shear.setY(shear.y / scale.z);
      shear.setZ(shear.z / scale.z);

      me[0] = xAxis.x;me[4] = yAxis.x;me[8] = zAxis.x;
      me[1] = xAxis.y;me[5] = yAxis.y;me[9] = zAxis.y;
      me[2] = xAxis.z;me[6] = yAxis.z;me[10] = zAxis.z;

      if (xAxis.dot(new Vector3().crossVectors(yAxis, zAxis)) < 0) {
        scale.multiplyScalar(-1);
        matrix.multiplyScalar(-1);
      }

      quaternion.setFromRotationMatrix(matrix);

      return this;
    };
  }(),

  makePerspective: function makePerspective(left, right, top, bottom, near, far) {

    if (far === undefined) {

      console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
    }

    var te = this.elements;
    var x = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);

    var a = (right + left) / (right - left);
    var b = (top + bottom) / (top - bottom);
    var c = -(far + near) / (far - near);
    var d = -2 * far * near / (far - near);

    te[0] = x;te[4] = 0;te[8] = a;te[12] = 0;
    te[1] = 0;te[5] = y;te[9] = b;te[13] = 0;
    te[2] = 0;te[6] = 0;te[10] = c;te[14] = d;
    te[3] = 0;te[7] = 0;te[11] = -1;te[15] = 0;

    return this;
  },

  makeOrthographic: function makeOrthographic(left, right, top, bottom, near, far) {

    var te = this.elements;
    var w = 1.0 / (right - left);
    var h = 1.0 / (top - bottom);
    var p = 1.0 / (far - near);

    var x = (right + left) * w;
    var y = (top + bottom) * h;
    var z = (far + near) * p;

    te[0] = 2 * w;te[4] = 0;te[8] = 0;te[12] = -x;
    te[1] = 0;te[5] = 2 * h;te[9] = 0;te[13] = -y;
    te[2] = 0;te[6] = 0;te[10] = -2 * p;te[14] = -z;
    te[3] = 0;te[7] = 0;te[11] = 0;te[15] = 1;

    return this;
  },

  equals: function equals(matrix) {

    var te = this.elements;
    var me = matrix.elements;

    for (var i = 0; i < 16; i++) {

      if (te[i] !== me[i]) return false;
    }

    return true;
  },

  fromArray: function fromArray(array, offset) {

    if (offset === undefined) offset = 0;

    for (var i = 0; i < 16; i++) {

      this.elements[i] = array[i + offset];
    }

    return this;
  },

  toArray: function toArray(array, offset) {

    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;

    var te = this.elements;

    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];

    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];

    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];

    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];

    return array;
  }

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion(x, y, z, w) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = w !== undefined ? w : 1;
}

Quaternion.prototype = {

  constructor: Quaternion,

  get x() {

    return this._x;
  },

  set x(value) {

    this._x = value;
    this.onChangeCallback();
  },

  get y() {

    return this._y;
  },

  set y(value) {

    this._y = value;
    this.onChangeCallback();
  },

  get z() {

    return this._z;
  },

  set z(value) {

    this._z = value;
    this.onChangeCallback();
  },

  get w() {

    return this._w;
  },

  set w(value) {

    this._w = value;
    this.onChangeCallback();
  },

  set: function set(x, y, z, w) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this.onChangeCallback();

    return this;
  },

  clone: function clone() {

    return new this.constructor(this._x, this._y, this._z, this._w);
  },

  copy: function copy(quaternion) {

    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this.onChangeCallback();

    return this;
  },

  setFromEuler: function setFromEuler(euler, update) {

    if ((euler && euler.isEuler) === false) {

      throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    var c1 = Math.cos(euler._x / 2);
    var c2 = Math.cos(euler._y / 2);
    var c3 = Math.cos(euler._z / 2);
    var s1 = Math.sin(euler._x / 2);
    var s2 = Math.sin(euler._y / 2);
    var s3 = Math.sin(euler._z / 2);

    var order = euler.order;

    if (order === 'XYZ') {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'YXZ') {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'ZXY') {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'ZYX') {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'YZX') {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'XZY') {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;
    }

    if (update !== false) this.onChangeCallback();

    return this;
  },

  setFromAxisAngle: function setFromAxisAngle(axis, angle) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    // assumes axis is normalized

    var halfAngle = angle / 2,
        s = Math.sin(halfAngle);

    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);

    this.onChangeCallback();

    return this;
  },

  setFromRotationMatrix: function setFromRotationMatrix(m) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10],
        trace = m11 + m22 + m33,
        s;

    if (trace > 0) {

      s = 0.5 / Math.sqrt(trace + 1.0);

      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {

      s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {

      s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {

      s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this.onChangeCallback();

    return this;
  },

  setFromUnitVectors: function () {

    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;

    var EPS = 0.000001;

    return function setFromUnitVectors(vFrom, vTo) {

      if (v1 === undefined) v1 = new Vector3();

      r = vFrom.dot(vTo) + 1;

      if (r < EPS) {

        r = 0;

        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {

          v1.set(-vFrom.y, vFrom.x, 0);
        } else {

          v1.set(0, -vFrom.z, vFrom.y);
        }
      } else {

        v1.crossVectors(vFrom, vTo);
      }

      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;

      return this.normalize();
    };
  }(),

  inverse: function inverse() {

    return this.conjugate().normalize();
  },

  conjugate: function conjugate() {

    this._x *= -1;
    this._y *= -1;
    this._z *= -1;

    this.onChangeCallback();

    return this;
  },

  dot: function dot(v) {

    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  },

  lengthSq: function lengthSq() {

    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },

  length: function length() {

    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },

  normalize: function normalize() {

    var l = this.length();

    if (l === 0) {

      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {

      l = 1 / l;

      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this.onChangeCallback();

    return this;
  },

  multiply: function multiply(q, p) {

    if (p !== undefined) {

      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }

    return this.multiplyQuaternions(this, q);
  },

  premultiply: function premultiply(q) {

    return this.multiplyQuaternions(q, this);
  },

  multiplyQuaternions: function multiplyQuaternions(a, b) {

    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a._x,
        qay = a._y,
        qaz = a._z,
        qaw = a._w;
    var qbx = b._x,
        qby = b._y,
        qbz = b._z,
        qbw = b._w;

    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this.onChangeCallback();

    return this;
  },

  slerp: function slerp(qb, t) {

    if (t === 0) return this;
    if (t === 1) return this.copy(qb);

    var x = this._x,
        y = this._y,
        z = this._z,
        w = this._w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {

      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;

      cosHalfTheta = -cosHalfTheta;
    } else {

      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {

      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;

      return this;
    }

    var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    if (Math.abs(sinHalfTheta) < 0.001) {

      this._w = 0.5 * (w + this._w);
      this._x = 0.5 * (x + this._x);
      this._y = 0.5 * (y + this._y);
      this._z = 0.5 * (z + this._z);

      return this;
    }

    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
        ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;

    this.onChangeCallback();

    return this;
  },

  equals: function equals(quaternion) {

    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },

  fromArray: function fromArray(array, offset) {

    if (offset === undefined) offset = 0;

    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];

    this.onChangeCallback();

    return this;
  },

  toArray: function toArray(array, offset) {

    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;

    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;

    return array;
  },

  onChange: function onChange(callback) {

    this.onChangeCallback = callback;

    return this;
  },

  onChangeCallback: function onChangeCallback() {}

};

(0, _assign2.default)(Quaternion, {

  slerp: function slerp(qa, qb, qm, t) {

    return qm.copy(qa).slerp(qb, t);
  },

  slerpFlat: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {

    // fuzz-free, array-based Quaternion SLERP operation

    var x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3],
        x1 = src1[srcOffset1 + 0],
        y1 = src1[srcOffset1 + 1],
        z1 = src1[srcOffset1 + 2],
        w1 = src1[srcOffset1 + 3];

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {

      var s = 1 - t,
          cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
          dir = cos >= 0 ? 1 : -1,
          sqrSin = 1 - cos * cos;

      // Skip the Slerp for tiny steps to avoid numeric problems:
      if (sqrSin > _epsilon2.default) {

        var sin = Math.sqrt(sqrSin),
            len = Math.atan2(sin, cos * dir);

        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      var tDir = t * dir;

      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;

      // Normalize in case we just did a lerp:
      if (s === 1 - t) {

        var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);

        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }

});

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector3(x, y, z) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
}

Vector3.prototype = {

  constructor: Vector3,

  isVector3: true,

  set: function set(x, y, z) {

    this.x = x;
    this.y = y;
    this.z = z;

    return this;
  },

  setScalar: function setScalar(scalar) {

    this.x = scalar;
    this.y = scalar;
    this.z = scalar;

    return this;
  },

  setX: function setX(x) {

    this.x = x;

    return this;
  },

  setY: function setY(y) {

    this.y = y;

    return this;
  },

  setZ: function setZ(z) {

    this.z = z;

    return this;
  },

  setComponent: function setComponent(index, value) {

    switch (index) {

      case 0:
        this.x = value;break;
      case 1:
        this.y = value;break;
      case 2:
        this.z = value;break;
      default:
        throw new Error('index is out of range: ' + index);

    }

    return this;
  },

  getComponent: function getComponent(index) {

    switch (index) {

      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error('index is out of range: ' + index);

    }
  },

  clone: function clone() {

    return new this.constructor(this.x, this.y, this.z);
  },

  copy: function copy(v) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;
  },

  add: function add(v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;
  },

  addScalar: function addScalar(s) {

    this.x += s;
    this.y += s;
    this.z += s;

    return this;
  },

  addVectors: function addVectors(a, b) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;

    return this;
  },

  addScaledVector: function addScaledVector(v, s) {

    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;

    return this;
  },

  sub: function sub(v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;
  },

  subScalar: function subScalar(s) {

    this.x -= s;
    this.y -= s;
    this.z -= s;

    return this;
  },

  subVectors: function subVectors(a, b) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;

    return this;
  },

  multiply: function multiply(v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;

    return this;
  },

  multiplyScalar: function multiplyScalar(scalar) {

    if (isFinite(scalar)) {

      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;
    }

    return this;
  },

  multiplyVectors: function multiplyVectors(a, b) {

    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;

    return this;
  },

  applyEuler: function () {

    var quaternion;

    return function applyEuler(euler) {

      if ((euler && euler.isEuler) === false) {

        console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
      }

      if (quaternion === undefined) quaternion = new Quaternion();

      return this.applyQuaternion(quaternion.setFromEuler(euler));
    };
  }(),

  applyAxisAngle: function () {

    var quaternion;

    return function applyAxisAngle(axis, angle) {

      if (quaternion === undefined) quaternion = new Quaternion();

      return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
    };
  }(),

  applyMatrix3: function applyMatrix3(m) {

    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;

    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;

    return this;
  },

  applyMatrix4: function applyMatrix4(m) {

    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;

    this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
    var w = e[3] * x + e[7] * y + e[11] * z + e[15];

    return this.divideScalar(w);
  },

  applyQuaternion: function applyQuaternion(q) {

    var x = this.x,
        y = this.y,
        z = this.z;
    var qx = q.x,
        qy = q.y,
        qz = q.z,
        qw = q.w;

    // calculate quat * vector

    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

    return this;
  },

  project: function () {

    var matrix;

    return function project(camera) {

      if (matrix === undefined) matrix = new Matrix4();

      matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
      return this.applyMatrix4(matrix);
    };
  }(),

  unproject: function () {

    var matrix;

    return function unproject(camera) {

      if (matrix === undefined) matrix = new Matrix4();

      matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
      return this.applyMatrix4(matrix);
    };
  }(),

  transformDirection: function transformDirection(m) {

    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    var x = this.x,
        y = this.y,
        z = this.z;
    var e = m.elements;

    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;

    return this.normalize();
  },

  divide: function divide(v) {

    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;

    return this;
  },

  divideScalar: function divideScalar(scalar) {

    return this.multiplyScalar(1 / scalar);
  },

  min: function min(v) {

    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);

    return this;
  },

  max: function max(v) {

    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);

    return this;
  },

  clamp: function clamp(min, max) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));

    return this;
  },

  clampScalar: function () {

    var min, max;

    return function clampScalar(minVal, maxVal) {

      if (min === undefined) {

        min = new Vector3();
        max = new Vector3();
      }

      min.set(minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal);

      return this.clamp(min, max);
    };
  }(),

  clampLength: function clampLength(min, max) {

    var length = this.length();

    return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
  },

  floor: function floor() {

    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);

    return this;
  },

  ceil: function ceil() {

    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);

    return this;
  },

  round: function round() {

    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);

    return this;
  },

  roundToZero: function roundToZero() {

    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);

    return this;
  },

  negate: function negate() {

    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;

    return this;
  },

  dot: function dot(v) {

    return this.x * v.x + this.y * v.y + this.z * v.z;
  },

  lengthSq: function lengthSq() {

    return this.x * this.x + this.y * this.y + this.z * this.z;
  },

  length: function length() {

    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },

  lengthManhattan: function lengthManhattan() {

    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },

  normalize: function normalize() {

    return this.divideScalar(this.length());
  },

  setLength: function setLength(length) {

    return this.multiplyScalar(length / this.length());
  },

  lerp: function lerp(v, alpha) {

    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;

    return this;
  },

  lerpVectors: function lerpVectors(v1, v2, alpha) {

    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },

  cross: function cross(v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }

    var x = this.x,
        y = this.y,
        z = this.z;

    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;

    return this;
  },

  crossVectors: function crossVectors(a, b) {

    var ax = a.x,
        ay = a.y,
        az = a.z;
    var bx = b.x,
        by = b.y,
        bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;
  },

  projectOnVector: function projectOnVector(vector) {

    var scalar = vector.dot(this) / vector.lengthSq();

    return this.copy(vector).multiplyScalar(scalar);
  },

  projectOnPlane: function () {

    var v1;

    return function projectOnPlane(planeNormal) {

      if (v1 === undefined) v1 = new Vector3();

      v1.copy(this).projectOnVector(planeNormal);

      return this.sub(v1);
    };
  }(),

  reflect: function () {

    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length

    var v1;

    return function reflect(normal) {

      if (v1 === undefined) v1 = new Vector3();

      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
    };
  }(),

  angleTo: function angleTo(v) {

    var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());

    // clamp, to handle numerical problems

    return Math.acos(_Math.clamp(theta, -1, 1));
  },

  distanceTo: function distanceTo(v) {

    return Math.sqrt(this.distanceToSquared(v));
  },

  distanceToSquared: function distanceToSquared(v) {

    var dx = this.x - v.x,
        dy = this.y - v.y,
        dz = this.z - v.z;

    return dx * dx + dy * dy + dz * dz;
  },

  distanceToManhattan: function distanceToManhattan(v) {

    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  },

  setFromSpherical: function setFromSpherical(s) {

    var sinPhiRadius = Math.sin(s.phi) * s.radius;

    this.x = sinPhiRadius * Math.sin(s.theta);
    this.y = Math.cos(s.phi) * s.radius;
    this.z = sinPhiRadius * Math.cos(s.theta);

    return this;
  },

  setFromCylindrical: function setFromCylindrical(c) {

    this.x = c.radius * Math.sin(c.theta);
    this.y = c.y;
    this.z = c.radius * Math.cos(c.theta);

    return this;
  },

  setFromMatrixPosition: function setFromMatrixPosition(m) {

    return this.setFromMatrixColumn(m, 3);
  },

  setFromMatrixScale: function setFromMatrixScale(m) {

    var sx = this.setFromMatrixColumn(m, 0).length();
    var sy = this.setFromMatrixColumn(m, 1).length();
    var sz = this.setFromMatrixColumn(m, 2).length();

    this.x = sx;
    this.y = sy;
    this.z = sz;

    return this;
  },

  setFromMatrixColumn: function setFromMatrixColumn(m, index) {

    if (typeof m === 'number') {

      console.warn('THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).');
      var temp = m;
      m = index;
      index = temp;
    }

    return this.fromArray(m.elements, index * 4);
  },

  equals: function equals(v) {

    return v.x === this.x && v.y === this.y && v.z === this.z;
  },

  fromArray: function fromArray(array, offset) {

    if (offset === undefined) offset = 0;

    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];

    return this;
  },

  toArray: function toArray(array, offset) {

    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;

    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;

    return array;
  },

  fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {

    if (offset !== undefined) {

      console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);

    return this;
  }

};

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4(x, y, z, w) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w !== undefined ? w : 1;
}

Vector4.prototype = {

  constructor: Vector4,

  isVector4: true,

  set: function set(x, y, z, w) {

    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;

    return this;
  },

  setScalar: function setScalar(scalar) {

    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;

    return this;
  },

  setX: function setX(x) {

    this.x = x;

    return this;
  },

  setY: function setY(y) {

    this.y = y;

    return this;
  },

  setZ: function setZ(z) {

    this.z = z;

    return this;
  },

  setW: function setW(w) {

    this.w = w;

    return this;
  },

  setComponent: function setComponent(index, value) {

    switch (index) {

      case 0:
        this.x = value;break;
      case 1:
        this.y = value;break;
      case 2:
        this.z = value;break;
      case 3:
        this.w = value;break;
      default:
        throw new Error('index is out of range: ' + index);

    }

    return this;
  },

  getComponent: function getComponent(index) {

    switch (index) {

      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error('index is out of range: ' + index);

    }
  },

  clone: function clone() {

    return new this.constructor(this.x, this.y, this.z, this.w);
  },

  copy: function copy(v) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;

    return this;
  },

  add: function add(v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;

    return this;
  },

  addScalar: function addScalar(s) {

    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;

    return this;
  },

  addVectors: function addVectors(a, b) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;

    return this;
  },

  addScaledVector: function addScaledVector(v, s) {

    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;

    return this;
  },

  sub: function sub(v, w) {

    if (w !== undefined) {

      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;

    return this;
  },

  subScalar: function subScalar(s) {

    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;

    return this;
  },

  subVectors: function subVectors(a, b) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;

    return this;
  },

  multiplyScalar: function multiplyScalar(scalar) {

    if (isFinite(scalar)) {

      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
    }

    return this;
  },

  applyMatrix4: function applyMatrix4(m) {

    var x = this.x,
        y = this.y,
        z = this.z,
        w = this.w;
    var e = m.elements;

    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

    return this;
  },

  divideScalar: function divideScalar(scalar) {

    return this.multiplyScalar(1 / scalar);
  },

  setAxisAngleFromQuaternion: function setAxisAngleFromQuaternion(q) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    // q is assumed to be normalized

    this.w = 2 * Math.acos(q.w);

    var s = Math.sqrt(1 - q.w * q.w);

    if (s < 0.0001) {

      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {

      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }

    return this;
  },

  setAxisAngleFromRotationMatrix: function setAxisAngleFromRotationMatrix(m) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var angle,
        x,
        y,
        z,
        // variables for result
    epsilon = 0.01,
        // margin to allow for rounding errors
    epsilon2 = 0.1,
        // margin to distinguish between 0 and 180 degrees

    te = m.elements,
        m11 = te[0],
        m12 = te[4],
        m13 = te[8],
        m21 = te[1],
        m22 = te[5],
        m23 = te[9],
        m31 = te[2],
        m32 = te[6],
        m33 = te[10];

    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {

      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms

      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {

        // this singularity is identity matrix so angle = 0

        this.set(1, 0, 0, 0);

        return this; // zero angle, arbitrary axis
      }

      // otherwise this singularity is angle = 180

      angle = Math.PI;

      var xx = (m11 + 1) / 2;
      var yy = (m22 + 1) / 2;
      var zz = (m33 + 1) / 2;
      var xy = (m12 + m21) / 4;
      var xz = (m13 + m31) / 4;
      var yz = (m23 + m32) / 4;

      if (xx > yy && xx > zz) {

        // m11 is the largest diagonal term

        if (xx < epsilon) {

          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {

          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {

        // m22 is the largest diagonal term

        if (yy < epsilon) {

          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {

          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {

        // m33 is the largest diagonal term so base result on this

        if (zz < epsilon) {

          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {

          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }

      this.set(x, y, z, angle);

      return this; // return 180 deg rotation
    }

    // as we have reached here there are no singularities so we can handle normally

    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

    if (Math.abs(s) < 0.001) s = 1;

    // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);

    return this;
  },

  min: function min(v) {

    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);

    return this;
  },

  max: function max(v) {

    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);

    return this;
  },

  clamp: function clamp(min, max) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));

    return this;
  },

  clampScalar: function () {

    var min, max;

    return function clampScalar(minVal, maxVal) {

      if (min === undefined) {

        min = new Vector4();
        max = new Vector4();
      }

      min.set(minVal, minVal, minVal, minVal);
      max.set(maxVal, maxVal, maxVal, maxVal);

      return this.clamp(min, max);
    };
  }(),

  floor: function floor() {

    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);

    return this;
  },

  ceil: function ceil() {

    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);

    return this;
  },

  round: function round() {

    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);

    return this;
  },

  roundToZero: function roundToZero() {

    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);

    return this;
  },

  negate: function negate() {

    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;

    return this;
  },

  dot: function dot(v) {

    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  },

  lengthSq: function lengthSq() {

    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },

  length: function length() {

    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },

  lengthManhattan: function lengthManhattan() {

    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },

  normalize: function normalize() {

    return this.divideScalar(this.length());
  },

  setLength: function setLength(length) {

    return this.multiplyScalar(length / this.length());
  },

  lerp: function lerp(v, alpha) {

    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;

    return this;
  },

  lerpVectors: function lerpVectors(v1, v2, alpha) {

    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  },

  equals: function equals(v) {

    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  },

  fromArray: function fromArray(array, offset) {

    if (offset === undefined) offset = 0;

    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];

    return this;
  },

  toArray: function toArray(array, offset) {

    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;

    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;

    return array;
  },

  fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {

    if (offset !== undefined) {

      console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);

    return this;
  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Color(r, g, b) {

  if (g === undefined && b === undefined) {

    // r is THREE.Color, hex or string
    return this.set(r);
  }

  return this.setRGB(r, g, b);
}

Color.prototype = {

  constructor: Color,

  isColor: true,

  r: 1, g: 1, b: 1,

  set: function set(value) {

    if (value && value.isColor) {

      this.copy(value);
    } else if (typeof value === 'number') {

      this.setHex(value);
    } else if (typeof value === 'string') {

      this.setStyle(value);
    }

    return this;
  },

  setScalar: function setScalar(scalar) {

    this.r = scalar;
    this.g = scalar;
    this.b = scalar;

    return this;
  },

  setHex: function setHex(hex) {

    hex = Math.floor(hex);

    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;

    return this;
  },

  setRGB: function setRGB(r, g, b) {

    this.r = r;
    this.g = g;
    this.b = b;

    return this;
  },

  setHSL: function () {

    function hue2rgb(p, q, t) {

      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
      return p;
    }

    return function setHSL(h, s, l) {

      // h,s,l ranges are in 0.0 - 1.0
      h = _Math.euclideanModulo(h, 1);
      s = _Math.clamp(s, 0, 1);
      l = _Math.clamp(l, 0, 1);

      if (s === 0) {

        this.r = this.g = this.b = l;
      } else {

        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;

        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }

      return this;
    };
  }(),

  setStyle: function setStyle(style) {

    function handleAlpha(string) {

      if (string === undefined) return;

      if (parseFloat(string) < 1) {

        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
      }
    }

    var m;

    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {

      // rgb / hsl

      var color;
      var name = m[1];
      var components = m[2];

      switch (name) {

        case 'rgb':
        case 'rgba':

          if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

            // rgb(255,0,0) rgba(255,0,0,0.5)
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;

            handleAlpha(color[5]);

            return this;
          }

          if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;

            handleAlpha(color[5]);

            return this;
          }

          break;

        case 'hsl':
        case 'hsla':

          if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
            var h = parseFloat(color[1]) / 360;
            var s = parseInt(color[2], 10) / 100;
            var l = parseInt(color[3], 10) / 100;

            handleAlpha(color[5]);

            return this.setHSL(h, s, l);
          }

          break;

      }
    } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {

      // hex color

      var hex = m[1];
      var size = hex.length;

      if (size === 3) {

        // #ff0
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;

        return this;
      } else if (size === 6) {

        // #ff0000
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;

        return this;
      }
    }

    if (style && style.length > 0) {

      // color keywords
      var hex = ColorKeywords[style];

      if (hex !== undefined) {

        // red
        this.setHex(hex);
      } else {

        // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
      }
    }

    return this;
  },

  clone: function clone() {

    return new this.constructor(this.r, this.g, this.b);
  },

  copy: function copy(color) {

    this.r = color.r;
    this.g = color.g;
    this.b = color.b;

    return this;
  },

  copyGammaToLinear: function copyGammaToLinear(color, gammaFactor) {

    if (gammaFactor === undefined) gammaFactor = 2.0;

    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);

    return this;
  },

  copyLinearToGamma: function copyLinearToGamma(color, gammaFactor) {

    if (gammaFactor === undefined) gammaFactor = 2.0;

    var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;

    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);

    return this;
  },

  convertGammaToLinear: function convertGammaToLinear() {

    var r = this.r,
        g = this.g,
        b = this.b;

    this.r = r * r;
    this.g = g * g;
    this.b = b * b;

    return this;
  },

  convertLinearToGamma: function convertLinearToGamma() {

    this.r = Math.sqrt(this.r);
    this.g = Math.sqrt(this.g);
    this.b = Math.sqrt(this.b);

    return this;
  },

  getHex: function getHex() {

    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },

  getHexString: function getHexString() {

    return ('000000' + this.getHex().toString(16)).slice(-6);
  },

  getHSL: function getHSL(optionalTarget) {

    // h,s,l ranges are in 0.0 - 1.0

    var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

    var r = this.r,
        g = this.g,
        b = this.b;

    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);

    var hue, saturation;
    var lightness = (min + max) / 2.0;

    if (min === max) {

      hue = 0;
      saturation = 0;
    } else {

      var delta = max - min;

      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

      switch (max) {

        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);break;
        case g:
          hue = (b - r) / delta + 2;break;
        case b:
          hue = (r - g) / delta + 4;break;

      }

      hue /= 6;
    }

    hsl.h = hue;
    hsl.s = saturation;
    hsl.l = lightness;

    return hsl;
  },

  getStyle: function getStyle() {

    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  },

  offsetHSL: function offsetHSL(h, s, l) {

    var hsl = this.getHSL();

    hsl.h += h;hsl.s += s;hsl.l += l;

    this.setHSL(hsl.h, hsl.s, hsl.l);

    return this;
  },

  add: function add(color) {

    this.r += color.r;
    this.g += color.g;
    this.b += color.b;

    return this;
  },

  addColors: function addColors(color1, color2) {

    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;

    return this;
  },

  addScalar: function addScalar(s) {

    this.r += s;
    this.g += s;
    this.b += s;

    return this;
  },

  sub: function sub(color) {

    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);

    return this;
  },

  multiply: function multiply(color) {

    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;

    return this;
  },

  multiplyScalar: function multiplyScalar(s) {

    this.r *= s;
    this.g *= s;
    this.b *= s;

    return this;
  },

  lerp: function lerp(color, alpha) {

    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;

    return this;
  },

  equals: function equals(c) {

    return c.r === this.r && c.g === this.g && c.b === this.b;
  },

  fromArray: function fromArray(array, offset) {

    if (offset === undefined) offset = 0;

    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];

    return this;
  },

  toArray: function toArray(array, offset) {

    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;

    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;

    return array;
  },

  toJSON: function toJSON() {

    return this.getHex();
  }

};

var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3() {

  this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);

  if (arguments.length > 0) {

    console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
  }
}

Matrix3.prototype = {

  constructor: Matrix3,

  isMatrix3: true,

  set: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {

    var te = this.elements;

    te[0] = n11;te[1] = n21;te[2] = n31;
    te[3] = n12;te[4] = n22;te[5] = n32;
    te[6] = n13;te[7] = n23;te[8] = n33;

    return this;
  },

  identity: function identity() {

    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);

    return this;
  },

  clone: function clone() {

    return new this.constructor().fromArray(this.elements);
  },

  copy: function copy(m) {

    var me = m.elements;

    this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);

    return this;
  },

  setFromMatrix4: function setFromMatrix4(m) {

    var me = m.elements;

    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);

    return this;
  },

  applyToBufferAttribute: function () {

    var v1;

    return function applyToBufferAttribute(attribute) {

      if (v1 === undefined) v1 = new Vector3();

      for (var i = 0, l = attribute.count; i < l; i++) {

        v1.x = attribute.getX(i);
        v1.y = attribute.getY(i);
        v1.z = attribute.getZ(i);

        v1.applyMatrix3(this);

        attribute.setXYZ(i, v1.x, v1.y, v1.z);
      }

      return attribute;
    };
  }(),

  multiplyScalar: function multiplyScalar(s) {

    var te = this.elements;

    te[0] *= s;te[3] *= s;te[6] *= s;
    te[1] *= s;te[4] *= s;te[7] *= s;
    te[2] *= s;te[5] *= s;te[8] *= s;

    return this;
  },

  determinant: function determinant() {

    var te = this.elements;

    var a = te[0],
        b = te[1],
        c = te[2],
        d = te[3],
        e = te[4],
        f = te[5],
        g = te[6],
        h = te[7],
        i = te[8];

    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  },

  getInverse: function getInverse(matrix, throwOnDegenerate) {

    if (matrix && matrix.isMatrix4) {

      console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
    }

    var me = matrix.elements,
        te = this.elements,
        n11 = me[0],
        n21 = me[1],
        n31 = me[2],
        n12 = me[3],
        n22 = me[4],
        n32 = me[5],
        n13 = me[6],
        n23 = me[7],
        n33 = me[8],
        t11 = n33 * n22 - n32 * n23,
        t12 = n32 * n13 - n33 * n12,
        t13 = n23 * n12 - n22 * n13,
        det = n11 * t11 + n21 * t12 + n31 * t13;

    if (det === 0) {

      var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

      if (throwOnDegenerate === true) {

        throw new Error(msg);
      } else {

        console.warn(msg);
      }

      return this.identity();
    }

    var detInv = 1 / det;

    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;

    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;

    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;

    return this;
  },

  transpose: function transpose() {

    var tmp,
        m = this.elements;

    tmp = m[1];m[1] = m[3];m[3] = tmp;
    tmp = m[2];m[2] = m[6];m[6] = tmp;
    tmp = m[5];m[5] = m[7];m[7] = tmp;

    return this;
  },

  getNormalMatrix: function getNormalMatrix(matrix4) {

    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  },

  transposeIntoArray: function transposeIntoArray(r) {

    var m = this.elements;

    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];

    return this;
  },

  fromArray: function fromArray(array, offset) {

    if (offset === undefined) offset = 0;

    for (var i = 0; i < 9; i++) {

      this.elements[i] = array[i + offset];
    }

    return this;
  },

  toArray: function toArray(array, offset) {

    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;

    var te = this.elements;

    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];

    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];

    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];

    return array;
  }

};

/**
 * @author bhouston / http://clara.io
 */

function Line3(start, end) {

  this.start = start !== undefined ? start : new Vector3();
  this.end = end !== undefined ? end : new Vector3();
}

Line3.prototype = {

  constructor: Line3,

  set: function set(start, end) {

    this.start.copy(start);
    this.end.copy(end);

    return this;
  },

  clone: function clone() {

    return new this.constructor().copy(this);
  },

  copy: function copy(line) {

    this.start.copy(line.start);
    this.end.copy(line.end);

    return this;
  },

  getCenter: function getCenter(optionalTarget) {

    var result = optionalTarget || new Vector3();
    return result.addVectors(this.start, this.end).multiplyScalar(0.5);
  },

  delta: function delta(optionalTarget) {

    var result = optionalTarget || new Vector3();
    return result.subVectors(this.end, this.start);
  },

  distanceSq: function distanceSq() {

    return this.start.distanceToSquared(this.end);
  },

  distance: function distance() {

    return this.start.distanceTo(this.end);
  },

  at: function at(t, optionalTarget) {

    var result = optionalTarget || new Vector3();

    return this.delta(result).multiplyScalar(t).add(this.start);
  },

  closestPointToPointParameter: function () {

    var startP = new Vector3();
    var startEnd = new Vector3();

    return function closestPointToPointParameter(point, clampToLine) {

      startP.subVectors(point, this.start);
      startEnd.subVectors(this.end, this.start);

      var startEnd2 = startEnd.dot(startEnd);
      var startEnd_startP = startEnd.dot(startP);

      var t = startEnd_startP / startEnd2;

      if (clampToLine) {

        t = _Math.clamp(t, 0, 1);
      }

      return t;
    };
  }(),

  closestPointToPoint: function closestPointToPoint(point, clampToLine, optionalTarget) {

    var t = this.closestPointToPointParameter(point, clampToLine);

    var result = optionalTarget || new Vector3();

    return this.delta(result).multiplyScalar(t).add(this.start);
  },

  applyMatrix4: function applyMatrix4(matrix) {

    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);

    return this;
  },

  equals: function equals(line) {

    return line.start.equals(this.start) && line.end.equals(this.end);
  }

};

/**
 * @author bhouston / http://clara.io
 */

function Plane(normal, constant) {

  this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
  this.constant = constant !== undefined ? constant : 0;
}

Plane.prototype = {

  constructor: Plane,

  set: function set(normal, constant) {

    this.normal.copy(normal);
    this.constant = constant;

    return this;
  },

  setComponents: function setComponents(x, y, z, w) {

    this.normal.set(x, y, z);
    this.constant = w;

    return this;
  },

  setFromNormalAndCoplanarPoint: function setFromNormalAndCoplanarPoint(normal, point) {

    this.normal.copy(normal);
    this.constant = -point.dot(this.normal); // must be this.normal, not normal, as this.normal is normalized

    return this;
  },

  setFromCoplanarPoints: function () {

    var v1 = new Vector3();
    var v2 = new Vector3();

    return function setFromCoplanarPoints(a, b, c) {

      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();

      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

      this.setFromNormalAndCoplanarPoint(normal, a);

      return this;
    };
  }(),

  clone: function clone() {

    return new this.constructor().copy(this);
  },

  copy: function copy(plane) {

    this.normal.copy(plane.normal);
    this.constant = plane.constant;

    return this;
  },

  normalize: function normalize() {

    // Note: will lead to a divide by zero if the plane is invalid.

    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;

    return this;
  },

  negate: function negate() {

    this.constant *= -1;
    this.normal.negate();

    return this;
  },

  distanceToPoint: function distanceToPoint(point) {

    return this.normal.dot(point) + this.constant;
  },

  distanceToSphere: function distanceToSphere(sphere) {

    return this.distanceToPoint(sphere.center) - sphere.radius;
  },

  projectPoint: function projectPoint(point, optionalTarget) {

    return this.orthoPoint(point, optionalTarget).sub(point).negate();
  },

  orthoPoint: function orthoPoint(point, optionalTarget) {

    var perpendicularMagnitude = this.distanceToPoint(point);

    var result = optionalTarget || new Vector3();
    return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
  },

  intersectLine: function () {

    var v1 = new Vector3();

    return function intersectLine(line, optionalTarget) {

      var result = optionalTarget || new Vector3();

      var direction = line.delta(v1);

      var denominator = this.normal.dot(direction);

      if (denominator === 0) {

        // line is coplanar, return origin
        if (this.distanceToPoint(line.start) === 0) {

          return result.copy(line.start);
        }

        // Unsure if this is the correct method to handle this case.
        return undefined;
      }

      var t = -(line.start.dot(this.normal) + this.constant) / denominator;

      if (t < 0 || t > 1) {

        return undefined;
      }

      return result.copy(direction).multiplyScalar(t).add(line.start);
    };
  }(),

  intersectsLine: function intersectsLine(line) {

    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    var startSign = this.distanceToPoint(line.start);
    var endSign = this.distanceToPoint(line.end);

    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },

  intersectsBox: function intersectsBox(box) {

    return box.intersectsPlane(this);
  },

  intersectsSphere: function intersectsSphere(sphere) {

    return sphere.intersectsPlane(this);
  },

  coplanarPoint: function coplanarPoint(optionalTarget) {

    var result = optionalTarget || new Vector3();
    return result.copy(this.normal).multiplyScalar(-this.constant);
  },

  applyMatrix4: function () {

    var v1 = new Vector3();
    var m1 = new Matrix3();

    return function applyMatrix4(matrix, optionalNormalMatrix) {

      var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);

      // transform normal based on theory here:
      // http://www.songho.ca/opengl/gl_normaltransform.html
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
      var normal = this.normal.applyMatrix3(normalMatrix).normalize();

      // recalculate constant (like in setFromNormalAndCoplanarPoint)
      this.constant = -referencePoint.dot(normal);

      return this;
    };
  }(),

  translate: function translate(offset) {

    this.constant = this.constant - offset.dot(this.normal);

    return this;
  },

  equals: function equals(plane) {

    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }

};

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Triangle(a, b, c) {

  this.a = a !== undefined ? a : new Vector3();
  this.b = b !== undefined ? b : new Vector3();
  this.c = c !== undefined ? c : new Vector3();
}

Triangle.normal = function () {

  var v0 = new Vector3();

  return function normal(a, b, c, optionalTarget) {

    var result = optionalTarget || new Vector3();

    result.subVectors(c, b);
    v0.subVectors(a, b);
    result.cross(v0);

    var resultLengthSq = result.lengthSq();
    if (resultLengthSq > 0) {

      return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
    }

    return result.set(0, 0, 0);
  };
}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
Triangle.barycoordFromPoint = function () {

  var v0 = new Vector3();
  var v1 = new Vector3();
  var v2 = new Vector3();

  return function barycoordFromPoint(point, a, b, c, optionalTarget) {

    v0.subVectors(c, a);
    v1.subVectors(b, a);
    v2.subVectors(point, a);

    var dot00 = v0.dot(v0);
    var dot01 = v0.dot(v1);
    var dot02 = v0.dot(v2);
    var dot11 = v1.dot(v1);
    var dot12 = v1.dot(v2);

    var denom = dot00 * dot11 - dot01 * dot01;

    var result = optionalTarget || new Vector3();

    // collinear or singular triangle
    if (denom === 0) {

      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return result.set(-2, -1, -1);
    }

    var invDenom = 1 / denom;
    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // barycentric coordinates must always sum to 1
    return result.set(1 - u - v, v, u);
  };
}();

Triangle.containsPoint = function () {

  var v1 = new Vector3();

  return function containsPoint(point, a, b, c) {

    var result = Triangle.barycoordFromPoint(point, a, b, c, v1);

    return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
  };
}();

Triangle.prototype = {

  constructor: Triangle,

  set: function set(a, b, c) {

    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);

    return this;
  },

  setFromPointsAndIndices: function setFromPointsAndIndices(points, i0, i1, i2) {

    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);

    return this;
  },

  clone: function clone() {

    return new this.constructor().copy(this);
  },

  copy: function copy(triangle) {

    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);

    return this;
  },

  area: function () {

    var v0 = new Vector3();
    var v1 = new Vector3();

    return function area() {

      v0.subVectors(this.c, this.b);
      v1.subVectors(this.a, this.b);

      return v0.cross(v1).length() * 0.5;
    };
  }(),

  midpoint: function midpoint(optionalTarget) {

    var result = optionalTarget || new Vector3();
    return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },

  normal: function normal(optionalTarget) {

    return Triangle.normal(this.a, this.b, this.c, optionalTarget);
  },

  plane: function plane(optionalTarget) {

    var result = optionalTarget || new Plane();

    return result.setFromCoplanarPoints(this.a, this.b, this.c);
  },

  barycoordFromPoint: function barycoordFromPoint(point, optionalTarget) {

    return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
  },

  containsPoint: function containsPoint(point) {

    return Triangle.containsPoint(point, this.a, this.b, this.c);
  },

  closestPointToPoint: function () {

    var plane, edgeList, projectedPoint, closestPoint;

    return function closestPointToPoint(point, optionalTarget) {

      if (plane === undefined) {

        plane = new Plane();
        edgeList = [new Line3(), new Line3(), new Line3()];
        projectedPoint = new Vector3();
        closestPoint = new Vector3();
      }

      var result = optionalTarget || new Vector3();
      var minDistance = Infinity;

      // project the point onto the plane of the triangle

      plane.setFromCoplanarPoints(this.a, this.b, this.c);
      plane.projectPoint(point, projectedPoint);

      // check if the projection lies within the triangle

      if (this.containsPoint(projectedPoint) === true) {

        // if so, this is the closest point

        result.copy(projectedPoint);
      } else {

        // if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

        edgeList[0].set(this.a, this.b);
        edgeList[1].set(this.b, this.c);
        edgeList[2].set(this.c, this.a);

        for (var i = 0; i < edgeList.length; i++) {

          edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);

          var distance = projectedPoint.distanceToSquared(closestPoint);

          if (distance < minDistance) {

            minDistance = distance;

            result.copy(closestPoint);
          }
        }
      }

      return result;
    };
  }(),

  equals: function equals(triangle) {

    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }

};

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Sphere(center, radius) {

  this.center = center !== undefined ? center : new Vector3();
  this.radius = radius !== undefined ? radius : 0;
}

Sphere.prototype = {

  constructor: Sphere,

  set: function set(center, radius) {

    this.center.copy(center);
    this.radius = radius;

    return this;
  },

  setFromPoints: function () {

    var box = new Box3();

    return function setFromPoints(points, optionalCenter) {

      var center = this.center;

      if (optionalCenter !== undefined) {

        center.copy(optionalCenter);
      } else {

        box.setFromPoints(points).getCenter(center);
      }

      var maxRadiusSq = 0;

      for (var i = 0, il = points.length; i < il; i++) {

        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }

      this.radius = Math.sqrt(maxRadiusSq);

      return this;
    };
  }(),

  clone: function clone() {

    return new this.constructor().copy(this);
  },

  copy: function copy(sphere) {

    this.center.copy(sphere.center);
    this.radius = sphere.radius;

    return this;
  },

  empty: function empty() {

    return this.radius <= 0;
  },

  containsPoint: function containsPoint(point) {

    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },

  distanceToPoint: function distanceToPoint(point) {

    return point.distanceTo(this.center) - this.radius;
  },

  intersectsSphere: function intersectsSphere(sphere) {

    var radiusSum = this.radius + sphere.radius;

    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },

  intersectsBox: function intersectsBox(box) {

    return box.intersectsSphere(this);
  },

  intersectsPlane: function intersectsPlane(plane) {

    // We use the following equation to compute the signed distance from
    // the center of the sphere to the plane.
    //
    // distance = q * n - d
    //
    // If this distance is greater than the radius of the sphere,
    // then there is no intersection.

    return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
  },

  clampPoint: function clampPoint(point, optionalTarget) {

    var deltaLengthSq = this.center.distanceToSquared(point);

    var result = optionalTarget || new Vector3();

    result.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {

      result.sub(this.center).normalize();
      result.multiplyScalar(this.radius).add(this.center);
    }

    return result;
  },

  getBoundingBox: function getBoundingBox(optionalTarget) {

    var box = optionalTarget || new Box3();

    box.set(this.center, this.center);
    box.expandByScalar(this.radius);

    return box;
  },

  applyMatrix4: function applyMatrix4(matrix) {

    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();

    return this;
  },

  translate: function translate(offset) {

    this.center.add(offset);

    return this;
  },

  equals: function equals(sphere) {

    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }

};

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3(min, max) {

  this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
  this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
}

Box3.prototype = {

  constructor: Box3,

  isBox3: true,

  set: function set(min, max) {

    this.min.copy(min);
    this.max.copy(max);

    return this;
  },

  setFromArray: function setFromArray(array) {

    var minX = +Infinity;
    var minY = +Infinity;
    var minZ = +Infinity;

    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;

    for (var i = 0, l = array.length; i < l; i += 3) {

      var x = array[i];
      var y = array[i + 1];
      var z = array[i + 2];

      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;

      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
  },

  setFromBufferAttribute: function setFromBufferAttribute(attribute) {

    var minX = +Infinity;
    var minY = +Infinity;
    var minZ = +Infinity;

    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;

    for (var i = 0, l = attribute.count; i < l; i++) {

      var x = attribute.getX(i);
      var y = attribute.getY(i);
      var z = attribute.getZ(i);

      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;

      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
  },

  setFromPoints: function setFromPoints(points) {

    this.makeEmpty();

    for (var i = 0, il = points.length; i < il; i++) {

      this.expandByPoint(points[i]);
    }

    return this;
  },

  setFromCenterAndSize: function () {

    var v1 = new Vector3();

    return function setFromCenterAndSize(center, size) {

      var halfSize = v1.copy(size).multiplyScalar(0.5);

      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);

      return this;
    };
  }(),

  setFromObject: function () {

    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms

    var v1 = new Vector3();

    return function setFromObject(object) {

      var scope = this;

      object.updateMatrixWorld(true);

      this.makeEmpty();

      object.traverse(function (node) {

        var i, l;

        var geometry = node.geometry;

        if (geometry !== undefined) {

          if (geometry.isGeometry) {

            var vertices = geometry.vertices;

            for (i = 0, l = vertices.length; i < l; i++) {

              v1.copy(vertices[i]);
              v1.applyMatrix4(node.matrixWorld);

              scope.expandByPoint(v1);
            }
          } else if (geometry.isBufferGeometry) {

            var attribute = geometry.attributes.position;

            if (attribute !== undefined) {

              for (i = 0, l = attribute.count; i < l; i++) {

                v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);

                scope.expandByPoint(v1);
              }
            }
          }
        }
      });

      return this;
    };
  }(),

  clone: function clone() {

    return new this.constructor().copy(this);
  },

  copy: function copy(box) {

    this.min.copy(box.min);
    this.max.copy(box.max);

    return this;
  },

  makeEmpty: function makeEmpty() {

    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;

    return this;
  },

  isEmpty: function isEmpty() {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },

  getCenter: function getCenter(optionalTarget) {

    var result = optionalTarget || new Vector3();
    return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
  },

  getSize: function getSize(optionalTarget) {

    var result = optionalTarget || new Vector3();
    return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
  },

  expandByPoint: function expandByPoint(point) {

    this.min.min(point);
    this.max.max(point);

    return this;
  },

  expandByVector: function expandByVector(vector) {

    this.min.sub(vector);
    this.max.add(vector);

    return this;
  },

  expandByScalar: function expandByScalar(scalar) {

    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);

    return this;
  },

  containsPoint: function containsPoint(point) {

    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  },

  containsBox: function containsBox(box) {

    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  },

  getParameter: function getParameter(point, optionalTarget) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new Vector3();

    return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  },

  intersectsBox: function intersectsBox(box) {

    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  },

  intersectsSphere: function () {

    var closestPoint;

    return function intersectsSphere(sphere) {

      if (closestPoint === undefined) closestPoint = new Vector3();

      // Find the point on the AABB closest to the sphere center.
      this.clampPoint(sphere.center, closestPoint);

      // If that point is inside the sphere, the AABB and sphere intersect.
      return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    };
  }(),

  intersectsPlane: function intersectsPlane(plane) {

    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.

    var min, max;

    if (plane.normal.x > 0) {

      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {

      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {

      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {

      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {

      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {

      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant;
  },

  clampPoint: function clampPoint(point, optionalTarget) {

    var result = optionalTarget || new Vector3();
    return result.copy(point).clamp(this.min, this.max);
  },

  distanceToPoint: function () {

    var v1 = new Vector3();

    return function distanceToPoint(point) {

      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),

  getBoundingSphere: function () {

    var v1 = new Vector3();

    return function getBoundingSphere(optionalTarget) {

      var result = optionalTarget || new Sphere();

      this.getCenter(result.center);

      result.radius = this.getSize(v1).length() * 0.5;

      return result;
    };
  }(),

  intersect: function intersect(box) {

    this.min.max(box.min);
    this.max.min(box.max);

    // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
    if (this.isEmpty()) this.makeEmpty();

    return this;
  },

  union: function union(box) {

    this.min.min(box.min);
    this.max.max(box.max);

    return this;
  },

  applyMatrix4: function () {

    var points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];

    return function applyMatrix4(matrix) {

      // transform of empty box is an empty box.
      if (this.isEmpty()) return this;

      // NOTE: I am using a binary pattern to specify all 2^3 combinations below
      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

      this.setFromPoints(points);

      return this;
    };
  }(),

  translate: function translate(offset) {

    this.min.add(offset);
    this.max.add(offset);

    return this;
  },

  equals: function equals(box) {

    return box.min.equals(this.min) && box.max.equals(this.max);
  }

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Euler(x, y, z, order) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || Euler.DefaultOrder;
}

Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

Euler.DefaultOrder = 'XYZ';

Euler.prototype = {

  constructor: Euler,

  isEuler: true,

  get x() {

    return this._x;
  },

  set x(value) {

    this._x = value;
    this.onChangeCallback();
  },

  get y() {

    return this._y;
  },

  set y(value) {

    this._y = value;
    this.onChangeCallback();
  },

  get z() {

    return this._z;
  },

  set z(value) {

    this._z = value;
    this.onChangeCallback();
  },

  get order() {

    return this._order;
  },

  set order(value) {

    this._order = value;
    this.onChangeCallback();
  },

  set: function set(x, y, z, order) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this.onChangeCallback();

    return this;
  },

  clone: function clone() {

    return new this.constructor(this._x, this._y, this._z, this._order);
  },

  copy: function copy(euler) {

    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this.onChangeCallback();

    return this;
  },

  setFromRotationMatrix: function setFromRotationMatrix(m, order, update) {

    var clamp = _Math.clamp;

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements;
    var m11 = te[0],
        m12 = te[4],
        m13 = te[8];
    var m21 = te[1],
        m22 = te[5],
        m23 = te[9];
    var m31 = te[2],
        m32 = te[6],
        m33 = te[10];

    order = order || this._order;

    if (order === 'XYZ') {

      this._y = Math.asin(clamp(m13, -1, 1));

      if (Math.abs(m13) < 0.99999) {

        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
      } else {

        this._x = Math.atan2(m32, m22);
        this._z = 0;
      }
    } else if (order === 'YXZ') {

      this._x = Math.asin(-clamp(m23, -1, 1));

      if (Math.abs(m23) < 0.99999) {

        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
      } else {

        this._y = Math.atan2(-m31, m11);
        this._z = 0;
      }
    } else if (order === 'ZXY') {

      this._x = Math.asin(clamp(m32, -1, 1));

      if (Math.abs(m32) < 0.99999) {

        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
      } else {

        this._y = 0;
        this._z = Math.atan2(m21, m11);
      }
    } else if (order === 'ZYX') {

      this._y = Math.asin(-clamp(m31, -1, 1));

      if (Math.abs(m31) < 0.99999) {

        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
      } else {

        this._x = 0;
        this._z = Math.atan2(-m12, m22);
      }
    } else if (order === 'YZX') {

      this._z = Math.asin(clamp(m21, -1, 1));

      if (Math.abs(m21) < 0.99999) {

        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
      } else {

        this._x = 0;
        this._y = Math.atan2(m13, m33);
      }
    } else if (order === 'XZY') {

      this._z = Math.asin(-clamp(m12, -1, 1));

      if (Math.abs(m12) < 0.99999) {

        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
      } else {

        this._x = Math.atan2(-m23, m33);
        this._y = 0;
      }
    } else {

      console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
    }

    this._order = order;

    if (update !== false) this.onChangeCallback();

    return this;
  },

  setFromQuaternion: function () {

    var matrix;

    return function setFromQuaternion(q, order, update) {

      if (matrix === undefined) matrix = new Matrix4();

      matrix.makeRotationFromQuaternion(q);

      return this.setFromRotationMatrix(matrix, order, update);
    };
  }(),

  setFromVector3: function setFromVector3(v, order) {

    return this.set(v.x, v.y, v.z, order || this._order);
  },

  reorder: function () {

    // WARNING: this discards revolution information -bhouston

    var q = new Quaternion();

    return function reorder(newOrder) {

      q.setFromEuler(this);

      return this.setFromQuaternion(q, newOrder);
    };
  }(),

  equals: function equals(euler) {

    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },

  fromArray: function fromArray(array) {

    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];

    this.onChangeCallback();

    return this;
  },

  toArray: function toArray(array, offset) {

    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;

    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;

    return array;
  },

  toVector3: function toVector3(optionalResult) {

    if (optionalResult) {

      return optionalResult.set(this._x, this._y, this._z);
    } else {

      return new Vector3(this._x, this._y, this._z);
    }
  },

  onChange: function onChange(callback) {

    this.onChangeCallback = callback;

    return this;
  },

  onChangeCallback: function onChangeCallback() {}

};

/**
 * @author bhouston / http://clara.io
 */

function Ray(origin, direction) {

  this.origin = origin !== undefined ? origin : new Vector3();
  this.direction = direction !== undefined ? direction : new Vector3();
}

Ray.prototype = {

  constructor: Ray,

  set: function set(origin, direction) {

    this.origin.copy(origin);
    this.direction.copy(direction);

    return this;
  },

  clone: function clone() {

    return new this.constructor().copy(this);
  },

  copy: function copy(ray) {

    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);

    return this;
  },

  at: function at(t, optionalTarget) {

    var result = optionalTarget || new Vector3();

    return result.copy(this.direction).multiplyScalar(t).add(this.origin);
  },

  lookAt: function lookAt(v) {

    this.direction.copy(v).sub(this.origin).normalize();

    return this;
  },

  recast: function () {

    var v1 = new Vector3();

    return function recast(t) {

      this.origin.copy(this.at(t, v1));

      return this;
    };
  }(),

  closestPointToPoint: function closestPointToPoint(point, optionalTarget) {

    var result = optionalTarget || new Vector3();
    result.subVectors(point, this.origin);
    var directionDistance = result.dot(this.direction);

    if (directionDistance < 0) {

      return result.copy(this.origin);
    }

    return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },

  distanceToPoint: function distanceToPoint(point) {

    return Math.sqrt(this.distanceSqToPoint(point));
  },

  distanceSqToPoint: function () {

    var v1 = new Vector3();

    return function distanceSqToPoint(point) {

      var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);

      // point behind the ray

      if (directionDistance < 0) {

        return this.origin.distanceToSquared(point);
      }

      v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

      return v1.distanceToSquared(point);
    };
  }(),

  distanceSqToSegment: function () {

    var segCenter = new Vector3();
    var segDir = new Vector3();
    var diff = new Vector3();

    return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {

      // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment

      segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      segDir.copy(v1).sub(v0).normalize();
      diff.copy(this.origin).sub(segCenter);

      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(segDir);
      var b0 = diff.dot(this.direction);
      var b1 = -diff.dot(segDir);
      var c = diff.lengthSq();
      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;

      if (det > 0) {

        // The ray and segment are not parallel.

        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;

        if (s0 >= 0) {

          if (s1 >= -extDet) {

            if (s1 <= extDet) {

              // region 0
              // Minimum at interior points of ray and segment.

              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {

              // region 1

              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {

            // region 5

            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {

          if (s1 <= -extDet) {

            // region 4

            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {

            // region 3

            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {

            // region 2

            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {

        // Ray and segment are parallel.

        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }

      if (optionalPointOnRay) {

        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }

      if (optionalPointOnSegment) {

        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
      }

      return sqrDist;
    };
  }(),

  intersectSphere: function () {

    var v1 = new Vector3();

    return function intersectSphere(sphere, optionalTarget) {

      v1.subVectors(sphere.center, this.origin);
      var tca = v1.dot(this.direction);
      var d2 = v1.dot(v1) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;

      if (d2 > radius2) return null;

      var thc = Math.sqrt(radius2 - d2);

      // t0 = first intersect point - entrance on front of sphere
      var t0 = tca - thc;

      // t1 = second intersect point - exit point on back of sphere
      var t1 = tca + thc;

      // test to see if both t0 and t1 are behind the ray - if so, return null
      if (t0 < 0 && t1 < 0) return null;

      // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.
      if (t0 < 0) return this.at(t1, optionalTarget);

      // else t0 is in front of the ray, so return the first collision point scaled by t0
      return this.at(t0, optionalTarget);
    };
  }(),

  intersectsSphere: function intersectsSphere(sphere) {

    return this.distanceToPoint(sphere.center) <= sphere.radius;
  },

  distanceToPlane: function distanceToPlane(plane) {

    var denominator = plane.normal.dot(this.direction);

    if (denominator === 0) {

      // line is coplanar, return origin
      if (plane.distanceToPoint(this.origin) === 0) {

        return 0;
      }

      // Null is preferable to undefined since undefined means.... it is undefined

      return null;
    }

    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

    // Return if the ray never intersects the plane

    return t >= 0 ? t : null;
  },

  intersectPlane: function intersectPlane(plane, optionalTarget) {

    var t = this.distanceToPlane(plane);

    if (t === null) {

      return null;
    }

    return this.at(t, optionalTarget);
  },

  intersectsPlane: function intersectsPlane(plane) {

    // check if the ray lies on the plane first

    var distToPoint = plane.distanceToPoint(this.origin);

    if (distToPoint === 0) {

      return true;
    }

    var denominator = plane.normal.dot(this.direction);

    if (denominator * distToPoint < 0) {

      return true;
    }

    // ray origin is behind the plane (and is pointing behind it)

    return false;
  },

  intersectBox: function intersectBox(box, optionalTarget) {

    var tmin, tmax, tymin, tymax, tzmin, tzmax;

    var invdirx = 1 / this.direction.x,
        invdiry = 1 / this.direction.y,
        invdirz = 1 / this.direction.z;

    var origin = this.origin;

    if (invdirx >= 0) {

      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {

      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }

    if (invdiry >= 0) {

      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {

      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }

    if (tmin > tymax || tymin > tmax) return null;

    // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if (tymin > tmin || tmin !== tmin) tmin = tymin;

    if (tymax < tmax || tmax !== tmax) tmax = tymax;

    if (invdirz >= 0) {

      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {

      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }

    if (tmin > tzmax || tzmin > tmax) return null;

    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

    //return point closest to the ray (positive side)

    if (tmax < 0) return null;

    return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
  },

  intersectsBox: function () {

    var v = new Vector3();

    return function intersectsBox(box) {

      return this.intersectBox(box, v) !== null;
    };
  }(),

  intersectTriangle: function () {

    // Compute the offset origin, edges, and normal.
    var diff = new Vector3();
    var edge1 = new Vector3();
    var edge2 = new Vector3();
    var normal = new Vector3();

    return function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {

      // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

      edge1.subVectors(b, a);
      edge2.subVectors(c, a);
      normal.crossVectors(edge1, edge2);

      // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
      var DdN = this.direction.dot(normal);
      var sign;

      if (DdN > 0) {

        if (backfaceCulling) return null;
        sign = 1;
      } else if (DdN < 0) {

        sign = -1;
        DdN = -DdN;
      } else {

        return null;
      }

      diff.subVectors(this.origin, a);
      var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));

      // b1 < 0, no intersection
      if (DdQxE2 < 0) {

        return null;
      }

      var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));

      // b2 < 0, no intersection
      if (DdE1xQ < 0) {

        return null;
      }

      // b1+b2 > 1, no intersection
      if (DdQxE2 + DdE1xQ > DdN) {

        return null;
      }

      // Line intersects triangle, check if ray does.
      var QdN = -sign * diff.dot(normal);

      // t < 0, no intersection
      if (QdN < 0) {

        return null;
      }

      // Ray intersects triangle.
      return this.at(QdN / DdN, optionalTarget);
    };
  }(),

  applyMatrix4: function applyMatrix4(matrix4) {

    this.direction.add(this.origin).applyMatrix4(matrix4);
    this.origin.applyMatrix4(matrix4);
    this.direction.sub(this.origin);
    this.direction.normalize();

    return this;
  },

  equals: function equals(ray) {

    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }

};

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The poles (phi) are at the positive and negative y axis.
 * The equator starts at positive z.
 */

function Spherical(radius, phi, theta) {

  this.radius = radius !== undefined ? radius : 1.0;
  this.phi = phi !== undefined ? phi : 0; // up / down towards top and bottom pole
  this.theta = theta !== undefined ? theta : 0; // around the equator of the sphere

  return this;
}

Spherical.prototype = {

  constructor: Spherical,

  set: function set(radius, phi, theta) {

    this.radius = radius;
    this.phi = phi;
    this.theta = theta;

    return this;
  },

  clone: function clone() {

    return new this.constructor().copy(this);
  },

  copy: function copy(other) {

    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;

    return this;
  },

  // restrict phi to be betwee EPS and PI-EPS
  makeSafe: function makeSafe() {

    var EPS = 0.000001;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));

    return this;
  },

  setFromVector3: function setFromVector3(vec3) {

    this.radius = vec3.length();

    if (this.radius === 0) {

      this.theta = 0;
      this.phi = 0;
    } else {

      this.theta = Math.atan2(vec3.x, vec3.z); // equator angle around y-up axis
      this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1)); // polar angle
    }

    return this;
  }

};

var REVISION = '84-threekit';
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var PCSSSoftShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RGB_S3TC_DXT1_Format = 2001;
var RGBA_S3TC_DXT1_Format = 2002;
var RGBA_S3TC_DXT3_Format = 2003;
var RGBA_S3TC_DXT5_Format = 2004;
var RGB_PVRTC_4BPPV1_Format = 2100;
var RGB_PVRTC_2BPPV1_Format = 2101;
var RGBA_PVRTC_4BPPV1_Format = 2102;
var RGBA_PVRTC_2BPPV1_Format = 2103;
var RGB_ETC1_Format = 2151;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var OrderIndependentTransperancy = 3300;
var PaintersTransperancy = 3301;

Vector2.InstanceScalarSize = 2;
Vector3.InstanceScalarSize = 3;
Vector4.InstanceScalarSize = 4;

Color.InstanceScalarSize = 3;
Quaternion.InstanceScalarSize = 4;

Matrix3.InstanceScalarSize = 9;
Matrix4.InstanceScalarSize = 16;

//override the toJSON function to return serialization to its previous state
Color.prototype.toJSON = function () {
  return { r: this.r, g: this.g, b: this.b };
};

exports.Matrix4 = Matrix4;
exports.Matrix3 = Matrix3;
exports.Vector2 = Vector2;
exports.Vector3 = Vector3;
exports.Vector4 = Vector4;
exports.Quaternion = Quaternion;
exports.Color = Color;
exports.Triangle = Triangle;
exports.Box3 = Box3;
exports.Euler = Euler;
exports.Math = _Math;
exports.Ray = Ray;
exports.Spherical = Spherical;
exports.Sphere = Sphere;
exports.Plane = Plane;
exports.REVISION = REVISION;
exports.MOUSE = MOUSE;
exports.CullFaceNone = CullFaceNone;
exports.CullFaceBack = CullFaceBack;
exports.CullFaceFront = CullFaceFront;
exports.CullFaceFrontBack = CullFaceFrontBack;
exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
exports.BasicShadowMap = BasicShadowMap;
exports.PCFShadowMap = PCFShadowMap;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
exports.PCSSSoftShadowMap = PCSSSoftShadowMap;
exports.FrontSide = FrontSide;
exports.BackSide = BackSide;
exports.DoubleSide = DoubleSide;
exports.FlatShading = FlatShading;
exports.SmoothShading = SmoothShading;
exports.NoColors = NoColors;
exports.FaceColors = FaceColors;
exports.VertexColors = VertexColors;
exports.NoBlending = NoBlending;
exports.NormalBlending = NormalBlending;
exports.AdditiveBlending = AdditiveBlending;
exports.SubtractiveBlending = SubtractiveBlending;
exports.MultiplyBlending = MultiplyBlending;
exports.CustomBlending = CustomBlending;
exports.AddEquation = AddEquation;
exports.SubtractEquation = SubtractEquation;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
exports.MinEquation = MinEquation;
exports.MaxEquation = MaxEquation;
exports.ZeroFactor = ZeroFactor;
exports.OneFactor = OneFactor;
exports.SrcColorFactor = SrcColorFactor;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
exports.SrcAlphaFactor = SrcAlphaFactor;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
exports.DstAlphaFactor = DstAlphaFactor;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
exports.DstColorFactor = DstColorFactor;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
exports.NeverDepth = NeverDepth;
exports.AlwaysDepth = AlwaysDepth;
exports.LessDepth = LessDepth;
exports.LessEqualDepth = LessEqualDepth;
exports.EqualDepth = EqualDepth;
exports.GreaterEqualDepth = GreaterEqualDepth;
exports.GreaterDepth = GreaterDepth;
exports.NotEqualDepth = NotEqualDepth;
exports.MultiplyOperation = MultiplyOperation;
exports.MixOperation = MixOperation;
exports.AddOperation = AddOperation;
exports.NoToneMapping = NoToneMapping;
exports.LinearToneMapping = LinearToneMapping;
exports.ReinhardToneMapping = ReinhardToneMapping;
exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
exports.CineonToneMapping = CineonToneMapping;
exports.UVMapping = UVMapping;
exports.CubeReflectionMapping = CubeReflectionMapping;
exports.CubeRefractionMapping = CubeRefractionMapping;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
exports.SphericalReflectionMapping = SphericalReflectionMapping;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
exports.RepeatWrapping = RepeatWrapping;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
exports.NearestFilter = NearestFilter;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
exports.LinearFilter = LinearFilter;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
exports.UnsignedByteType = UnsignedByteType;
exports.ByteType = ByteType;
exports.ShortType = ShortType;
exports.UnsignedShortType = UnsignedShortType;
exports.IntType = IntType;
exports.UnsignedIntType = UnsignedIntType;
exports.FloatType = FloatType;
exports.HalfFloatType = HalfFloatType;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
exports.UnsignedShort565Type = UnsignedShort565Type;
exports.UnsignedInt248Type = UnsignedInt248Type;
exports.AlphaFormat = AlphaFormat;
exports.RGBFormat = RGBFormat;
exports.RGBAFormat = RGBAFormat;
exports.LuminanceFormat = LuminanceFormat;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
exports.RGBEFormat = RGBEFormat;
exports.DepthFormat = DepthFormat;
exports.DepthStencilFormat = DepthStencilFormat;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
exports.LoopOnce = LoopOnce;
exports.LoopRepeat = LoopRepeat;
exports.LoopPingPong = LoopPingPong;
exports.InterpolateDiscrete = InterpolateDiscrete;
exports.InterpolateLinear = InterpolateLinear;
exports.InterpolateSmooth = InterpolateSmooth;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
exports.WrapAroundEnding = WrapAroundEnding;
exports.TrianglesDrawMode = TrianglesDrawMode;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
exports.TriangleFanDrawMode = TriangleFanDrawMode;
exports.LinearEncoding = LinearEncoding;
exports.sRGBEncoding = sRGBEncoding;
exports.GammaEncoding = GammaEncoding;
exports.RGBEEncoding = RGBEEncoding;
exports.LogLuvEncoding = LogLuvEncoding;
exports.RGBM7Encoding = RGBM7Encoding;
exports.RGBM16Encoding = RGBM16Encoding;
exports.RGBDEncoding = RGBDEncoding;
exports.BasicDepthPacking = BasicDepthPacking;
exports.RGBADepthPacking = RGBADepthPacking;
exports.OrderIndependentTransperancy = OrderIndependentTransperancy;
exports.PaintersTransperancy = PaintersTransperancy;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(13);
var core = __webpack_require__(113);
var hide = __webpack_require__(42);
var redefine = __webpack_require__(64);
var ctx = __webpack_require__(52);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(519), __esModule: true };

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _create = __webpack_require__(48);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = ObjectArrayView;

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

var _FlatArrayView = __webpack_require__(227);

var _FlatArrayView2 = _interopRequireDefault(_FlatArrayView);

var _ObjectBuffer = __webpack_require__(68);

var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Object view mapping fixed size objects to flat arrays.
 *
 * @constructor
 *
 * @param {!function(new:*)} type
 *
 *    object constructor
 *
 * @param {number} length
 *
 *    number of objects to map,
 *    can be null when an existing array is given,
 *
 * @param {ArrayOrType=} optionalArrayOrType
 *
 *    existing array or array constructor, default is Float32Array
 *
 * @param {number=} optionalStride
 *
 *    an explicit stride for cases where it differs from the element size
 *    deduced from {@code type.InstanceScalarSize}
 */
function ObjectArrayView(type, length, optionalArrayOrType, optionalStride) {
  var elementSize = type.InstanceScalarSize || optionalStride;
  var stride = optionalStride || elementSize;
  var arrayLength = length !== null ? length * stride : null;

  if (elementSize === undefined || stride === undefined) throw Error("Can't determine element size / stride!");

  var existingArrayOrType = optionalArrayOrType || Float32Array;

  var array = _Arrays2.default.maybeCreate(existingArrayOrType, arrayLength);

  _FlatArrayView2.default.call(this, array, length ||
  // Note: Integer division by 'stride', rounding towards infinity
  // at a minimum remainder of 'elementSize':
  (array.length + stride - elementSize) / stride | 0);

  this.type = type;
  this.stride = stride;
  this.elementSize = elementSize;
  this.tempBuffer = new Float32Array(elementSize);
}

ObjectArrayView.prototype = (0, _assign2.default)((0, _create2.default)(_FlatArrayView2.default.prototype), {
  constructor: ObjectArrayView,

  getAt: function getAt(index, optionalValue) {
    var result = optionalValue || new this.type();
    return result.fromArray(this.data, index * this.stride);
  },

  setAt: function setAt(index, value) {
    value.toArray(this.data, index * this.stride);
  },

  addAt: function addAt(index, value) {
    value.toArray(this.tempBuffer, 0);
    for (var i = 0, offset = index * this.stride; i < this.elementSize; i++) {
      this.data[offset + i] += this.tempBuffer[i];
    }
  },

  multiplyScalarAt: function multiplyScalarAt(index, scalar) {
    for (var i = 0, offset = index * this.stride; i < this.elementSize; i++) {
      this.data[offset + i] *= scalar;
    }
  },

  newCompatibleView: function newCompatibleView(arrayOrType, optionalLength) {
    return new ObjectArrayView(this.type, optionalLength || null, arrayOrType, this.stride);
  },

  newCompatibleBuffer: function newCompatibleBuffer() {
    return new _ObjectBuffer2.default(this.type, this.data.constructor, this.stride);
  }
});

ObjectArrayView.fromObjects = function (type, objects, optionalArrayType) {
  var result = new ObjectArrayView(type, objects.length, optionalArrayType);

  _Arrays2.default.copyObjects(objects, result.data);
  return result;
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(525), __esModule: true };

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = PolyMesh;

var _earcut = __webpack_require__(304);

var _earcut2 = _interopRequireDefault(_earcut);

var _three = __webpack_require__(0);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _findBoundingBox = __webpack_require__(430);

var _findBoundingBox2 = _interopRequireDefault(_findBoundingBox);

var _calculateVolume = __webpack_require__(427);

var _calculateVolume2 = _interopRequireDefault(_calculateVolume);

var _cleanPolyMesh = __webpack_require__(102);

var _cleanPolyMesh2 = _interopRequireDefault(_cleanPolyMesh);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _FaceNormals = __webpack_require__(232);

var _FaceNormals2 = _interopRequireDefault(_FaceNormals);

var _setNormalsFromSmoothingGroups = __webpack_require__(440);

var _setNormalsFromSmoothingGroups2 = _interopRequireDefault(_setNormalsFromSmoothingGroups);

var _ShapeSet = __webpack_require__(233);

var _Normals = __webpack_require__(50);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PolyMesh(from, replacements) {
  if (!from) {
    this.faceRangeOffsets = new Uint32Array(1);
    this.positions = new _PolyMap2.default();

    this.colorMaps = new _ObjectsByName2.default();
    this.uvMaps = new _ObjectsByName2.default();
  } else {
    if (!from.colorMaps) console.error('Polymesh must have initialized colorMaps container.');
    if (!from.uvMaps) console.error('Polymesh must have initialized uvMaps container.');

    this.faceRangeOffsets = from.faceRangeOffsets; // Uint32Array
    this.positions = from.positions; // PolyMap Object
    this.normalMap = from.normalMap; // PolyMap Object
    this.uvMaps = _ObjectsByName2.default.shallowClone(from.uvMaps); // ObjectsByName contains PolyMap Object
    if (from.tangentMap) this.tangentMap = from.tangentMap; // PolyMap Object

    // optional properties discarded topology change:
    if (from.skinning) this.skinning = from.skinning; // Skinning Object
    if (from.edgeCreaseWeights) this.edgeCreaseWeights = from.edgeCreaseWeights; // Float32Array : index === edge, value === weight {0..1}
    if (from.materialIds) this.materialIds = from.materialIds; // Uint32Array  : index === face

    if (from.blendShapes) this.blendShapes = from.blendShapes; // BlendShape Object

    // not implemented:
    // this.tangentMap = from.tangentMap;                           // PolyMap Object
    this.colorMaps = _ObjectsByName2.default.shallowClone(from.colorMaps); // ObjectsByName contains PolyMap Object

    // this._cachedVolume = (typeof from._cachedVolume === 'number' && !isNaN(from._cachedVolume)) ? from._cachedVolume : null;

    if (replacements) {
      (0, _assign2.default)(this, replacements);
    }
  }

  this._cachedVolume = null; // if we can have some verification of validity of from._cachedVolume, we can use that
  this.boundingBox = (0, _findBoundingBox2.default)(this.positions);
  this._faceNormals = null;
}

PolyMesh.prototype = {
  constructor: PolyMesh,

  getNumFaces: function getNumFaces() {
    return this.faceRangeOffsets.length - 1;
  },

  getNumFaceVertices: function getNumFaceVertices() {
    return this.positions.faceValueIndices.length;
  },

  getNumVertices: function getNumVertices() {
    return this.positions.values.length;
  },

  getMapById: function getMapById(mapId) {
    return _PolyMaps2.default.resolveMap(this, mapId) || null;
  },

  topologyChanged: function topologyChanged() {
    var materialIdsValid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    //this function is only to be called during construction of a new polymesh
    //its purpose is to nullify data that would become invalidated due to a change in topology
    //the data to remain intact would have to also be correctly mapped in each operator
    //in the future operators will instead generate a mapping that can be applied through
    //a general mapping function so such additions can be done in a singular location
    if (this.skinning) this.skinning = null;
    if (this.edgeCreaseWeights) this.edgeCreaseWeights = null;
    if (this.materialIds && !materialIdsValid) this.materialIds = null;
    return this;
  },

  getVolume: function getVolume() {
    // Keep in mind that this does is the volume for the base geometry, so you may want to multiply
    // the result by the scaling of its transform (ex. getVolume() * scale.x * scale.y * scale.z)
    if (this._cachedVolume === null) this._cachedVolume = (0, _calculateVolume2.default)(this);
    return this._cachedVolume;
  },

  // face normal structure, computed on-demand for normals of each face
  get faceNormals() {
    if (!this._faceNormals) this._faceNormals = new _FaceNormals2.default(this.positions);

    return this._faceNormals;
  }
};

PolyMesh.fromData = function (faceRangeOffsets, positions, optionalIndices, optionalMaterialIds) {
  var polyMesh = new PolyMesh({
    faceRangeOffsets: faceRangeOffsets,
    positions: positions.isPolyMap ? positions : _PolyMap2.default.fromData(faceRangeOffsets, optionalIndices || null, positions),
    uvMaps: new _ObjectsByName2.default(), // ObjectsByName< PolyMap<Vector2> >
    colorMaps: new _ObjectsByName2.default() // ObjectsByName< PolyMap<Color> >
  });

  if (optionalMaterialIds) polyMesh.materialIds = optionalMaterialIds;

  return polyMesh;
};

PolyMesh.fromShapeSet = function (shapeSet) {
  // triangulate each faces
  var nbFaces = shapeSet.loopRangeOffsets.length - 1;
  var faceArray = [0];
  var indicesArray = [];
  var smoothGroups = [];

  var faceArrayOffset = 0;
  var faceBegin = shapeSet.loopRangeOffsets[0];
  for (var fi = 0; fi < nbFaces; ++fi) {
    var faceUntil = shapeSet.loopRangeOffsets[fi + 1];

    // triangulate with holes
    var triangles = (0, _earcut2.default)(shapeSet.positions.data.subarray(faceBegin * 3, faceUntil * 3), shapeSet.holeOffsets[fi], 3);

    var backFaceBegin = faceBegin + shapeSet.backFaceOffsets;

    // copy the triangles into the new indices array
    var nbTriangles = triangles.length;
    for (var t = 0; t < nbTriangles; t += 3) {
      // front face
      faceArrayOffset += 3;
      faceArray.push(faceArrayOffset);

      indicesArray.push(triangles[t] + faceBegin);
      indicesArray.push(triangles[t + 1] + faceBegin);
      indicesArray.push(triangles[t + 2] + faceBegin);
      smoothGroups.push(_ShapeSet.SmoothingGroupIds.Front);

      // back face
      faceArrayOffset += 3;
      faceArray.push(faceArrayOffset);

      indicesArray.push(triangles[t] + backFaceBegin);
      indicesArray.push(triangles[t + 2] + backFaceBegin);
      indicesArray.push(triangles[t + 1] + backFaceBegin);
      smoothGroups.push(_ShapeSet.SmoothingGroupIds.Back);
    }
    faceBegin = faceUntil;
  }

  // handle the bevels
  var nbBevelTriangles = shapeSet.bevelSegments.length;
  for (var bi = 0; bi < nbBevelTriangles; bi += 3) {
    faceArrayOffset += 3;
    faceArray.push(faceArrayOffset);

    indicesArray.push(shapeSet.bevelSegments[bi]);
    indicesArray.push(shapeSet.bevelSegments[bi + 1]);
    indicesArray.push(shapeSet.bevelSegments[bi + 2]);
  }

  // add precalculated smoothing groups for the bevel triangles
  smoothGroups = smoothGroups.concat(shapeSet.bevelSmoothingGroups);

  var faceRangeOffsets = new Uint32Array(faceArray);
  var faceValueIndices = new Uint32Array(indicesArray);

  // create position PolyMap
  var positions = _PolyMap2.default.fromData(faceRangeOffsets, faceValueIndices, shapeSet.positions);

  var from = {
    faceRangeOffsets: faceRangeOffsets,
    positions: positions,
    normalMap: new _ObjectsByName2.default(),
    uvMaps: new _ObjectsByName2.default(),
    colorMaps: new _ObjectsByName2.default()
  };

  // let resultMesh = cleanPolyMesh(new PolyMesh(from)); // interferes with smoothing groups
  var resultMesh = new PolyMesh(from);
  resultMesh = (0, _setNormalsFromSmoothingGroups2.default)(resultMesh, smoothGroups);

  return resultMesh;
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = PolyMap;

var _three = __webpack_require__(0);

var _IndexMappings = __webpack_require__(124);

var _IndexMappings2 = _interopRequireDefault(_IndexMappings);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

var _EdgeVertexAdjacency = __webpack_require__(422);

var _EdgeVertexAdjacency2 = _interopRequireDefault(_EdgeVertexAdjacency);

var _FaceEdgeAdjacency = __webpack_require__(423);

var _FaceEdgeAdjacency2 = _interopRequireDefault(_FaceEdgeAdjacency);

var _ValueAdjacency = __webpack_require__(425);

var _ValueAdjacency2 = _interopRequireDefault(_ValueAdjacency);

var _FaceFaceAdjacency = __webpack_require__(424);

var _FaceFaceAdjacency2 = _interopRequireDefault(_FaceFaceAdjacency);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @template T
 * @constructor
 *
 * @param {!PolyMap|!Object} from object to copy the properties from
 */
function PolyMap(from, replacements) {
  if (!from) {
    this.faceRangeOffsets = new Uint32Array(1);
    this.faceValueIndices = new Uint32Array(0);
    this.values = new _ObjectArrayView2.default(_three.Vector3, 0);
  } else {
    this.faceRangeOffsets = from.faceRangeOffsets; //Uint32Array
    this.faceValueIndices = from.faceValueIndices; //Uint32Array
    this.values = from.values; //ObjectArrayView contains Three.Vector3 or Three.Vector2 usually

    // Cached transient information (can be rebuilt from the above):

    // Inverse index (value indices -> faces):
    var valueFaceIndices = from.valueFaceIndices || null;
    this.valueFaceIndices = valueFaceIndices;
    this.valueFaceIndexOffsets = // only reuse when complete
    valueFaceIndices && from.valueFaceIndexOffsets || null;

    // The low value index acts as the pivot for edge enumeration, so
    // the following array is indexed by edge UIDs:
    this._edgeVertexAdjacency = null;
    this._faceEdgeAdjacency = null;
    this._valueAdjacency = null;
    this._valueValueAdjacency = null;
    this._faceFaceAdjacency = null;

    if (replacements) {
      (0, _assign2.default)(this, replacements);
    }
  }
}

PolyMap.fromData = function (faceOffsets, indices, values) {
  var result = new PolyMap({
    faceRangeOffsets: faceOffsets,

    faceValueIndices: indices || _IndexMappings2.default.identity(values.length, Uint32Array),

    values: values.repack(Float32Array)
  });

  var nFaceVertices = faceOffsets[faceOffsets.length - 1];

  if (result.faceValueIndices.length !== nFaceVertices) throw Error('Number of postition indices or unindexed ' + 'data values does not match the number of face vertices!');

  return result;
};

PolyMap.prototype = {
  constructor: PolyMap,
  isPolyMap: true,

  findValueIndexOffset: function findValueIndexOffset(faceIndex, valueIndex) {
    var offsets = this.faceRangeOffsets;
    var indices = this.faceValueIndices;

    var begin = offsets[faceIndex];
    var until = offsets[faceIndex + 1];

    for (var i = begin; i !== until; ++i) {
      if (indices[i] === valueIndex) return i;
    }return -1;
  },

  // adjacency structures, computed on-demand adjacency structures.

  get edgeVertexAdjacency() {
    if (!this._edgeVertexAdjacency) this._edgeVertexAdjacency = new _EdgeVertexAdjacency2.default(this);

    return this._edgeVertexAdjacency;
  },

  get faceEdgeAdjacency() {
    if (!this._faceEdgeAdjacency) this._faceEdgeAdjacency = new _FaceEdgeAdjacency2.default(this);

    return this._faceEdgeAdjacency;
  },

  get valueAdjacency() {
    if (!this._valueAdjacency) this._valueAdjacency = new _ValueAdjacency2.default(this);

    return this._valueAdjacency;
  },

  get valueValueAdjacency() {
    if (!this._valueValueAdjacency) this._valueValueAdjacency = new ValueValueAdjacency(this);

    return this._valueValueAdjacency;
  },

  get faceFaceAdjacency() {
    if (!this._faceFaceAdjacency) this._faceFaceAdjacency = new _FaceFaceAdjacency2.default(this);

    return this._faceFaceAdjacency;
  },

  // Inverse index (value index -> faces) build

  updateInverseIndex: function updateInverseIndex() {
    if (this.valueFaceIndices === null) {
      var faceOffsets = this.faceRangeOffsets;

      var faceIndex = -1;
      var nextFaceStart = faceOffsets[0];

      var indices = this.faceValueIndices;

      var writeOffsets = this._updateValueFaceIndexOffsets();
      var nDestOffsets = writeOffsets.length;

      var nFaceIndices = indices.length;
      var faceIndices = new Uint32Array(nFaceIndices);

      for (var i = 0; i !== nFaceIndices; ++i) {
        if (i === nextFaceStart) nextFaceStart = faceOffsets[++faceIndex + 1];

        faceIndices[writeOffsets[indices[i]]++] = faceIndex;
      }

      this.valueFaceIndices = faceIndices;

      // Shift the write offsets back to their initial values:

      if (writeOffsets.byteOffset === 0) throw Error('Invalid .valueFaceIndexOffsets != null!');

      this.valueFaceIndexOffsets = new Uint32Array(writeOffsets.buffer, 0, nDestOffsets);
    }

    return this;
  },

  _updateValueFaceIndexOffsets: function _updateValueFaceIndexOffsets() {
    var result = this.valueFaceIndexOffsets;

    if (result === null) {
      var nValues = this.values.length;
      var requiredLength = nValues + 2;

      // Two extra values... Why?
      //
      // 1. For uniform access we keep n+1 offsets, that is
      //    0, o_0, o_1, o_2 ..., <length>
      //
      // 2. The build of the inverse indices is destructive
      //    and shifts the offsets by one index. The result
      //    is something like:
      //
      //    o_0, o_1, o_2, ..., <length>, <length>
      //
      //    Now we will want our leading zero back.

      var buffer = new Uint32Array(requiredLength);
      var histogramArea = buffer.subarray(2);

      result = buffer.subarray(1);

      _IndexMappings2.default.histogram(this.faceValueIndices, nValues, histogramArea);

      _Arrays2.default.accumulate(histogramArea);

      this.valueFaceIndices = null;
      this.valueFaceIndexOffsets = result;
    }

    return result;
  },

  // Compaction

  compactValues: function compactValues() {
    var values = this.values;
    var nValues = values.length;

    if (nValues !== 0) {
      var sourceToTargetMap = new Uint32Array(nValues);
      var nCompactValues = this._compactFaceIndexOffsets(sourceToTargetMap);

      if (nCompactValues !== nValues) {
        this._compactData(sourceToTargetMap, nCompactValues);
        this._compactIndices(sourceToTargetMap);
      }
    }

    return this;
  },

  _compactFaceIndexOffsets: function _compactFaceIndexOffsets(outSourceToTargetMap) {
    var faceIndexOffsets = this._updateValueFaceIndexOffsets();
    var nValues = outSourceToTargetMap.length;

    var nCompactValues = 0;
    var offset = 0; // == faceIndexOffsets[ 0 ]

    for (var i = 0; i !== nValues; ++i) {
      var nextOffset = faceIndexOffsets[i + 1];

      outSourceToTargetMap[i] = nCompactValues;
      // Note: Filling in incorrect values at indices that are no longer
      // used, actually. But those allow to replay the compaction of the
      // offsets on the values once the size is known.
      //
      // The value that corresponds to the last index in an equal range
      // is the one to keep.

      if (offset !== nextOffset) {
        if (nCompactValues !== i) faceIndexOffsets[nCompactValues] = offset;

        offset = nextOffset;
        ++nCompactValues;
      }
    }

    faceIndexOffsets[nCompactValues] = offset;

    if (nCompactValues !== nValues) {
      // Note: Since only empty ranges were removed, neither need to null
      // nor rebuild .valueFaceIndices.

      if (faceIndexOffsets.byteOffset !== 0) {
        // this will be our leading zero and we want to keep it, so have
        // a little dance with the typed arrays API...

        var bufferView = new Uint32Array(faceIndexOffsets.buffer),
            slice = _Arrays2.default.slice(bufferView, 0, nCompactValues + 2);

        faceIndexOffsets = slice.subarray(1);

        // ... phew!
      } else {
        faceIndexOffsets = _Arrays2.default.slice(faceIndexOffsets, 0, nCompactValues + 1);
      }
    }

    this.valueFaceIndexOffsets = faceIndexOffsets;
    return nCompactValues;
  },

  _compactData: function _compactData(sourceToTargetMap, nCompactValues) {
    // Rewrite the values to a new buffer, avoiding to build another
    // temporary map, instead exploit the bogus padding of the STTM:

    var values = this.values;
    var nValues = values.length;
    var newValues = new _ObjectArrayView2.default(values.type, nCompactValues);
    var writeIndex = sourceToTargetMap[0];
    var element = newValues.newRangeArray();

    for (var i = 1; i !== nValues; ++i) {
      var nextWriteIndex = sourceToTargetMap[i];

      if (writeIndex !== nextWriteIndex) {
        // now i - 1 is the source position we want

        values.rangeToArray(i - 1, 1, element);
        newValues.arrayToRange(element, writeIndex, 1);

        writeIndex = nextWriteIndex;
      }
    }

    values.rangeToArray(nValues - 1, 1, element);
    newValues.arrayToRange(element, writeIndex, 1);

    this.values = newValues;
  },

  _compactIndices: function _compactIndices(sourceToTargetMap) {
    // The size of the index array does not change - it has already (else
    // there'd be no unused indices), but we don't know when (the typical
    // case would be in a previous transaction), so the same array can be
    // in use elsewhere...

    var indices = this.faceValueIndices;
    var nIndices = indices.length;

    var newIndices = new Uint32Array(nIndices);

    _IndexMappings2.default.apply(indices, sourceToTargetMap, newIndices);
    this.faceValueIndices = newIndices;
  }
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _typeof2 = __webpack_require__(38);

var _typeof3 = _interopRequireDefault(_typeof2);

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.find = find;
exports.filter = filter;
exports.get = get;
exports.getAll = getAll;
exports.getEval = getEval;
exports.getWorldTransform = getWorldTransform;
exports.getRelativeTransform = getRelativeTransform;
exports.getLocalTransform = getLocalTransform;
exports.set = set;
exports.setAll = setAll;
exports.getWarnings = getWarnings;
exports.setVRCamera = setVRCamera;
exports.clone = clone;
exports.cloneModel = cloneModel;
exports.pruneAssets = pruneAssets;
exports.getNodeBoundingBox = getNodeBoundingBox;
exports.isVisible = isVisible;
exports.getAvailableOperators = getAvailableOperators;
exports.getScreenPosition = getScreenPosition;
exports.getCurrentPass = getCurrentPass;
exports.exportJSON = exportJSON;
exports.addNode = addNode;
exports.addOperator = addOperator;

var _three = __webpack_require__(0);

var _sceneGraph = __webpack_require__(10);

var _player = __webpack_require__(8);

var _assets = __webpack_require__(33);

var _selectors = __webpack_require__(123);

var _operators = __webpack_require__(101);

var _operators2 = _interopRequireDefault(_operators);

var _configuration = __webpack_require__(98);

var _getProjectionMatrix = __webpack_require__(105);

var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This module is a high level scene graph manipulation and query library.
 *
 * * Either id, name, or regex's can be used for node names.
 * * All `get` functions return the value, or undefined if no match is found
 * * All `find` functions return an `id` or a Path
 * * All `filter` functions return an array of `id` or Path
 * *
 * @module scene
 * @public
 *
 */

/**
 * Finds first matching node.
 * If propertyName is specified, will look for the first matching operator,
 * and if found, return a path to the operator property.
 * (See {@tutorial sdk-SceneGraph})
 *
 * @public
 * @param {(String|QueryObject)} query The query object to filter on (or a string that gets converted to a query object).
 *
 * @example
 *
 * // Return the node uuid
 * scene.find('Box'); -> 'uuid'
 * // Return the path to the transform operator
 * scene.find('Box','Transform','translation'); -> ['uuid','Transform',0]
 * // Match the first node that starts with Box
 * scene.find('Box*');
 *
 */
function find(store, query, onlyNode) {
  var queryObj = (0, _selectors.buildQueryObject)(query);
  var sceneGraph = store.get('sceneGraph');

  // Don't need to do a search if we have an id
  if (queryObj.id) {
    var foundNode = sceneGraph.nodes[queryObj.id];
    if (foundNode && queryObj.parent) {
      return foundNode.parent || null;
    }

    if (foundNode && queryObj.child) {
      return (0, _selectors.findChild)(store, foundNode, { type: queryObj.child, shallow: true }, false, true) || null;
    }

    return foundNode ? (0, _selectors.getMatch)(foundNode, queryObj, onlyNode) : null;
  }

  // If we ask to search `all`, then we do a linear search. This lets us
  // find nodes from scenes not in the active scene graph.
  if (queryObj.from && queryObj.from.all) {
    var result = void 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(sceneGraph.nodes)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var id = _step.value;

        result = (0, _selectors.getMatch)(sceneGraph.nodes[id], queryObj);
        if (result) return result;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return null;
  }

  var rootId = queryObj.from ? find(store, queryObj.from, true) : sceneGraph.activeSceneId;

  var rootNode = rootId && sceneGraph.nodes[rootId];

  return rootNode ? (0, _selectors.findChild)(store, rootNode, queryObj, queryObj.includeParent && rootNode, onlyNode) : null;
}

/**
 * This function will iterate through the scene graph, returning an array
 * of all elements that match the parameters provided.
 *
 * The return value of this function will either be an array of ids (if nodequery and
 * plug are provied), or an array of paths (if property is provided).
 *
 * (See {@tutorial sdk-SceneGraph})
 *
 * @public
 * @param {(String|QueryObject)} query The query object to filter on (or a string that gets converted to a query object).
 * @returns {Array}
 */
function filter(store, query) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var queryObj = (0, _selectors.buildQueryObject)(query);
  var sceneGraph = store.get('sceneGraph');
  var fromId = queryObj.from ? find(store, queryObj.from) : sceneGraph.activeSceneId;

  // No matching from query, return empty search
  if (!fromId) return [];

  var fromNode = sceneGraph.nodes[fromId];

  if (!fromNode) {
    throw new Error('Unknown node to filter from');
  }

  return (0, _selectors.matchChildren)(store, fromNode, queryObj, queryObj.includeParent && fromNode, options.onlyNode);
}

/**
 * Returns the value at the matching property.
 *
 * (See {@tutorial sdk-SceneGraph})
 *
 * @param {(String|QueryObject|Path)} query The query object to filter on (or a string that gets converted to a query object).
 * @returns {any}
 * @public
 */
function get(store, query) {
  var path = Array.isArray(query) ? query : find(store, query);
  if (!path || !Array.isArray(path)) return undefined;
  if (path.length >= 2 && path[1] === 'eval') {
    var evalNode = (0, _sceneGraph.getEvalSceneGraph)(store).evaluatedNodes[path[0]];
    var evalPlug = evalNode && evalNode[path[2]];
    return evalPlug && path[3] ? evalPlug[path[3]] : evalPlug;
  }

  return (0, _sceneGraph.get)(store, path);
}

/**
 * Returns an array of values for the matching properties
 *
 * (See {@tutorial sdk-SceneGraph})
 *
 * @param {(String|QueryObject|Path)} query The query object to filter on (or a found path)
 * @returns {any[]}
 * @public
 */
function getAll(store, query) {
  var paths = Array.isArray(query) ? query : filter(store, query);
  return paths ? paths.reduce(function (obj, path) {
    obj[path[0]] = (0, _sceneGraph.get)(store, path);
    return obj;
  }, {}) : undefined;
}

/**
 * Returns the evaluated plug (and/or property).
 * @param {String} nodeId id of the node
 * @param {String} plug
 * @param {?String} key
 *
 * @example
 *
 * // Return the calculated transform
 * ctx.getEval('Box','Transfrom','translation');
 * // Return the orbitTarget for the scene camera
 * ctx.getEval(true, 'Player', 'orbitTarget');
 */
function getEval(store, nodeId, plug, key) {
  return get(store, key ? [nodeId, plug, key] : [nodeId, plug]);
}

/**
 * Get the world transform for a node.
 *
 * @param {String} id
 * @public
 * @returns {?Matrix4}
 */
function getWorldTransform(store, id) {
  var transform = get(store, { id: id, evalPlug: 'Transform' });
  if (!transform) return null;

  var localTransform = transform.transform;
  var node = store.get('sceneGraph').nodes[id];
  var parent = node && node.parent;

  var parentTransform = parent && getWorldTransform(store, parent);
  return parentTransform ? new _three.Matrix4().copy(parentTransform).multiply(localTransform) : new _three.Matrix4().copy(localTransform);
}

/**
 * Get the transform for a node relative to a specified ancestor node. If rootId is not in id's
 *  ancestry, the result is simply the world transform.
 *
 * @param {String} id
 * @param {String} rootId - the node for which we want to calculated id's relative transform from
 * @public
 * @returns {?Matrix4}
 */
function getRelativeTransform(store, id, rootId) {
  var transform = get(store, { id: id, evalPlug: 'Transform' });
  if (!transform || id === rootId) return null;

  var localTransform = transform.transform;
  var node = store.get('sceneGraph').nodes[id];
  var parent = node && node.parent;
  var parentTransform = parent && getRelativeTransform(store, parent, rootId);
  return parentTransform ? new _three.Matrix4().copy(parentTransform).multiply(localTransform) : new _three.Matrix4().copy(localTransform);
}

/**
 * Get the local transform for a node.
 *
 * @returns {?Matrix4}
 */
function getLocalTransform(transform) {
  var translation = transform.translation,
      rotation = transform.rotation,
      scale = transform.scale,
      rotateOrder = transform.rotateOrder,
      preRotation = transform.preRotation,
      rotatePivotOffset = transform.rotatePivotOffset,
      localRotatePivot = transform.localRotatePivot,
      scalePivotOffset = transform.scalePivotOffset,
      localScalePivot = transform.localScalePivot,
      shear = transform.shear;

  if (scale.x === 0) scale.x = 0.0000001;
  if (scale.y === 0) scale.y = 0.0000001;
  if (scale.z === 0) scale.z = 0.0000001;
  var zero = new _three.Vector3(0, 0, 0);

  var matrixStack = [];

  var translationM = new _three.Matrix4().makeTranslation(translation.x, translation.y, translation.z);
  matrixStack.push(translationM);

  var rotatePivotOffestM = new _three.Matrix4();
  if (!rotatePivotOffset.equals(zero)) {
    rotatePivotOffestM.makeTranslation(rotatePivotOffset.x, rotatePivotOffset.y, rotatePivotOffset.z);
    matrixStack.push(rotatePivotOffestM);
  }

  var localRotatePivotM = new _three.Matrix4();
  var invLocalRotatePivotM = new _three.Matrix4();
  var localRotatePivotFlag = false;
  if (!localRotatePivot.equals(zero)) {
    localRotatePivotM.makeTranslation(localRotatePivot.x, localRotatePivot.y, localRotatePivot.z);
    matrixStack.push(localRotatePivotM);
    invLocalRotatePivotM.getInverse(localRotatePivotM, true);
    localRotatePivotFlag = true;
  }

  var preRotationM = new _three.Matrix4();
  if (!preRotation.equals(zero)) {
    var localRotationRadians = new _three.Vector3().copy(preRotation).multiplyScalar(Math.PI / 180);
    preRotationM.makeRotationFromEuler(new _three.Euler(localRotationRadians.x, localRotationRadians.y, localRotationRadians.z, rotateOrder));
    matrixStack.push(preRotationM);
  }

  var rotationRadians = new _three.Vector3().copy(rotation).multiplyScalar(Math.PI / 180);
  var rotationM = new _three.Matrix4().makeRotationFromEuler(new _three.Euler(rotationRadians.x, rotationRadians.y, rotationRadians.z, rotateOrder));
  matrixStack.push(rotationM);

  if (localRotatePivotFlag) matrixStack.push(invLocalRotatePivotM);

  var scalePivotOffsetM = new _three.Matrix4();
  if (!scalePivotOffset.equals(zero)) {
    scalePivotOffsetM.makeTranslation(scalePivotOffset.x, scalePivotOffset.y, scalePivotOffset.z);
    matrixStack.push(scalePivotOffsetM);
  }

  var localScalePivotM = new _three.Matrix4();
  var invLocalScalePivotM = new _three.Matrix4();
  var localScalePivotFlag = false;
  if (!localScalePivot.equals(zero)) {
    localScalePivotM.makeTranslation(localScalePivot.x, localScalePivot.y, localScalePivot.z);
    matrixStack.push(localScalePivotM);
    invLocalScalePivotM.getInverse(localScalePivotM, true);
    localScalePivotFlag = true;
  }

  var sX = shear.x,
      sY = shear.y,
      sZ = shear.z;
  var shearM = new _three.Matrix4().set(1, sX, sY, 0, 0, 1, sZ, 0, 0, 0, 1, 0, 0, 0, 0, 1); //.makeShear(new Vector3(0, 0, 0));
  matrixStack.push(shearM);

  var scaleM = new _three.Matrix4().makeScale(scale.x, scale.y, scale.z);
  matrixStack.push(scaleM);

  if (localScalePivotFlag) matrixStack.push(invLocalScalePivotM);

  var matrixAccumulation = new _three.Matrix4();
  for (var i = 0; i < matrixStack.length; i++) {
    matrixAccumulation.multiply(matrixStack[i]);
  }

  return matrixAccumulation;
}

/**
 * Sets the property at path to value.
 *
 * (See {@tutorial sdk-SceneGraph})
 *
 * @param {(Path|QueryObject|String)} query The query object to filter on (or a string that gets converted to a query object).
 * @param {any} value The value to set, the type must match the property being set.
 * @public
 */
function set(query, value) {
  return function (store) {
    var path = Array.isArray(query) ? query : find(store, query);
    if (!path) {
      console.warn('No matching query', query);
      return _promise2.default.resolve();
    }

    if (path.length === 3) {
      if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== 'object') throw new Error('If no property is set, expect an object to merge into the operator');
      return store.dispatch((0, _sceneGraph.merge)(path, value));
    } else if (path.length === 4) {
      return store.dispatch((0, _sceneGraph.set)(path, value));
    } else if (path.length === 2) {
      if (path[1] !== 'name') throw new Error('Can only set node name');
      return store.dispatch((0, _sceneGraph.set)(path, value));
    }
  };
}

/**
 * Given an array of paths, will set the `value` on each path.
 * This can be combined with `find` to set a number of properties at once.
 *
 * (See {@tutorial sdk-SceneGraph})
 *
 * @public
 * @param {(Path[]|QueryObject|String)} query An array of path arrays, or a QueryObject
 * @param {any} value The value to set the properties to.
 *
 * @example
 *
 * // Move all boxes to the origin
 * const paths = ctx.find('Box*', 'Transform', 'translation');
 * setAll(paths, {x: 0, y: 0, z: 0});
 *
 */
function setAll(query, value) {
  //if (!Array.isArray(paths)) return Promise.reject('paths must be an array');
  return function (store) {
    var paths = Array.isArray(query) ? query : filter(store, query);
    //console.log('ctx.setAll', paths, value);
    return _promise2.default.all(paths.map(function (path) {
      return store.dispatch(set(path, value));
    }));
  };
}

/*
 * Returns an array of nodes with warnings in the scene graph.
 * @private
 */
function getWarnings(store) {
  var sceneGraph = store.get('sceneGraph');
  var nodeIds = (0, _keys2.default)(sceneGraph.nodes);
  var node = void 0;
  var warningNodes = [];
  for (var i = 0; i < nodeIds.length; i++) {
    node = sceneGraph.nodes[nodeIds[i]];
    if (node && node.warnings && node.warnings.length) warningNodes.push(node);
  }

  return warningNodes;
}

function setVRCamera(query) {
  return function (store) {
    query.type = 'Camera';
    var newVRCamera = find(store, query);
    if (Array.isArray(newVRCamera)) newVRCamera = newVRCamera[0];
    store.dispatch(set({ plug: 'Player', property: 'vrCamera' }, newVRCamera));
  };
}

/**
 * Given a query, clone these nodes. Without options, these nodes will be cloned
 * in place
 *
 * @public
 * @param {(QueryObject|String|Path[])} query A list of nodes (from filter), or query that will find a list of nodes to clone
 * @param {Object} [options]
 * @param {String} [options.to] The scene being cloned to (default is the active scene)
 * @param {String} [options.withNull] Add a null to clone the nodes to
 * @param {Object} [options.includeDependencies] Clone dependencies (default true)
 *
 * @example
 *
 * // Clone all nodes from Objects on import scene into active scene
 * scene.clone({from: {id: importId, child: 'Objects'}});
 *
 * // Clone children of a null to a new null
 * scene.clone({from: {id: importId, child: 'Objects'}}, {withNull: 'New Parent Null'});
 *
 * // Clone children, without also cloning dependencies.
 *
 *
 * // Return the path to the transform operator
 * scene.find('Box','Transform','translation'); -> ['uuid','Transform',0]
 * // Match the first node that starts with Box
 * scene.find('Box*');
 *
 */
function clone(query) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (options.cloneDependencies === undefined) options.cloneDependencies = true;

  return function (store) {
    var _nodeMap;

    var paths = Array.isArray(query) ? query : filter(store, query);
    var sceneGraph = store.get('sceneGraph');
    if (!paths.length) {
      console.warn('No match for clone: ', query);
      return _promise2.default.resolve(true);
    }

    var fromSceneId = (0, _sceneGraph.findRoot)(store, paths[0]);
    var toSceneId = options.to || sceneGraph.activeSceneId;
    var fromObjectsId = find(store, { id: fromSceneId, child: 'Objects' });
    var toObjectsId = find(store, { id: toSceneId, child: 'Objects' });

    var nodeMap = (_nodeMap = {}, (0, _defineProperty3.default)(_nodeMap, fromObjectsId, toObjectsId), (0, _defineProperty3.default)(_nodeMap, find(store, {
      id: fromSceneId,
      child: 'MaterialLibrary'
    }), find(store, { id: toSceneId, child: 'MaterialLibrary' })), _nodeMap);

    var nullNode = options.withNull ? store.dispatch((0, _sceneGraph.addNode)({
      name: options.withNull,
      parent: toObjectsId,
      type: 'Null',
      plugs: {
        Null: [['Null', {}]],
        Transform: [['Transform', {}]],
        Properties: [['Default', {}]]
      }
    })) : _promise2.default.resolve(null);

    return nullNode.then(function (nullNodeId) {
      if (nullNodeId) nodeMap[fromObjectsId] = nullNodeId;
      return store.dispatch((0, _sceneGraph.clone)(paths, nodeMap, {
        cloneDependencies: options.cloneDependencies
      })).then(function (cloneMap) {
        if (nullNodeId) cloneMap[options.withNull] = nullNodeId;
        return cloneMap;
      });
    });
  };
}

/**
 * Given a query, clone these nodes. Without options, these nodes will be cloned
 * in place
 *
 * @param {Object} attrs
 * @param {String} attrs.sceneId scene id to import
 * @param {Object} [options]
 * @param {String} [options.to] The scene being cloned to (default is the active scene)
 *
 * @example
 *
 * // Clone all nodes from Objects on import scene into active scene
 * scene.clone({from: {id: importId, child: 'Objects'}});
 *
 * // Clone children of a null to a new null
 * scene.clone({from: {id: importId, child: 'Objects'}}, {withNull: 'New Parent Null'});
 *
 * // Clone children, without also cloning dependencies.
 *
 *
 * // Return the path to the transform operator
 * scene.find('Box','Transform','translation'); -> ['uuid','Transform',0]
 * // Match the first node that starts with Box
 * scene.find('Box*');
 *
 */
function cloneModel(_ref) {
  var sceneId = _ref.sceneId;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var query = {
      from: { id: sceneId },
      child: 'Objects',
      type: ['PolyMesh', 'Null']
    };
    var paths = filter(store, query);
    var sceneGraph = store.get('sceneGraph');
    if (!paths.length) {
      console.warn('No match for clone: ', query);
      return _promise2.default.resolve(true);
    }

    var fromSceneId = (0, _sceneGraph.findRoot)(store, paths[0]);
    var toSceneId = options.to || sceneGraph.activeSceneId;
    var fromObjectsId = find(store, { id: fromSceneId, child: 'Objects' });
    var toObjectsId = find(store, { id: toSceneId, child: 'Objects' });
    var fromMatLibId = find(store, {
      id: fromSceneId,
      child: 'MaterialLibrary'
    });
    var configurator = get(store, {
      id: fromSceneId,
      plug: 'Player',
      property: 'configurator'
    });

    var nodeMap = (0, _defineProperty3.default)({}, fromObjectsId, toObjectsId);

    var rootName = get(store, { id: fromSceneId, property: 'name' });

    var modelNode = store.dispatch(addNode({ name: rootName + ' Model', parent: toObjectsId, type: 'Model' }));

    return modelNode.then(function (modelNodeId) {
      store.dispatch((0, _configuration.initializeConfiguration)({
        id: modelNodeId,
        config: configurator,
        sceneId: sceneId
      }));
      nodeMap[fromObjectsId] = modelNodeId;
      nodeMap[fromMatLibId] = modelNodeId;
      return store.dispatch((0, _sceneGraph.clone)(paths, nodeMap, { cloneDependencies: true })).then(function (cloneMap) {
        return modelNodeId;
      });
    });
  };
}

function pruneAssets() {
  return function (store) {
    var sceneGraph = store.get('sceneGraph');
    var usedAssets = {};
    var nodes = filter(store, { includeParent: true });

    function storeFileRefs(id) {
      var plugs = sceneGraph.nodes[id] && sceneGraph.nodes[id].plugs;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        var _loop = function _loop() {
          var plugName = _step2.value;

          plugs[plugName].forEach(function (op, opIdx) {
            var operator = (0, _operators.lookupOperator)(plugName, op.type, []);
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var refKey = _step3.value;

                if (op[refKey]) usedAssets[op[refKey]] = true;
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          });
        };

        for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(plugs || {})), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    nodes.forEach(storeFileRefs);

    return _promise2.default.all((0, _assets.filter)(store).map(function (asset) {
      return !usedAssets[asset.get('id')] && store.dispatch((0, _assets.removeFile)(asset.get('id')));
    }));
  };
}

function getLocalBoundingBox(store, id) {
  var mesh = get(store, { id: id, evalPlug: 'PolyMesh', property: 'mesh' });
  var boundingBox = new _three.Box3();
  if (mesh) {
    boundingBox.copy(mesh.boundingBox);
  }
  return boundingBox;
}

/**
 * Returns the bounding box of a node.
 *
 * @public
 * @param {String} id The uuid of a node
 *
 * @example
 *
 * var nodeId = scene.find({ name: 'Gear' });
 * var boundingBox = scene.getNodeBoundingBox(nodeId);
 *
 */
function getNodeBoundingBox(store, id) {
  var nodeBB = new _three.Box3();

  // build bbox of all descendants, relative to id's transform
  (0, _sceneGraph.traverseHierarchy)(store, id, true, function (traversedId) {
    var childBB = getLocalBoundingBox(store, traversedId);
    var relativeTransform = getRelativeTransform(store, traversedId, id);
    childBB.applyMatrix4(relativeTransform);
    nodeBB.union(childBB);
  });

  // if no transform exists (ex. root scene node), treat as identity matrix
  var worldTransform = getWorldTransform(store, id) || new _three.Matrix4();
  var localBB = getLocalBoundingBox(store, id);

  // combine descendants' relative bbox with own, and put whole thing into
  // worldspace
  nodeBB.union(localBB);
  nodeBB.applyMatrix4(worldTransform);
  return nodeBB;
}

/**
 * Returns a boolean indicating whether the specified node is actually visible
 * in the scene. If the scene is using hierarchical visibility, this is simply
 * the node's visibility flag. Otherwise, it is a product of its own and all
 * ancestral visibility flags.
 *
 * @param {*} store
 * @param {String} id The uuid of the node to determine visibility for
 *@returns {boolean}
 */
function isVisible(store, id) {
  function isHierarchicallyVisible(nodeId) {
    var node = store.get('sceneGraph').nodes[nodeId];
    var parent = node && node.parent;

    var selfVisible = get(store, {
      id: nodeId,
      plug: 'Properties',
      property: 'visible'
    });

    if (!parent || selfVisible === undefined) return true;
    return selfVisible && isHierarchicallyVisible(parent);
  }

  if (get(store, {
    id: store.get('sceneGraph').activeSceneId,
    plug: 'Properties',
    property: 'hierarchyVisibility'
  }) !== 'Enable') {
    return get(store, { id: id, plug: 'Properties', property: 'visible' });
  }
  return isHierarchicallyVisible(id);
}

function getAvailableOperators() {
  return _operators2.default;
}

/**
 * Returns the two dimensional screen position of a node.
 *
 * @public
 * @param {String} id The uuid of a node
 * @returns {Object} { x, y, top, left, width, height }
 *
 * @example
 *
 * var nodeId = scene.find({ name: 'Gear' });
 * var position = scene.getScreenPosition(nodeId);
 * console.log('position: ', position.x, position.y);
 * console.log('box: ', position.top, position.left, position.width, position.height);
 *
 */
function getScreenPosition(store, id) {
  if (!id) return null;

  var rect = (0, _player.getRect)(store);
  var widthHalf = 0.5 * rect.width;
  var heightHalf = 0.5 * rect.height;

  var bbox = getNodeBoundingBox(store, id);
  var sBox = new _three.Box3(); // Box2 would suffice, but not currently exposed
  var vertex = new _three.Vector3();

  var cameraId = (0, _player.getCamera)(store);
  var matrixWorld = (0, _player.getCameraWorldTransform)(store);
  var cameraData = get(store, { id: cameraId, evalPlug: 'Camera' });
  var projectionMatrix = (0, _getProjectionMatrix2.default)(cameraData);

  // note, Vector3.project() expects a ThreeJS camera input, but in reality
  // just needs an object with projection and world matrices, so we construct
  // one here for that purpose
  var camera = { projectionMatrix: projectionMatrix, matrixWorld: matrixWorld };

  if (bbox.isEmpty()) {
    var worldTransform = getWorldTransform(store, id);
    if (!worldTransform) return null;
    var worldPosition = new _three.Vector3().setFromMatrixPosition(worldTransform);
    worldPosition.project(camera);
    return {
      top: (worldPosition.y - 1) * -heightHalf,
      left: (worldPosition.x + 1) * widthHalf,
      width: 0,
      height: 0,
      x: (worldPosition.x + 1) * widthHalf,
      y: (worldPosition.y - 1) * -heightHalf
    };
  }

  for (var i = 0; i < 8; i++) {
    vertex.set(bbox[Math.floor(i / 4) ? 'max' : 'min'].x, bbox[Math.floor(i / 2) % 2 ? 'max' : 'min'].y, bbox[i % 2 ? 'max' : 'min'].z);
    vertex.project(camera);
    sBox.expandByPoint(vertex);
  }
  var result = {
    top: (sBox.max.y - 1) * -heightHalf,
    left: (sBox.min.x + 1) * widthHalf,
    width: (sBox.max.x - sBox.min.x) * widthHalf,
    height: (sBox.max.y - sBox.min.y) * heightHalf
  };
  result.x = result.left + result.width / 2;
  result.y = result.top + result.height / 2;
  return result;
}

function getCurrentPass(store, optionalPassName) {
  if (optionalPassName) {
    return get(store, { name: optionalPassName, evalPlug: 'Pass' });
  }
  var currPassID = get(store, {
    name: 'Passes',
    plug: 'GeneralRenderer',
    property: 'curPass'
  });
  var currPass = get(store, { id: currPassID, evalPlug: 'Pass' });
  return currPass || get(store, { type: 'Pass', evalPlug: 'Pass' });
}

function exportJSON(store, sceneId) {
  var _sceneId = sceneId || store.get('sceneGraph').activeSceneId;

  var nodes = filter(store, { from: { id: _sceneId }, includeParent: true });
  return {
    sceneGraph: (0, _sceneGraph.exportJSON)(store, nodes),
    assets: (0, _assets.exportJSON)(store)
  };
}

var nodeTypes = {
  //Scene: {
  //  'Environment': 'Environment',
  //  'Timeline': 'Timeline',
  //  'Player': 'Player',
  //},
  PolyMesh: {
    PolyMesh: 'Box',
    Transform: 'Transform',
    Material: 'Reference',
    Properties: 'PolyMeshProperties'
  },
  Light: {
    Light: 'PointLight',
    Transform: 'Transform',
    Properties: 'Default'
  },
  Camera: {
    Camera: 'Camera',
    Transform: 'Transform',
    Properties: 'Default'
  },
  Null: {
    Null: 'Null',
    Transform: 'Transform',
    Properties: 'Default'
  },
  Model: {
    Null: 'Null',
    Transform: 'Transform',
    Mixer: 'Mixer',
    Properties: 'ModelProperties'
  },
  Material: {
    Material: 'Physical',
    Properties: 'MaterialProperties'
  },
  Image: {
    Image: 'Image',
    Properties: 'ImageProperties'
  },
  Pass: {
    Pass: 'Pass'
  },
  Renderer: {
    Renderer: 'WebGLRenderer'
  },
  Bone: {
    Bone: 'Bone',
    Transform: 'BoneTransform',
    Properties: 'Default'
  },
  Annotation: {
    Annotation: 'Annotation',
    Transform: 'Transform',
    Properties: 'Default'
  }
  // Objects: [],
  // MaterialLibrary: [],
  // Renderers: [],
  // Passes: [],
};

/**
 * Add a node to the scene.
 *
 * @public
 * @param {Node} node The new node being added
 * @param {String} node.name The name of the new node
 * @param {String} node.type The type of the new node
 * @param {String} node.parent the id of the parent node for the new node
 * @param {Object} [node.plugs] The plugs for the new node
 * @returns {Promise}
 *
 */
function addNode(node) {
  var name = node.name,
      type = node.type,
      parent = node.parent,
      plugs = node.plugs;

  if (!parent) throw new Error('addNode requires parent to be set');
  if (!type) throw new Error('addNode requires type to be set');
  if (!name) throw new Error('addNode requires name to be set');
  if (!nodeTypes[type]) throw new Error('invalid type: ' + type + ' for addNode');
  var toPlugs = plugs || {};
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = (0, _getIterator3.default)((0, _keys2.default)(nodeTypes[type])), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _plugName = _step4.value;

      if (!toPlugs[_plugName]) toPlugs[_plugName] = [[nodeTypes[type][_plugName], {}]];
      if (!toPlugs[_plugName][0][0]) throw new Error('Required operator for ' + _plugName);
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return (0, _sceneGraph.addNode)({ name: name, type: type, plugs: toPlugs, parent: parent });
}

/**
 * Add an operator to an existing node in the scene.
 *
 * @public
 * @param {String} id The id of the node receiving the operator
 * @param {String} plugType The plug that is receiving the operator
 * @param {string} operatorType The type of operator being added
 * @param {Object} [operator] The details of the operator
 * @param {String} [name] the name of the operator
 * @returns {Promise}
 *
 */
function addOperator(id, plugType, operatorType) {
  var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var name = arguments[4];

  if (!id) throw new Error('addOperator requires the id for the element receiving the operator');
  if (!plugType) throw new Error('addOperator requires the plug to be set');
  if (!operatorType) throw new Error('addOperator requires the operator type to be set');

  var plug = _operators2.default[plugType];
  if (!plug) throw new Error('Unknown plug: ' + plugType);
  var op = plug[operatorType];
  if (!op) throw new Error('Unknown operator: ' + operatorType);

  return (0, _sceneGraph.addOperator)(id, plugType, [operatorType, operator, name]);
}

var publicApi = {
  actions: {
    set: set,
    setAll: setAll,
    clone: clone,
    cloneModel: cloneModel,
    pruneAssets: pruneAssets,
    setVRCamera: setVRCamera,
    addOperator: addOperator,
    addNode: addNode
  },
  selectors: {
    get: get,
    getAll: getAll,
    getWorldTransform: getWorldTransform,
    find: find,
    filter: filter,
    getWarnings: getWarnings,
    exportJSON: exportJSON,
    getNodeBoundingBox: getNodeBoundingBox,
    getCurrentPass: getCurrentPass,
    getAvailableOperators: getAvailableOperators,
    getScreenPosition: getScreenPosition,
    isVisible: isVisible
  }
};

exports.default = publicApi;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.progressBarOptions = exports.manipulators = exports.RENDER_MODES = undefined;

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _createReducer;

exports.useManipulator = useManipulator;
exports.getActiveManipulator = getActiveManipulator;
exports.addTool = addTool;
exports.removeTool = removeTool;
exports.showTool = showTool;
exports.hideTool = hideTool;
exports.updateToolOptions = updateToolOptions;
exports.getRect = getRect;
exports.setRect = setRect;
exports.setCameraAttrs = setCameraAttrs;
exports.getCameraAttrs = getCameraAttrs;
exports.getCameraWorldTransform = getCameraWorldTransform;
exports.useCamera = useCamera;
exports.useVrCamera = useVrCamera;
exports.setCamera = setCamera;
exports.setThree = setThree;
exports.getThree = getThree;
exports.getThreeScene = getThreeScene;
exports.getThreeCamera = getThreeCamera;
exports.getBoundingBox = getBoundingBox;
exports.getCamera = getCamera;
exports.getTools = getTools;
exports.setCameraPosition = setCameraPosition;
exports.getInitialCameraPosition = getInitialCameraPosition;
exports.requestFullscreen = requestFullscreen;
exports.exitFullscreen = exitFullscreen;
exports.toggleFullscreen = toggleFullscreen;
exports.isFullscreen = isFullscreen;
exports.setFullscreen = setFullscreen;
exports.getRenderingMode = getRenderingMode;
exports.isNormalRenderingMode = isNormalRenderingMode;
exports.isVRMode = isVRMode;
exports.isLenticularMode = isLenticularMode;
exports.activateTool = activateTool;
exports.isToolActive = isToolActive;
exports.getActiveTools = getActiveTools;
exports.requestLenticularMode = requestLenticularMode;
exports.requestNormalMode = requestNormalMode;
exports.getPrevCamera = getPrevCamera;
exports.setRenderMode = setRenderMode;
exports.toggleLenticularMode = toggleLenticularMode;
exports.enableDeviceTracking = enableDeviceTracking;
exports.disableDeviceTracking = disableDeviceTracking;
exports.toggleDeviceTracking = toggleDeviceTracking;
exports.isDeviceTracking = isDeviceTracking;
exports.setPlayerElement = setPlayerElement;
exports.setActiveColor = setActiveColor;
exports.setHoverColor = setHoverColor;
exports.setFullscreenBGColor = setFullscreenBGColor;
exports.getActiveColor = getActiveColor;
exports.getHoverColor = getHoverColor;
exports.getFullscreenBGColor = getFullscreenBGColor;
exports.animateCameraTo = animateCameraTo;
exports.resize = resize;
exports.filterNodesFromPosition = filterNodesFromPosition;
exports.filterNodesFromCenter = filterNodesFromCenter;
exports.filterInteractiveBoxesFromPosition = filterInteractiveBoxesFromPosition;
exports.filterInteractiveBoxesFromCenter = filterInteractiveBoxesFromCenter;
exports.setCameraRadiusConstraint = setCameraRadiusConstraint;
exports.getCanvasElement = getCanvasElement;
exports.getCameraRadiusConstraint = getCameraRadiusConstraint;
exports.displayThumbnail = displayThumbnail;
exports.shouldDisplayThumbnail = shouldDisplayThumbnail;
exports.getThumbnailURL = getThumbnailURL;
exports.displayVrSettings = displayVrSettings;
exports.shouldDisplayVrSettings = shouldDisplayVrSettings;
exports.setProgressBar = setProgressBar;
exports.getProgressBar = getProgressBar;
exports.frameScene = frameScene;
exports.createExplode = createExplode;

var _three = __webpack_require__(0);

var _immutable = __webpack_require__(32);

var _queryString = __webpack_require__(690);

var _queryString2 = _interopRequireDefault(_queryString);

var _createReducer2 = __webpack_require__(46);

var _createReducer3 = _interopRequireDefault(_createReducer2);

var _v = __webpack_require__(79);

var _v2 = _interopRequireDefault(_v);

var _scene = __webpack_require__(7);

var _animation = __webpack_require__(67);

var _sceneGraph = __webpack_require__(10);

var _sceneIO = __webpack_require__(20);

var _updateCameraLookAtTarget = __webpack_require__(71);

var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

var _calculateBoundingBox = __webpack_require__(252);

var _calculateBoundingBox2 = _interopRequireDefault(_calculateBoundingBox);

var _camera = __webpack_require__(126);

var _setMatrixOnNode = __webpack_require__(127);

var _setMatrixOnNode2 = _interopRequireDefault(_setMatrixOnNode);

var _decompose2 = __webpack_require__(51);

var _decompose3 = _interopRequireDefault(_decompose2);

var _getTargetWorldMatrix = __webpack_require__(59);

var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

var _commands = __webpack_require__(43);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RENDER_MODES = exports.RENDER_MODES = {
  normal: 'normal',
  vr: 'vr',
  lenticular: 'lenticular'
};

/**
 * This module supports the UI for the player.
 *
 * @module player
 * @public
 */

var manipulators = exports.manipulators = {
  orbit: 'orbit',
  pan: 'pan',
  zoom: 'zoom',
  nodeRotate: 'nodeRotate',
  nodeMove: 'nodeMove',
  nodeScale: 'nodeScale'
};

var progressBarOptions = exports.progressBarOptions = {
  default: 'default',
  circle: 'circle',
  line: 'line',
  none: 'none'
};

var USE_MANIPULATOR = 'USE_MANIPULATOR';
var SET_CAMERA = 'SET_CAMERA';
var SET_PREV_CAMERA = 'SET_PREV_CAMERA';
var SET_CAMERA_ATTRS = 'SET_CAMERA_ATTRS';
var SET_CAMERA_POSITION = 'SET_CAMERA_POSITION';
var SET_RECT = 'SET_RECT';
var DISPLAY_THUMBNAIL = 'DISPLAY_THUMBNAIL';
var DISPLAY_VR_SETTINGS = 'DISPLAY_VR_SETTINGS';

var SET_ACTIVE_COLOR = 'SET_ACTIVE_COLOR';
var SET_HOVER_COLOR = 'SET_HOVER_COLOR';
var SET_PLAYER_ELEMENT = 'SET_PLAYER_ELEMENT';
var REQUEST_FULL_SCREEN = 'REQUEST_FULL_SCREEN';
var EXIT_FULL_SCREEN = 'EXIT_FULL_SCREEN';
var SET_FULL_SCREEN = 'SET_FULL_SCREEN';
var SET_RENDER_MODE = 'SET_RENDER_MODE';
var SET_PROGRESS_BAR = 'SET_PROGRESS_BAR';

var REQUEST_NORMAL_MODE = 'REQUEST_NORMAL_MODE';
var REQUEST_LENTICULAR_MODE = 'REQUEST_LENTICULAR_MODE';
var SET_DEVICE_TRACKING = 'SET_DEVICE_TRACKING';
var SET_BACKGROUND_COLOR = 'SET_BACKGROUND_COLOR';
var REQUEST_STEREO_MODE = 'REQUEST_STEREO_MODE';
var REQUEST_PARALLAX_MODE = 'REQUEST_PARALLAX_MODE';
var EXIT_STEREOPARALLAX_MODE = 'EXIT_STEREOPARALLAX_MODE';
var SET_CONSTRAIN_CAMERA_RADIUS = 'SET_CONSTRAIN_CAMERA_RADIUS';
var SET_THREE_OBJECTS = 'SET_THREE_OBJECTS';

var defaultThumbnailOptions = (0, _immutable.Map)({
  width: 1280,
  height: 960,
  cache: true,
  renderer: 'webgl'
});

var initialState = (0, _immutable.Map)({
  activeColor: '#ffc85f',
  hoverColor: '#C08618',
  fullscreenBackgroundColor: '#FFF',
  activeManipulator: manipulators.orbit,
  fullScreen: false,
  renderingMode: RENDER_MODES.normal,
  deviceTracking: false,
  camera: (0, _immutable.Map)({
    polarAngle: null,
    azimuthAngle: null,
    boundingRadius: null,
    maxZoom: null
  }),
  rect: (0, _immutable.Map)({ width: 400, height: 300 }),
  initialCameraWorldMatrix: null,
  initialTargetWorldMatrix: null,
  cameraWorldMatrix: null,
  displayThumbnail: true,
  playerElement: null,
  canvasElement: null,
  activeCamera: null, // because of circular dependency issues, this is not defined on initialization of this module: virtualCameraId,
  threeObjects: (0, _immutable.Map)(),
  displayVrSettings: false,
  prevCamera: null,
  orientationHandler: null,
  constrainCameraRadius: null,
  progressBarOption: progressBarOptions['default'],
  thumbnailOptions: defaultThumbnailOptions
});

var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, USE_MANIPULATOR, function (state, manipulator) {
  return state.set('activeManipulator', manipulator);
}), (0, _defineProperty3.default)(_createReducer, SET_CAMERA, function (state, _ref) {
  var id = _ref.id,
      prevCameraId = _ref.prevCameraId;

  return state.set('activeCamera', id).set('prevCamera', prevCameraId);
}), (0, _defineProperty3.default)(_createReducer, SET_CAMERA_ATTRS, function (state, attrs) {
  return state.mergeIn(['camera'], attrs);
}), (0, _defineProperty3.default)(_createReducer, SET_RECT, function (state, rect) {
  return state.set('rect', rect);
}), (0, _defineProperty3.default)(_createReducer, SET_CAMERA_POSITION, function (state, attrs) {
  return state.merge(attrs);
}), (0, _defineProperty3.default)(_createReducer, SET_PLAYER_ELEMENT, function (state, _ref2) {
  var playerEl = _ref2.playerEl,
      canvasEl = _ref2.canvasEl;

  return state.set('playerElement', playerEl).set('canvasElement', canvasEl);
}), (0, _defineProperty3.default)(_createReducer, DISPLAY_THUMBNAIL, function (state, _ref3) {
  var display = _ref3.display,
      options = _ref3.options;

  return state.set('displayThumbnail', !!display).mergeIn(['thumbnailOptions'], (0, _immutable.Map)(options));
}), (0, _defineProperty3.default)(_createReducer, DISPLAY_VR_SETTINGS, function (state, display) {
  return state.set('displayVrSettings', !!display);
}), (0, _defineProperty3.default)(_createReducer, SET_ACTIVE_COLOR, function (state, color) {
  return state.set('activeColor', color);
}), (0, _defineProperty3.default)(_createReducer, SET_HOVER_COLOR, function (state, color) {
  return state.set('hoverColor', color);
}), (0, _defineProperty3.default)(_createReducer, SET_BACKGROUND_COLOR, function (state, color) {
  return state.set('fullscreenBackgroundColor', color);
}), (0, _defineProperty3.default)(_createReducer, SET_PROGRESS_BAR, function (state, option) {
  if (!progressBarOptions[option]) option = progressBarOptions['default'];
  return state.set('progressBarOption', option);
}), (0, _defineProperty3.default)(_createReducer, REQUEST_FULL_SCREEN, function (state) {
  return state.set('fullScreen', true);
}), (0, _defineProperty3.default)(_createReducer, EXIT_FULL_SCREEN, function (state) {
  return state.set('fullScreen', false);
}), (0, _defineProperty3.default)(_createReducer, SET_FULL_SCREEN, function (state, fullScreen) {
  return state.set('fullScreen', fullScreen);
}), (0, _defineProperty3.default)(_createReducer, SET_RENDER_MODE, function (state, mode, _ref4) {
  var createEvent = _ref4.createEvent;

  if (state.get('renderingMode') !== mode) createEvent('renderingMode', mode);
  return state.set('renderingMode', mode);
}), (0, _defineProperty3.default)(_createReducer, REQUEST_LENTICULAR_MODE, function (state, _ref5) {
  var trackDevice = _ref5.trackDevice,
      cameraId = _ref5.cameraId;

  return state.merge({
    renderingMode: 'lenticular',
    deviceTracking: trackDevice,
    prevCamera: cameraId
  });
}), (0, _defineProperty3.default)(_createReducer, REQUEST_NORMAL_MODE, function (state) {
  return state.merge({
    renderingMode: 'normal',
    deviceTracking: false
  });
}), (0, _defineProperty3.default)(_createReducer, SET_DEVICE_TRACKING, function (state, deviceTracking) {
  return state.set('deviceTracking', deviceTracking);
}), (0, _defineProperty3.default)(_createReducer, SET_CONSTRAIN_CAMERA_RADIUS, function (state, radius) {
  return state.set('constrainCameraRadius', radius);
}), (0, _defineProperty3.default)(_createReducer, SET_THREE_OBJECTS, function (state, obj, _ref6) {
  var createEvent = _ref6.createEvent;

  createEvent('threeinitialized');
  return state.set('threeObjects', (0, _immutable.Map)(obj));
}), _createReducer));

function useManipulator(manipulator) {
  return { type: USE_MANIPULATOR, payload: manipulator };
}

function getActiveManipulator(store) {
  return store.getIn(['player', 'activeManipulator']);
}

/**
 * Add a tool (See {@tutorial sdk-Tools})
 *
 * @public
 * @param {Tool} Tool
 * @param {String} name provide a name for the tool to allow removing it.
 * @returns {Promise}
 *
 */
function addTool(tool, name) {
  return (0, _commands.addCommand)({ tool: tool, enabled: true }, name);
}

/**
 * Remove a tool (See {@tutorial sdk-Tools})
 *
 * @public
 * @param {String} name The name of the tool to remove
 * @returns {Promise}
 */
function removeTool(name) {
  return (0, _commands.removeCommand)(name);
}

/**
 * Show the tool's button
 *
 * @public
 * @param {String} name the name of the tool.
 * @returns {Promise}
 *
 */
function showTool(name) {
  return (0, _commands.updateCommand)(name, { display: { playerTools: true } });
}

/**
 * Hide the tool's button. (The tool can still be active when hidden).
 *
 * @public
 * @param {String} name the name of the tool.
 * @returns {Promise}
 *
 */
function hideTool(name) {
  return (0, _commands.updateCommand)(name, { display: { playerTools: false } });
}

function updateToolOptions(name, options) {
  return { type: UPDATE_COMMAND_OPTIONS, payload: { name: name, options: options } };
}

function getRect(store) {
  return store.getIn(['player', 'rect']);
}

function setRect(rect) {
  return { type: SET_RECT, payload: rect };
}

function setCameraAttrs(attrs) {
  return function (store) {
    store.dispatch({ type: SET_CAMERA_ATTRS, payload: attrs });
    var cameraId = getCamera(store);
    if (!cameraId) return;

    // Store the new camera attrs in the camera data, and touch the cameraNode to rerender
    var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
    if (cameraData) {
      cameraData.newAngleAttrs = attrs;
    }

    store.dispatch((0, _sceneGraph.touch)(cameraId));
  };
}

function getCameraAttrs(store) {
  return store.getIn(['player', 'camera']);
}

/**
 * Returns the world matrix of the active camera
 */
function getCameraWorldTransform(store) {
  return (0, _scene.getWorldTransform)(store, getCamera(store));
}

/**
 * This sets the scene to use the camera.
 */
function useCamera(id) {
  return function (store) {
    // store.dispatch(setCamera(id, getCamera(store)));
    return store.dispatch((0, _scene.set)({ scene: true, plug: 'Player', property: 'camera' }, id));
  };
}

function useVrCamera(switchToVR) {
  return function (store) {
    if (switchToVR) {
      var activeCamera = store.getIn(['player', 'activeCamera']);
      var fromVrCamera = (0, _scene.get)(store, { plug: 'Player', property: 'vrCamera' }) || _sceneGraph.virtualCameraId;
      store.dispatch(setCamera(_sceneGraph.vrCameraId, activeCamera));

      var sceneGraph = store.get('sceneGraph');
      var fromNode = sceneGraph.nodes[fromVrCamera];
      var cameraNode = sceneGraph.nodes[_sceneGraph.vrCameraId];

      var copiedNode = (0, _sceneGraph.initNode)(fromNode);

      var plugs = (0, _assign2.default)({}, copiedNode.plugs);
      return store.dispatch((0, _sceneGraph.replace)(_sceneGraph.vrCameraId, (0, _assign2.default)(cameraNode, { plugs: plugs })));
    } else {
      var prevCamera = store.getIn(['player', 'prevCamera']) || _sceneGraph.virtualCameraId;
      return store.dispatch(setCamera(prevCamera, null));
    }
  };
}

/**
 * Sets the active camera for the scene
 * @private
 */
function setCamera(id, prevCameraId) {
  return function (store) {
    var target = (0, _getTargetWorldMatrix2.default)(store, prevCameraId);
    var oldCamData = (0, _scene.get)(store, { id: prevCameraId, evalPlug: 'Camera' });
    var oldCameraTransform = (0, _scene.get)(store, {
      id: prevCameraId,
      evalPlug: 'Transform'
    });
    if (oldCameraTransform && !oldCameraTransform.target) {
      oldCamData.targetWorldMatrix = target;
    }

    var newCamData = (0, _scene.get)(store, { id: id, evalPlug: 'Camera' });
    if (newCamData.targetWorldMatrix) {
      store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose3.default)(newCamData.targetWorldMatrix)));
      newCamData.targetWorldMatrix = null;
    }

    store.dispatch({ type: SET_CAMERA, payload: { id: id, prevCameraId: prevCameraId } });
  };
}

/**
 * @private
 */
function setThree(payload) {
  return { type: SET_THREE_OBJECTS, payload: payload };
}

/**
 * Returns an object with the active three.js scene, camera, and renderer.
 * These will not be available immediately, so wait for at least the
 * 'preloaded' event before calling this function.
 *
 * @public
 *
 */
function getThree(store) {
  return store.getIn(['player', 'threeObjects']).toJS();
}

function getThreeScene(store) {
  return store.getIn(['player', 'threeObjects', 'scene']);
}

function getThreeCamera(store) {
  return store.getIn(['player', 'threeObjects', 'camera']);
}

function getBoundingBox(store) {
  var threeScene = getThreeScene(store);
  return (0, _calculateBoundingBox2.default)(threeScene);
}

/**
 * Returns the current active camera
 * @public
 */
function getCamera(store) {
  return store.getIn(['player', 'activeCamera']) || _sceneGraph.virtualCameraId;
}

function getTools(store) {
  return store.getIn(['player', 'tools']);
}

function setCameraPosition(attrs) {
  return { type: SET_CAMERA_POSITION, payload: attrs };
}

function getInitialCameraPosition(store) {
  return {
    initialCameraWorldMatrix: store.getIn(['player', 'initialCameraWorldMatrix']),
    initialTargetWorldMatrix: store.getIn(['player', 'initialTargetWorldMatrix'])
  };
}

/**
 *
 * Enable fullscreen mode.
 * @public
 *
 */
function requestFullscreen() {
  return function (store) {
    var playerEl = store.getIn(['player', 'playerElement']);
    ['requestFullscreen', 'webkitRequestFullscreen', 'mozRequestFullScreen', 'msRequestFullscreen'].forEach(function (fn) {
      if (playerEl[fn]) return playerEl[fn]();
    });

    store.dispatch({ type: REQUEST_FULL_SCREEN });
  };
}

/**
 * Exit fullscreen mode
 * @public
 */
function exitFullscreen() {
  return function (store) {
    ['exitFullscreen', 'webkitExitFullscreen', 'mozCancelFullScreen', 'msExitFullscreen'].forEach(function (fn) {
      if (document[fn]) return document[fn]();
    });

    return store.dispatch({ type: EXIT_FULL_SCREEN });
  };
}

/**
 * Toggle fullscreen mode
 * @public
 *
 */
function toggleFullscreen() {
  return function (store) {
    return store.dispatch(isFullscreen(store) ? exitFullscreen() : requestFullscreen());
  };
}

/**
 * Check whether were in fullscreen mode.
 * @public
 *
 */
function isFullscreen(store) {
  return store.getIn(['player', 'fullScreen']);
}

/**
 * Set the value of fullscreen (set on an event handler, if the native
 * browser control is used to escape full screen mode.
 */
function setFullscreen(fullScreen) {
  return function (store) {
    if (isFullscreen(store) !== fullScreen) {
      store.dispatch({ type: SET_FULL_SCREEN, payload: fullScreen });
    }

    if (!fullScreen && isVRMode(store)) {
      store.dispatch((0, _commands.deactivateCommand)('vrSettings'));
    }
  };
}

function getRenderingMode(store) {
  return store.getIn(['player', 'renderingMode']);
}

/**
 * @public
 *
 */
function isNormalRenderingMode(store) {
  return store.getIn(['player', 'renderingMode']) === RENDER_MODES.normal;
}

/**
 * Check whether we are in VR mode.
 * @public
 *
 */
function isVRMode(store) {
  return store.getIn(['player', 'renderingMode']) === RENDER_MODES.vr;
}

/**
 * Check whether we are in Lenticular rendering mode.
 * @public
 */
function isLenticularMode(store) {
  return store.getIn(['player', 'renderingMode']) === RENDER_MODES.lenticular;
}

function activateTool(toolName) {
  return function (store) {
    var tool = store.getIn(['player', 'tools', toolName]);
    if (!tool) return;
    if (tool.get('action')) return tool.get('action')(store);
    var isActive = _isToolActive(store, tool);
    if (tool.get('activate') && !isActive) return tool.get('activate')(store);
    if (tool.get('deactivate') && isActive) return tool.get('deactivate')(store);
    return store.dispatch(useManipulator(toolName));
  };
}

function _isToolActive(store, tool) {
  if (tool.get('isActive')) return tool.get('isActive')(store);
  return store.getIn(['player', 'activeManipulator']) === tool.get('name');
}

function isToolActive(store, toolName) {
  var tool = store.getIn(['player', 'tools', toolName]);
  return tool && _isToolActive(store, tool);
}

function getActiveTools(store) {
  return store.getIn(['player', 'tools']).filter(function (tool) {
    return _isToolActive(store, tool);
  });
}

function requestLenticularMode(_ref7) {
  var fullscreen = _ref7.fullscreen,
      trackDevice = _ref7.trackDevice;

  return function (store) {
    if (fullscreen) store.dispatch(requestFullscreen());
    var cameraId = getCamera(store);
    store.dispatch({
      type: REQUEST_LENTICULAR_MODE,
      payload: { trackDevice: trackDevice, cameraId: cameraId }
    });
  };
}

function requestNormalMode() {
  return { type: REQUEST_NORMAL_MODE };
}

function getPrevCamera(store) {
  return store.getIn(['player', 'prevCamera']);
}

function setRenderMode(mode) {
  if (!RENDER_MODES[mode]) throw new Error('Invalid Render Mode: ' + mode);
  return { type: SET_RENDER_MODE, payload: mode };
}

function toggleLenticularMode() {
  return function (store) {
    store.dispatch(isLenticularMode(store) ? requestNormalMode() : requestLenticularMode({}));
  };
}

function enableDeviceTracking() {
  return { type: SET_DEVICE_TRACKING, payload: true };
}

function disableDeviceTracking() {
  return { type: SET_DEVICE_TRACKING, payload: false };
}

function toggleDeviceTracking() {
  return function (store) {
    console.log('toggle device tracking', !isDeviceTracking(store));
    store.dispatch(isDeviceTracking(store) ? disableDeviceTracking() : enableDeviceTracking());
  };
}

function isDeviceTracking(store) {
  return store.getIn(['player', 'deviceTracking']);
}

/**
 * Store the rendered player element
 */
function setPlayerElement(playerEl, canvasEl) {
  return { type: SET_PLAYER_ELEMENT, payload: { playerEl: playerEl, canvasEl: canvasEl } };
}

/**
 * Set the active color and timeline color to be used for the player css.
 *
 * @public
 * @param {Color} color a valid css color (ex. '#ff0000'}.
 * @returns {Promise}
 *
 */
function setActiveColor(color) {
  return { type: SET_ACTIVE_COLOR, payload: color };
}

/**
 * Set the hover color to be used for the player css.
 *
 * @public
 * @param {Color} color a valid css color (ex. '#ff0000'}.
 * @returns {Promise}
 *
 */
function setHoverColor(color) {
  return { type: SET_HOVER_COLOR, payload: color };
}

/**
 * Set the fullscreen background color to be used for the player css.
 *
 * @public
 * @param {Color} color a valid css color (ex. '#ff0000'}.
 * @returns {Promise}
 *
 */
function setFullscreenBGColor(color) {
  return { type: SET_BACKGROUND_COLOR, payload: color };
}

/**
 * Return the active color.
 *
 * @public
 */
function getActiveColor(store) {
  return store.getIn(['player', 'activeColor']);
}

/**
 * Return the hover color.
 *
 * @public
 */
function getHoverColor(store) {
  return store.getIn(['player', 'hoverColor']);
}

/**
 * Return the fullscreen background color.
 *
 * @public
 */
function getFullscreenBGColor(store) {
  return store.getIn(['player', 'fullscreenBackgroundColor']);
}

function slerpTween(startMatrix, endMatrix, startTarget, endTarget) {
  var startPosition = new _three.Vector3();
  var startQuaternion = new _three.Quaternion();
  var scale = new _three.Vector3(1, 1, 1);
  startMatrix.decompose(startPosition, startQuaternion, scale);

  var endPosition = new _three.Vector3();
  var endQuaternion = new _three.Quaternion();
  endMatrix.decompose(endPosition, endQuaternion, scale);

  var startTargetPos = new _three.Vector3().setFromMatrixPosition(startTarget);
  var startDistance = startTargetPos.distanceTo(startPosition);

  var endTargetPos = new _three.Vector3().setFromMatrixPosition(endTarget);
  var endDistance = endTargetPos.distanceTo(endPosition);

  var target = new _three.Vector3();
  var direction = new _three.Vector3();

  var position = new _three.Vector3();
  var quaternion = new _three.Quaternion();
  var matrix = new _three.Matrix4();

  return function (time, start, end, duration) {
    var _t = time / duration;
    //interpolate look at target between start and end positions
    target.lerpVectors(startTargetPos, endTargetPos, _t);

    //interpolate distance camera is from target
    var distance = startDistance * (1 - _t) + endDistance * _t;

    _three.Quaternion.slerp(startQuaternion, endQuaternion, quaternion, _t);

    //position is distance along direction from target
    direction.set(0, 0, 1).applyQuaternion(quaternion);
    position.copy(target).addScaledVector(direction, distance);

    //point camera at target from position
    matrix.compose(position, quaternion, scale);

    return matrix;
  };
}

/**
 * Animate the camera to the position of another.
 *
 * @public
 * @param {String} id - the id of the camera to move to.
 * @param {Number} duration - length of the animation (ms), default 300.
 * @returns {Promise}
 */
function animateCameraTo(id, duration) {
  return function (store) {
    var cameraId = getCamera(store);
    if (!cameraId || !id) return;

    var prep = _promise2.default.resolve();

    // if camera is targeted, temporarily disable targeting during animation
    var camTarget = (0, _scene.find)(store, {
      id: cameraId,
      plug: 'Transform',
      property: 'target'
    });
    var targetingDisabled = false;
    if (camTarget && (0, _scene.get)(store, { id: cameraId, plug: 'Camera', property: 'targeted' })) {
      var target = (0, _scene.get)(store, camTarget);
      if (target) {
        prep = store.dispatch((0, _scene.set)({ id: cameraId, plug: 'Camera', property: 'targeted' }, false));
        targetingDisabled = true;
      }
    }

    var startFov = (0, _scene.get)(store, {
      id: cameraId,
      plug: 'Camera',
      property: 'fieldOfView'
    });
    var endFov = (0, _scene.get)(store, {
      id: id,
      plug: 'Camera',
      property: 'fieldOfView'
    });
    return prep.then(function () {
      var animations = store.getIn(['animation', 'animations']);
      var toRemove = animations.filter(function (anim) {
        return anim.name === 'animateCameraTo';
      });
      return _promise2.default.all(toRemove.map(function (anim) {
        return store.dispatch((0, _animation.removeAnimation)(anim.id));
      }));
    }).then(function () {
      return store.dispatch((0, _commands.updateCommands)(['zoom', 'pan', 'orbit', 'home'], { enabled: false }));
    }).then(function () {
      var currentCameraTransform = (0, _scene.getWorldTransform)(store, cameraId);
      var currentTargetTransform = (0, _getTargetWorldMatrix2.default)(store, cameraId);

      var newCameraInfo = (0, _camera.initCamera)(store, false, id);
      var newCameraTransform = newCameraInfo.camera;
      var newTargetTransform = newCameraInfo.target;

      var actualDuration = duration || 300;

      return new _promise2.default(function (resolve, reject) {
        store.dispatch((0, _animation.queueAnimation)({
          autoplay: true,
          name: 'animateCameraTo',
          iterations: 1,
          tracks: [{
            path: { id: cameraId, evalPlug: 'Transform' },
            duration: actualDuration,
            value: newCameraTransform,
            startValue: currentCameraTransform,
            tween: slerpTween(currentCameraTransform, newCameraTransform, currentTargetTransform, newTargetTransform),
            set: function set(_path, to) {
              (0, _setMatrixOnNode2.default)(store, cameraId, to);
            }
          }, {
            path: {
              id: cameraId,
              plug: 'Camera',
              property: 'fieldOfView'
            },
            duration: actualDuration,
            value: endFov,
            startValue: startFov
          }],
          onEnd: function onEnd() {
            resolve(store.dispatch(useCamera(id)).then(function () {
              // if camera was targeted, re-enable targeting now that animation is over
              return targetingDisabled ? store.dispatch((0, _scene.set)({
                id: cameraId,
                plug: 'Camera',
                property: 'targeted'
              }, true)) : null;
            }));
          }
        }));
      });
    }).then(function () {
      return store.dispatch((0, _commands.updateCommands)(['zoom', 'pan', 'orbit', 'home'], { enabled: true }));
    });
  };
}

/**
 * Trigger a resize event. If you manually resize the player's dom element,
 * use this to force the player to rerender with the updated size.
 *
 * @public
 */
function resize() {
  return function (store) {
    var translator = store.getTranslator();
    if (translator) translator.resize();
  };
}

/**
 * Given a manipulator event, return the list of node ids at that position
 *
 * @public
 * @param {Event} event generated by the manipulator interface. (See {@tutorial sdk-Tools})
 * @param {String} [rootNode] Id of root of nodes that will be checked against position
 * @returns {Array} list of node ids found.
 *
 * @example
 *
 * api.player.addTool({
 *   click: (ev) => {
 *     var nodes = api.player.filterNodesFromPosition(ev);
 *     console.log('Found: ', nodes.map((id) => api.scene.get({id: id, property: 'name'})));
 *   }
 * }, 'FindNode');
 *
 */
function filterNodesFromPosition(store, event, rootNode) {
  var translator = store.getTranslator();
  if (!translator || !translator.raycastSelect) return null;
  var x = event.clientX / (event.rect.width / 2) - 1;
  var y = -(event.clientY / (event.rect.height / 2) - 1);
  var hits = translator.raycastSelect({ x: x, y: y }, rootNode);
  return hits.map(function (hit) {
    return hit.id;
  });
}

/**
 * return the list of node ids at the center of the screen
 *
 * @public
 * @param {String} [rootNode] Id of root of nodes that will be checked against center
 * @returns {Array} list of node ids found.
 */
function filterNodesFromCenter(store, rootNode) {
  var translator = store.getTranslator();
  if (!translator || !translator.raycastSelect) return null;
  var hits = translator.raycastSelect({ x: 0, y: 0 }, rootNode);
  return hits.map(function (hit) {
    return hit.id;
  });
}

function hitInteractiveNodes(store, ray) {
  var controllerNodes = (0, _scene.filter)(store, {
    plug: 'Properties',
    properties: { interactive: true }
  });
  var hitIds = controllerNodes.map(function (path) {
    var id = path[0];
    var bb = (0, _scene.getNodeBoundingBox)(store, id);
    var point = ray.intersectBox(bb);
    return {
      hit: !!point,
      id: id,
      distance: point ? point.distanceTo(ray.origin) : Infinity
    };
  }).filter(function (i) {
    return i.hit;
  });
  hitIds.sort(function (a, b) {
    return a.distance - b.distance;
  });
  return hitIds.map(function (i) {
    return i.id;
  });
}

function filterInteractiveBoxesFromPosition(store, event) {
  var controllerNodes = (0, _scene.filter)(store, {
    plug: 'Properties',
    properties: { interactive: true }
  });
  var translator = store.getTranslator();
  if (!translator || !translator.getCameraMouseRay) return null;
  var x = event.clientX / (event.rect.width / 2) - 1;
  var y = -(event.clientY / (event.rect.height / 2) - 1);
  var ray = translator.getCameraMouseRay({ x: x, y: y }).ray;
  return hitInteractiveNodes(store, ray);
}

function filterInteractiveBoxesFromCenter(store) {
  var translator = store.getTranslator();
  if (!translator || !translator.getCameraMouseRay) return null;
  var ray = translator.getCameraMouseRay({ x: 0, y: 0 }).ray;
  return hitInteractiveNodes(store, ray);
}

/**
* Will constrain the target of the camera to remain inside the bounding sphere of the scene.
* The camera will not be allowed to enter the bounding sphere of the scene nor leave  bounding sphere defined by arguments
*
* @public
* @param {Number} radius distance around the center of the scene that defineds outer bounding sphere, setting radius to null disables bounding spheres
*/
function setCameraRadiusConstraint(radius) {
  return function (store) {
    var cameraId = getCamera(store);
    if (!cameraId) return;

    store.dispatch((0, _sceneGraph.merge)([cameraId, 'Properties', 0], {
      constrainCameraSphere: true,
      maxZoom: radius
    }));
  };
}

function getCanvasElement(store) {
  return store.getIn(['player', 'canvasElement']);
}

function getCameraRadiusConstraint(store) {
  return store.getIn(['player', 'constrainCameraRadius']);
}

/**
 * Turn thumbnail display on or off
 * @public
 * @param {Boolean} display - Display thumbnail (default true)
 */
function displayThumbnail(display) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return { type: DISPLAY_THUMBNAIL, payload: { display: display, options: options } };
}

function shouldDisplayThumbnail(store) {
  return store.getIn(['player', 'displayThumbnail']);
}

function getThumbnailURL(store, sceneId) {
  var thumbnailOptions = store.getIn(['player', 'thumbnailOptions']);

  var path = !(0, _immutable.is)(thumbnailOptions, defaultThumbnailOptions) ? 'render?' + _queryString2.default.stringify(thumbnailOptions.toJS()) : 'v2thumbnail';
  return "https://editor.vimarket.io/api" + '/scenes/' + sceneId + '/' + path;
}

function displayVrSettings(display) {
  return { type: DISPLAY_VR_SETTINGS, payload: display };
}

function shouldDisplayVrSettings(store) {
  return store.getIn(['player', 'displayVrSettings']);
}

/**
 * Set the desired progress bar:
 *   default -- the default circle
 *   line -- an unobtrisive line across the bottom of the div
 *   none -- to allow custom progress bars to be used.
 *
 * @public
 * @param {String} option  Desired progress bar, either 'default','line', or 'none'
 *
 */
function setProgressBar(option) {
  return { type: SET_PROGRESS_BAR, payload: option };
}

function getProgressBar(store) {
  return store.getIn(['player', 'progressBarOption']);
}

/**
 * Reposition camera to adjust the frame of the object
 * @public
 * @param {Array} [optionalNodeList] An array of selected node Id
*/
function frameScene(optionalNodeList) {
  return function (store) {
    var list = optionalNodeList || [(0, _scene.find)(store, 'Objects')];
    var box = new _three.Box3().makeEmpty();
    list.forEach(function (id) {
      return box.union((0, _scene.getNodeBoundingBox)(store, id));
    });
    if (box.isEmpty()) return;
    (0, _camera.frameSphere)(store, box.getBoundingSphere());
  };
}
/**
 * Auto explode function
 * @public
 * @param {String} [explodeMode] xyz, xy/yz/xz x/y/z
 * @param {String} [nodeType] The based node type for exploding, default is 'Null', either 'Null' or 'PolyMesh'
 * @param {Number} [explodeSize] explode size, default is 1
 * @param {Number} [duration] duration, default is 3000
 * @returns {Object}
*/
function parseExplodeMode(mode) {
  mode = mode ? mode : 'xyz';
  switch (mode) {
    case 'xyz':
    case 'xzy':
    case 'yxz':
    case 'yzx':
    case 'zxy':
    case 'zyx':
    default:
      mode = 0;
      break;
    case 'xy':
    case 'yx':
      mode = 1;
      break;
    case 'xz':
    case 'zx':
      mode = 2;
      break;
    case 'yz':
    case 'zy':
      mode = 3;
      break;
    case 'x':
      mode = 4;
      break;
    case 'y':
      mode = 5;
      break;
    case 'z':
      mode = 6;
      break;
  }
  return mode;
}
function createClip(store, positions, size, duration, explodeSize, mode) {
  var translator = store.getTranslator();
  var meshes = (0, _scene.filter)(store, { type: 'PolyMesh' });
  var worldBox = translator.getNodeListBoundingBox(meshes);
  var worldSphere = worldBox.getBoundingSphere();
  var explodeClip = {
    id: (0, _v2.default)(),
    name: 'Explode Clip',
    tracks: []
  };
  positions.forEach(function (position, i) {
    var id = position.id;
    var sp = position.boundingSphere;
    var translation = (0, _scene.get)(store, {
      id: id,
      plug: 'Transform',
      property: 'translation'
    });
    var newTranslation = translation.clone();
    var dir = sp.center.sub(worldSphere.center).normalize();
    switch (mode) {
      case 0:
        if (i < 1) break; //don't animate the biggest child
        newTranslation.x += dir.x * (worldSphere.radius + sp.radius) * explodeSize;
        newTranslation.y += dir.y * (worldSphere.radius + sp.radius) * explodeSize;
        newTranslation.z += dir.z * (worldSphere.radius + sp.radius) * explodeSize;
        break;
      case 1:
        if (i < 1) break; //don't animate the biggest child
        newTranslation.x += dir.x * (worldSphere.radius + sp.radius) * explodeSize;
        newTranslation.y += dir.y * (worldSphere.radius + sp.radius) * explodeSize;
        break;
      case 2:
        if (i < 1) break; //don't animate the biggest child
        newTranslation.x += dir.x * (worldSphere.radius + sp.radius) * explodeSize;
        newTranslation.z += dir.z * (worldSphere.radius + sp.radius) * explodeSize;
        break;
      case 3:
        if (i < 1) break; //don't animate the biggest child
        newTranslation.y += dir.y * (worldSphere.radius + sp.radius) * explodeSize;
        newTranslation.z += dir.z * (worldSphere.radius + sp.radius) * explodeSize;
        break;
      case 4:
        size -= sp.radius * explodeSize;
        newTranslation.x = size;
        size -= sp.radius * explodeSize;
        break;
      case 5:
        size -= sp.radius * explodeSize;
        newTranslation.y = size;
        size -= sp.radius * explodeSize;
        break;
      case 6:
        size -= sp.radius * explodeSize;
        newTranslation.z = size;
        size -= sp.radius * explodeSize;
        break;
    }
    var path = (0, _scene.find)(store, {
      id: id,
      plug: 'Transform',
      property: 'translation'
    });
    explodeClip.tracks.push({
      easing: 'linear',
      type: 'Vec3',
      path: path,
      start: 0,
      keyframes: {
        x: {
          ts: [0, duration],
          vs: [translation.x, newTranslation.x]
        },
        y: {
          ts: [0, duration],
          vs: [translation.y, newTranslation.y]
        },
        z: {
          ts: [0, duration],
          vs: [translation.z, newTranslation.z]
        }
      }
    });
  });
  return explodeClip;
}
function createCameras(store, size, explodeSize, mode) {
  var translator = store.getTranslator();
  var meshes = (0, _scene.filter)(store, { type: 'PolyMesh' });
  var worldBox = translator.getNodeListBoundingBox(meshes);
  var worldSphere = worldBox.getBoundingSphere();
  var cameraId = getCamera(store);
  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
  size = mode < 4 ? worldSphere.radius * 4 * explodeSize : size * 2;
  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
  var angle = cameraData.aspectRatio >= 1 ? Math.PI * cameraData.fieldOfView / 360 : Math.atan(cameraData.aspectRatio * Math.tan(Math.PI * cameraData.fieldOfView / 360));
  var distance = size / 2 / Math.sin(angle);

  var _decompose = (0, _decompose3.default)(cameraWorldMatrix),
      translation = _decompose.translation,
      rotation = _decompose.rotation;

  var parent = (0, _scene.find)(store, { name: 'Objects' });
  var srcPlugs = {
    Camera: [['Camera', {}]],
    Transform: [['Transform', {
      translation: translation,
      rotation: rotation
    }]],
    Properties: [['CameraProperties', {}]]
  };

  var newTranslation = translation.clone().sub(worldSphere.center);
  newTranslation.normalize().multiplyScalar(distance).add(worldSphere.center);
  var dstPlugs = {
    Camera: [['Camera', {}]],
    Transform: [['Transform', {
      translation: newTranslation,
      rotation: rotation
    }]],
    Properties: [['CameraProperties', {}]]
  };
  return store.dispatch((0, _scene.addNode)({
    name: 'srcCamera',
    type: 'Camera',
    plugs: srcPlugs,
    parent: parent
  })).then(function (srcCameraId) {
    return store.dispatch((0, _scene.addNode)({
      name: 'dstCamera',
      type: 'Camera',
      plugs: dstPlugs,
      parent: parent
    })).then(function (dstCameraId) {
      return {
        srcCamera: srcCameraId,
        dstCamera: dstCameraId
      };
    });
  });
}
function createExplode(explodeMode, nodeType, explodeSize, duration) {
  return function (store) {
    explodeSize = explodeSize > 0 ? explodeSize : 1;
    nodeType = nodeType == 'PolyMesh' ? 'PolyMesh' : 'Null';
    duration = duration || 3000;
    var mode = parseExplodeMode(explodeMode);

    //---------------------calcuate the new position for each node-------------------------------------------
    var sceneGraph = store.get('sceneGraph');
    var translator = store.getTranslator();
    var nodes = (0, _scene.filter)(store, { type: nodeType });
    var positions = [];
    var level = 0;
    nodes.forEach(function (nodeId) {
      var node = sceneGraph.nodes[nodeId];
      var isRootNull = true;
      if (node.children) {
        node.children.forEach(function (child) {
          var type = (0, _scene.get)(store, { id: child, property: 'type' });
          if (type !== 'Null') isRootNull = false;
        });
      }
      if (isRootNull && nodeType === 'Null') return;
      var bbox = translator.getNodeListBoundingBox(nodeType == 'Null' ? node.children : [nodeId]);
      var bSphere = bbox.getBoundingSphere();
      positions.push({ id: nodeId, boundingSphere: bSphere });
      level += bSphere.radius;
    });
    var size = level * explodeSize;
    // sort the mesh by diff props in diff modes
    switch (mode) {
      case 0:
      case 1:
      case 2:
      case 3:
        //xyz
        positions.sort(function (a, b) {
          return b.boundingSphere.radius - a.boundingSphere.radius;
        });
        break;
      case 4:
        //x
        positions.sort(function (a, b) {
          return b.boundingSphere.center.x - a.boundingSphere.center.x;
        });
        break;
      case 5:
        //y
        positions.sort(function (a, b) {
          return b.boundingSphere.center.y - a.boundingSphere.center.y;
        });
        break;
      case 6:
        //z
        positions.sort(function (a, b) {
          return b.boundingSphere.center.z - a.boundingSphere.center.z;
        });
        break;
    }
    //----------------------create clip tracks for each node-----------------------
    var explodeClip = createClip(store, positions, size, duration, explodeSize, mode);
    store.dispatch((0, _animation.addClip)(explodeClip, explodeClip.id));
    //----------------------create dst and src cameras-----------------------
    return createCameras(store, size, explodeSize, mode).then(function (cameras) {
      return {
        explodeClipId: explodeClip.id,
        srcCamera: cameras.srcCamera,
        dstCamera: cameras.dstCamera
      };
    });
  };
}

var publicApi = {
  reducer: reducer,
  actions: {
    addTool: addTool,
    removeTool: removeTool,
    showTool: showTool,
    hideTool: hideTool,
    useManipulator: useManipulator,
    setCameraAttrs: setCameraAttrs,
    useCamera: useCamera,
    setCameraPosition: setCameraPosition,
    animateCameraTo: animateCameraTo,
    resize: resize,
    displayThumbnail: displayThumbnail,
    setActiveColor: setActiveColor,
    requestFullscreen: requestFullscreen,
    exitFullscreen: exitFullscreen,
    setFullscreen: setFullscreen,
    toggleFullscreen: toggleFullscreen,
    setHoverColor: setHoverColor,
    requestLenticularMode: requestLenticularMode,
    enableDeviceTracking: enableDeviceTracking,
    disableDeviceTracking: disableDeviceTracking,
    toggleDeviceTracking: toggleDeviceTracking,
    requestNormalMode: requestNormalMode,
    setFullscreenBGColor: setFullscreenBGColor,
    setCameraRadiusConstraint: setCameraRadiusConstraint,
    updateToolOptions: updateToolOptions,
    setCamera: setCamera,
    frameScene: frameScene,
    setProgressBar: setProgressBar,
    createExplode: createExplode
  },
  selectors: {
    getCamera: getCamera,
    getCameraAttrs: getCameraAttrs,
    getInitialCameraPosition: getInitialCameraPosition,
    getCameraWorldTransform: getCameraWorldTransform,
    getActiveColor: getActiveColor,
    getCanvasElement: getCanvasElement,
    isFullscreen: isFullscreen,
    isVRMode: isVRMode,
    isLenticularMode: isLenticularMode,
    getFullscreenBGColor: getFullscreenBGColor,
    isDeviceTracking: isDeviceTracking,
    shouldDisplayThumbnail: shouldDisplayThumbnail,
    filterNodesFromPosition: filterNodesFromPosition,
    filterNodesFromCenter: filterNodesFromCenter,
    getThreeScene: getThreeScene,
    getThreeCamera: getThreeCamera,
    getProgressBar: getProgressBar,
    getThree: getThree
  }
};
exports.default = publicApi;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.virtualPivotId = exports.controllerRootId = exports.virtualTargetId = exports.vrCameraId = exports.virtualCameraId = exports.deleteNode = exports.addNode = exports.virtualNodes = undefined;

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _typeof2 = __webpack_require__(38);

var _typeof3 = _interopRequireDefault(_typeof2);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _virtualNodes, _createReducer;

exports.initNode = initNode;
exports.addOperator = addOperator;
exports.get = get;
exports.getVRCamera = getVRCamera;
exports.setVRCamera = setVRCamera;
exports.set = set;
exports.merge = merge;
exports.replace = replace;
exports.multi = multi;
exports.touch = touch;
exports.reparent = reparent;
exports.findParent = findParent;
exports.findRoot = findRoot;
exports.clone = clone;
exports.oldNodeJSON = oldNodeJSON;
exports.exportJSON = exportJSON;
exports.updateNodeTransform = updateNodeTransform;
exports.getEvalSceneGraph = getEvalSceneGraph;
exports.setContentStore = setContentStore;
exports.saveIndex = saveIndex;
exports.checkout = checkout;
exports.rebase = rebase;
exports.undo = undo;
exports.getLastCommit = getLastCommit;
exports.getHistory = getHistory;
exports.fetchCommits = fetchCommits;
exports.getCommit = getCommit;
exports.redo = redo;
exports.commit = commit;
exports.syncToLatest = syncToLatest;
exports.traverseHierarchy = traverseHierarchy;

var _three = __webpack_require__(0);

var _v = __webpack_require__(79);

var _v2 = _interopRequireDefault(_v);

var _immutable = __webpack_require__(32);

var _mapObjIndexed = __webpack_require__(106);

var _mapObjIndexed2 = _interopRequireDefault(_mapObjIndexed);

var _createReducer2 = __webpack_require__(46);

var _createReducer3 = _interopRequireDefault(_createReducer2);

var _assets = __webpack_require__(33);

var _actionTypes = __webpack_require__(58);

var _operators = __webpack_require__(101);

var _operators2 = _interopRequireDefault(_operators);

var _evalSceneGraph = __webpack_require__(349);

var _syncSceneGraph2 = __webpack_require__(352);

var _syncSceneGraph3 = _interopRequireDefault(_syncSceneGraph2);

var _diffTree = __webpack_require__(348);

var _diffTree2 = _interopRequireDefault(_diffTree);

var _diffReferences = __webpack_require__(347);

var _diffReferences2 = _interopRequireDefault(_diffReferences);

var _diffObjects = __webpack_require__(346);

var _diffObjects2 = _interopRequireDefault(_diffObjects);

var _createStore = __webpack_require__(128);

var _scene = __webpack_require__(7);

var _sceneIO = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * Low level sceneGraph manipulation.
 *
 * @module sceneGraph
 * @public
 *
 */

var SET = 'SET';
var MERGE = 'MERGE';
var REPLACE = 'REPLACE';
var MULTI = 'MULTI';
var REPARENT = 'REPARENT';
var ADD_OPERATOR = 'ADD_OPERATOR';
var TOUCH = 'TOUCH';
var SET_CONTENT_STORE = 'SET_CONTENT_STORE';
var VERIFY = 'VERIFY';
var virtualCameraId = 'cccccccc-cccc-1ccc-accc-cccccccccccc';
var vrCameraId = 'bbbbbbbb-bbbb-0bbb-zbbb-bbbbbbbbbbbb';
var virtualTargetId = 'dddddddd-dddd-0ddd-addd-dddddddddddd';
var controllerRootId = 'eeeeeeee-eeee-4eee-feee-eeeeeeeeeeee';
var virtualPivotId = 'ffffffff-ffff-3fff-gfff-ffffffffffff';

var virtualNodes = exports.virtualNodes = (_virtualNodes = {}, (0, _defineProperty3.default)(_virtualNodes, virtualCameraId, true), (0, _defineProperty3.default)(_virtualNodes, vrCameraId, true), (0, _defineProperty3.default)(_virtualNodes, virtualTargetId, true), (0, _defineProperty3.default)(_virtualNodes, virtualPivotId, true), _virtualNodes);

function assert(truthy, message) {
  if (!truthy) throw new Error('assertion failure: ' + message);
}

/*
 * Convert from immutable.js scenegraph to our new object format
 */
function convertFromImmutable(scene) {
  throw new Error('Unsupported scene format');
}

var numNodes = 0;

/**
 * Initialize node from object literal format
 */
function initNode(node) {
  var plugs = {};
  var warnings = node.warnings || [];
  var id = node.id,
      children = node.children,
      name = node.name,
      type = node.type,
      parent = node.parent;

  (0, _keys2.default)(node.plugs).forEach(function (plugName) {
    plugs[plugName] = node.plugs[plugName].map(function (op) {
      var type = op.type;
      var operator = (0, _operators.lookupOperator)(plugName, type, warnings);
      return operator.init(type, op, op.name);
    });
  });
  return { id: id, children: children, name: name, type: type, parent: parent, plugs: plugs, warnings: warnings, _v: 0 };
}

function checkNode(node) {
  if (!node.hasOwnProperty('_v')) node._v = 0;
  return node;
}

function buildOp(plugName, op, warnings) {
  var type = void 0,
      props = void 0,
      name = void 0;
  if (Array.isArray(op)) {
    var _op = (0, _slicedToArray3.default)(op, 3);

    type = _op[0];
    props = _op[1];
    name = _op[2];
  } else {
    type = op.type;
    name = op.name;
    props = op;
  }

  return (0, _operators.lookupOperator)(plugName, type, warnings).init(type, props, name);
}

function buildNode(_ref) {
  var id = _ref.id,
      name = _ref.name,
      type = _ref.type,
      children = _ref.children,
      parent = _ref.parent,
      plugs = _ref.plugs;

  var warnings = [];

  return {
    id: id,
    name: name,
    type: type,
    parent: parent,
    warnings: warnings,
    _v: 0,
    children: children || [],
    plugs: (0, _mapObjIndexed2.default)(function (ops, plug) {
      return ops.map(function (op) {
        return buildOp(plug, op, warnings);
      });
    }, plugs)
  };
}

function errorNode(_ref2) {
  var id = _ref2.id,
      name = _ref2.name,
      children = _ref2.children,
      parent = _ref2.parent;

  children = children ? (0, _immutable.List)(children) : (0, _immutable.List)();
  return (0, _immutable.Map)({ id: id, name: name, type: 'ErrorNode', children: children, parent: parent, plugs: (0, _immutable.Map)() });
}

function initializeVirtualNodes(state) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!state.nodes[virtualCameraId] || options.force) {
    state.nodes[virtualCameraId] = buildNode({
      id: virtualCameraId,
      name: 'CAMERA',
      type: 'Camera',
      plugs: {
        Camera: [['Camera', {}]],
        Transform: [['Transform', {}]],
        Properties: [['CameraProperties', {}]]
      }
    });
  }

  if (!state.nodes[vrCameraId] || options.force) {
    state.nodes[vrCameraId] = buildNode({
      id: vrCameraId,
      name: 'VR CAMERA',
      type: 'Camera',
      plugs: {
        Camera: [['Camera', { fieldOfView: 45 }]],
        Transform: [['Transform', { translation: { x: 0, y: 1.6, z: 1 } }]],
        Properties: [['CameraProperties', {}]]
      }
    });
  }

  if (!state.nodes[virtualTargetId] || options.force) {
    state.nodes[virtualTargetId] = buildNode({
      id: virtualTargetId,
      name: 'VIRTUAL TARGET NULL',
      type: 'Null',
      plugs: {
        Transform: [['Transform', {}]]
      }
    });
  }

  if (!state.nodes[controllerRootId] || options.force) {
    state.nodes[controllerRootId] = buildNode({
      id: controllerRootId,
      name: 'CONTROLER ROOT NULL',
      type: 'Null',
      plugs: {
        Transform: [['Transform', {}]]
      }
    });
  }

  if (!state.nodes[virtualPivotId] || options.force) {
    state.nodes[virtualPivotId] = buildNode({
      id: virtualPivotId,
      name: 'VIRTUAL PIVOT NULL',
      type: 'Null',
      plugs: {
        Transform: [['Transform', {}]]
      }
    });
  }
}

function newInitialState() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return (0, _assign2.default)(obj, {
    _v: 0,
    nodes: {},
    fileReferences: { to: {}, from: {} },
    nodeReferences: { to: {}, from: {} },
    cameraReferences: {},
    worldTransformReferences: {},
    evaluatedNodes: {},
    loaded: false,
    activeSceneId: null,
    objects: {}, // { [hash]: 'content string' }
    refs: {}, // { HEAD: sha1, INDEX: sha1, }
    origin: {}, // { HEAD: sha1 }
    // history: [],      // [ commitHash, commitHash ]
    // HEAD: null,       // pointer to head commit
    // STAGING: null,    // pointer to staging commit
    commits: {}, // commit objects by hash
    _ev: 0,
    _sv: 0
  });
}

function markNodeDirty(state, node) {
  var plugName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (node) {
    if (!node._changedPlug) {
      node._changedPlug = plugName;
    } else if (node._changedPlug !== plugName) {
      node._changedPlug = true;
    }
    node._v += 1;
  }
  state._v += 1;
}

function setReducer(state, _ref3) {
  var path = _ref3.path,
      value = _ref3.value;

  if (!path.length || path.length < 2) {
    throw new Error('SET requires a path with length 2 or 4');
  }

  var _path = (0, _slicedToArray3.default)(path, 4),
      nodeId = _path[0],
      plugName = _path[1],
      idx = _path[2],
      key = _path[3];

  var node = state.nodes[nodeId];

  if (path.length === 2 && path[1] === 'name') {
    node.name = value;
    markNodeDirty(state, node);
  } else {
    var plug = node && node.plugs[plugName];
    var op = plug && plug[idx];
    if (!op) throw new Error('Setting data on unknown operator: ' + path.join(','));

    var operator = _operators2.default[plugName][op.type];
    if (operator.set(op, key, value)) {
      markNodeDirty(state, node, plugName);
    }
  }

  return state;
}

/*
* Reducer
*/
var reducer = (0, _createReducer3.default)({}, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, _createStore.ActionTypes.INIT, function (state) {
  return newInitialState();
}), (0, _defineProperty3.default)(_createReducer, TOUCH, function (state, id) {
  var node = state.nodes[id];
  markNodeDirty(state, node);
  return state;
}), (0, _defineProperty3.default)(_createReducer, SET, setReducer), (0, _defineProperty3.default)(_createReducer, MERGE, function (state, _ref4) {
  var path = _ref4.path,
      attrs = _ref4.attrs;

  if (!path.length || path.length !== 3) {
    throw new Error('MERGE requires a path with length 3');
  }

  if ((typeof attrs === 'undefined' ? 'undefined' : (0, _typeof3.default)(attrs)) !== 'object') {
    throw new Error('MERGE requires an object to merge in');
  }

  var _path2 = (0, _slicedToArray3.default)(path, 3),
      nodeId = _path2[0],
      plugName = _path2[1],
      idx = _path2[2];

  var node = state.nodes[nodeId];
  var plug = node && node.plugs[plugName];
  var op = plug && plug[idx];
  var operator = op && _operators2.default[plugName][op.type];
  if (!operator) throw new Error('Setting data on unknown operator: ' + path.join(','));
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(attrs)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var k = _step.value;

      operator.set(op, k, attrs[k]);
    }
    //op._v += 1;
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  markNodeDirty(state, node, plugName);
  return state;
}), (0, _defineProperty3.default)(_createReducer, REPLACE, function (state, _ref5) {
  var id = _ref5.id,
      node = _ref5.node;

  var originalNode = state.nodes[id];
  if (!originalNode) return;

  var v = originalNode._v;
  state.nodes[id] = node;
  node._v = v;
  markNodeDirty(state, node);
  return state;
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.ADD_NODE, function (state, attrs) {
  var id = attrs.id,
      parent = attrs.parent;

  var parentNode = parent && state.nodes[parent];
  if (parent && !parentNode) throw new Error('Unknown parent: \'' + parent + '\'');

  if (state.nodes[id]) throw new Error('Adding a node that already exists: ' + id);

  state.nodes[id] = attrs.node ? checkNode(attrs.node) : buildNode(attrs);

  if (parent && !parentNode.children) {
    parentNode.children = [];
  }
  if (parent && parentNode.children.indexOf(id) === -1) {
    parentNode.children.push(id);
  }
  markNodeDirty(state, parentNode);
  return state;
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.DELETE_NODE, function (state, nodeId) {
  function deleteNodesFromState(id) {
    var node = state.nodes[id];
    if (node) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(node.children || []), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var childId = _step2.value;

          deleteNodesFromState(childId);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var references = state.nodeReferences.from[id];
      (0, _keys2.default)(references || {}).forEach(function (refKey) {
        var path = JSON.parse(refKey);
        setReducer(state, { path: path, value: null });
      });

      if (state.cameraReferences[id]) delete state.cameraReferences[id];
      if (state.worldTransformReferences[id]) delete state.worldTransformReferences[id];

      delete state.nodes[id];
    }

    return node;
  }

  var node = deleteNodesFromState(nodeId);
  if (!node) return state;
  var parent = node.parent && state.nodes[node.parent];
  if (parent) {
    var idx = parent.children.indexOf(nodeId);
    if (idx !== -1) parent.children.splice(idx, 1);
  }

  markNodeDirty(state, parent);
  return state;
}), (0, _defineProperty3.default)(_createReducer, ADD_OPERATOR, function (state, attrs) {
  var id = attrs.id,
      plug = attrs.plug,
      op = attrs.op;

  var node = state.nodes[id];
  if (!node) throw new Error('Unknown node: ' + id);

  var ops = node.plugs[plug];
  if (!ops) throw new Error('Unknown plug: ' + plug);

  if (!Array.isArray(op)) throw new Error('Expect op to be an array of 2 or 3');

  var _op2 = (0, _slicedToArray3.default)(op, 3),
      type = _op2[0],
      props = _op2[1],
      name = _op2[2];

  var operator = (0, _operators.lookupOperator)(plug, type, node.warnings);
  ops.push(operator.init(type, props, name));
  markNodeDirty(state, node, plug);

  return state;
}), (0, _defineProperty3.default)(_createReducer, MULTI, function (state, ops) {
  var v = state._v;
  for (var opId in ops) {
    var op = ops[opId];
    if (op.type === SET) setReducer(state, op.payload);
  }

  state._v = v + 1;
  //console.log('create new multi state in: ', new Date() - s);
  return state;
}), (0, _defineProperty3.default)(_createReducer, REPARENT, function (state, _ref6) {
  var parentId = _ref6.parentId,
      childIds = _ref6.childIds;

  var newParentNode = state.nodes[parentId];
  if (!newParentNode) {
    console.warn('Unknown parent for reparent: ' + parentId);
    return state;
  }

  // iterate copy of array to protect from corruption from child removals
  childIds.slice().forEach(function (childId) {
    var childNode = state.nodes[childId];
    if (!childNode) return;

    var childParentId = childNode && childNode.parent;
    var prevParentNode = childParentId && state.nodes[childParentId];
    var idx = prevParentNode && prevParentNode.children ? prevParentNode.children.indexOf(childId) : -1;
    if (idx !== -1) {
      prevParentNode.children.splice(idx, 1);
      markNodeDirty(state, prevParentNode);
    }

    newParentNode.children.push(childId);
    childNode.parent = parentId;
    markNodeDirty(state, childNode);
  });

  markNodeDirty(state, newParentNode);
  return state;
}), (0, _defineProperty3.default)(_createReducer, SET_CONTENT_STORE, function (state, _ref7) {
  var objects = _ref7.objects,
      refs = _ref7.refs,
      origin = _ref7.origin;

  // console.log('SET_CONTENT_STORE', objects, refs, origin);
  if (objects) (0, _assign2.default)(state.objects, objects);
  if (origin) (0, _assign2.default)(state.origin, origin);
  if (refs) (0, _assign2.default)(state.refs, refs);
  return state;
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.USE_SCENE, function (state, id) {
  state.activeSceneId = id;
  return state;
}), (0, _defineProperty3.default)(_createReducer, VERIFY, function (state) {
  initVirtualNodes(state);
  return state;
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOAD_SCENE, function (state, _ref8) {
  var scene = _ref8.scene,
      nodes = _ref8.nodes;

  if (scene) throw new Error('Loading incompatible scene format'); // loading old immutable scene format
  var sceneJS = (0, _mapObjIndexed2.default)(initNode, JSON.parse(nodes));

  (0, _assign2.default)(state.nodes, sceneJS);

  initializeVirtualNodes(state);
  markNodeDirty(state);

  return state;
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state, id) {
  newInitialState(state);
  initializeVirtualNodes(state, { force: true });
  return state;
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADED_FILE, function (state, id) {
  if (state.fileReferences.from[id]) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(state.fileReferences.from[id])), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var refKey = _step3.value;

        var _JSON$parse = JSON.parse(refKey),
            _JSON$parse2 = (0, _slicedToArray3.default)(_JSON$parse, 3),
            nodeId = _JSON$parse2[0],
            plugName = _JSON$parse2[1],
            opIdx = _JSON$parse2[2];

        markNodeDirty(state, state.nodes[nodeId], plugName);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  return state;
}), _createReducer));

// Return a new node object from existing node
function copyNode(node) {
  var newPlugs = {};
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var plug = _step4.value;

      newPlugs[plug] = node.plugs[plug].map(function (op) {
        return (0, _assign2.default)({}, op);
      });
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return {
    id: (0, _v2.default)(),
    name: node.name,
    type: node.type,
    parent: node.parent,
    children: [].concat(node.children),
    plugs: newPlugs,
    _v: 1
  };
}

/**
 * Add a node to the scene.
 *
 * @public
 * @param {Node} node
 * @returns {Promise}
 */
function _addNode(node) {
  var id = node.id,
      name = node.name,
      type = node.type,
      plugs = node.plugs,
      parent = node.parent;

  if (!id) id = (0, _v2.default)();
  name = name || id;

  return {
    type: _actionTypes.ADD_NODE,
    payload: { id: id, name: name, type: type, plugs: plugs, parent: parent },
    resolve: id
  };
}

/**
 * Deletes a node
 *
 * @public
 * @param {String} id The node id
 * @returns {Promise}
 */
exports.addNode = _addNode;
function _deleteNode(id) {
  return {
    type: _actionTypes.DELETE_NODE,
    payload: id
  };
}

/**
 *
 * Add an operator to a plug of a node.
 */
exports.deleteNode = _deleteNode;
function addOperator(id, plug, op) {
  return {
    type: ADD_OPERATOR,
    payload: { id: id, plug: plug, op: op }
  };
}

/**
 * get a property
 *
 * @param {Path} path to the operator property.
 * @returns {any} value
 *
 * @example
 * // scene.get([uuid
 */
function get(store, path) {
  if (!Array.isArray(path)) throw new Error('Expect path to be an array');

  var sceneGraph = store.get('sceneGraph');
  var result = sceneGraph.nodes[path[0]];

  if (path.length >= 2) {
    if (path[1] === 'name' || path[1] === 'type') {
      return result && result[path[1]];
    }

    result = result && result.plugs[path[1]];
  }

  if (path.length >= 3) {
    result = result && result[path[2]];
  }

  if (path.length >= 4 && result) {
    var operator = (0, _operators.lookupOperator)(path[1], result.type, []);
    result = operator.get(result, path[3]);
  }

  return result;
}

function getVRCamera(store) {
  return get(store, [(0, _sceneIO.getSceneId)(store), 'Player', 0, 'vrCamera']);
}

function setVRCamera(camId) {
  return function (store) {
    var path = [(0, _sceneIO.getSceneId)(store), 'Player', 0, 'vrCamera'];
    store.dispatch(set(path, camId));
  };
}

/**
 * set a property on an operator. This takes a Path array,
 * and a value
 *
 * @param {Path} path includes the operator property.
 * @param {any} value
 * @returns {Promise}
 *
 */
function set(path, value) {
  return { type: SET, payload: { path: path, value: value }, meta: { remote: true } };
}

/**
 * Merges an object into an operator.
 *
 * @param {Path} path to the operator.
 * @param {Object} attrs
 * @returns {Promise}
 *
 */
function merge(path, attrs) {
  return { type: MERGE, payload: { path: path, attrs: attrs } };
}

/**
 * Replace a node with the given node contents
 * @private
 *
 */
function replace(id, node) {
  return { type: REPLACE, payload: { id: id, node: node } };
}

/**
 * An array of scene actions.
 *
 * @param {Action[]} ops
 * @returns {Promise}
 */
function multi(ops) {
  return { type: MULTI, payload: ops };
}

/**
 * Touch sceneGraph node, so it is re-evaluated and translated
 */
function touch(id) {
  return { type: TOUCH, payload: id };
}

/**
 * Reparent nodes to the new parent.
 *
 * @public
 * @param {String} parent id of the new parent node
 * @param {Array} childIds list of ids to reparent
 *
 * @example
 * // reparent children of 'MyModel' to 'NewParentNull'
 * const parentId = scene.find({ name: 'NewParentNull' });
 * const nodesToReparent = scene.filter({ from: { name: 'MyModel' } });
 * sceneGraph.reparent(parentId, nodesToReparent);
 */
function reparent(parentId, childIds) {
  return { type: REPARENT, payload: { parentId: parentId, childIds: childIds } };
}

/**
 * Return the parent id of the node.
 */
function findParent(store, id) {
  var node = store.get('sceneGraph').nodes[id];
  return node && node.parent;
}

/**
 * Return the root parent id of the node.
 */
function findRoot(store, id) {
  var node = store.get('sceneGraph').nodes[id];
  var parent = node && node.parent;
  return parent ? findRoot(store, parent) : id;
}

/**
 * Clone nodes. Given a list of ids, this will copy the node with a new id,
 * and update the parent and child of each node. By passing in a map of *old
 * parent id* to *new parent id*, the nodes can be cloned to a different location
 * in the sceneGraph (or from one to another).
 *
 * @public
 * @param {Array} ids list of ids to clone
 * @param {Object} nodeMap of {oldNodeId: newNodeId} Can be used for passing
 *                         new parents, or new depencies.
 * @param {Object} [options]
 * @param {Boolean} [options.cloneDependencies] Clone dependencies as well.
 *
 * @example
 * // clone children of 'MyModel' to 'NewParentNull'
 * const parentId = scene.find({ name: 'NewParentNull' });
 * const myModelId = scene.find({ name: 'MyModel' });
 * const nodesToClone = scene.filter({ from: { id: myModelId } });
 * sceneGraph.clone(nodesToClone, { [myModelId]: parentId });
 * // clone dependencies
 * sceneGraph.clone(nodesToClone, { [myModelId]: parentId }, {cloneDependencies: true});
 */
function clone(ids) {
  var nodeMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var cloneDependencies = options.cloneDependencies;

  var nodes = ids.reduce(function (acc, id) {
    acc[id] = true;
    return acc;
  }, {});
  var assets = {};

  return function (store) {
    var sceneGraph = store.get('sceneGraph');

    // Find dependencies
    function checkDependency(id) {
      var node = sceneGraph.nodes[id];
      var name = node && node.name;
      if (!node || !node.plugs) return;

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var plug = _step5.value;

          var ops = node.plugs[plug];

          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = (0, _getIterator3.default)(ops), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var op = _step6.value;

              var operator = _operators2.default[plug][op.type];
              if (operator) {
                var _iteratorNormalCompletion7 = true;
                var _didIteratorError7 = false;
                var _iteratorError7 = undefined;

                try {
                  for (var _iterator7 = (0, _getIterator3.default)(operator.referenceKeys), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    var key = _step7.value;

                    var refId = op[key];
                    if (refId && !nodes[refId] && !nodeMap[refId]) {
                      nodes[refId] = true;
                      checkDependency(refId);
                    }
                  }
                } catch (err) {
                  _didIteratorError7 = true;
                  _iteratorError7 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
                      _iterator7.return();
                    }
                  } finally {
                    if (_didIteratorError7) {
                      throw _iteratorError7;
                    }
                  }
                }

                var _iteratorNormalCompletion8 = true;
                var _didIteratorError8 = false;
                var _iteratorError8 = undefined;

                try {
                  for (var _iterator8 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var _key = _step8.value;

                    var _refId = op[_key];
                    if (_refId && store.getIn(['assets', 'assets', _refId])) {
                      assets[_refId] = true;
                    }
                  }
                } catch (err) {
                  _didIteratorError8 = true;
                  _iteratorError8 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                      _iterator8.return();
                    }
                  } finally {
                    if (_didIteratorError8) {
                      throw _iteratorError8;
                    }
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }

    if (cloneDependencies) ids.forEach(checkDependency);

    // Generate new ids
    (0, _keys2.default)(nodes).forEach(function (id) {
      return nodes[id] = (0, _v2.default)();
    });
    (0, _keys2.default)(assets).forEach(function (assetId) {
      return assets[assetId] = (0, _v2.default)();
    });

    function updateDependencies(node) {
      var resultNode = node;
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        var _loop = function _loop() {
          var plug = _step9.value;

          var ops = node.plugs[plug];
          ops.forEach(function (op, opIdx) {
            var operator = _operators2.default[plug][op.type];
            if (operator) {
              var _iteratorNormalCompletion10 = true;
              var _didIteratorError10 = false;
              var _iteratorError10 = undefined;

              try {
                for (var _iterator10 = (0, _getIterator3.default)(operator.referenceKeys), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                  var key = _step10.value;

                  var refId = op[key];
                  var newRef = refId && (nodes[refId] || nodeMap[refId]);
                  if (newRef) resultNode.plugs[plug][opIdx][key] = newRef;
                }
              } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion10 && _iterator10.return) {
                    _iterator10.return();
                  }
                } finally {
                  if (_didIteratorError10) {
                    throw _iteratorError10;
                  }
                }
              }

              var _iteratorNormalCompletion11 = true;
              var _didIteratorError11 = false;
              var _iteratorError11 = undefined;

              try {
                for (var _iterator11 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                  var _key2 = _step11.value;

                  var _refId2 = op[_key2];
                  if (_refId2 && assets[_refId2]) {
                    resultNode.plugs[plug][opIdx][_key2] = assets[_refId2];
                  }
                }
              } catch (err) {
                _didIteratorError11 = true;
                _iteratorError11 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion11 && _iterator11.return) {
                    _iterator11.return();
                  }
                } finally {
                  if (_didIteratorError11) {
                    throw _iteratorError11;
                  }
                }
              }
            }
          });
        };

        for (var _iterator9 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9.return) {
            _iterator9.return();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      return resultNode;
    }

    // Remap parents, children and dependencies
    (0, _keys2.default)(nodes).forEach(function (id) {
      var oldNode = sceneGraph.nodes[id];
      var newNode = copyNode(oldNode);
      newNode.id = nodes[id];

      var nodeParent = oldNode.parent;
      var parent = nodeParent && (nodes[nodeParent] || nodeMap[nodeParent] || nodeParent);
      newNode.parent = parent;

      newNode.children = [];
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = (0, _getIterator3.default)(oldNode.children), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var childId = _step12.value;

          if (nodes[childId]) newNode.children.push(nodes[childId]);else if (nodeMap[childId]) newNode.children.push(nodeMap[childId]);
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      store.dispatch({
        type: _actionTypes.ADD_NODE,
        payload: {
          id: nodes[id],
          parent: parent,
          node: updateDependencies(newNode)
        }
      });
    });

    var firstNodeRootId = findRoot(store, nodes[(0, _keys2.default)(nodes)[0]]);

    (0, _keys2.default)(assets).forEach(function (assetId) {
      var asset = store.getIn(['assets', 'assets', assetId]);
      if (asset) {
        store.dispatch((0, _assets.addFile)(asset.set('id', assets[assetId]).set('sceneId', firstNodeRootId).toJS()));
      }
    });

    return _promise2.default.resolve(nodes);
  };
}

function oldNodeJSON(node) {
  var plugs = (0, _keys2.default)(node.plugs).map(function (plugName) {
    return {
      type: plugName,
      operators: node.plugs[plugName].map(function (op) {
        var operator = (0, _operators.lookupOperator)(plugName, op.type, []);
        return operator.export(op);
      })
    };
  });

  return {
    _id: node.id,
    name: node.name,
    type: node.type,
    plugs: plugs,
    nodes: []
  };
}

/**
 * Given a list of nodes, build and return the old scene graph format.
 */
function exportJSON(store, nodes) {
  var rootNode = void 0;
  var nodeMap = {};
  var sceneGraph = store.get('sceneGraph');

  nodes.forEach(function (nodeId) {
    var node = sceneGraph.nodes[nodeId];
    if (!node) return;

    var newNode = oldNodeJSON(node);
    nodeMap[newNode._id] = newNode;
    if (!rootNode) rootNode = newNode;

    if (node.parent && nodeMap[node.parent]) {
      nodeMap[node.parent].nodes.push(newNode);
    }
  });

  return rootNode;
}

function updateNodeTransform(store, nodeId, newTransform) {
  var parentNodeId = findParent(store, nodeId);

  //const parent = store.getIn(['sceneGraph',parentNode.get('id'),'parent']);
  var parentWorldTransform = (0, _scene.getWorldTransform)(store, parentNodeId);
  //console.log( 'parentWorldTransform', parentWorldTransform );

  var position = new _three.Vector3(),
      quaternion = new _three.Quaternion(),
      scale = new _three.Vector3();

  var tempTransform = new _three.Matrix4();
  tempTransform.copy(newTransform);

  if (parentWorldTransform) {
    var invParentWorldTransform = new _three.Matrix4();
    invParentWorldTransform.getInverse(parentWorldTransform, true);
    tempTransform.multiplyMatrices(invParentWorldTransform, tempTransform);
  }

  tempTransform.decompose(position, quaternion, scale);
  //console.log( 'position', JSON.stringify( position ) );
  //console.log( 'scale', JSON.stringify( scale ) );
  var euler = new _three.Euler().setFromQuaternion(quaternion, 'ZYX');
  //console.log( 'euler', JSON.stringify( euler ) );

  //let translation = node.getIn(['plugs','Transform',0,'translation']);
  //let rotation = node.getIn(['plugs','Transform',0,'rotation']);
  store.dispatch(set([nodeId, 'Transform', 0, 'translation'], {
    x: position.x,
    y: position.y,
    z: position.z
  }));
  store.dispatch(set([nodeId, 'Transform', 0, 'rotation'], {
    x: _three.Math.radToDeg(euler.x),
    y: _three.Math.radToDeg(euler.y),
    z: _three.Math.radToDeg(euler.z)
  }));
}

function getEvalSceneGraph(store) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var sceneGraph = store.get('sceneGraph');

  if (sceneGraph._v === sceneGraph._ev) {
    return sceneGraph;
  }

  //console.log('updateSceneGraph', sceneGraph._ev, 'from', sceneGraph._v);
  (0, _evalSceneGraph.evaluateSceneGraph)(store, sceneGraph, options);
  return sceneGraph;
}

function setContentStore(payload) {
  return { type: SET_CONTENT_STORE, payload: payload };
}

/**
 * Returns a resolved promise when all objects for the commit have been loaded.
 */
function ensureObjectsFor(store, toCommitHash) {
  var sceneGraph = store.get('sceneGraph');
  var toCommit = _getCommit(sceneGraph, toCommitHash);

  if (sceneGraph.objects[toCommit.root]) return _promise2.default.resolve(true);

  return store.callApi({
    url: '/api/scene/' + sceneGraph.activeSceneId + '/objects/' + sceneGraph.refs.HEAD + '/' + toCommitHash
  }).then(function (payload) {
    return store.dispatch(setContentStore(payload));
  });
}

/**
 * Takes the current tree, writes a commit, and saves that to `refs.INDEX`
 */
function saveIndex() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return function (store) {
    var sceneGraph = store.get('sceneGraph');
    if (!sceneGraph.refs.HEAD && !(0, _keys2.default)(sceneGraph.nodes).length) {
      return _promise2.default.resolve();
    }

    var _syncSceneGraph = (0, _syncSceneGraph3.default)(store),
        objects = _syncSceneGraph.objects,
        commit = _syncSceneGraph.commit,
        commitHash = _syncSceneGraph.commitHash;

    var headCommit = _getCommit(sceneGraph, sceneGraph.refs.HEAD);

    if (headCommit && commit.root === headCommit.root) {
      // no changes, set index to head
      return store.dispatch(setContentStore({ refs: { INDEX: sceneGraph.refs.HEAD } }));
    }

    var objs = (0, _assign2.default)({}, sceneGraph.objects, objects);

    // console.log('saveIndex, commit: ', commit, objects)
    return store.dispatch(setContentStore({ objects: objects, refs: { INDEX: commitHash }, commit: commit }));
  };
}

/*
 * This action creator is responsible for setting the state to match the
 * commits given. There are a few scenarios:
 * 1. toHead, no fromHead -- initial checkout, just set to 'to' commit
 * 2. toHead and fromHead -- move from 'from' commit to 'to' commit
 * 3. toHead, fromHead and secondHEAD -- this is a three way merge, where we start with the shared
 *     commit 'from', add 'to' on top, then add 'second' on top of that.
 */
function setToCommit(_ref9) {
  var toHEAD = _ref9.toHEAD,
      secondHEAD = _ref9.secondHEAD,
      fromHEAD = _ref9.fromHEAD,
      options = _ref9.options;

  return function (store) {
    //console.log('setTo', toHEAD, fromHEAD, options);
    var sceneGraph = store.get('sceneGraph');

    if (!fromHEAD) fromHEAD = sceneGraph.refs.INDEX;
    var fromCommit = fromHEAD && _getCommit(sceneGraph, fromHEAD);

    var toCommit = _getCommit(sceneGraph, toHEAD);
    var secondCommit = secondHEAD && _getCommit(sceneGraph, secondHEAD);

    (0, _diffTree2.default)(sceneGraph, toCommit, fromCommit, secondCommit, {
      changeNode: function changeNode(_ref10) {
        var id = _ref10.id,
            plugs = _ref10.plugs;

        var node = sceneGraph.nodes[id];
        node.plugs = (0, _assign2.default)({}, node.plugs, plugs);
        store.dispatch(replace(id, initNode(node)));
      },
      addNode: function addNode(attrs) {
        return store.dispatch(_addNode(attrs));
      },
      deleteNode: function deleteNode(id) {
        return store.dispatch(_deleteNode(id));
      },
      addFile: function addFile(attrs) {
        return store.dispatch((0, _assets.addFile)(attrs));
      }
    });

    (0, _diffReferences2.default)(sceneGraph, toCommit, fromCommit, secondCommit, function (path, value) {
      store.dispatch(set(path, value));
    });

    store.dispatch({ type: VERIFY });

    if (options.detached) {
      store.dispatch({
        type: SET_CONTENT_STORE,
        payload: { refs: { DETACHED_HEAD: toHEAD } }
      });
    } else {
      store.dispatch({
        type: SET_CONTENT_STORE,
        payload: { refs: { HEAD: toHEAD, DETACHED_HEAD: null } }
      });
    }

    store.dispatch({ type: TOUCH });
  };
}

/**
 * checkout will:
 *  1. checkpoint the INDEX
 *  2. checkout the new HEAD
 */
function checkout(toHEAD) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    return store.dispatch(saveIndex()).then(function () {
      return ensureObjectsFor(store, toHEAD).then(function () {
        return store.dispatch(setToCommit({ toHEAD: toHEAD, options: options }));
      });
    });
  };
}

/**
 * rebase will:
 *  1. checkpoint the INDEX
 *  2. checkout the new head
 *  3. apply the INDEX onto the new head
 */
function rebase(toHEAD) {
  return function (store) {
    var sceneGraph = store.get('sceneGraph');
    var HEAD = sceneGraph.refs.HEAD;

    return store.dispatch(saveIndex()).then(function () {
      var INDEX = sceneGraph.refs.INDEX;

      return ensureObjectsFor(store, toHEAD).then(function () {
        if (HEAD === INDEX) {
          return store.dispatch(setToCommit({ toHEAD: toHEAD, options: {} }));
        } else {
          // checkout common ancestor, then merge upstream HEAD and INDEX on top.
          store.dispatch(setToCommit({ toHEAD: HEAD, options: {} }));
          return store.dispatch(setToCommit({
            toHEAD: toHEAD,
            fromHEAD: HEAD,
            secondHEAD: INDEX,
            options: {}
          }));
        }
      });
    });
  };
}

function undo(commitHash) {
  return function (store) {
    // console.log('undo: ', commitHash);
    var sceneGraph = store.get('sceneGraph');
    var history = sceneGraph.history;
    var toCommitHash = commitHash || history[1];
    if (!toCommitHash) {
      return console.log('Nothing to undo');
    }
    store.dispatch(loadFromContent(toCommitHash));
  };
}

function getLastCommit(store) {
  var sceneGraph = store.get('sceneGraph');
  var history = sceneGraph.history;
  if (!history || !history.length) return null;
  return sceneGraph.commits[history[history.length - 1]];
}

function getHistory(store) {
  var sceneGraph = store.get('sceneGraph');
  var _sceneGraph$refs = sceneGraph.refs,
      HEAD = _sceneGraph$refs.HEAD,
      DETACHED_HEAD = _sceneGraph$refs.DETACHED_HEAD;

  var ref = HEAD;
  var history = [];
  while (ref) {
    var _commit = _getCommit(sceneGraph, ref);
    var active = DETACHED_HEAD ? ref === DETACHED_HEAD : ref === HEAD;
    if (_commit) {
      history.push([ref, _commit, active]);
      ref = _commit.parents.length === 1 && _commit.parents[0];
    } else {
      ref = null;
    }
  }
  return history;
}

function fetchCommits(sceneId) {
  return function (store) {
    return store.callApi({ url: '/api/scene/' + sceneId + '/commits' }).then(function (result) {
      return store.dispatch(setContentStore(result));
    });
  };
}

function getCommit(store, commitHash) {
  return _getCommit(store.get('sceneGraph'), commitHash);
}

function redo() {
  return function (store) {
    console.log('redo');
  };
}

function _getCommit(sceneGraph, commitHash) {
  if (!sceneGraph.commits[commitHash]) {
    if (!sceneGraph.objects[commitHash]) {
      // TODO: make this throw an error
      return null;
    }

    sceneGraph.commits[commitHash] = JSON.parse(sceneGraph.objects[commitHash]);
    sceneGraph.commits[commitHash].createdAt = new Date(sceneGraph.commits[commitHash].createdAt);
  }
  return sceneGraph.commits[commitHash];
}

/**
 * commit will:
 *   1. Save the index
 *   2. Set the local HEAD
 *   3. Send the new HEAD to the server
 */
function commit() {
  return function (store) {
    var sceneGraph = store.get('sceneGraph');
    var sceneId = sceneGraph.activeSceneId;

    return store.dispatch(saveIndex()).then(function (_ref11) {
      var refs = _ref11.refs,
          commit = _ref11.commit,
          objects = _ref11.objects;

      if (!commit) return; // Nothing to commit

      // TODO: What happens if the server simply hasn't acknowledge the previous commit?
      var originCommit = _getCommit(sceneGraph, sceneGraph.origin.HEAD);
      //const originCommit = _getCommit(sceneGraph, sceneGraph.refs.HEAD);

      var objectsToSave = originCommit ? (0, _diffObjects2.default)(sceneGraph, commit, originCommit) : objects;
      // save new commit
      objectsToSave[refs.INDEX] = objects[refs.INDEX];

      store.dispatch({
        type: SET_CONTENT_STORE,
        payload: { refs: { HEAD: refs.INDEX } }
      });

      // console.log('saveIndex: ', sceneGraph, refs, commit, objects, newObjects, objectsToSave);
      return store.callApi({
        url: "https://editor.vimarket.io/threehub" + '/api/scene/' + sceneId + '/commit',
        method: 'POST',
        body: { objects: objectsToSave, ref: refs.INDEX }
      }).then(function (payload) {
        console.log('saved commit?', payload);
        // return store.dispatch(setContentStore(payload));
      }).catch(function (err) {
        console.log('handle api error', err);
      });
    });
  };
}

function syncToLatest() {
  return function (store) {
    var sceneGraph = store.get('sceneGraph');
    var sceneId = sceneGraph.activeSceneId;

    return store.callApi({
      url: '/api/scene/' + sceneId + '/sync/' + sceneGraph.refs.HEAD
    }).then(function (_ref12) {
      var objects = _ref12.objects,
          HEAD = _ref12.HEAD;

      if (HEAD !== sceneGraph.refs.HEAD) {
        //console.log('rebase to: ', HEAD, objects);
        store.dispatch(setContentStore({ objects: objects, origin: { HEAD: HEAD } }));
        return store.dispatch(rebase(HEAD));
      }
    });
  };
}

/**
 * Traverse all descendants of a given node (defaults to 'Objects'), passing ids
 * to a callback.
 * @param {*} store
 * @param {*} optionalId
 * @param {*} visibleOnly
 * @param {*} callback
 */
function traverseHierarchy(store, optionalId) {
  var visibleOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var callback = arguments[3];

  if (!callback) {
    console.error('traverseHierarchy: no callback provided');
    return;
  }
  var sceneGraph = store.get('sceneGraph');
  var sceneId = sceneGraph.activeSceneId;
  var nodes = sceneGraph.nodes;

  var hierarchicalVisibility = nodes[sceneId] && nodes[sceneId].plugs.Properties[0].hierarchyVisibility === 'Enable';

  var rootId = optionalId || (0, _scene.find)(store, 'Objects');
  if (visibleOnly && hierarchicalVisibility && !(0, _scene.isVisible)(store, rootId)) return;

  var node = nodes[rootId];
  if (!node) return;

  node.children.forEach(function (childId) {
    var propPlug = nodes[childId].plugs.Properties;
    var childVisibility = propPlug && propPlug[0] && propPlug[0].visible;

    // notify caller of found node
    if (!visibleOnly || childVisibility) {
      callback(childId);
    }

    // traverse child's hierarchy
    if (!visibleOnly || !hierarchicalVisibility || hierarchicalVisibility && childVisibility) {
      traverseHierarchy(store, childId, visibleOnly, callback);
    }
  });
}

var publicApi = {
  reducer: reducer,
  actions: {
    set: set,
    merge: merge,
    multi: multi,
    addNode: _addNode,
    deleteNode: _deleteNode,
    reparent: reparent,
    clone: clone,
    addOperator: addOperator,
    undo: undo,
    redo: redo,
    saveIndex: saveIndex,
    touch: touch,
    setVRCamera: setVRCamera
  },
  selectors: { get: get, exportJSON: exportJSON, getVRCamera: getVRCamera }
};
exports.default = publicApi;
exports.virtualCameraId = virtualCameraId;
exports.vrCameraId = vrCameraId;
exports.virtualTargetId = virtualTargetId;
exports.controllerRootId = controllerRootId;
exports.virtualPivotId = virtualPivotId;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(29);
var core = __webpack_require__(9);
var ctx = __webpack_require__(57);
var hide = __webpack_require__(62);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(14);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

var _defineProperties = __webpack_require__(261);

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _create = __webpack_require__(48);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _SparkleMaterial;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var THREE = __webpack_require__(330);
// File:examples/js/pmrem/PMREMGenerator.js

/**
 * @author Prashant Sharma / spidersharma03
 * @author Ben Houston / bhouston, https://clara.io
 *
 * To avoid cube map seams, I create an extra pixel around each face. This way when the cube map is
 * sampled by an application later(with a little care by sampling the centre of the texel), the extra 1 border
 *	of pixels makes sure that there is no seams artifacts present. This works perfectly for cubeUV format as
 *	well where the 6 faces can be arranged in any manner whatsoever.
 * Code in the beginning of fragment shader's main function does this job for a given resolution.
 *	Run Scene_PMREM_Test.html in the examples directory to see the sampling from the cube lods generated
 *	by this class.
 */

THREE.PMREMGenerator = function (sourceTexture, samplesPerLevel, resolution) {

	this.sourceTexture = sourceTexture;
	this.resolution = resolution !== undefined ? resolution : 256; // NODE: 256 is currently hard coded in the glsl code for performance reasons
	this.samplesPerLevel = samplesPerLevel !== undefined ? samplesPerLevel : 64;
	this.samplesPerLevel = Math.min(128, this.samplesPerLevel); // limit to 128 because that is the size of our poisson table.

	var monotonicEncoding = sourceTexture.encoding === THREE.LinearEncoding || sourceTexture.encoding === THREE.GammaEncoding || sourceTexture.encoding === THREE.sRGBEncoding;

	this.sourceTexture.minFilter = monotonicEncoding ? THREE.LinearFilter : THREE.NearestFilter;
	this.sourceTexture.magFilter = monotonicEncoding ? THREE.LinearFilter : THREE.NearestFilter;
	this.sourceTexture.generateMipmaps = this.sourceTexture.generateMipmaps && monotonicEncoding;

	this.cubeLods = [];

	var size = this.resolution;
	var params = {
		format: this.sourceTexture.format,
		magFilter: this.sourceTexture.magFilter,
		minFilter: this.sourceTexture.minFilter,
		type: this.sourceTexture.type,
		generateMipmaps: this.sourceTexture.generateMipmaps,
		anisotropy: this.sourceTexture.anisotropy,
		encoding: this.sourceTexture.encoding
	};

	// how many LODs fit in the given CubeUV Texture.
	this.numLods = Math.log(size) / Math.log(2) - 2; // IE11 doesn't support Math.log2

	for (var i = 0; i < this.numLods; i++) {

		var renderTarget = new THREE.WebGLRenderTargetCube(size, size, params);
		renderTarget.texture.name = "PMREMGenerator.cube" + i;
		this.cubeLods.push(renderTarget);
		size = Math.max(16, size / 2);
	}

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.0, 1000);

	this.shader = this.getShader();
	this.shader.defines['SAMPLES_PER_LEVEL'] = this.samplesPerLevel;
	this.planeMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), this.shader);
	this.planeMesh.material.side = THREE.DoubleSide;
	this.scene = new THREE.Scene();
	this.scene.add(this.planeMesh);
	this.scene.add(this.camera);

	this.shader.uniforms['envMap'].value = this.sourceTexture;
	this.shader.envMap = this.sourceTexture;
};

THREE.PMREMGenerator.prototype = {

	constructor: THREE.PMREMGenerator,

	/*
  * Prashant Sharma / spidersharma03: More thought and work is needed here.
  * Right now it's a kind of a hack to use the previously convolved map to convolve the current one.
  * I tried to use the original map to convolve all the lods, but for many textures(specially the high frequency)
  * even a high number of samples(1024) dosen't lead to satisfactory results.
  * By using the previous convolved maps, a lower number of samples are generally sufficient(right now 32, which
  * gives okay results unless we see the reflection very carefully, or zoom in too much), however the math
  * goes wrong as the distribution function tries to sample a larger area than what it should be. So I simply scaled
  * the roughness by 0.9(totally empirical) to try to visually match the original result.
  * The condition "if(i <5)" is also an attemt to make the result match the original result.
  * This method requires the most amount of thinking I guess. Here is a paper which we could try to implement in future::
  * http://http.developer.nvidia.com/GPUGems3/gpugems3_ch20.html
  */
	update: function update(renderer) {

		this.shader.uniforms['envMap'].value = this.sourceTexture;
		this.shader.envMap = this.sourceTexture;

		var gammaInput = renderer.gammaInput;
		var gammaOutput = renderer.gammaOutput;
		var toneMapping = renderer.toneMapping;
		var toneMappingExposure = renderer.toneMappingExposure;

		renderer.toneMapping = THREE.LinearToneMapping;
		renderer.toneMappingExposure = 1.0;
		renderer.gammaInput = false;
		renderer.gammaOutput = false;

		for (var i = 0; i < this.numLods; i++) {

			var r = i / (this.numLods - 1);
			this.shader.uniforms['roughness'].value = r * 0.95; // see comment above, pragmatic choice
			this.shader.uniforms['queryScale'].value.x = i == 0 ? -1 : 1;
			var size = this.cubeLods[i].width;
			this.shader.uniforms['mapSize'].value = size;
			this.renderToCubeMapTarget(renderer, this.cubeLods[i]);

			if (i < 5) this.shader.uniforms['envMap'].value = this.cubeLods[i].texture;
		}

		renderer.toneMapping = toneMapping;
		renderer.toneMappingExposure = toneMappingExposure;
		renderer.gammaInput = gammaInput;
		renderer.gammaOutput = gammaOutput;
	},

	renderToCubeMapTarget: function renderToCubeMapTarget(renderer, renderTarget) {

		for (var i = 0; i < 6; i++) {

			this.renderToCubeMapTargetFace(renderer, renderTarget, i);
		}
	},

	renderToCubeMapTargetFace: function renderToCubeMapTargetFace(renderer, renderTarget, faceIndex) {

		renderTarget.activeCubeFace = faceIndex;
		this.shader.uniforms['faceIndex'].value = faceIndex;
		this.shader.uniforms['seed'].value = Math.random();
		renderer.render(this.scene, this.camera, renderTarget, true);
	},

	getShader: function getShader() {

		return new THREE.ShaderMaterial({

			defines: {
				"SAMPLES_PER_LEVEL": 20
			},

			uniforms: {
				"faceIndex": { value: 0 },
				"roughness": { value: 0.5 },
				"mapSize": { value: 0.5 },
				"envMap": { value: null },
				"queryScale": { value: new THREE.Vector3(1, 1, 1) },
				"testColor": { value: new THREE.Vector3(1, 1, 1) },
				"seed": { value: 0.0 }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "precision highp float;\n\
				#include <common>\n\
				varying vec2 vUv;\n\
				uniform int faceIndex;\n\
				uniform float roughness;\n\
				uniform samplerCube envMap;\n\
				uniform float mapSize;\n\
				uniform vec3 testColor;\n\
				uniform vec3 queryScale;\n\
				uniform float seed;\n\
				float poissonLine[128];\n\
				void initPoissonTable()	{\n\
					poissonLine[0] = 0.68999;\n\
					poissonLine[1] = 0.45883;\n\
					poissonLine[2] = 0.1408;\n\
					poissonLine[3] = 0.58453;\n\
					poissonLine[4] = 0.02776;\n\
					poissonLine[5] = 0.3657;\n\
					poissonLine[6] = 0.05616;\n\
					poissonLine[7] = 0.22111;\n\
					poissonLine[8] = 0.16301;\n\
					poissonLine[9] = 0.7939;\n\
					poissonLine[10] = 0.94334;\n\
					poissonLine[11] = 0.93425;\n\
					poissonLine[12] = 0.87263;\n\
					poissonLine[13] = 0.73582;\n\
					poissonLine[14] = 0.12286;\n\
					poissonLine[15] = 0.26529;\n\
					poissonLine[16] = 0.72647;\n\
					poissonLine[17] = 0.83657;\n\
					poissonLine[18] = 0.96543;\n\
					poissonLine[19] = 0.32305;\n\
					poissonLine[20] = 0.25021;\n\
					poissonLine[21] = 0.58689;\n\
					poissonLine[22] = 0.41629;\n\
					poissonLine[23] = 0.12616;\n\
					poissonLine[24] = 0.91421;\n\
					poissonLine[25] = 0.52287;\n\
					poissonLine[26] = 0.20964;\n\
					poissonLine[27] = 0.17271;\n\
					poissonLine[28] = 0.84766;\n\
					poissonLine[29] = 0.0022;\n\
					poissonLine[30] = 0.40568;\n\
					poissonLine[31] = 0.04687;\n\
					poissonLine[32] = 0.11933;\n\
					poissonLine[33] = 0.67212;\n\
					poissonLine[34] = 0.18933;\n\
					poissonLine[35] = 0.86945;\n\
					poissonLine[36] = 0.52297;\n\
					poissonLine[37] = 0.84475;\n\
					poissonLine[38] = 0.74494;\n\
					poissonLine[39] = 0.02533;\n\
					poissonLine[40] = 0.6232;\n\
					poissonLine[41] = 0.96762;\n\
					poissonLine[42] = 0.00449;\n\
					poissonLine[43] = 0.7535;\n\
					poissonLine[44] = 0.48421;\n\
					poissonLine[45] = 0.07936;\n\
					poissonLine[46] = 0.84871;\n\
					poissonLine[47] = 0.47694;\n\
					poissonLine[48] = 0.22845;\n\
					poissonLine[49] = 0.37711;\n\
					poissonLine[50] = 0.49824;\n\
					poissonLine[51] = 0.35694;\n\
					poissonLine[52] = 0.38277;\n\
					poissonLine[53] = 0.83666;\n\
					poissonLine[54] = 0.57835;\n\
					poissonLine[55] = 0.49536;\n\
					poissonLine[56] = 0.0132;\n\
					poissonLine[57] = 0.4593;\n\
					poissonLine[58] = 0.3938;\n\
					poissonLine[59] = 0.61267;\n\
					poissonLine[60] = 0.47573;\n\
					poissonLine[61] = 0.2202;\n\
					poissonLine[62] = 0.11283;\n\
					poissonLine[63] = 0.04534;\n\
					poissonLine[64] = 0.30502;\n\
					poissonLine[65] = 0.40026;\n\
					poissonLine[66] = 0.30118;\n\
					poissonLine[67] = 0.73927;\n\
					poissonLine[68] = 0.82648;\n\
					poissonLine[69] = 0.19517;\n\
					poissonLine[70] = 0.20144;\n\
					poissonLine[71] = 0.72373;\n\
					poissonLine[72] = 0.77945;\n\
					poissonLine[73] = 0.37953;\n\
					poissonLine[74] = 0.67661;\n\
					poissonLine[75] = 0.13671;\n\
					poissonLine[76] = 0.22514;\n\
					poissonLine[77] = 0.45704;\n\
					poissonLine[78] = 0.44605;\n\
					poissonLine[79] = 0.8856;\n\
					poissonLine[80] = 0.88545;\n\
					poissonLine[81] = 0.32133;\n\
					poissonLine[82] = 0.66175;\n\
					poissonLine[83] = 0.01964;\n\
					poissonLine[84] = 0.14848;\n\
					poissonLine[85] = 0.37481;\n\
					poissonLine[86] = 0.39741;\n\
					poissonLine[87] = 0.2039;\n\
					poissonLine[88] = 0.50282;\n\
					poissonLine[89] = 0.00156;\n\
					poissonLine[90] = 0.69715;\n\
					poissonLine[91] = 0.71233;\n\
					poissonLine[92] = 0.76777;\n\
					poissonLine[93] = 0.90509;\n\
					poissonLine[94] = 0.19425;\n\
					poissonLine[95] = 0.64406;\n\
					poissonLine[96] = 0.06155;\n\
					poissonLine[97] = 0.60422;\n\
					poissonLine[98] = 0.65107;\n\
					poissonLine[99] = 0.52872;\n\
					poissonLine[100] = 0.481;\n\
					poissonLine[101] = 0.95757;\n\
					poissonLine[102] = 0.53635;\n\
					poissonLine[103] = 0.42727;\n\
					poissonLine[104] = 0.91034;\n\
					poissonLine[105] = 0.24529;\n\
					poissonLine[106] = 0.75649;\n\
					poissonLine[107] = 0.13242;\n\
					poissonLine[108] = 0.75987;\n\
					poissonLine[109] = 0.62928;\n\
					poissonLine[110] = 0.84537;\n\
					poissonLine[111] = 0.95954;\n\
					poissonLine[112] = 0.47203;\n\
					poissonLine[113] = 0.6294;\n\
					poissonLine[114] = 0.67411;\n\
					poissonLine[115] = 0.89943;\n\
					poissonLine[116] = 0.77134;\n\
					poissonLine[117] = 0.77034;\n\
					poissonLine[118] = 0.46964;\n\
					poissonLine[119] = 0.78511;\n\
					poissonLine[120] = 0.74841;\n\
					poissonLine[121] = 0.51348;\n\
					poissonLine[122] = 0.58248;\n\
					poissonLine[123] = 0.00892;\n\
					poissonLine[124] = 0.89159;\n\
					poissonLine[125] = 0.14869;\n\
					poissonLine[126] = 0.39455;\n\
					poissonLine[127] = 0.75754;\n\
				}\n\
				\n\
				vec3 ImportanceSampleGGX( float radians, float radius, mat3 vecSpace, float roughness )\n\
				{\n\
					float rad = radius * roughness;\n\
					float up = sqrt( max( 1.0 - pow2( rad ), 0.0001 ) );\n\
					return vecSpace * vec3 (rad * cos( radians ), rad * sin( radians ), up );\n\
				}\n\
				mat3 matrixFromVector(vec3 n) {\n\
					float a = 1.0 / (1.0 + n.z);\n\
					float b = -n.x * n.y * a;\n\
					vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\
					vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\
					return mat3(b1, b2, n);\n\
				}\n\
				\n\
				float unitToRadians( float unit ) { return PI * 2.0 * unit; }\n\
				\n\
				void main() {\n\
					initPoissonTable();\n\
					vec3 sampleDirection;\n\
					vec2 uv = vUv*2.0 - 1.0;\n\
					float offset = -1.0/mapSize;\n\
					const float a = -1.0;\n\
					const float b = 1.0;\n\
					float c = -1.0 + offset;\n\
					float d = 1.0 - offset;\n\
					float bminusa = b - a;\n\
					uv.x = (uv.x - a)/bminusa * d - (uv.x - b)/bminusa * c;\n\
					uv.y = (uv.y - a)/bminusa * d - (uv.y - b)/bminusa * c;\n\
					if (faceIndex==0) {\n\
						sampleDirection = vec3(1.0, -uv.y, -uv.x);\n\
					} else if (faceIndex==1) {\n\
						sampleDirection = vec3(-1.0, -uv.y, uv.x);\n\
					} else if (faceIndex==2) {\n\
						sampleDirection = vec3(uv.x, 1.0, uv.y);\n\
					} else if (faceIndex==3) {\n\
						sampleDirection = vec3(uv.x, -1.0, -uv.y);\n\
					} else if (faceIndex==4) {\n\
						sampleDirection = vec3(uv.x, -uv.y, 1.0);\n\
					} else {\n\
						sampleDirection = vec3(-uv.x, -uv.y, -1.0);\n\
					}\n\
					mat3 vecSpace = matrixFromVector(normalize(sampleDirection * queryScale));\n\
					vec3 rgbColor = vec3(0.0);\n\
					const int NumSamples = SAMPLES_PER_LEVEL;\n\
					vec3 direction;\n\
					float invNumSamples = 1.0 / float(NumSamples);\n\
					for( int i = 0; i < NumSamples; i ++ ) {\n\
						float unit = ( float(i) ) * invNumSamples;\n\
						float angle = unitToRadians( unit + 0.5 );\n\
						float radius = poissonLine[ i ];\n\
						direction = ImportanceSampleGGX( angle, radius, vecSpace, roughness);\n\
						vec3 color = envMapTexelToLinear(textureCube(envMap,direction)).rgb;\n\
						rgbColor.rgb += color;\n\
					}\n\
					rgbColor *= invNumSamples;\n\
					//rgbColor = testColorMap( roughness ).rgb;\n\
					gl_FragColor = linearToOutputTexel( vec4( rgbColor, 1.0 ) );\n\
				}",
			blending: THREE.CustomBlending,
			blendSrc: THREE.OneFactor,
			blendDst: THREE.ZeroFactor,
			blendSrcAlpha: THREE.OneFactor,
			blendDstAlpha: THREE.ZeroFactor,
			blendEquation: THREE.AddEquation
		});
	}

};

// File:examples/js/pmrem/PMREMCubeUVPacker.js

/**
 * @author Prashant Sharma / spidersharma03
 * @author Ben Houston / bhouston, https://clara.io
 *
 * This class takes the cube lods(corresponding to different roughness values), and creates a single cubeUV
 * Texture. The format for a given roughness set of faces is simply::
 * +X+Y+Z
 * -X-Y-Z
 * For every roughness a mip map chain is also saved, which is essential to remove the texture artifacts due to
 * minification.
 * Right now for every face a PlaneMesh is drawn, which leads to a lot of geometry draw calls, but can be replaced
 * later by drawing a single buffer and by sending the appropriate faceIndex via vertex attributes.
 * The arrangement of the faces is fixed, as assuming this arrangement, the sampling function has been written.
 */

THREE.PMREMCubeUVPacker = function (cubeTextureLods, numLods) {

	this.cubeLods = cubeTextureLods;
	this.numLods = numLods;
	var size = cubeTextureLods[0].width * 4;

	var sourceTexture = cubeTextureLods[0].texture;
	var params = {
		format: sourceTexture.format,
		magFilter: sourceTexture.magFilter,
		minFilter: sourceTexture.minFilter,
		type: sourceTexture.type,
		generateMipmaps: sourceTexture.generateMipmaps,
		anisotropy: sourceTexture.anisotropy,
		encoding: sourceTexture.encoding === THREE.RGBEEncoding ? THREE.RGBM16Encoding : sourceTexture.encoding
	};

	if (params.encoding === THREE.RGBM16Encoding) {
		params.magFilter = THREE.LinearFilter;
		params.minFilter = THREE.LinearFilter;
	}

	this.CubeUVRenderTarget = new THREE.WebGLRenderTarget(size, size, params);
	this.CubeUVRenderTarget.texture.name = "PMREMCubeUVPacker.cubeUv";
	this.CubeUVRenderTarget.texture.mapping = THREE.CubeUVReflectionMapping;
	this.camera = new THREE.OrthographicCamera(-size * 0.5, size * 0.5, -size * 0.5, size * 0.5, 0.0, 1000);

	this.scene = new THREE.Scene();
	this.scene.add(this.camera);

	this.objects = [];
	var xOffset = 0;
	var faceOffsets = [];
	faceOffsets.push(new THREE.Vector2(0, 0));
	faceOffsets.push(new THREE.Vector2(1, 0));
	faceOffsets.push(new THREE.Vector2(2, 0));
	faceOffsets.push(new THREE.Vector2(0, 1));
	faceOffsets.push(new THREE.Vector2(1, 1));
	faceOffsets.push(new THREE.Vector2(2, 1));
	var yOffset = 0;
	var textureResolution = size;
	size = cubeTextureLods[0].width;
	//console.log( 'textureResolution', textureResolution );

	var offset2 = 0;
	var c = 4.0;
	this.numLods = Math.log(cubeTextureLods[0].width) / Math.log(2) - 2; // IE11 doesn't support Math.log2
	for (var i = 0; i < this.numLods; i++) {

		var offset1 = (textureResolution - textureResolution / c) * 0.5;
		//if ( size > 16 )
		c *= 2;
		var nMips = 6; //size > 16 ? 6 : 1;
		var mipOffsetX = 0;
		var mipOffsetY = 0;
		var mipSize = size;

		for (var j = 0; j < nMips; j++) {

			// Mip Maps
			for (var k = 0; k < 6; k++) {

				// 6 Cube Faces
				var material = this.getShader();
				material.uniforms['envMap'].value = this.cubeLods[i].texture;
				material.envMap = this.cubeLods[i].texture;
				material.uniforms['faceIndex'].value = k;
				material.uniforms['mapSize'].value = mipSize;
				var color = material.uniforms['testColor'].value;
				var planeMesh = new THREE.Mesh(new THREE.PlaneGeometry(mipSize, mipSize, 0), material);
				planeMesh.position.x = faceOffsets[k].x * mipSize - offset1 + mipOffsetX;
				planeMesh.position.y = faceOffsets[k].y * mipSize - offset1 + offset2 + mipOffsetY;
				/*			console.log( "planeMesh.position", planeMesh.position.x + offset1, planeMesh.position.y + offset1, mipSize,
    			 	( Math.abs( planeMesh.position.x + offset1 + mipSize ) > textureResolution ),
    			  ( Math.abs( planeMesh.position.y + offset1 + mipSize ) > textureResolution ) );*/

				planeMesh.material.side = THREE.DoubleSide;
				this.scene.add(planeMesh);
				this.objects.push(planeMesh);
			}
			mipOffsetY += 1.75 * mipSize;
			mipOffsetX += 1.25 * mipSize;
			mipSize /= 2;
		}
		offset2 += 2 * size;
		//if ( size > 16 )
		size /= 2;
	}
};

THREE.PMREMCubeUVPacker.prototype = {

	constructor: THREE.PMREMCubeUVPacker,

	update: function update(renderer) {

		var gammaInput = renderer.gammaInput;
		var gammaOutput = renderer.gammaOutput;
		var toneMapping = renderer.toneMapping;
		var toneMappingExposure = renderer.toneMappingExposure;
		renderer.gammaInput = false;
		renderer.gammaOutput = false;
		renderer.toneMapping = THREE.LinearToneMapping;
		renderer.toneMappingExposure = 1.0;
		renderer.render(this.scene, this.camera, this.CubeUVRenderTarget, false);

		renderer.toneMapping = toneMapping;
		renderer.toneMappingExposure = toneMappingExposure;
		renderer.gammaInput = gammaInput;
		renderer.gammaOutput = gammaOutput;
	},

	getShader: function getShader() {

		var shaderMaterial = new THREE.ShaderMaterial({

			uniforms: {
				"faceIndex": { value: 0 },
				"mapSize": { value: 0 },
				"envMap": { value: null },
				"testColor": { value: new THREE.Vector3(1, 1, 1) }
			},

			vertexShader: "precision highp float;\
				varying vec2 vUv;\
				void main() {\
					vUv = uv;\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\
				}",

			fragmentShader: "precision highp float;\
				varying vec2 vUv;\
				uniform samplerCube envMap;\
				uniform float mapSize;\
				uniform vec3 testColor;\
				uniform int faceIndex;\
				\
				void main() {\
					vec3 sampleDirection;\
					vec2 uv = vUv;\
					uv = uv * 2.0 - 1.0;\
					uv.y *= -1.0;\
					if(faceIndex == 0) {\
						sampleDirection = normalize(vec3(1.0, uv.y, -uv.x));\
					} else if(faceIndex == 1) {\
						sampleDirection = normalize(vec3(uv.x, 1.0, uv.y));\
					} else if(faceIndex == 2) {\
						sampleDirection = normalize(vec3(uv.x, uv.y, 1.0));\
					} else if(faceIndex == 3) {\
						sampleDirection = normalize(vec3(-1.0, uv.y, uv.x));\
					} else if(faceIndex == 4) {\
						sampleDirection = normalize(vec3(uv.x, -1.0, -uv.y));\
					} else {\
						sampleDirection = normalize(vec3(-uv.x, uv.y, -1.0));\
					}\
					vec4 color = envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\
					gl_FragColor = linearToOutputTexel( color );\
				}",

			blending: THREE.CustomBlending,
			premultipliedAlpha: false,
			blendSrc: THREE.OneFactor,
			blendDst: THREE.ZeroFactor,
			blendSrcAlpha: THREE.OneFactor,
			blendDstAlpha: THREE.ZeroFactor,
			blendEquation: THREE.AddEquation

		});

		return shaderMaterial;
	}

};

// File:examples/js/shaders/CopyShader.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

THREE.CopyShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"opacity": { value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")

};

// File:examples/js/shaders/CompositeShader.js

/**
 * @author bhouston / http://clara.io
 *
 * Various composite operations
 */

THREE.CompositeShader = {

	defines: {

		"BLENDING": THREE.NoBlending

	},

	uniforms: {

		"tSource": { type: "t", value: null },
		"opacitySource": { type: "f", value: 1.0 },

		"tDestination": { type: "t", value: null },
		"opacityDestination": { type: "f", value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tSource;", "uniform float opacitySource;", "uniform sampler2D tDestination;", "uniform float opacityDestination;", "varying vec2 vUv;", "void main() {", "vec4 d = opacityDestination * texture2D( tDestination, vUv );", "vec4 s = opacitySource * texture2D( tSource, vUv );",

	// all blending modes are implemented assuming premultiplied values

	"#if (BLENDING == " + THREE.NormalBlending + ")", "gl_FragColor = d * ( 1.0 - s.a ) + s;", "#elif (BLENDING == " + THREE.AdditiveBlending + ")", "gl_FragColor = d + s;", "#elif (BLENDING == " + THREE.SubtractiveBlending + ")", "gl_FragColor = d - s;", "#elif (BLENDING == " + THREE.MultiplyBlending + ")", "gl_FragColor = d * s;", "#else", // THREE.NoBlending

	"gl_FragColor = s;", "#endif", "}"].join("\n")

};

// File:examples/js/shaders/GlossyMirrorShader.js

THREE.GlossyMirrorShader = {

	defines: {
		"SPECULAR_MAP": 0,
		"ROUGHNESS_MAP": 0,
		"GLOSSY_REFLECTIONS": 1,
		"REFLECTION_LOD_LEVELS": 4,
		"PERSPECTIVE_CAMERA": 1
	},

	uniforms: {

		"metalness": { type: "f", value: 0.0 },

		"specularColor": { type: "c", value: new THREE.Color(0xffffff) },
		"tSpecular": { type: "t", value: null },

		"tReflection": { type: "t", value: null },
		"tReflection1": { type: "t", value: null },
		"tReflection2": { type: "t", value: null },
		"tReflection3": { type: "t", value: null },
		"tReflection4": { type: "t", value: null },
		"tReflectionDepth": { type: "t", value: null },

		"roughness": { type: "f", value: 0.0 },
		"distanceFade": { type: "f", value: 0.01 },
		"fresnelStrength": { type: "f", value: 1.0 },

		"reflectionTextureMatrix": { type: "m4", value: new THREE.Matrix4() },
		"mirrorCameraWorldMatrix": { type: "m4", value: new THREE.Matrix4() },
		"mirrorCameraProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },
		"mirrorCameraInverseProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },
		"mirrorCameraNear": { type: "f", value: 0 },
		"mirrorCameraFar": { type: "f", value: 0 },
		"screenSize": { type: "v2", value: new THREE.Vector2() },
		"mirrorNormal": { type: "v3", value: new THREE.Vector3() },
		"mirrorWorldPosition": { type: "v3", value: new THREE.Vector3() }
	},

	vertexShader: ["uniform mat4 reflectionTextureMatrix;", "varying vec4 mirrorCoord;", "varying vec3 vecPosition;", "varying vec3 worldNormal;", "varying vec2 vUv;", "void main() {", "vUv = uv;", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "vecPosition = cameraPosition - worldPosition.xyz;", "worldNormal = (modelMatrix * vec4(normal,0.0)).xyz;", "mirrorCoord = reflectionTextureMatrix * worldPosition;", "gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),

	blending: THREE.NormalBlending,
	transparent: true,

	fragmentShader: ["#include <common>", "#include <packing>", "#include <bsdfs>", "uniform float roughness;", "#if ROUGHNESS_MAP == 1", "uniform sampler2D tRoughness;", "#endif", "uniform float metalness;", "uniform float distanceFade;", "uniform float fresnelStrength;", "uniform vec3 specularColor;", "#if SPECULAR_MAP == 1", "uniform sampler2D tSpecular;", "#endif", "uniform sampler2D tReflection;", "#if GLOSSY_REFLECTIONS == 1", "uniform sampler2D tReflection1;", "uniform sampler2D tReflection2;", "uniform sampler2D tReflection3;", "uniform sampler2D tReflection4;", "uniform sampler2D tReflectionDepth;", "#endif", "varying vec3 vecPosition;", "varying vec3 worldNormal;", "varying vec2 vUv;", "varying vec4 mirrorCoord;", "uniform mat4 mirrorCameraProjectionMatrix;", "uniform mat4 mirrorCameraInverseProjectionMatrix;", "uniform mat4 mirrorCameraWorldMatrix;", "uniform float mirrorCameraNear;", "uniform float mirrorCameraFar;", "uniform vec2 screenSize;", "uniform vec3 mirrorNormal;", "uniform vec3 mirrorWorldPosition;", "#if GLOSSY_REFLECTIONS == 1", "float getReflectionDepth() {", "return unpackRGBAToDepth( texture2DProj( tReflectionDepth, mirrorCoord ) );", "}", "float getReflectionViewZ( const in float reflectionDepth ) {", "#if PERSPECTIVE_CAMERA == 1", "return perspectiveDepthToViewZ( reflectionDepth, mirrorCameraNear, mirrorCameraFar );", "#else", "return orthographicDepthToViewZ( reflectionDepth, mirrorCameraNear, mirrorCameraFar );", "#endif", "}", "vec3 getReflectionViewPosition( const in vec2 screenPosition, const in float reflectionDepth, const in float reflectionViewZ ) {", "float clipW = mirrorCameraProjectionMatrix[2][3] * reflectionViewZ + mirrorCameraProjectionMatrix[3][3];", "vec4 clipPosition = vec4( ( vec3( screenPosition, reflectionDepth ) - 0.5 ) * 2.0, 1.0 );", "clipPosition *= clipW;", // unprojection.
	"return ( mirrorCameraInverseProjectionMatrix * clipPosition ).xyz;", "}", "#endif", "vec4 getReflection( const in vec4 mirrorCoord, const in float lodLevel ) {", "#if GLOSSY_REFLECTIONS == 0", "return texture2DProj( tReflection, mirrorCoord );", "#else", "vec4 color0, color1;", "float alpha;", "if( lodLevel < 1.0 ) {", "color0 = texture2DProj( tReflection, mirrorCoord );", "color1 = texture2DProj( tReflection1, mirrorCoord );", "alpha = lodLevel;", "}", "else if( lodLevel < 2.0) {", "color0 = texture2DProj( tReflection1, mirrorCoord );", "color1 = texture2DProj( tReflection2, mirrorCoord );", "alpha = lodLevel - 1.0;", "}", "else if( lodLevel < 3.0 ) {", "color0 = texture2DProj( tReflection2, mirrorCoord );", "color1 = texture2DProj( tReflection3, mirrorCoord );", "alpha = lodLevel - 2.0;", "}", "else {", "color0 = texture2DProj( tReflection3, mirrorCoord );", "color1 = color0;", "alpha = 0.0;", "}", "return mix( color0, color1, alpha );", "#endif", "}", "void main() {", "vec3 specular = specularColor;", "#if SPECULAR_MAP == 1", "specular *= texture2D( tSpecular, vUv );", "#endif", "float fade = 1.0;", "#if GLOSSY_REFLECTIONS == 1", "float localRoughness = roughness;", "#if ROUGHNESS_MAP == 1", "localRoughness *= texture2D( tRoughness, vUv ).r;", "#endif", "vec2 screenPosition = gl_FragCoord.xy / screenSize;", "float reflectionDepth = getReflectionDepth();", "float reflectionViewZ = getReflectionViewZ( reflectionDepth );", "vec3 reflectionViewPosition = getReflectionViewPosition( screenPosition, reflectionDepth, reflectionViewZ );", "vec3 reflectionWorldPosition = ( mirrorCameraWorldMatrix * vec4( reflectionViewPosition, 1.0 ) ).xyz;", "vec3 closestPointOnMirror = projectOnPlane( reflectionWorldPosition, mirrorWorldPosition, mirrorNormal );", "vec3 pointOnMirror = linePlaneIntersect( cameraPosition, normalize( reflectionWorldPosition - cameraPosition ), mirrorWorldPosition, mirrorNormal );", "float distance = length( closestPointOnMirror - reflectionWorldPosition );", "localRoughness = localRoughness * distance * 0.2;", "float lodLevel = localRoughness;", "fade = 1.0 - smoothstep( 0.0, 1.0, distanceFade * distance * 0.2 );", "#else", "float lodLevel = 0.0;", "#endif", "vec4 reflection = getReflection( mirrorCoord, lodLevel );",

	// apply dieletric-conductor model parameterized by metalness parameter.
	"float dotNV = clamp( dot( normalize( worldNormal ), normalize( vecPosition ) ), EPSILON, 1.0 );", "specular = mix( vec3( 0.05 ), specular, metalness );",
	// TODO: Invert fresnel.
	"vec3 fresnel;", "if( fresnelStrength < 0.0 ) {", "fresnel = mix( specular, specular * pow( dotNV, 2.0 ), -fresnelStrength ) * pow( 1.0 - roughness, 2.0 );", "} else {", "fresnel = mix( specular, F_Schlick( specular, dotNV ), fresnelStrength ) * pow( 1.0 - roughness, 2.0 );", "}", "gl_FragColor = vec4( reflection.rgb, fresnel * fade * reflection.a );", // fresnel controls alpha


	"}"].join("\n")

};

// File:examples/js/shaders/SAOShader.js

/**
 * @author bhouston / http://clara.io/
 *
 * Scalable Ambient Occlusion
 *
 */

THREE.ShaderChunk['sao'] = ["#include <packing>", "float getDepth( const in vec2 screenPosition ) {", "#if DEPTH_PACKING == 1", "return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "#else", "return texture2D( tDepth, screenPosition ).x;", "#endif", "}", "vec4 setDepth( const in float depth ) {", "#if DEPTH_PACKING == 1", "return packDepthToRGBA( depth );", "#else", "return vec4( depth, 0, 0, 0 );", "#endif", "}", "float getViewZ( const in float depth ) {", "#if PERSPECTIVE_CAMERA == 1", "return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "#else", "return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "#endif", "}"].join("\n");

THREE.SAOShader = {

	blending: THREE.NoBlending,

	defines: {
		'NUM_SAMPLES': 13,
		'NUM_RINGS': 7,
		"NORMAL_TEXTURE": 0,
		"DIFFUSE_TEXTURE": 1,
		"DEPTH_PACKING": 1,
		"DEPTH_MIPS": 0,
		"PERSPECTIVE_CAMERA": 1
	},

	extensions: {
		'derivatives': true
	},

	uniforms: {

		"tDepth": { type: "t", value: null },
		"tDepth1": { type: "t", value: null },
		"tDepth2": { type: "t", value: null },
		"tDepth3": { type: "t", value: null },

		"tDiffuse": { type: "t", value: null },
		"tNormal": { type: "t", value: null },
		"size": { type: "v2", value: new THREE.Vector2(512, 512) },

		"cameraNear": { type: "f", value: 1 },
		"cameraFar": { type: "f", value: 100 },
		"cameraProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },
		"cameraInverseProjectionMatrix": { type: "m4", value: new THREE.Matrix4() },

		"intensity": { type: "f", value: 0.1 },

		"occlusionSphereWorldRadius": { type: "f", value: 100.0 },
		"worldToScreenRatio": { type: "v2", value: new THREE.Vector2(1, 1) },
		"randomSeed": { type: "f", value: 0.0 }
	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#include <common>", "varying vec2 vUv;", "#if DIFFUSE_TEXTURE == 1", "uniform sampler2D tDiffuse;", "#endif", "#define MAX_MIP_LEVEL 3", "uniform sampler2D tDepth;", "#if DEPTH_MIPS == 1", "uniform sampler2D tDepth1;", "uniform sampler2D tDepth2;", "uniform sampler2D tDepth3;", "#endif", "#if NORMAL_TEXTURE == 1", "uniform sampler2D tNormal;", "#endif", "uniform float cameraNear;", "uniform float cameraFar;", "uniform mat4 cameraProjectionMatrix;", "uniform mat4 cameraInverseProjectionMatrix;", "uniform float intensity;", "uniform float occlusionSphereWorldRadius;", "uniform vec2 size;", "uniform vec2 worldToScreenRatio;", "uniform float randomSeed;", "#include <sao>", "vec4 getDefaultColor( const in vec2 screenPosition ) {", "#if DIFFUSE_TEXTURE == 1", "return texture2D( tDiffuse, vUv );", "#else", "return vec4( 1.0 );", "#endif", "}", "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {", "float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];", "vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );", "clipPosition *= clipW;", // unprojection.
	"return ( cameraInverseProjectionMatrix * clipPosition ).xyz;", "}", "vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {", "#if NORMAL_TEXTURE == 1", "return -unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );", "#else", "return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );", "#endif", "}", "float getDepthMIP( const in vec2 screenPosition, const int mipLevel ) {", "vec4 rawDepth;", "#if DEPTH_MIPS == 0", "rawDepth = texture2D( tDepth, screenPosition );", "#else", "if( mipLevel == 0 ) {", "rawDepth = texture2D( tDepth, screenPosition );", "}", "else if( mipLevel == 1 ) {", "rawDepth = texture2D( tDepth1, screenPosition );", "}", "else if( mipLevel == 2 ) {", "rawDepth = texture2D( tDepth2, screenPosition );", "}", "else {", "rawDepth = texture2D( tDepth3, screenPosition );", "}", "#endif", "#if DEPTH_PACKING == 1", "return unpackRGBAToDepth( rawDepth );", "#else", "return rawDepth.x;", "#endif", "}", "float scaleDividedByCameraFar;", "float minResolutionMultipliedByCameraFar;", "float errorCorrectionFactor;", "float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {", "vec3 viewDelta = sampleViewPosition - centerViewPosition;", "float viewDistance2 = dot( viewDelta, viewDelta );", "return max( ( dot( centerViewNormal, viewDelta ) + centerViewPosition.z * 0.001 ) / ( viewDistance2 + 0.0001 ), 0.0 );// * smoothstep( pow2( occlusionSphereWorldRadius ), 0.0, viewDistance2 );", "}",

	/*
 "float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {",
 		"vec3 viewDelta = sampleViewPosition - centerViewPosition;",
 	"float viewDistance2 = dot( viewDelta, viewDelta );",
 		"return max( pow3( pow2( occlusionSphereWorldRadius ) - viewDistance2 ), 0.0 ) *",
 		"max( ( dot( centerViewNormal, viewDelta ) - 0.01 * occlusionSphereWorldRadius ) / ( viewDistance2 + 0.0001 ), 0.0 );",
 	"}",*/

	//"const float maximumScreenRadius = 10.0;",

	"int getMipLevel( const in vec2 occlusionSphereScreenRadius ) {", "return int( clamp( floor( log2( length( occlusionSphereScreenRadius * size ) ) - 4.0 ), 0.0, 3.0 ) );", "}",

	// moving costly divides into consts
	"const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );", "const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );", "float getAmbientOcclusion( const in vec3 centerViewPosition ) {",

	// precompute some variables require in getOcclusion.
	"vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );", "vec2 invSize = 1.0 / size;", "vec2 occlusionSphereScreenRadius = occlusionSphereWorldRadius * worldToScreenRatio / centerViewPosition.z;",

	// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
	"float random = rand( vUv + randomSeed );", "float angle = random * PI2;", "float radiusStep = INV_NUM_SAMPLES;", "float radius = radiusStep * ( 0.5 + random );", "float occlusionSum = 0.0;", "for( int i = 0; i < NUM_SAMPLES; i ++ ) {", "radius = (float(i) + 0.5) * radiusStep;", "vec2 sampleUvOffset = vec2( cos( angle ), sin( angle ) ) * radius * occlusionSphereScreenRadius * 1.0;",

	// round to nearest true sample to avoid misalignments between viewZ and normals, etc.
	"sampleUvOffset = floor( sampleUvOffset * size + vec2( 0.5 ) ) * invSize;", "if( sampleUvOffset.x == 0.0 && sampleUvOffset.y == 0.0 ) continue;", "angle += ANGLE_STEP;", "vec2 sampleUv = vUv + sampleUvOffset;", "if( sampleUv.x <= 0.0 || sampleUv.y <= 0.0 || sampleUv.x >= 1.0 || sampleUv.y >= 1.0 ) continue;", // skip points outside of texture.

	//"int depthMipLevel = getMipLevel( radius * occlusionSphereScreenRadius );",
	"float sampleDepth = getDepthMIP( sampleUv, int( 4.0 * radius ) );", "if( sampleDepth >= ( 1.0 - EPSILON ) ) {", "continue;", "}", "float sampleViewZ = getViewZ( sampleDepth );", "vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );", "occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );", "}", "return occlusionSum * intensity * 2.0 * occlusionSphereWorldRadius / ( float( NUM_SAMPLES ) );",
	//"return occlusionSum * intensity * 5.0 / ( float( NUM_SAMPLES ) * pow( occlusionSphereWorldRadius, 6.0 ) );",

	"}", "void main() {", "float centerDepth = getDepth( vUv );", "if( centerDepth >= ( 1.0 - EPSILON ) ) {", "discard;", "}",

	/*	"float mipDepth = unpackRGBAToDepth( texture2D( tDepth3, vUv ) );",
 	"gl_FragColor.xyz = vec3( (centerDepth - mipDepth) * 50.0 + 0.5 );",
 	"gl_FragColor.a = 1.0;",
 	"return;",*/

	"float centerViewZ = getViewZ( centerDepth );", "vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );", "float ambientOcclusion = getAmbientOcclusion( viewPosition );",

	//"gl_FragColor = getDefaultColor( vUv );",

	"gl_FragColor = packDepthToRGBA( centerDepth );", "gl_FragColor.x = max( 1.0 - ambientOcclusion, 0.0 );", "}"].join("\n")

};

// source: http://g3d.cs.williams.edu/websvn/filedetails.php?repname=g3d&path=%2FG3D10%2Fdata-files%2Fshader%2FAmbientOcclusion%2FAmbientOcclusion_minify.pix
THREE.SAODepthMinifyShader = {

	blending: THREE.NoBlending,

	defines: {
		"DEPTH_PACKING": 1
		//	"JITTERED_SAMPLING": 1
	},

	uniforms: {

		"tDepth": { type: "t", value: null },
		"cameraNear": { type: "f", value: 1 },
		"cameraFar": { type: "f", value: 100 },
		"size": { type: "v2", value: new THREE.Vector2(256, 256) }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#include <common>", "#include <packing>", "varying vec2 vUv;", "uniform sampler2D tDepth;", "uniform vec2 size;", "uniform float cameraNear;", "uniform float cameraFar;", "void main() {",

	/*		g3d_FragColor.mask = texelFetch(
 			CSZ_buffer,
 			clamp(
 				ssP * 2 + ivec2(ssP.y & 1, ssP.x & 1),
 				ivec2(0),
 				textureSize(CSZ_buffer, previousMIPNumber) - ivec2(1)),
 			previousMIPNumber).mask;
 
 	 }*/

	"vec2 uv = vUv;",

	//	"uv += ( round( vec2( rand( vUv * size ), rand( vUv * size + vec2( 0.333, 2.0 ) ) ) ) - 0.5 ) / size;",
	"vec2 invSize = 0.5 / size;",

	// NOTE: no need for depth decoding if nearest interpolation is used.
	/*	"float viewZ = 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, -1.0 ) ) ), cameraNear, cameraFar );",
 	"viewZ += 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, 1.0 ) ) ), cameraNear, cameraFar );",
 	"viewZ += 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, 1.0 ) ) ), cameraNear, cameraFar );",
 	"viewZ += 1.0 / perspectiveDepthToViewZ( unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, -1.0 ) ) ), cameraNear, cameraFar );",
 	"viewZ *= 0.25;",
 	"gl_FragColor = packDepthToRGBA( viewZToPerspectiveDepth( 1.0 / viewZ, cameraNear, cameraFar ) );",*/
	"float depth = unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, -1.0 ) ) );", "depth += unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, 1.0 ) ) );", "depth += unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( -1.0, 1.0 ) ) );", "depth += unpackRGBAToDepth( texture2D( tDepth, vUv + invSize * vec2( 1.0, -1.0 ) ) );", "depth *= 0.25;", "gl_FragColor = packDepthToRGBA( depth );", "}"].join("\n")

};

THREE.SAOBilaterialFilterShader = {

	blending: THREE.NoBlending,

	defines: {
		"PERSPECTIVE_CAMERA": 1,
		"KERNEL_SAMPLE_RADIUS": 4
	},

	uniforms: {

		"tAODepth": { type: "t", value: null },
		"tAONormal": { type: "t", value: null },
		"size": { type: "v2", value: new THREE.Vector2(256, 256) },

		"kernelDirection": { type: "v2", value: new THREE.Vector2(1, 0) },

		"cameraNear": { type: "f", value: 1 },
		"cameraFar": { type: "f", value: 100 },
		"edgeSharpness": { type: "f", value: 3 },
		"packOutput": { type: "f", value: 1 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#include <common>", "varying vec2 vUv;", "uniform sampler2D tAODepth;", "uniform sampler2D tAONormal;", "uniform vec2 size;", "uniform float cameraNear;", "uniform float cameraFar;", "uniform float edgeSharpness;", "uniform int packOutput;", "uniform vec2 kernelDirection;", "#include <packing>", "float getViewZ( const in float depth ) {", "#if PERSPECTIVE_CAMERA == 1", "return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "#else", "return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "#endif", "}", "void addTapInfluence( const in vec2 tapUv, const in vec3 centerNormal, const in float centerViewZ, const in float kernelWeight, inout float aoSum, inout float weightSum ) {", "vec4 depthTexel = texture2D( tAODepth, tapUv );", "float ao = depthTexel.r;", "depthTexel.r = 1.0;", "float depth = unpackRGBAToDepth( depthTexel );", "if( depth >= ( 1.0 - EPSILON ) ) {", "return;", "}", "float tapViewZ = -getViewZ( depth );", "float depthWeight = max(0.0, 1.0 - (edgeSharpness * 20.0) * abs(tapViewZ - centerViewZ));", "vec3 normal = unpackRGBToNormal(texture2D(tAONormal, tapUv).rgb);", "float normalCloseness = dot(normal, centerNormal);", "float k_normal = 4.0;", "float normalError = (1.0 - pow4( normalCloseness )) * k_normal;", "float normalWeight = max((1.0 - edgeSharpness * normalError), 0.00);", "float tapWeight = kernelWeight * ( depthWeight + normalWeight );", "aoSum += ao * tapWeight;", "weightSum += tapWeight;", "}", "float normpdf(in float x, in float sigma) {", "return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;", "}", "void main() {", "vec4 depthTexel = texture2D( tAODepth, vUv );", "float ao = depthTexel.r;", "depthTexel.r = 1.0;", "float depth = unpackRGBAToDepth( depthTexel );", "if( depth >= ( 1.0 - EPSILON ) ) {", "discard;", "}", "float centerViewZ = -getViewZ( depth );", "float weightSum = normpdf(0.0, 5.0) + 0.1;", "float aoSum = ao * weightSum;", "vec2 uvIncrement = ( kernelDirection / size );", "vec2 rTapUv = vUv, lTapUv = vUv;", "vec3 normalCenter = unpackRGBToNormal(texture2D(tAONormal, vUv).rgb);", "for( int i = 1; i <= KERNEL_SAMPLE_RADIUS; i ++ ) {", "float kernelWeight = normpdf(float(i), 5.0) + 0.1;", "rTapUv += uvIncrement;", "addTapInfluence( rTapUv, normalCenter, centerViewZ, kernelWeight, aoSum, weightSum );", "lTapUv -= uvIncrement;", "addTapInfluence( lTapUv, normalCenter, centerViewZ, kernelWeight, aoSum, weightSum );", "}", "ao = aoSum / weightSum;", "if( packOutput == 1 ) {", "gl_FragColor = depthTexel;", "gl_FragColor.r = ao;", "}", "else {", "gl_FragColor = vec4( vec3( ao ), 1.0 );", "}", "}"].join("\n")

};

// File:examples/js/shaders/BlurShader.js

/**
 * @author bhouston / http://clara.io
 *
 * For a horizontal blur, use X_STEP 1, Y_STEP 0
 * For a vertical blur, use X_STEP 0, Y_STEP 1
 *
 */

THREE.BlurShader = {

	defines: {

		"KERNEL_RADIUS": 4

	},

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"size": { type: "v2", value: new THREE.Vector2(512, 512) },
		"sampleUvOffsets": { type: "v2v", value: [new THREE.Vector2(0, 0)] },
		"sampleWeights": { type: "1fv", value: [1.0] }

	},

	vertexShader: ["#include <common>", "varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 size;", "uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];", "uniform float sampleWeights[ KERNEL_RADIUS + 1 ];", "varying vec2 vUv;", "void main() {", "vec2 invSize = 1.0 / size;", "float weightSum = sampleWeights[0];", "vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;", "for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {", "float weight = sampleWeights[i];", "vec2 sampleUvOffset = sampleUvOffsets[i] * invSize;", "diffuseSum += ( texture2D( tDiffuse, vUv + sampleUvOffset ) + texture2D( tDiffuse, vUv - sampleUvOffset ) ) * weight;", "weightSum += 2.0 * weight;", "}", "gl_FragColor =diffuseSum / weightSum;", "}"].join("\n")

};

THREE.BlurShaderUtils = {

	createSampleWeights: function createSampleWeights(kernelRadius, stdDev) {

		var gaussian = function gaussian(x, stdDev) {
			return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);
		};

		var weights = [];

		for (var i = 0; i <= kernelRadius; i++) {
			weights.push(gaussian(i, stdDev));
		}

		return weights;
	},

	createSampleOffsets: function createSampleOffsets(kernelRadius, uvIncrement) {

		var offsets = [];

		for (var i = 0; i <= kernelRadius; i++) {
			offsets.push(uvIncrement.clone().multiplyScalar(i));
		}

		return offsets;
	},

	configure: function configure(material, kernelRadius, stdDev, uvIncrement) {

		kernelRadius = kernelRadius | 0;

		if (material.defines['KERNEL_RADIUS'] !== kernelRadius || material.stdDev != stdDev) {

			material.defines['KERNEL_RADIUS'] = kernelRadius;
			material.uniforms['sampleUvOffsets'].value = THREE.BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);
			material.uniforms['sampleWeights'].value = THREE.BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);

			material.uvIncrement = uvIncrement;
			material.stdDev = stdDev;

			material.needsUpdate = true;
		}
	}

};

// File:examples/js/shaders/LuminosityHighPassShader.js

/**
 * @author bhouston / http://clara.io/
 *
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

THREE.LuminosityHighPassShader = {

	shaderID: "luminosityHighPass",

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"luminosityThreshold": { type: "f", value: 1.0 },
		"smoothWidth": { type: "f", value: 1.0 },
		"defaultColor": { type: "c", value: new THREE.Color(0x000000) },
		"defaultOpacity": { type: "f", value: 0.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float v = dot( texel.xyz, luma );", "vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "gl_FragColor = mix( outputColor, texel, alpha );", "}"].join("\n")

};

// File:examples/js/postprocessing/EffectComposer.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io/
 */

THREE.EffectComposer = function (renderer, cameraAware, renderTarget) {

	this.renderer = renderer;
	this.cameraAware = cameraAware || false;

	if (renderTarget === undefined) {

		var parameters = {
			minFilter: THREE.LinearFilter,
			magFilter: THREE.LinearFilter,
			format: THREE.RGBAFormat,
			stencilBuffer: true
		};
		var size = renderer.getSize();
		renderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);
		renderTarget.texture.name = "EffectComposer.rt1";
		renderTarget.texture.generateMipmaps = false;
	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();
	this.renderTarget2.texture.name = "EffectComposer.rt2";
	this.renderTarget2.texture.generateMipmaps = false;

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	if (this.cameraAware) {
		this.writeBuffer2 = this.renderTarget1.clone();
		this.readBuffer2 = this.renderTarget2.clone();
	}

	this.tempBufferMap = {};

	this.passes = [];

	if (THREE.CopyShader === undefined) console.error("THREE.EffectComposer relies on THREE.CopyShader");

	this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
};

(0, _assign2.default)(THREE.EffectComposer.prototype, {

	swapBuffers: function swapBuffers() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;
	},

	swapDualBuffers: function swapDualBuffers() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

		tmp = this.readBuffer2;
		this.readBuffer2 = this.writeBuffer2;
		this.writeBuffer2 = tmp;
	},

	requestBuffer: function requestBuffer(key) {
		if (!this.tempBufferMap[key]) {
			var sharedRenderTarget = this.renderTarget1.clone();
			sharedRenderTarget.texture.name = "EffectComposer.buffer[" + key + "]";
			sharedRenderTarget.texture.generateMipmaps = false;
			this.tempBufferMap[key] = sharedRenderTarget;
		}
		return this.tempBufferMap[key];
	},

	addPass: function addPass(pass) {

		this.passes.push(pass);

		var size = this.renderer.getSize();
		pass.setSize(size.width, size.height);
	},

	insertPass: function insertPass(pass, index) {

		this.passes.splice(index, 0, pass);
	},

	render: function render(delta) {

		var maskActive = false;

		var pass,
		    i,
		    il = this.passes.length;

		for (i = 0; i < il; i++) {

			pass = this.passes[i];

			if (pass.enabled === false) continue;

			pass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);

			if (pass.needsSwap) {

				if (maskActive) {

					var context = this.renderer.context;

					context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);

					this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);

					context.stencilFunc(context.EQUAL, 1, 0xffffffff);
				}

				this.swapBuffers();
			}

			if (THREE.MaskPass !== undefined) {

				if (pass instanceof THREE.MaskPass) {

					maskActive = true;
				} else if (pass instanceof THREE.ClearMaskPass) {

					maskActive = false;
				}
			}
		}
	},

	vrRender: function vrRender(vrEffect, scene, camera, forceClear, delta) {

		var vrDisplay = vrEffect.getVRDisplay();

		if (vrDisplay && vrDisplay.isPresenting) {

			var autoUpdate = scene.autoUpdate;

			if (autoUpdate) {

				scene.updateMatrixWorld();
				scene.autoUpdate = false;
			}

			var size = this.renderer.getSize();
			var eyeParamsL = vrDisplay.getEyeParameters('left');
			var eyeParamsR = vrDisplay.getEyeParameters('right');

			var eyeTranslationL = new THREE.Vector3().fromArray(eyeParamsL.offset);
			var eyeTranslationR = new THREE.Vector3().fromArray(eyeParamsR.offset);

			var defaultLeftBounds = [0.0, 0.0, 0.5, 1.0];
			var defaultRightBounds = [0.5, 0.0, 0.5, 1.0];
			var frameData = null;

			if ('VRFrameData' in window) {

				frameData = new window.VRFrameData();
			}

			var maskActive = false;

			if (Array.isArray(scene)) {

				console.warn('THREE.VREffect.render() no longer supports arrays. Use object.layers instead.');
				scene = scene[0];
			}

			// When rendering we don't care what the recommended size is, only what the actual size
			// of the backbuffer is.

			var layers = vrDisplay.getLayers();
			var leftBounds;
			var rightBounds;

			if (layers.length) {

				var layer = layers[0];

				leftBounds = layer.leftBounds !== null && layer.leftBounds.length === 4 ? layer.leftBounds : defaultLeftBounds;
				rightBounds = layer.rightBounds !== null && layer.rightBounds.length === 4 ? layer.rightBounds : defaultRightBounds;
			} else {

				leftBounds = defaultLeftBounds;
				rightBounds = defaultRightBounds;
			}

			var renderRectL = {
				x: Math.round(size.width * leftBounds[0]),
				y: Math.round(size.height * leftBounds[1]),
				width: Math.round(size.width * leftBounds[2]),
				height: Math.round(size.height * leftBounds[3])
			};
			var renderRectR = {
				x: Math.round(size.width * rightBounds[0]),
				y: Math.round(size.height * rightBounds[1]),
				width: Math.round(size.width * rightBounds[2]),
				height: Math.round(size.height * rightBounds[3])
			};

			if (this.renderer.autoClear || forceClear) this.renderer.clear();

			if (camera.parent === null) camera.updateMatrixWorld();

			var cameraL = vrEffect.getCameraL();
			var cameraR = vrEffect.getCameraR();
			camera.matrixWorld.decompose(cameraL.position, cameraL.quaternion, cameraL.scale);
			camera.matrixWorld.decompose(cameraR.position, cameraR.quaternion, cameraR.scale);

			var scale = vrEffect.scale;
			cameraL.translateOnAxis(eyeTranslationL, scale);
			cameraR.translateOnAxis(eyeTranslationR, scale);

			if (vrDisplay.getFrameData) {

				vrDisplay.depthNear = camera.near;
				vrDisplay.depthFar = camera.far;

				vrDisplay.getFrameData(frameData);

				cameraL.projectionMatrix.elements = frameData.leftProjectionMatrix;
				cameraR.projectionMatrix.elements = frameData.rightProjectionMatrix;
				cameraL.updateMatrixWorld();
				cameraR.updateMatrixWorld();
			} else {

				cameraL.projectionMatrix = vrEffect.fovToProjection(eyeParamsL.fieldOfView, true, camera.near, camera.far);
				cameraR.projectionMatrix = vrEffect.fovToProjection(eyeParamsR.fieldOfView, true, camera.near, camera.far);
			}

			var pass,
			    i,
			    il = this.passes.length;

			for (i = 0; i < il; i++) {

				pass = this.passes[i];

				if (pass.enabled === false || pass.cameraAware === false) continue;

				this.renderer.setScissorTest(true);

				// render left eye
				this.renderer.setScissor(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
				this.renderer.setViewport(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);

				if (pass.camera && pass.camera.isPerspectiveCamera) pass.camera = cameraL;
				pass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);

				// // render right eye
				this.renderer.setScissor(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
				this.renderer.setViewport(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);

				if (pass.camera && pass.camera.isPerspectiveCamera) pass.camera = cameraR;
				pass.render(this.renderer, this.writeBuffer2, this.readBuffer2, delta, maskActive);

				if (pass.needsSwap) {

					if (maskActive) {

						var context = this.renderer.context;

						context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);

						this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);

						context.stencilFunc(context.EQUAL, 1, 0xffffffff);
					}

					this.swapDualBuffers();
				}

				if (THREE.MaskPass !== undefined) {

					if (pass instanceof THREE.MaskPass) {

						maskActive = true;
					} else if (pass instanceof THREE.ClearMaskPass) {

						maskActive = false;
					}
				}

				if (pass.camera && pass.camera.isPerspectiveCamera) pass.camera = camera;
			}

			this.renderer.setScissorTest(false);
			this.renderer.setViewport(0, 0, size.width, size.height);

			if (autoUpdate) {

				scene.autoUpdate = true;
			}

			if (vrEffect.autoSubmitFrame) {

				vrEffect.submitFrame();
			}
		}

		if (!this.renderer.getContextAttributes().preserveDrawingBuffer) this.render();
	},

	stereoRender: function stereoRender(stereoEffect, scene, camera, delta) {

		camera.updateMatrixWorld();
		stereoEffect.updateStereo(camera);

		var maskActive = false;

		var pass,
		    i,
		    il = this.passes.length;

		var size = this.renderer.getSize();

		for (i = 0; i < il; i++) {

			pass = this.passes[i];

			if (pass.enabled === false || pass.cameraAware === false) continue;

			this.renderer.setScissorTest(true);

			this.renderer.setScissor(0, 0, size.width / 2, size.height);
			this.renderer.setViewport(0, 0, size.width / 2, size.height);
			if (pass.camera instanceof THREE.PerspectiveCamera) pass.camera = stereoEffect.getCameraL(); // the camera of texturePass is orthographcial
			pass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);

			this.renderer.setScissor(size.width / 2, 0, size.width / 2, size.height);
			this.renderer.setViewport(size.width / 2, 0, size.width / 2, size.height);
			if (pass.camera instanceof THREE.PerspectiveCamera) pass.camera = stereoEffect.getCameraR();
			pass.render(this.renderer, this.writeBuffer2, this.readBuffer2, delta, maskActive);

			if (pass.needsSwap) {

				if (maskActive) {

					var context = this.renderer.context;

					context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);

					this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);

					context.stencilFunc(context.EQUAL, 1, 0xffffffff);
				}

				this.swapBuffers();
			}

			if (THREE.MaskPass !== undefined) {

				if (pass instanceof THREE.MaskPass) {

					maskActive = true;
				} else if (pass instanceof THREE.ClearMaskPass) {

					maskActive = false;
				}
			}
		}
	},

	reset: function reset(renderTarget) {

		if (renderTarget === undefined) {

			var size = this.renderer.getSize();

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize(size.width, size.height);
		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		if (this.cameraAware) {
			this.writeBuffer2 = this.writeBuffer.clone();
			this.readBuffer2 = this.readBuffer.clone();
		}
	},

	dispose: function dispose() {

		for (var key in this.tempBufferMap) {

			if (this.tempBufferMap.hasOwnProperty(key)) {

				this.tempBufferMap[key].dispose();
			}
		}

		for (var i = 0; i < this.passes.length; i++) {

			this.passes[i].dispose();
		}
	},

	setSize: function setSize(width, height) {

		this.renderTarget1.setSize(width, height);
		this.renderTarget2.setSize(width, height);

		if (this.cameraAware) {
			this.writeBuffer2.setSize(width, height);
			this.readBuffer2.setSize(width, height);
		}

		for (var key in this.tempBufferMap) {

			if (this.tempBufferMap.hasOwnProperty(key)) {

				this.tempBufferMap[key].setSize(width, height);
			}
		}

		for (var i = 0; i < this.passes.length; i++) {

			this.passes[i].setSize(width, height);
		}
	}

});

THREE.Pass = function () {

	// if set to true, the pass is processed by the composer
	this.enabled = true;

	// if set to true, the pass indicates to swap read and write buffer after rendering
	this.needsSwap = true;

	// if set to true, the pass clears its buffer before rendering
	this.clear = false;

	// if set to true, the result of the pass is rendered to screen
	this.renderToScreen = false;

	// if set to true, the result of the pass is rendered to both camera of the vr effect
	this.cameraAware = false;
};

(0, _assign2.default)(THREE.Pass.prototype, {

	setSize: function setSize(width, height) {},

	dispose: function dispose() {},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		console.error("THREE.Pass: .render() must be implemented in derived pass.");
	}

});

// File:examples/js/postprocessing/RenderPass.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io/
 */

THREE.RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {

	THREE.Pass.call(this);

	this.scene = scene;
	this.camera = camera;

	this.renderOver = false;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;

	this.clear = true;
	this.clearDepth = false;
	this.needsSwap = false;

	if (THREE.CopyShader === undefined) console.error("THREE.SSAARenderPass relies on THREE.CopyShader");

	this.overMaterial = new THREE.ShaderMaterial(THREE.CopyShader);
	this.overMaterial.uniforms = THREE.UniformsUtils.clone(this.overMaterial.uniforms);
	this.overMaterial.blending = THREE.NormalBlending;
	this.overMaterial.premultipliedAlpha = true;
	this.overMaterial.transparent = true;
	this.overMaterial.depthTest = false;
	this.overMaterial.depthWrite = false;

	this.camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene2 = new THREE.Scene();
	this.quad2 = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this.copyMaterial);
	this.quad2.frustumCulled = false; // Avoid getting clipped
	this.scene2.add(this.quad2);
};

THREE.RenderPass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.RenderPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.scene.overrideMaterial = this.overrideMaterial;

		var oldClearColor, oldClearAlpha;
		oldClearColor = renderer.getClearColor();
		oldClearAlpha = renderer.getClearAlpha();

		if (this.clearDepth) {

			renderer.clearDepth();
		}

		if (this.renderOver) {

			renderer.setClearColor(0x000000, 0);
			renderer.renderOverride(this.overrideMaterial, this.scene, this.camera, writeBuffer, true);

			this.overMaterial.uniforms['tDiffuse'].value = writeBuffer.texture;

			if (this.clearColor !== undefined) {

				renderer.setClearColor(this.clearColor, this.clearAlpha);
			}

			renderer.renderOverride(this.overMaterial, this.scene2, this.camera2, this.renderToScreen ? null : readBuffer, this.clear);
		} else {

			if (this.clearColor !== undefined) {

				renderer.setClearColor(this.clearColor, this.clearAlpha);
			}
			renderer.renderOverride(this.overrideMaterial, this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);
		}

		if (this.clearColor) {

			renderer.setClearColor(oldClearColor, oldClearAlpha);
		}

		this.scene.overrideMaterial = null;
		renderer.autoClear = oldAutoClear;
	}

});
// File:examples/js/postprocessing/MaskPass.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MaskPass = function (scene, camera) {

	THREE.Pass.call(this);

	this.scene = scene;
	this.camera = camera;

	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;
};

THREE.MaskPass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.MaskPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var context = renderer.context;
		var state = renderer.state;

		// don't update color or depth

		state.buffers.color.setMask(false);
		state.buffers.depth.setMask(false);

		// lock buffers

		state.buffers.color.setLocked(true);
		state.buffers.depth.setLocked(true);

		// set up stencil

		var writeValue, clearValue;

		if (this.inverse) {

			writeValue = 0;
			clearValue = 1;
		} else {

			writeValue = 1;
			clearValue = 0;
		}

		state.buffers.stencil.setTest(true);
		state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
		state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
		state.buffers.stencil.setClear(clearValue);

		// draw into the stencil buffer

		renderer.render(this.scene, this.camera, readBuffer, this.clear);
		renderer.render(this.scene, this.camera, writeBuffer, this.clear);

		// unlock color and depth buffer for subsequent rendering

		state.buffers.color.setLocked(false);
		state.buffers.depth.setLocked(false);

		// only render where stencil is set to 1

		state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
		state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
	}

});

THREE.ClearMaskPass = function () {

	THREE.Pass.call(this);

	this.needsSwap = false;
};

THREE.ClearMaskPass.prototype = (0, _create2.default)(THREE.Pass.prototype);

(0, _assign2.default)(THREE.ClearMaskPass.prototype, {

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		renderer.state.buffers.stencil.setTest(false);
	}

});

// File:examples/js/postprocessing/ShaderPass.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShaderPass = function (shader, textureID) {

	THREE.Pass.call(this);

	this.textureID = textureID !== undefined ? textureID : "tDiffuse";

	if (shader instanceof THREE.ShaderMaterial) {

		this.uniforms = shader.uniforms;

		this.material = shader;
	} else if (shader) {

		this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

		this.material = new THREE.ShaderMaterial({

			defines: shader.defines || {},
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		});
	}

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

THREE.ShaderPass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.ShaderPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		if (this.uniforms[this.textureID]) {

			this.uniforms[this.textureID].value = readBuffer.texture;
		}

		if (this.renderToScreen) {

			renderer.renderPass(this.material);
		} else {

			renderer.renderPass(this.material, writeBuffer, this.clear);
		}
	}

});

// File:examples/js/postprocessing/SAOPass.js

/**
*
* Scalable Ambient Occlusion
*
* @author bhouston / http://clara.io/
*
*
*/

THREE.SAOPass = function (scene, camera) {

	THREE.Pass.call(this);

	this.scene = scene;
	this.camera = camera;

	this.intensity = 0.5;
	this.implicitNormals = false; // explicit normals requires or there are artifacts on mobile.
	this.occlusionSphereWorldRadius = 20;
	this.blurEnabled = true;
	this.outputOverride = null; // 'beauty', 'depth', 'sao'
	this.depthMIPs = false;
	this.downSamplingRatio = 2;
	this.blurKernelSize = this.downSamplingRatio === 1 ? 8 : 6;
	this.edgeSharpness = 1;

	/*
 if ( false && renderer.extensions.get('WEBGL_depth_texture') ) {
 		console.log( "using depth extension");
 		this.depthTexture = optionalBuffers.depthTexture || new THREE.DepthTexture();
 	this.depthTexture.type = isWebGL2 ? THREE.FloatType : THREE.UnsignedShortType;
 	this.depthTexture.minFilter = THREE.NearestFilter;
 	this.depthTexture.maxFilter = THREE.NearestFilter;
 		this.beautyRenderTarget.depthBuffer = true;
 	this.beautyRenderTarget.depthTexture = this.depthTexture;
 	}*/

	this.depthMaterial = new THREE.MeshDepthMaterial();
	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	this.depthMaterial.blending = THREE.NoBlending;
	this.depthMaterial.side = THREE.DoubleSide;

	this.normalMaterial = new THREE.MeshNormalMaterial();
	this.normalMaterial.side = this.depthMaterial.side; // both normal and depth materials bot need to render with the same sidedness

	if (THREE.SAOShader === undefined) console.error("THREE.SAOPass relies on THREE.SAOShader");
	if (THREE.CopyShader === undefined) console.error("THREE.SAOPass relies on THREE.CopyShader");

	this.depthMinifyMaterial = new THREE.ShaderMaterial(THREE.SAODepthMinifyShader);
	this.depthMinifyMaterial.uniforms = THREE.UniformsUtils.clone(this.depthMinifyMaterial.uniforms);
	this.depthMinifyMaterial.defines = (0, _assign2.default)({}, this.depthMinifyMaterial.defines);
	this.depthMinifyMaterial.blending = THREE.NoBlending;

	this.saoMaterial = new THREE.ShaderMaterial(THREE.SAOShader);
	this.saoMaterial.uniforms = THREE.UniformsUtils.clone(this.saoMaterial.uniforms);
	this.saoMaterial.defines = (0, _assign2.default)({}, this.saoMaterial.defines);
	this.saoMaterial.defines['DIFFUSE_TEXTURE'] = 0;
	this.saoMaterial.defines['NORMAL_TEXTURE'] = this.implicitNormals ? 0 : 1;
	this.saoMaterial.defines['MODE'] = 2;

	this.bilateralFilterMaterial = new THREE.ShaderMaterial(THREE.SAOBilaterialFilterShader);
	this.bilateralFilterMaterial.uniforms = THREE.UniformsUtils.clone(this.bilateralFilterMaterial.uniforms);
	this.bilateralFilterMaterial.defines = (0, _assign2.default)({}, this.bilateralFilterMaterial.defines);
	this.bilateralFilterMaterial.blending = THREE.NoBlending;
	this.bilateralFilterMaterial.premultipliedAlpha = true;

	this.bilateralUpsamplerMaterial = this.getBilateralUpsamplerMaterial();

	this.copyMaterial = new THREE.ShaderMaterial(THREE.CopyShader);
	this.copyMaterial.uniforms = THREE.UniformsUtils.clone(this.copyMaterial.uniforms);
	this.copyMaterial.uniforms['opacity'].value = 1.0;
	this.copyMaterial.blending = THREE.NoBlending;
	this.copyMaterial.premultipliedAlpha = true;
	this.copyMaterial.transparent = true;
	this.copyMaterial.depthTest = false;
	this.copyMaterial.depthWrite = false;
};

THREE.SAOPass.prototype = {

	dispose: function dispose() {

		if (this.saoRenderTarget) {
			this.saoRenderTarget.dispose();
			this.saoRenderTarget = null;
		}
		if (this.blurIntermediateRenderTarget) {
			this.blurIntermediateRenderTarget.dispose();
			this.blurIntermediateRenderTarget = null;
		}
		if (this.depthRenderTarget) {
			this.depthRenderTarget.dispose();
			this.depthRenderTarget = null;
		}
		if (this.depth1RenderTarget) {
			this.depth1RenderTarget.dispose();
			this.depth1RenderTarget = null;
		}
		if (this.depth2RenderTarget) {
			this.depth2RenderTarget.dispose();
			this.depth2RenderTarget = null;
		}
		if (this.depth3RenderTarget) {
			this.depth3RenderTarget.dispose();
			this.depth3RenderTarget = null;
		}
		if (this.normalRenderTarget) {
			this.normalRenderTarget.dispose();
			this.normalRenderTarget = null;
		}
		if (this.normalRenderTargetFullRes) {
			this.normalRenderTargetFullRes.dispose();
			this.normalRenderTargetFullRes = null;
		}
		if (this.depthRenderTargetFullRes) {
			this.depthRenderTargetFullRes.dispose();
			this.depthRenderTargetFullRes = null;
		}
		if (this.saoRenderTargetFullRes) {
			this.saoRenderTargetFullRes.dispose();
			this.saoRenderTargetFullRes = null;
		}
	},

	setSize: function setSize(width, height) {

		if (this.saoRenderTargetFullRes) this.saoRenderTargetFullRes.setSize(width, height);
		if (this.depthRenderTargetFullRes) this.depthRenderTargetFullRes.setSize(width, height);
		if (this.normalRenderTargetFullRes) this.normalRenderTargetFullRes.setSize(width, height);
		width = Math.ceil(width / this.downSamplingRatio);
		height = Math.ceil(height / this.downSamplingRatio);
		if (this.saoRenderTarget) this.saoRenderTarget.setSize(width, height);
		if (this.blurIntermediateRenderTarget) this.blurIntermediateRenderTarget.setSize(width, height);
		if (this.depthRenderTarget) this.depthRenderTarget.setSize(width, height);
		if (this.depth1RenderTarget) this.depth1RenderTarget.setSize(Math.ceil(width / 2), Math.ceil(height / 2));
		if (this.depth2RenderTarget) this.depth2RenderTarget.setSize(Math.ceil(width / 4), Math.ceil(height / 4));
		if (this.depth3RenderTarget) this.depth3RenderTarget.setSize(Math.ceil(width / 8), Math.ceil(height / 8));
		if (this.normalRenderTarget) this.normalRenderTarget.setSize(width, height);

		this.saoMaterial.uniforms['size'].value.set(width, height);
		this.bilateralFilterMaterial.uniforms['size'].value.set(width, height);
		//console.log( 'downsampledsize: ', width, height );
	},

	updateParameters: function updateParameters(camera) {

		var vSizeAt1M = 1 / (Math.tan(THREE.Math.DEG2RAD * camera.fov * 0.5) * 2);
		var sizeAt1M = new THREE.Vector2(vSizeAt1M / camera.aspect, vSizeAt1M);

		this.saoMaterial.uniforms['worldToScreenRatio'].value = sizeAt1M;
		this.saoMaterial.uniforms['intensity'].value = this.intensity;
		this.saoMaterial.uniforms['occlusionSphereWorldRadius'].value = this.occlusionSphereWorldRadius;

		this.depthMinifyMaterial.uniforms['cameraNear'].value = camera.near;
		this.depthMinifyMaterial.uniforms['cameraFar'].value = camera.far;

		this.saoMaterial.uniforms['cameraNear'].value = camera.near;
		this.saoMaterial.uniforms['cameraFar'].value = camera.far;
		this.saoMaterial.uniforms['cameraProjectionMatrix'].value = camera.projectionMatrix;
		this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.getInverse(camera.projectionMatrix);

		this.bilateralFilterMaterial.uniforms["cameraNear"].value = camera.near;
		this.bilateralFilterMaterial.uniforms["cameraFar"].value = camera.far;
	},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var width = readBuffer.width,
		    height = readBuffer.height;

		width = Math.ceil(width / this.downSamplingRatio);
		height = Math.ceil(height / this.downSamplingRatio);

		var depthTexture = readBuffer.depthBuffer && readBuffer.depthTexture ? readBuffer.depthTexture : null;

		if (!this.saoRenderTarget) {

			this.saoRenderTarget = new THREE.WebGLRenderTarget(width, height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
			this.saoRenderTargetFullRes = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
			this.blurIntermediateRenderTarget = new THREE.WebGLRenderTarget(width, height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
			this.depth1RenderTarget = new THREE.WebGLRenderTarget(Math.ceil(width / 2), Math.ceil(height / 2), { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
			this.depth2RenderTarget = new THREE.WebGLRenderTarget(Math.ceil(width / 4), Math.ceil(height / 4), { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
			this.depth3RenderTarget = new THREE.WebGLRenderTarget(Math.ceil(width / 8), Math.ceil(height / 8), { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
			this.normalRenderTarget = new THREE.WebGLRenderTarget(width, height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
			this.normalRenderTargetFullRes = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
		}

		if (!depthTexture && !this.depthRenderTarget) {

			this.depthRenderTarget = new THREE.WebGLRenderTarget(width, height, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat });
			this.depthRenderTargetFullRes = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat });
		}

		this.updateParameters(this.camera);

		var clearColor = renderer.getClearColor(),
		    clearAlpha = renderer.getClearAlpha(),
		    autoClear = renderer.autoClear;
		renderer.autoClear = false;

		if (!this.renderToScreen) {

			this.copyMaterial.uniforms['tDiffuse'].value = readBuffer.texture;
			this.copyMaterial.blending = THREE.NoBlending;

			renderer.renderPass(this.copyMaterial, writeBuffer, true);
		}

		var depthPackingMode = 0;

		if (!depthTexture) {

			var oldClearColor = renderer.getClearColor(),
			    oldClearAlpha = renderer.getClearAlpha();
			renderer.setClearColor(0xffffff, 1.0);

			renderer.renderOverride(this.depthMaterial, this.scene, this.camera, this.depthRenderTarget, true, false, true);

			renderer.setClearColor(0xffffff, 1.0);

			if (this.downSamplingRatio !== 1.0) {

				renderer.renderOverride(this.depthMaterial, this.scene, this.camera, this.depthRenderTargetFullRes, true, false, true);

				renderer.setClearColor(oldClearColor, oldClearAlpha);
			}
			depthTexture = this.depthRenderTarget.texture;
			depthPackingMode = 1;
		}

		if (this.depthMIPs) {

			this.depthMinifyMaterial.uniforms['tDepth'].value = depthTexture;
			this.depthMinifyMaterial.uniforms['size'].value.set(width, height);
			renderer.renderPass(this.depthMinifyMaterial, this.depth1RenderTarget, true);

			this.depthMinifyMaterial.uniforms['tDepth'].value = this.depth1RenderTarget.texture;
			this.depthMinifyMaterial.uniforms['size'].value.set(Math.ceil(width / 2), Math.ceil(height / 2));
			renderer.renderPass(this.depthMinifyMaterial, this.depth2RenderTarget, true);

			this.depthMinifyMaterial.uniforms['tDepth'].value = this.depth2RenderTarget.texture;
			this.depthMinifyMaterial.uniforms['size'].value.set(Math.ceil(width / 4), Math.ceil(height / 4));
			renderer.renderPass(this.depthMinifyMaterial, this.depth3RenderTarget, true);
		}

		if (this.outputOverride === "depth") {

			this.copyMaterial.uniforms['tDiffuse'].value = depthTexture;
			this.copyMaterial.blending = THREE.NoBlending;

			renderer.renderPass(this.copyMaterial, this.renderToScreen ? null : writeBuffer, true);
			return;
		}
		if (this.outputOverride === "depth1") {

			this.copyMaterial.uniforms['tDiffuse'].value = this.depth1RenderTarget.texture;
			this.copyMaterial.blending = THREE.NoBlending;

			renderer.renderPass(this.copyMaterial, this.renderToScreen ? null : writeBuffer, true);
			return;
		}
		if (this.outputOverride === "depth2") {

			this.copyMaterial.uniforms['tDiffuse'].value = this.depth2RenderTarget.texture;
			this.copyMaterial.blending = THREE.NoBlending;

			renderer.renderPass(this.copyMaterial, this.renderToScreen ? null : writeBuffer, true);
			return;
		}
		if (this.outputOverride === "depth3") {

			this.copyMaterial.uniforms['tDiffuse'].value = this.depth3RenderTarget.texture;
			this.copyMaterial.blending = THREE.NoBlending;

			renderer.renderPass(this.copyMaterial, this.renderToScreen ? null : writeBuffer, true);
			return;
		}

		if (!this.implicitNormals) {

			var oldClearColor = renderer.getClearColor(),
			    oldClearAlpha = renderer.getClearAlpha();
			renderer.setClearColor(new THREE.Color(0.5, 0.5, 1.0), 1.0);

			renderer.renderOverride(this.normalMaterial, this.scene, this.camera, this.normalRenderTarget, true, false, true);

			if (this.downSamplingRatio !== 1.0) {

				renderer.setClearColor(new THREE.Color(0.5, 0.5, 1.0), 1.0);

				renderer.renderOverride(this.normalMaterial, this.scene, this.camera, this.normalRenderTargetFullRes, true, false, true);
			}

			renderer.setClearColor(oldClearColor, oldClearAlpha);
		}

		if (this.outputOverride === "normal") {

			this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;
			this.copyMaterial.blending = THREE.NoBlending;

			renderer.renderPass(this.copyMaterial, this.renderToScreen ? null : this.renderToScreen ? null : writeBuffer, true);
			return;
		}

		this.saoMaterial.defines['DEPTH_PACKING'] = depthPackingMode;
		this.saoMaterial.defines['DEPTH_MIPS'] = this.depthMIPs ? 1 : 0;
		this.saoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
		this.saoMaterial.uniforms["tDepth"].value = depthTexture;
		if (this.depthMIPs) {

			this.saoMaterial.uniforms["tDepth1"].value = this.depth1RenderTarget.texture;
			this.saoMaterial.uniforms["tDepth2"].value = this.depth2RenderTarget.texture;
			this.saoMaterial.uniforms["tDepth3"].value = this.depth3RenderTarget.texture;
		}

		var oldClearColor = renderer.getClearColor(),
		    oldClearAlpha = renderer.getClearAlpha();
		renderer.setClearColor(0xffffff, 1.0);

		renderer.renderPass(this.saoMaterial, this.saoRenderTarget, true); // , 0xffffff, 0.0, "sao"

		if (this.blurEnabled) {

			this.bilateralFilterMaterial.defines['KERNEL_SAMPLE_RADIUS'] = this.blurKernelSize;
			this.bilateralFilterMaterial.uniforms["tAODepth"].value = this.saoRenderTarget.texture;
			this.bilateralFilterMaterial.uniforms["tAONormal"].value = this.normalRenderTarget.texture;
			this.bilateralFilterMaterial.uniforms["kernelDirection"].value = new THREE.Vector2(1, 0);
			this.bilateralFilterMaterial.uniforms["packOutput"].value = 1;
			this.bilateralFilterMaterial.uniforms['edgeSharpness'].value = this.edgeSharpness;

			renderer.renderPass(this.bilateralFilterMaterial, this.blurIntermediateRenderTarget, true); // , 0xffffff, 0.0, "sao vBlur"

			this.bilateralFilterMaterial.uniforms["tAODepth"].value = this.blurIntermediateRenderTarget.texture;
			this.bilateralFilterMaterial.uniforms["kernelDirection"].value = new THREE.Vector2(0, 1);
			this.bilateralFilterMaterial.uniforms["packOutput"].value = 0;

			renderer.renderPass(this.bilateralFilterMaterial, this.saoRenderTarget, true); // 0xffffff, 0.0, "sao hBlur"
		}
		if (this.downSamplingRatio > 1.0) {
			//Bilateral Up sampler
			this.bilateralUpsamplerMaterial.uniforms["inputTexture"].value = this.saoRenderTarget.texture;
			this.bilateralUpsamplerMaterial.uniforms["NormalTextureFullRes"].value = this.normalRenderTargetFullRes.texture;
			this.bilateralUpsamplerMaterial.uniforms["DepthTextureFullRes"].value = this.depthRenderTargetFullRes.texture;
			this.bilateralUpsamplerMaterial.uniforms["NormalTextureHalfRes"].value = this.normalRenderTarget.texture;
			this.bilateralUpsamplerMaterial.uniforms["DepthTextureHalfRes"].value = this.depthRenderTarget.texture;
			this.bilateralUpsamplerMaterial.uniforms["texSize"].value = new THREE.Vector2(this.saoRenderTarget.width, this.saoRenderTarget.height);
			this.bilateralUpsamplerMaterial.uniforms["cameraNearFar"].value = new THREE.Vector2(this.camera.near, this.camera.far);
			renderer.renderPass(this.bilateralUpsamplerMaterial, this.saoRenderTargetFullRes, true); // 0xffffff, 0.0, "sao hBlur"
		}
		renderer.setClearColor(oldClearColor, oldClearAlpha);

		if (this.outputOverride === "sao") {

			this.copyMaterial.uniforms['tDiffuse'].value = this.downSamplingRatio > 1.0 ? this.saoRenderTargetFullRes.texture : this.saoRenderTarget.texture;
			this.copyMaterial.blending = THREE.NoBlending;

			renderer.renderPass(this.copyMaterial, this.renderToScreen ? null : writeBuffer, true);
			return;
		}

		renderer.autoClear = false;

		this.copyMaterial.uniforms['tDiffuse'].value = this.downSamplingRatio > 1.0 ? this.saoRenderTargetFullRes.texture : this.saoRenderTarget.texture;
		this.copyMaterial.blending = THREE.MultiplyBlending;
		this.copyMaterial.premultipliedAlpha = true;

		renderer.renderPass(this.copyMaterial, this.renderToScreen ? null : writeBuffer, false);

		renderer.autoClear = autoClear;
		renderer.setClearColor(clearColor);
		renderer.setClearAlpha(clearAlpha);
	},

	getBilateralUpsamplerMaterial: function getBilateralUpsamplerMaterial(kernelRadius) {

		return new THREE.ShaderMaterial({

			uniforms: {
				"inputTexture": { value: null },
				"NormalTextureFullRes": { value: null },
				"DepthTextureFullRes": { value: null },
				"NormalTextureHalfRes": { value: null },
				"DepthTextureHalfRes": { value: null },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) },
				"cameraNearFar": { value: new THREE.Vector2(0.5, 0.5) }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\n\
				#include <packing>\n\
				varying vec2 vUv;\n\
				uniform sampler2D inputTexture;\n\
				uniform sampler2D NormalTextureFullRes;\n\
				uniform sampler2D DepthTextureFullRes;\n\
				uniform sampler2D NormalTextureHalfRes;\n\
				uniform sampler2D DepthTextureHalfRes;\n\
				uniform vec2 texSize;\
				uniform vec2 cameraNearFar;\
				\
				void main()\
				{\
					vec2 uvOffsets[4];\
					uvOffsets[0] = vUv + vec2(0.0, 1.0)/texSize;\
					uvOffsets[1] = vUv + vec2(1.0, 0.0)/texSize;\
					uvOffsets[2] = vUv + vec2(-1.0, 0.0)/texSize;\
					uvOffsets[3] = vUv + vec2(0.0, -1.0)/texSize;\
					\
					float depth_weights[4];\
					float depth_hires = unpackRGBAToDepth(texture2D(DepthTextureFullRes, vUv));\
					depth_hires = -perspectiveDepthToViewZ(depth_hires, cameraNearFar.x, cameraNearFar.y);\
					if(depth_hires == 1.0)\
						discard;\
					float depth_coarse1 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[0]));\
					depth_coarse1 = -perspectiveDepthToViewZ(depth_coarse1, cameraNearFar.x, cameraNearFar.y);\
					depth_weights[0] = 1.0 / (0.001 + abs(depth_hires-depth_coarse1));\
					float depth_coarse2 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[1]));\
					depth_coarse2 = -perspectiveDepthToViewZ(depth_coarse2, cameraNearFar.x, cameraNearFar.y);\
					depth_weights[1] = 1.0 / (0.001 + abs(depth_hires-depth_coarse2));\
					float depth_coarse3 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[2]));\
					depth_coarse3 = -perspectiveDepthToViewZ(depth_coarse3, cameraNearFar.x, cameraNearFar.y);\
					depth_weights[2] = 1.0 / (0.001 + abs(depth_hires-depth_coarse3));\
					float depth_coarse4 = unpackRGBAToDepth(texture2D(DepthTextureHalfRes, uvOffsets[3]));\
					depth_coarse4 = -perspectiveDepthToViewZ(depth_coarse4, cameraNearFar.x, cameraNearFar.y);\
					depth_weights[3] = 1.0 / (0.001 + abs(depth_hires-depth_coarse4));\
					\
					float norm_weights[4];\
					vec3 norm_fullRes = unpackRGBToNormal(texture2D(NormalTextureFullRes, vUv).rgb);\
					vec3 norm_coarse1 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[0]).rgb);\
					norm_weights[0] = pow(abs(dot(norm_coarse1, norm_fullRes)), 32.0);\
					vec3 norm_coarse2 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[1]).rgb);\
					norm_weights[1] = pow(abs(dot(norm_coarse2, norm_fullRes)), 32.0);\
					vec3 norm_coarse3 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[2]).rgb);\
					norm_weights[2] = pow(abs(dot(norm_coarse3, norm_fullRes)), 32.0);\
					vec3 norm_coarse4 = unpackRGBToNormal(texture2D(NormalTextureHalfRes, uvOffsets[3]).rgb);\
					norm_weights[3] = pow(abs(dot(norm_coarse4, norm_fullRes)), 32.0);\
					\
					vec3 colorOut = vec3(0.0);\
					float weight_sum = 0.0;\
					float weight = norm_weights[0] * depth_weights[0];\
					colorOut += texture2D(inputTexture, uvOffsets[0]).rgb*weight;\
					weight_sum += weight;\
				  weight = norm_weights[1] * depth_weights[1];\
					colorOut += texture2D(inputTexture, uvOffsets[1]).rgb*weight;\
					weight_sum += weight;\
				  weight = norm_weights[2] * depth_weights[2];\
					colorOut += texture2D(inputTexture, uvOffsets[2]).rgb*weight;\
					weight_sum += weight;\
				  weight = norm_weights[3] * depth_weights[3];\
					colorOut += texture2D(inputTexture, uvOffsets[3]).rgb*weight;\
					weight_sum += weight;\
					colorOut /= weight_sum;\
					gl_FragColor = vec4(colorOut, 1.0);\
				}"
		});
	}

};

// File:examples/js/postprocessing/SSAARenderPass.js

/**
*
* Supersample Anti-Aliasing Render Pass
*
* @author bhouston / http://clara.io/
*
* This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.
*
* References: https://en.wikipedia.org/wiki/Supersampling
*
*/

THREE.SSAARenderPass = function (scene, camera, clearColor, clearAlpha) {

	THREE.Pass.call(this);

	this.scene = scene;
	this.camera = camera;

	this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.
	this.unbiased = true;

	this.needsSwap = false;

	// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.
	this.clearColor = clearColor !== undefined ? clearColor : 0x000000;
	this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;

	if (THREE.CopyShader === undefined) console.error("THREE.SSAARenderPass relies on THREE.CopyShader");

	this.overMaterial = new THREE.ShaderMaterial(THREE.CopyShader);
	this.overMaterial.uniforms = THREE.UniformsUtils.clone(this.overMaterial.uniforms);
	this.overMaterial.blending = THREE.NormalBlending;
	this.overMaterial.premultipliedAlpha = true;
	this.overMaterial.transparent = true;
	this.overMaterial.depthTest = false;
	this.overMaterial.depthWrite = false;

	this.addMaterial = new THREE.ShaderMaterial(THREE.CopyShader);
	this.addMaterial.uniforms = THREE.UniformsUtils.clone(this.addMaterial.uniforms);
	this.addMaterial.blending = THREE.AdditiveBlending;
	this.addMaterial.premultipliedAlpha = true;
	this.addMaterial.transparent = true;
	this.addMaterial.depthTest = false;
	this.addMaterial.depthWrite = false;

	this.camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene2 = new THREE.Scene();
	this.quad2 = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this.copyMaterial);
	this.quad2.frustumCulled = false; // Avoid getting clipped
	this.scene2.add(this.quad2);
};

THREE.SSAARenderPass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.SSAARenderPass,

	dispose: function dispose() {

		if (this.sampleRenderTarget) {
			this.sampleRenderTarget.dispose();
			this.sampleRenderTarget = null;
		}
	},

	setSize: function setSize(width, height) {

		if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);
	},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		if (!this.sampleRenderTarget) {

			this.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat, type: THREE.UnsignedByteType, name: "SSAARenderPass.sample" });
		}

		var jitterOffsets = THREE.SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];

		var autoClear = renderer.autoClear;
		renderer.autoClear = false;

		var oldClearColor = renderer.getClearColor().getHex();
		var oldClearAlpha = renderer.getClearAlpha();

		var baseSampleWeight = 1.0 / jitterOffsets.length;
		var roundingRange = 1 / 32;

		this.addMaterial.uniforms["tDiffuse"].value = this.sampleRenderTarget.texture;

		var width = readBuffer.width,
		    height = readBuffer.height;

		renderer.setClearColor(0x000000, 0);

		var oldDitherScale = renderer.ditherScale;
		if (this.unbiased) {
			renderer.ditherScale = jitterOffsets.length;
		}

		// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
		for (var i = 0; i < jitterOffsets.length; i++) {

			var jitterOffset = jitterOffsets[i];
			if (this.camera.setViewOffset) {
				this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16
				width, height);
			}

			var sampleWeight = baseSampleWeight;
			if (this.unbiased) {
				// the theory is that equal weights for each sample lead to an accumulation of rounding errors.
				// The following equation varies the sampleWeight per sample so that it is uniformly distributed
				// across a range of values whose rounding errors cancel each other out.
				var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;
				sampleWeight += roundingRange * uniformCenteredDistribution;
			}

			this.addMaterial.uniforms["opacity"].value = sampleWeight;
			renderer.render(this.scene, this.camera, this.sampleRenderTarget, true);

			renderer.renderPass(this.addMaterial, writeBuffer, i === 0);
		}

		if (this.camera.clearViewOffset) this.camera.clearViewOffset();

		renderer.ditherScale = oldDitherScale;

		this.overMaterial.uniforms["tDiffuse"].value = writeBuffer.texture;

		renderer.setClearColor(this.clearColor, this.clearAlpha);
		renderer.renderPass(this.overMaterial, this.renderToScreen ? null : readBuffer, this.clear);

		renderer.autoClear = autoClear;
		renderer.setClearColor(oldClearColor, oldClearAlpha);
	}

});

// These jitter vectors are specified in integers because it is easier.
// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)
// before being used, thus these integers need to be scaled by 1/16.
//
// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
THREE.SSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];
// File:examples/js/postprocessing/ClearPass.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ClearPass = function (clearColor, clearAlpha) {

	THREE.Pass.call(this);

	this.needsSwap = false;

	this.clearColor = clearColor !== undefined ? clearColor : 0x000000;
	this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
};

THREE.ClearPass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.ClearPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var oldClearColor, oldClearAlpha;

		if (this.clearColor !== undefined) {

			oldClearColor = renderer.getClearColor().getHex();
			oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor(this.clearColor, this.clearAlpha);
		}

		renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
		renderer.clear();

		if (this.clearColor) {

			renderer.setClearColor(oldClearColor, oldClearAlpha);
		}
	}

});

// File:examples/js/postprocessing/TexturePass.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.TexturePass = function (map, opacity) {

	THREE.Pass.call(this);

	if (THREE.CopyShader === undefined) console.error("THREE.TexturePass relies on THREE.CopyShader");

	var shader = THREE.CopyShader;

	this.map = map;
	this.opacity = opacity !== undefined ? opacity : 1.0;

	this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

	this.material = new THREE.ShaderMaterial({

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader,
		depthTest: false,
		depthWrite: false

	});

	this.needsSwap = false;

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

THREE.TexturePass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.TexturePass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.quad.material = this.material;

		this.uniforms["opacity"].value = this.opacity;
		this.uniforms["tDiffuse"].value = this.map;
		this.material.transparent = this.opacity < 1.0;

		if (this.map) {

			var rectSize = renderer.getSize();
			var width = this.map.image.width / rectSize.width || 1;
			var height = this.map.image.height / rectSize.height || 1;
			var min = Math.min(width, height);
			width = 1 / min * width;
			height = 1 / min * height;
			this.quad.scale.set(width, height, 1);
		}

		renderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);

		renderer.autoClear = oldAutoClear;
	}

});

// File:examples/js/postprocessing/CubeTexturePass.js

/**
 * @author bhouston / http://clara.io/
 */

THREE.CubeTexturePass = function (camera, envMap, opacity) {

	THREE.Pass.call(this);

	this.camera = camera;

	this.needsSwap = false;

	this.cubeMaterial = new THREE.MeshCubeMaterial();

	this.cubeMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(10, 10, 10), this.cubeMaterial);

	this.envMap = envMap;
	this.envMapIntensity = 1.0;
	this.opacity = opacity !== undefined ? opacity : 1.0;
	this.roughness = 0.0;

	this.cubeScene = new THREE.Scene();
	this.cubeCamera = new THREE.PerspectiveCamera();
	this.cubeScene.add(this.cubeMesh);
};

THREE.CubeTexturePass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.CubeTexturePass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);
		this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);

		if (this.cubeMaterial.envMap != this.envMap) {
			this.cubeMaterial.envMap = this.envMap;
			this.cubeMaterial.needsUpdate = true;
		}
		this.cubeMaterial.envMapIntensity = this.envMapIntensity;
		this.cubeMaterial.roughness = this.roughness;
		this.cubeMaterial.opacity = this.opacity;
		this.cubeMaterial.transparent = this.opacity < 1.0;

		renderer.render(this.cubeScene, this.cubeCamera, this.renderToScreen ? null : readBuffer, this.clear);

		renderer.autoClear = oldAutoClear;
	}

});

// File:examples/js/postprocessing/DofPass.js

/**
 * @author spidersharma03 / http://eduperiment.com/
 */

THREE.DofPass = function (resolution, scene, camera) {

	THREE.Pass.call(this);

	var resolution = resolution !== undefined ? resolution : new THREE.Vector2(256, 256);
	// render targets
	this.downSampleRes = new THREE.Vector2(Math.round(resolution.x / 2), Math.round(resolution.y / 2));

	var pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.HalfFloatType, format: THREE.RGBAFormat };

	this.renderTargetColorDownSample = new THREE.WebGLRenderTarget(this.downSampleRes.x, this.downSampleRes.y, pars);
	this.renderTargetColorDownSample.texture.generateMipmaps = false;

	this.renderTargetCoCDownSample = new THREE.WebGLRenderTarget(this.downSampleRes.x, this.downSampleRes.y, pars);
	this.renderTargetCoCDownSample.texture.generateMipmaps = false;

	this.renderTargetBlurTemp = new THREE.WebGLRenderTarget(this.downSampleRes.x, this.downSampleRes.y, pars);
	this.renderTargetBlurTemp.texture.generateMipmaps = false;

	var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };

	this.renderTargetDofBlur = new THREE.WebGLRenderTarget(this.downSampleRes.x, this.downSampleRes.y, pars);
	this.renderTargetDofBlur.texture.generateMipmaps = false;
	this.renderTargetDofBlurTemp = new THREE.WebGLRenderTarget(this.downSampleRes.x, this.downSampleRes.y, pars);
	this.renderTargetDofBlurTemp.texture.generateMipmaps = false;

	this.renderTargetDofCombine = new THREE.WebGLRenderTarget(resolution.x, resolution.y, pars);
	this.renderTargetDofCombine.texture.generateMipmaps = false;

	this.needsSwap = false;
	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.renderCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.renderScene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.renderScene.add(this.quad);

	this.focalDistance = 10.0;
	this.cameraNear = 0.1;
	this.cameraFar = 100;
	this.NearFarBlurScale = new THREE.Vector2(0.1, 0.5);

	this.downSamplingMaterial = this.getColorDownSamplingMaterial();

	this.cocMaterial = this.getCoCMaterial();
	this.cocMaterial.uniforms["NearFarBlurScale"].value = this.NearFarBlurScale;
	this.cocMaterial.uniforms["cameraNearFar"].value = new THREE.Vector2(camera.near, camera.far);
	this.cocMaterial.uniforms["focalDistance"].value = this.focalDistance;

	this.dilateNearCocMaterial = this.getDilateNearCocMaterial();
	this.dilateNearCocMaterial.uniforms["NearFarBlurScale"].value = this.NearFarBlurScale;

	this.dofBlurType = 1;
	this.dofBlurMaterial = this.dofBlurType === 0 ? this.getDofBlurCircularMaterial() : this.getDofBlurSeperableMaterial();

	this.dofCombineMaterial = this.getDofCombineMaterial();
	this.dofCombineMaterial.uniforms["NearFarBlurScale"].value = this.NearFarBlurScale;
	this.dofCombineMaterial.uniforms["cameraNearFar"].value = new THREE.Vector2(camera.near, camera.far);
	this.dofCombineMaterial.uniforms["focalDistance"].value = this.focalDistance;

	if (THREE.CopyShader === undefined) console.error("THREE.DofPass relies on THREE.CopyShader");

	var copyShader = THREE.CopyShader;

	this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);
	this.materialCopy = new THREE.ShaderMaterial({

		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader
	});

	this.depthMaterial = new THREE.MeshDepthMaterial();
	this.depthMaterial.side = THREE.DoubleSide;
	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	this.depthMaterial.blending = THREE.NoBlending;
	this.depthRenderTarget = new THREE.WebGLRenderTarget(resolution.x, resolution.y, { minFilter: THREE.NearesFilter, magFilter: THREE.NearesFilter, format: THREE.RGBAFormat });
	this.scene = scene;
	this.camera = camera;
};

THREE.DofPass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.DofPass,

	setSize: function setSize(width, height) {
		this.downSampleRes = new THREE.Vector2(Math.round(width / 2), Math.round(height / 2));

		var resx = this.downSampleRes.x;
		var resy = this.downSampleRes.y;

		this.renderTargetColorDownSample.setSize(resx, resy);
		this.renderTargetCoCDownSample.setSize(resx, resy);
		this.renderTargetBlurTemp.setSize(resx, resy);
		this.renderTargetDofBlur.setSize(resx, resy);
		this.renderTargetDofBlurTemp.setSize(resx, resy);
		this.renderTargetDofCombine.setSize(width, height);
		this.depthRenderTarget.setSize(width, height);
	},

	changeBlurType: function changeBlurType(blurType) {
		this.dofBlurType = blurType;
		this.dofBlurMaterial = this.dofBlurType === 0 ? this.getDofBlurCircularMaterial() : this.getDofBlurSeperableMaterial();
	},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		this.dilateNearCocMaterial.uniforms["texSize"].value = this.downSampleRes;
		this.dofBlurMaterial.uniforms["texSize"].value = this.downSampleRes;
		this.dofCombineMaterial.uniforms["texSize"].value = this.downSampleRes;

		this.cocMaterial.uniforms["focalDistance"].value = this.focalDistance;
		this.cocMaterial.uniforms["cameraNearFar"].value.x = this.cameraNear;
		this.cocMaterial.uniforms["cameraNearFar"].value.y = this.cameraFar;

		this.dofCombineMaterial.uniforms["focalDistance"].value = this.focalDistance;
		this.dofCombineMaterial.uniforms["cameraNearFar"].value.x = this.cameraNear;
		this.dofCombineMaterial.uniforms["cameraNearFar"].value.y = this.cameraFar;

		this.oldClearColor.copy(renderer.getClearColor());
		this.oldClearAlpha = renderer.getClearAlpha();
		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = true;

		if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);

		// Render Scene into depth buffer. This is temporary and should not be done here.
		this.scene.overrideMaterial = this.depthMaterial;
		renderer.setClearColor(0xffffff, 1);
		renderer.render(this.scene, this.camera, this.depthRenderTarget);
		this.scene.overrideMaterial = null;

		// 1. Downsample the Original texture, and store coc in the alpha channel
		this.quad.material = this.downSamplingMaterial;
		this.downSamplingMaterial.uniforms["colorTexture"].value = readBuffer.texture;
		renderer.render(this.renderScene, this.renderCamera, this.renderTargetColorDownSample);

		this.quad.material = this.cocMaterial;
		this.cocMaterial.uniforms["depthTexture"].value = this.depthRenderTarget.texture;
		renderer.render(this.renderScene, this.renderCamera, this.renderTargetCoCDownSample);

		// 2. Dilate/Blur Near field coc
		this.quad.material = this.dilateNearCocMaterial;
		this.dilateNearCocMaterial.uniforms["cocTexture"].value = this.renderTargetCoCDownSample.texture;
		this.dilateNearCocMaterial.uniforms["depthTexture"].value = this.depthRenderTarget.texture;
		this.dilateNearCocMaterial.uniforms["direction"].value = new THREE.Vector2(1, 0);
		renderer.render(this.renderScene, this.renderCamera, this.renderTargetBlurTemp);
		this.dilateNearCocMaterial.uniforms["cocTexture"].value = this.renderTargetBlurTemp.texture;
		this.dilateNearCocMaterial.uniforms["direction"].value = new THREE.Vector2(0, 1);
		renderer.render(this.renderScene, this.renderCamera, this.renderTargetCoCDownSample);

		// 3. Blur Dof
		if (this.dofBlurType === 0) {
			this.quad.material = this.dofBlurMaterial;
			this.dofBlurMaterial.uniforms["cocTexture"].value = this.renderTargetCoCDownSample.texture;
			this.dofBlurMaterial.uniforms["colorTexture"].value = this.renderTargetDownSample.texture;
			this.dofBlurMaterial.uniforms["depthTexture"].value = this.depthRenderTarget.texture;
			renderer.render(this.renderScene, this.renderCamera, this.renderTargetDofBlurTemp);
		} else {
			this.quad.material = this.dofBlurMaterial;
			this.dofBlurMaterial.uniforms["cocTexture"].value = this.renderTargetCoCDownSample.texture;
			this.dofBlurMaterial.uniforms["colorTexture"].value = this.renderTargetColorDownSample.texture;
			this.dofBlurMaterial.uniforms["direction"].value = new THREE.Vector2(1, 0);
			renderer.render(this.renderScene, this.renderCamera, this.renderTargetDofBlur);
			this.dofBlurMaterial.uniforms["colorTexture"].value = this.renderTargetDofBlur.texture;
			this.dofBlurMaterial.uniforms["direction"].value = new THREE.Vector2(0, 1);
			renderer.render(this.renderScene, this.renderCamera, this.renderTargetDofBlurTemp);
		}
		// 4. Dof Combine
		this.quad.material = this.dofCombineMaterial;
		this.dofCombineMaterial.uniforms["cocTexture"].value = this.renderTargetCoCDownSample.texture;
		this.dofCombineMaterial.uniforms["colorTexture"].value = readBuffer.texture;
		this.dofCombineMaterial.uniforms["depthTexture"].value = this.depthRenderTarget.texture;
		this.dofCombineMaterial.uniforms["blurTexture"].value = this.renderTargetDofBlurTemp.texture;
		renderer.render(this.renderScene, this.renderCamera, this.renderTargetDofCombine);

		// Copy Pass
		this.quad.material = this.materialCopy;
		this.copyUniforms["tDiffuse"].value = this.renderTargetDofCombine.texture;

		if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);
		renderer.render(this.renderScene, this.renderCamera, readBuffer);

		renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
		renderer.autoClear = oldAutoClear;
	},

	getColorDownSamplingMaterial: function getColorDownSamplingMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"colorTexture": { value: null }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\n\
				#include <packing>\n\
				varying vec2 vUv;\n\
				uniform sampler2D colorTexture;\n\
				\
				void main() {\n\
					gl_FragColor = texture2D(colorTexture, vUv);\n\
				}"
		});
	},

	getCoCMaterial: function getCoCMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"depthTexture": { value: null },
				"NearFarBlurScale": { value: new THREE.Vector2(0.5, 0.5) },
				"cameraNearFar": { value: new THREE.Vector2(0.1, 100) },
				"focalDistance": { value: 1.0 }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\n\
				#include <packing>\n\
				varying vec2 vUv;\n\
				uniform sampler2D depthTexture;\n\
				uniform vec2 NearFarBlurScale;\
				uniform vec2 cameraNearFar;\
				uniform float focalDistance;\
				const float MAXIMUM_BLUR_SIZE = 8.0;\
				\
				float computeCoc() {\
					vec4 packDepth = texture2D(depthTexture, vUv).rgba;\
					if(packDepth.x == 1.0) return max(NearFarBlurScale.x, NearFarBlurScale.y);\
						float depth = unpackRGBAToDepth(packDepth);\
						depth = -perspectiveDepthToViewZ(depth, cameraNearFar.x, cameraNearFar.y);\
						float coc = (depth - focalDistance)/depth;\
					return (coc > 0.0 ? coc * NearFarBlurScale.y : coc * NearFarBlurScale.x);\
				}\
				\
				void main() {\n\
					gl_FragColor = vec4(0.0, 0.0, 0.0, computeCoc());\n\
				}"
		});
	},

	getDilateNearCocMaterial: function getDilateNearCocMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"cocTexture": { value: null },
				"depthTexture": { value: null },
				"NearFarBlurScale": { value: new THREE.Vector2(0.5, 0.5) },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) },
				"direction": { value: new THREE.Vector2(1, 0) }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\n\
				varying vec2 vUv;\n\
				uniform sampler2D cocTexture;\n\
				uniform sampler2D depthTexture;\n\
				uniform vec2 direction;\
				uniform vec2 texSize;\
				uniform vec2 NearFarBlurScale;\
				const float MAXIMUM_BLUR_SIZE = 8.0;\
				\
				float expandNear(const in vec2 offset, const in bool isBackground) {\
					float coc = 0.0;\
					vec2 sampleOffsets = MAXIMUM_BLUR_SIZE * offset / 5.0;\
					float coc0 = texture2D(cocTexture, vUv).a;\
					float coc1 = texture2D(cocTexture, vUv - 5.0 * sampleOffsets).a;\
					float coc2 = texture2D(cocTexture, vUv - 4.0 * sampleOffsets).a;\
					float coc3 = texture2D(cocTexture, vUv - 3.0 * sampleOffsets).a;\
					float coc4 = texture2D(cocTexture, vUv - 2.0 * sampleOffsets).a;\
					float coc5 = texture2D(cocTexture, vUv - 1.0 * sampleOffsets).a;\
					float coc6 = texture2D(cocTexture, vUv + 1.0 * sampleOffsets).a;\
					float coc7 = texture2D(cocTexture, vUv + 2.0 * sampleOffsets).a;\
					float coc8 = texture2D(cocTexture, vUv + 3.0 * sampleOffsets).a;\
					float coc9 = texture2D(cocTexture, vUv + 4.0 * sampleOffsets).a;\
					float coc10 = texture2D(cocTexture, vUv + 5.0 * sampleOffsets).a;\
						\
					if(isBackground){\
						coc = abs(coc0) * 0.095474 + \
						(abs(coc1) + abs(coc10)) * 0.084264 + \
						(abs(coc2) + abs(coc9)) * 0.088139 + \
						(abs(coc3) + abs(coc8)) * 0.091276 + \
						(abs(coc4) + abs(coc7)) * 0.093585 + \
						(abs(coc5) + abs(coc6)) * 0.094998;\
					} else {\
						coc = min(coc0, 0.0);\
						coc = min(coc1 * 0.3, coc);\
						coc = min(coc2 * 0.5, coc);\
						coc = min(coc3 * 0.75, coc);\
						coc = min(coc4 * 0.8, coc);\
						coc = min(coc5 * 0.95, coc);\
						coc = min(coc6 * 0.95, coc);\
						coc = min(coc7 * 0.8, coc);\
						coc = min(coc8 * 0.75, coc);\
						coc = min(coc9 * 0.5, coc);\
						coc = min(coc10 * 0.3, coc);\
						if(abs(coc0) > abs(coc))\
							coc = coc0;\
					}\
					return coc;\
				}\
				\
				void main() {\n\
					vec2 offset = direction/texSize;\
					float coc = expandNear(offset, texture2D(depthTexture, vUv).x == 1.0);\
					gl_FragColor = vec4(0.0, 0.0, 0.0, coc);\n\
				}"
		});
	},

	getDofBlurCircularMaterial: function getDofBlurCircularMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"colorTexture": { value: null },
				"cocTexture": { value: null },
				"depthTexture": { value: null },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\n\
				varying vec2 vUv;\n\
				uniform sampler2D colorTexture;\n\
				uniform sampler2D cocTexture;\n\
				uniform sampler2D depthTexture;\n\
				uniform vec2 texSize;\
				const float MAXIMUM_BLUR_SIZE = 8.0;\
				\
				vec4 CircularBlur() {\
					\
					const int NUM_SAMPLES = 16;\
					vec2 poisson_disk_samples[NUM_SAMPLES];\
					poisson_disk_samples[0] = vec2(-0.399691779231, 0.728591545584);\
					poisson_disk_samples[1] = vec2(-0.48622557676, -0.84016533712);\
					poisson_disk_samples[2] = vec2(0.770309468987, -0.24906070432);\
					poisson_disk_samples[3] = vec2(0.556596796154, 0.820359876432);\
					poisson_disk_samples[4] = vec2(-0.933902004071, 0.0600539051593);\
					poisson_disk_samples[5] = vec2(0.330144964342, 0.207477293384);\
					poisson_disk_samples[6] = vec2(0.289013230975, -0.686749271417);\
					poisson_disk_samples[7] = vec2(-0.0832470893559, -0.187351643125);\
					poisson_disk_samples[8] = vec2(-0.296314525615, 0.254474834305);\
					poisson_disk_samples[9] = vec2(-0.850977666059, 0.484642744689);\
					poisson_disk_samples[10] = vec2(0.829287915319, 0.2345063545);\
					poisson_disk_samples[11] = vec2(-0.773042143899, -0.543741521254);\
					poisson_disk_samples[12] = vec2(0.0561133030864, 0.928419742597);\
					poisson_disk_samples[13] = vec2(-0.205799249508, -0.562072714492);\
					poisson_disk_samples[14] = vec2(-0.526991665882, -0.193690188118);\
					poisson_disk_samples[15] = vec2(-0.051789270667, -0.935374050821);\
						\
					vec4 cocr = texture2D(cocTexture, vUv);\
						\
					float blurDist = MAXIMUM_BLUR_SIZE * coc.a;\
						\
					float rnd = PI2 * rand( vUv );\
					float costheta = cos(rnd);\
					float sintheta = sin(rnd);\
					vec4 rotationMatrix = vec4(costheta, -sintheta, sintheta, costheta);\
						\
					vec3 colorSum = vec3(0.0);\
					float weightSum = 0.0;\
						\
					for (int i = 0; i < NUM_SAMPLES; i++) {\
						vec2 ofs = poisson_disk_samples[i];\
						ofs = vec2(dot(ofs, rotationMatrix.xy), dot(ofs, rotationMatrix.zw) );\
						vec2 texcoord = vUv + blurDist * ofs / texSize.xy;\
						vec4 sample = texture2D(colorTexture, texcoord);\
						float cocWeight = abs(sample.a);\
						cocWeight *= cocWeight * cocWeight;\
						colorSum += sample.rgb * cocWeight;\
						weightSum += cocWeight;\
					}\
						\
					colorSum /= weightSum;\
						\
					return vec4(colorSum, 1.0);\
				}\
				\
				void main() {\n\
					gl_FragColor = CircularBlur();\n\
				}"
		});
	},

	getDofBlurSeperableMaterial: function getDofBlurSeperableMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"cocTexture": { value: null },
				"colorTexture": { value: null },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) },
				"direction": { value: new THREE.Vector2(0.5, 0.5) }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\n\
				varying vec2 vUv;\n\
				uniform sampler2D cocTexture;\n\
				uniform sampler2D colorTexture;\n\
				uniform vec2 texSize;\
				uniform vec2 direction;\
				const float MAXIMUM_BLUR_SIZE = 8.0;\
				\
				const float SIGMA = 5.0;\
				const int NUM_SAMPLES = 4;\
				float normpdf(in float x, in float sigma)\
				{\
					return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\
				}\
				\
				vec4 weightedBlur() { \
					float cocIn = texture2D(cocTexture, vUv).a;\
					float kernelRadius = MAXIMUM_BLUR_SIZE * cocIn;\
					vec2 invSize = 1.0 / texSize;\
					cocIn *= cocIn * cocIn;\
					float centreSpaceWeight = normpdf(0.0, SIGMA) * abs(cocIn);\
					float weightSum = centreSpaceWeight;\
					vec4 centreSample = texture2D(colorTexture, vUv);\
					vec4 diffuseSum = centreSample * weightSum;\
					vec2 delta = invSize * kernelRadius/float(NUM_SAMPLES);\
					for( int i = 1; i <= NUM_SAMPLES; i ++ ) {\
							float spaceWeight = normpdf(float(i), SIGMA);\
							vec2 texcoord = direction * delta * float(i);\
							vec4 rightSample = texture2D( colorTexture, vUv + texcoord);\
							vec4 leftSample = texture2D( colorTexture, vUv - texcoord);\
							float leftCocWeight = abs(texture2D( cocTexture, vUv - texcoord).a);\
							float rightCocWeight = abs(texture2D( cocTexture, vUv + texcoord).a);\
							leftCocWeight *= leftCocWeight * leftCocWeight;\
							rightCocWeight *= rightCocWeight * rightCocWeight;\
							diffuseSum += ( (leftSample * leftCocWeight) + (rightSample * rightCocWeight) ) * spaceWeight;\
							weightSum += (spaceWeight * (leftCocWeight + rightCocWeight));\
					}\
				  return diffuseSum/weightSum;\
				}\
				\
				void main() {\n\
					gl_FragColor = weightedBlur();\n\
				}"
		});
	},

	getDofCombineMaterial: function getDofCombineMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"colorTexture": { value: null },
				"blurTexture": { value: null },
				"cocTexture": { value: null },
				"depthTexture": { value: null },
				"NearFarBlurScale": { value: new THREE.Vector2(0.5, 0.5) },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) },
				"cameraNearFar": { value: new THREE.Vector2(0.1, 100) },
				"focalDistance": { value: 20.0 }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\n\
				#include <packing>\n\
				varying vec2 vUv;\n\
				uniform sampler2D colorTexture;\n\
				uniform sampler2D blurTexture;\n\
				uniform sampler2D cocTexture;\n\
				uniform sampler2D depthTexture;\n\
				uniform vec2 texSize;\
				uniform vec2 NearFarBlurScale;\
				uniform vec2 cameraNearFar;\
				uniform float focalDistance;\
				\
				float computeCoc() {\
					vec4 packedDepth = texture2D(depthTexture, vUv);\
					if(packedDepth.x == 1.0) return max(NearFarBlurScale.x, NearFarBlurScale.y);\
						float depth = unpackRGBAToDepth(packedDepth);\
						depth = -perspectiveDepthToViewZ(depth, cameraNearFar.x, cameraNearFar.y);\
						float coc = (depth - focalDistance)/depth;\
					return (coc > 0.0 ? coc * NearFarBlurScale.y : coc * NearFarBlurScale.x);\
				}\
				\
				void main() {\n\
					vec4 blur = texture2D(blurTexture, vUv);\
					blur += texture2D(blurTexture, vUv + vec2(1.5, 0.5) / texSize);\
					blur += texture2D(blurTexture, vUv + vec2(-0.5, 1.5) / texSize);\
					blur += texture2D(blurTexture, vUv + vec2(-1.5, -0.5) / texSize);\
					blur += texture2D(blurTexture, vUv + vec2(0.5, -1.5) / texSize);\
					blur /= 5.0;\
					float coc = abs(min(texture2D(cocTexture, vUv).a, computeCoc()));\
					coc = clamp(coc * coc * 8.0, 0.0, 1.0);\
					vec4 color = mix(texture2D(colorTexture, vUv), blur, vec4(coc));\
					gl_FragColor = color;\n\
				}"
		});
	}

});

// File:examples/js/postprocessing/UnrealBloomPass.js

/**
 * @author spidersharma / http://eduperiment.com/
 Inspired from Unreal Engine::
 https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
 */

THREE.UnrealBloomPass = function (resolution, strength, radius, threshold) {

	THREE.Pass.call(this);

	this.strength = strength !== undefined ? strength : 1;
	this.radius = radius;
	this.threshold = threshold;
	this.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);

	// render targets
	var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
	this.renderTargetsHorizontal = [];
	this.renderTargetsVertical = [];
	this.nMips = 5;
	var resx = Math.round(this.resolution.x / 2);
	var resy = Math.round(this.resolution.y / 2);

	this.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);
	this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
	this.renderTargetBright.texture.generateMipmaps = false;

	for (var i = 0; i < this.nMips; i++) {

		var renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);

		renderTarget.texture.name = "UnrealBloomPass.h" + i;
		renderTarget.texture.generateMipmaps = false;

		this.renderTargetsHorizontal.push(renderTarget);

		var renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);

		renderTarget.texture.name = "UnrealBloomPass.v" + i;
		renderTarget.texture.generateMipmaps = false;

		this.renderTargetsVertical.push(renderTarget);

		resx = Math.round(resx / 2);

		resy = Math.round(resy / 2);
	}

	// luminosity high pass material

	if (THREE.LuminosityHighPassShader === undefined) console.error("THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader");

	var highPassShader = THREE.LuminosityHighPassShader;
	this.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms);

	this.highPassUniforms["luminosityThreshold"].value = threshold;
	this.highPassUniforms["smoothWidth"].value = 0.05;

	this.materialHighPassFilter = new THREE.ShaderMaterial({
		uniforms: this.highPassUniforms,
		vertexShader: highPassShader.vertexShader,
		fragmentShader: highPassShader.fragmentShader,
		defines: {}
	});

	// Gaussian Blur Materials
	this.separableBlurMaterials = [];
	var kernelSizeArray = [3, 5, 7, 9, 11];
	var resx = Math.round(this.resolution.x / 2);
	var resy = Math.round(this.resolution.y / 2);

	for (var i = 0; i < this.nMips; i++) {

		this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));

		this.separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);

		resx = Math.round(resx / 2);

		resy = Math.round(resy / 2);
	}

	// Composite material
	this.compositeMaterial = this.getCompositeMaterial(this.nMips);
	this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
	this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
	this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
	this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
	this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
	this.compositeMaterial.uniforms["bloomStrength"].value = strength;
	this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
	this.compositeMaterial.needsUpdate = true;

	var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
	this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
	this.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];
	this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;

	// copy material
	if (THREE.CopyShader === undefined) console.error("THREE.BloomPass relies on THREE.CopyShader");

	var copyShader = THREE.CopyShader;

	this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);
	this.copyUniforms["opacity"].value = 1.0;

	this.materialCopy = new THREE.ShaderMaterial({
		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.AdditiveBlending,
		depthTest: false,
		depthWrite: false,
		transparent: true
	});

	this.enabled = true;
	this.needsSwap = false;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

THREE.UnrealBloomPass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.UnrealBloomPass,

	dispose: function dispose() {
		for (var i = 0; i < this.renderTargetsHorizontal.length(); i++) {
			this.renderTargetsHorizontal[i].dispose();
		}
		for (var i = 0; i < this.renderTargetsVertical.length(); i++) {
			this.renderTargetsVertical[i].dispose();
		}
		this.renderTargetBright.dispose();
	},

	setSize: function setSize(width, height) {

		var resx = Math.round(width / 2);
		var resy = Math.round(height / 2);

		this.renderTargetBright.setSize(resx, resy);

		for (var i = 0; i < this.nMips; i++) {

			this.renderTargetsHorizontal[i].setSize(resx, resy);
			this.renderTargetsVertical[i].setSize(resx, resy);

			this.separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);

			resx = Math.round(resx / 2);
			resy = Math.round(resy / 2);
		}
	},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		this.oldClearColor.copy(renderer.getClearColor());
		this.oldClearAlpha = renderer.getClearAlpha();
		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setClearColor(new THREE.Color(0, 0, 0), 0);

		if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);

		// 1. Extract Bright Areas
		this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
		this.highPassUniforms["luminosityThreshold"].value = this.threshold;
		this.quad.material = this.materialHighPassFilter;
		renderer.render(this.scene, this.camera, this.renderTargetBright, true);

		// 2. Blur All the mips progressively
		var inputRenderTarget = this.renderTargetBright;

		for (var i = 0; i < this.nMips; i++) {

			this.quad.material = this.separableBlurMaterials[i];

			this.separableBlurMaterials[i].uniforms["colorTexture"].value = inputRenderTarget.texture;

			this.separableBlurMaterials[i].uniforms["direction"].value = THREE.UnrealBloomPass.BlurDirectionX;

			renderer.render(this.scene, this.camera, this.renderTargetsHorizontal[i], true);

			this.separableBlurMaterials[i].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i].texture;

			this.separableBlurMaterials[i].uniforms["direction"].value = THREE.UnrealBloomPass.BlurDirectionY;

			renderer.render(this.scene, this.camera, this.renderTargetsVertical[i], true);

			inputRenderTarget = this.renderTargetsVertical[i];
		}

		// Composite All the mips
		this.quad.material = this.compositeMaterial;
		this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
		this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
		this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
		renderer.render(this.scene, this.camera, this.renderTargetsHorizontal[0], true);

		// Blend it additively over the input texture
		this.quad.material = this.materialCopy;
		this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;

		if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);

		renderer.render(this.scene, this.camera, readBuffer);

		renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
		renderer.autoClear = oldAutoClear;
	},

	getSeperableBlurMaterial: function getSeperableBlurMaterial(kernelRadius) {

		return new THREE.ShaderMaterial({

			defines: {
				"KERNEL_RADIUS": kernelRadius,
				"SIGMA": kernelRadius
			},

			uniforms: {
				"colorTexture": { value: null },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) },
				"direction": { value: new THREE.Vector2(0.5, 0.5) }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\
				varying vec2 vUv;\n\
				uniform sampler2D colorTexture;\n\
				uniform vec2 texSize;\
				uniform vec2 direction;\
				\
				float gaussianPdf(in float x, in float sigma) {\
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
				}\
				void main() {\n\
					vec2 invSize = 1.0 / texSize;\
					float fSigma = float(SIGMA);\
					float weightSum = gaussianPdf(0.0, fSigma);\
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\
						float x = float(i);\
						float w = gaussianPdf(x, fSigma);\
						vec2 uvOffset = direction * invSize * x;\
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\
						diffuseSum += (sample1 + sample2) * w;\
						weightSum += 2.0 * w;\
					}\
					gl_FragColor = diffuseSum/weightSum;\n\
				}"
		});
	},

	getCompositeMaterial: function getCompositeMaterial(nMips) {

		return new THREE.ShaderMaterial({

			defines: {
				"NUM_MIPS": nMips
			},

			uniforms: {
				"blurTexture1": { value: null },
				"blurTexture2": { value: null },
				"blurTexture3": { value: null },
				"blurTexture4": { value: null },
				"blurTexture5": { value: null },
				"dirtTexture": { value: null },
				"bloomStrength": { value: 1.0 },
				"bloomFactors": { value: null },
				"bloomTintColors": { value: null },
				"bloomRadius": { value: 0.0 }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "varying vec2 vUv;\
				uniform sampler2D blurTexture1;\
				uniform sampler2D blurTexture2;\
				uniform sampler2D blurTexture3;\
				uniform sampler2D blurTexture4;\
				uniform sampler2D blurTexture5;\
				uniform sampler2D dirtTexture;\
				uniform float bloomStrength;\
				uniform float bloomRadius;\
				uniform float bloomFactors[NUM_MIPS];\
				uniform vec3 bloomTintColors[NUM_MIPS];\
				\
				float lerpBloomFactor(const in float factor) { \
					float mirrorFactor = 1.2 - factor;\
					return mix(factor, mirrorFactor, bloomRadius);\
				}\
				\
				void main() {\
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \
					 							 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \
												 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \
												 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \
												 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\
				}"
		});
	}

});

THREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);
THREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);

// File:examples/js/postprocessing/SparklePass.js


THREE.SparklePass = function (camera, renderer, worldSizeOfSparkle, sparkleTexture) {

	THREE.Pass.call(this);

	this.camera = camera;
	this.worldSizeOfSparkle = worldSizeOfSparkle;
	this.sparkleTexture = sparkleTexture;

	this.sparkleScene = new THREE.Scene();
	this.sparkles = [];

	this.gems = {}; // keep a list of all the sparkles for that gem

	this.needsSwap = true;

	// create the noise texture and noise shader
	this.noiseTexture = new THREE.WebGLRenderTarget(256, 256, {
		minFilter: THREE.LinearFilter,
		magFilter: THREE.LinearFilter,
		format: THREE.RGBAFormat,
		name: "Sparkle Noise Texture"
	});

	var noiseShader = new THREE.ShaderMaterial(THREE.NoiseShader);
	noiseShader.uniforms = THREE.UniformsUtils.clone(noiseShader.uniforms);
	noiseShader.blending = THREE.NoBlending;
	noiseShader.premultipliedAlpha = true;
	noiseShader.transparent = true;
	noiseShader.depthTest = false;
	noiseShader.depthWrite = false;
	noiseShader.needsUpdate = true;

	// render to the noise texture
	renderer.renderPass(noiseShader, this.noiseTexture, true);

	this.copyMaterial = new THREE.ShaderMaterial(THREE.CopyShader);
	this.copyMaterial.uniforms = THREE.UniformsUtils.clone(this.copyMaterial.uniforms);
	this.copyMaterial.uniforms['opacity'].value = 1.0;
	this.copyMaterial.blending = THREE.NoBlending;
	this.copyMaterial.premultipliedAlpha = true;
	this.copyMaterial.transparent = true;
	this.copyMaterial.depthTest = false;
	this.copyMaterial.depthWrite = false;
};

THREE.SparklePass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.SparklePass,

	setSparkleTexture: function setSparkleTexture(sparkleTexture) {
		this.sparkleTexture = sparkleTexture;
	},

	setWorldSizeOfSparkles: function setWorldSizeOfSparkles(worldSizeOfSparkle) {
		this.worldSizeOfSparkle = worldSizeOfSparkle;
	},

	updateScene: function updateScene(originalScene) {
		// TODO: update the "gems" list, needed for future editor
		// console.log(originalScene);
	},

	addGemstone: function addGemstone(gemstoneGeometry, originalMesh, sparklesCount) {
		if (!this.sparkleTexture) {
			return; // cannot add sparkles if there's no sparkle texture set
		}
		if (this.gems[originalMesh.uuid]) {
			return; // do not reinsert any sparkles if that object exists already
		}

		var sparkles = [];

		var rootNode = new THREE.Object3D();
		var baseSparkle = new THREE.Sparkle(this.sparkleTexture);

		// undo parent scale to normalize scale.
		baseSparkle.mesh.scale.set(1.0, 1.0, 1.0).divide(originalMesh.scale);
		baseSparkle.setScale(this.worldSizeOfSparkle);
		if (this.noiseTexture) {
			baseSparkle.material.uniforms["noiseTexture"].value = this.noiseTexture.texture;
		}

		var tmpVector = new THREE.Vector3();

		if (gemstoneGeometry instanceof THREE.BufferGeometry) {
			var positions = gemstoneGeometry.attributes.position.array;
			var nbVertices = positions.length / 3 - 1;

			for (var i = 0; i < sparklesCount; ++i) {
				var baseIndex = Math.round(Math.random() * nbVertices) * 3;
				tmpVector.x = positions[baseIndex];
				tmpVector.y = positions[baseIndex + 1];
				tmpVector.z = positions[baseIndex + 2];

				// randomly select a base sparkle to clone
				var sparkle = baseSparkle.shallowCopy();
				sparkle.mesh.position.copy(tmpVector);
				sparkle.setIntensity(1.0);

				sparkles.push(sparkle);
				rootNode.add(sparkle.mesh);
				sparkle.mesh.updateMatrixWorld(true);
			}
		} else {
			var vertices = gemstoneGeometry.vertices;
			var nbVertices = vertices.length - 1;

			for (var i = 0; i < sparklesCount; ++i) {
				tmpVector.copy(vertices[Math.round(Math.random() * nbVertices)]);

				// randomly select a base sparkle to clone
				var sparkle = baseSparkle.shallowCopy();
				sparkle.mesh.position.copy(tmpVector);
				sparkle.setIntensity(1.0);

				sparkles.push(sparkle);
				rootNode.add(sparkle.mesh);
				sparkle.mesh.updateMatrixWorld(true);
			}
		}
		this.sparkleScene.add(rootNode);

		this.gems[originalMesh.uuid] = {
			transform: rootNode,
			originalMesh: originalMesh,
			sparkles: sparkles
		};
		this.enabled = true; // have at least one sparkle, we can now use that pass
	},

	removeGemstone: function removeGemstone(originalMesh) {
		if (this.gems[originalMesh.uuid]) {
			this.sparkleScene.remove(this.gems[originalMesh.uuid].transform);
			this.gems[originalMesh.uuid] = null;
		}
	},

	setScreenTexture: function setScreenTexture(screenTexture) {
		// update the base material shared by all sparkles from an object so they all
		// use the same screen texture
		for (var meshId in this.gems) {
			var sparkles = this.gems[meshId] && this.gems[meshId].sparkles;
			if (sparkles) {
				for (var i = 0; i < sparkles.length; ++i) {
					sparkles[i].material.uniforms["screenTexture"].value = screenTexture;
				}
			}
		}
	},

	alignSparklesWithCamera: function alignSparklesWithCamera() {
		for (var meshId in this.gems) {
			var gem = this.gems[meshId];
			if (gem) {
				var sparkles = gem && gem.sparkles;
				gem.transform.visible = gem.originalMesh.visible;
				if (gem.transform.visible && sparkles) {
					var il = sparkles.length;
					for (var i = 0; i < il; ++i) {
						sparkles[i].alignWithCamera(this.camera, gem.originalMesh);
					}
				}
			}
		}
	},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {
		this.alignSparklesWithCamera();
		this.setScreenTexture(readBuffer.texture);

		this.copyMaterial.uniforms['tDiffuse'].value = readBuffer.texture;

		renderer.renderPass(this.copyMaterial, this.renderToScreen ? null : writeBuffer, true);

		var previousAutoClear = renderer.autoClear;
		renderer.autoClear = false;
		renderer.render(this.sparkleScene, this.camera, this.renderToScreen ? null : writeBuffer);
		renderer.autoClear = previousAutoClear;
	}

});

// File:examples/js/GlossyMirror.js

/**
 * @author spidersharma03
 * @author bhouston / Ben Houston / ben@clara.io
 */

THREE.MirrorHelper = function (mirror) {
	this.scene = new THREE.Scene();
	this.cameraOrtho = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null);
	this.scene.add(this.quad);
	this.mirror = mirror;
	this.numMipMaps = 4;

	this.mirrorTextureMipMaps = [];
	this.tempRenderTargets = [];
	var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: false };
	var mirrorTexture = mirror.mirrorRenderTarget;

	var width = mirrorTexture.width / 2,
	    height = mirrorTexture.height / 2;
	for (var i = 0; i < this.numMipMaps; i++) {

		var mirrorRenderTarget = new THREE.WebGLRenderTarget(width, height, parameters);
		mirrorRenderTarget.texture.generateMipmaps = false;
		this.mirrorTextureMipMaps.push(mirrorRenderTarget);

		var tempRenderTarget = new THREE.WebGLRenderTarget(width, height, parameters);
		tempRenderTarget.texture.generateMipmaps = false;
		this.tempRenderTargets.push(tempRenderTarget);

		width /= 2;height /= 2;
	}

	this.vBlurMaterial = new THREE.ShaderMaterial(THREE.BlurShader);
	this.vBlurMaterial.side = THREE.DoubleSide;
	this.vBlurMaterial.uniforms['size'].value.set(mirrorTexture.width / 2, mirrorTexture.height / 2);
	this.vBlurMaterial.blending = THREE.NoBlending;
	THREE.BlurShaderUtils.configure(this.vBlurMaterial, 5, 3.0, new THREE.Vector2(0, 1));

	this.hBlurMaterial = this.vBlurMaterial.clone();
	this.hBlurMaterial.side = THREE.DoubleSide;
	this.hBlurMaterial.uniforms['size'].value.set(mirrorTexture.width / 2, mirrorTexture.height / 2);
	this.hBlurMaterial.blending = THREE.NoBlending;
	THREE.BlurShaderUtils.configure(this.hBlurMaterial, 5, 3.0, new THREE.Vector2(1, 0));
};

THREE.MirrorHelper.prototype = {

	constructor: THREE.MirrorHelper,

	setSize: function setSize(width, height) {
		for (var i = 0; i < this.numMipMaps; i++) {
			width /= 2;height /= 2;
			this.mirrorTextureMipMaps[i].setSize(width, height);
			this.tempRenderTargets[i].setSize(width, height);
		}
	},

	update: function update(renderer) {

		var textureIn = this.mirror.mirrorRenderTarget;
		for (var i = 0; i < this.numMipMaps; i++) {
			var renderTarget = this.mirrorTextureMipMaps[i];
			var tempRenderTarget = this.tempRenderTargets[i];

			this.hBlurMaterial.uniforms['size'].value.set(textureIn.width, textureIn.height);
			this.hBlurMaterial.uniforms["tDiffuse"].value = textureIn.texture;
			this.quad.material = this.hBlurMaterial;
			renderer.render(this.scene, this.cameraOrtho, tempRenderTarget, true);

			this.vBlurMaterial.uniforms['size'].value.set(tempRenderTarget.width, tempRenderTarget.height);
			this.vBlurMaterial.uniforms["tDiffuse"].value = tempRenderTarget.texture;
			this.quad.material = this.vBlurMaterial;
			renderer.render(this.scene, this.cameraOrtho, renderTarget, true);

			textureIn = renderTarget;
		}
	}
};

THREE.GlossyMirror = function (options) {

	THREE.Object3D.call(this);

	this.name = 'mirror_' + this.id;

	options = options || {};

	this.matrixNeedsUpdate = true;

	var width = options.textureWidth !== undefined ? options.textureWidth : 512;
	var height = options.textureHeight !== undefined ? options.textureHeight : 512;

	this.size = new THREE.Vector3(width, height);

	this.localMirrorNormal = options.localMirrorNormal !== undefined ? options.localMirrorNormal : new THREE.Vector3(0, 0, 1);

	this.distanceFade = 0.1;
	this.metalness = 0.0;
	this.specularColor = new THREE.Color(0xffffff);
	this.roughness = 0.0;
	this.fresnelStrength = 1.0;

	this.mirrorPlane = new THREE.Plane();
	this.mirrorWorldPosition = new THREE.Vector3();
	this.cameraWorldPosition = new THREE.Vector3();
	this.rotationMatrix = new THREE.Matrix4();
	this.lookAtPosition = new THREE.Vector3(0, 0, -1);
	this.matrixNeedsUpdate = true;

	// For debug only, show the normal and plane of the mirror
	var debugMode = options.debugMode !== undefined ? options.debugMode : false;

	if (debugMode) {

		var arrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 10, 0xffff80);
		var planeGeometry = new THREE.Geometry();
		planeGeometry.vertices.push(new THREE.Vector3(-10, -10, 0));
		planeGeometry.vertices.push(new THREE.Vector3(10, -10, 0));
		planeGeometry.vertices.push(new THREE.Vector3(10, 10, 0));
		planeGeometry.vertices.push(new THREE.Vector3(-10, 10, 0));
		planeGeometry.vertices.push(planeGeometry.vertices[0]);
		var plane = new THREE.Line(planeGeometry, new THREE.LineBasicMaterial({ color: 0xffff80 }));

		this.add(arrow);
		this.add(plane);
	}

	this.reflectionTextureMatrix = new THREE.Matrix4();

	this.mirrorNormal = new THREE.Vector3();
	var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: false };

	this.mirrorRenderTarget = new THREE.WebGLRenderTarget(width, height, parameters);
	this.mirrorRenderTarget.texture.name = "GlossyMirror.mirror";

	this.material = new THREE.ShaderMaterial(THREE.GlossyMirrorShader);
	this.material.defines = (0, _assign2.default)({}, this.material.defines);
	this.material.uniforms = THREE.UniformsUtils.clone(this.material.uniforms);
	this.material.uniforms.tReflection.value = this.mirrorRenderTarget.texture;
	this.material.uniforms.reflectionTextureMatrix.value = this.reflectionTextureMatrix;

	this.mirrorRenderTarget.texture.generateMipmaps = false;

	this.clipPlane = new THREE.Plane(this.localMirrorNormal, 0);
	this.originalClipPlane = this.clipPlane.clone();
	this.falseClipPlane = this.clipPlane.clone();
	this.falseClipPlane.constant = 10000;

	this.depthMaterial = new THREE.MeshDepthMaterial();
	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	this.depthMaterial.blending = THREE.NoBlending;
	this.depthMaterial.side = THREE.FrontSide;

	this.depthRenderTarget = new THREE.WebGLRenderTarget(width, height, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat });
	this.depthRenderTarget.texture.generateMipmaps = false;
	this.depthRenderTarget.texture.name = "GlossyMirror.depth";

	this.material.uniforms.tReflectionDepth.value = this.depthRenderTarget.texture;

	this.material.uniforms['screenSize'].value = new THREE.Vector2(width, height);

	this.mirrorHelper = new THREE.MirrorHelper(this);

	this.material.uniforms.tReflection.value = this.mirrorRenderTarget.texture;
	this.material.uniforms.tReflection1.value = this.mirrorHelper.mirrorTextureMipMaps[0].texture;
	this.material.uniforms.tReflection2.value = this.mirrorHelper.mirrorTextureMipMaps[1].texture;
	this.material.uniforms.tReflection3.value = this.mirrorHelper.mirrorTextureMipMaps[2].texture;
	this.material.uniforms.tReflection4.value = this.mirrorHelper.mirrorTextureMipMaps[3].texture;

	this.setSize(width, height);
};

THREE.GlossyMirror.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Object3D.prototype), {

	constructor: THREE.GlossyMirror,

	setSize: function setSize(width, height) {

		if (this.size.x !== width || this.size.y !== height) {

			this.mirrorRenderTarget.setSize(width, height);
			this.depthRenderTarget.setSize(width, height);
			this.mirrorHelper.setSize(width, height);
			this.material.uniforms['screenSize'].value = new THREE.Vector2(width, height);

			this.size.set(width, height);
			this.matrixNeedsUpdate = true;
		}

		this.matrixNeedsUpdate = true;
	},

	updateReflectionTextureMatrix: function updateReflectionTextureMatrix(camera) {

		this.updateMatrixWorld();
		camera.updateMatrixWorld();

		this.mirrorWorldPosition.setFromMatrixPosition(this.matrixWorld);
		this.cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);

		this.rotationMatrix.extractRotation(this.matrixWorld);

		this.mirrorNormal.copy(this.localMirrorNormal);
		this.mirrorNormal.applyMatrix4(this.rotationMatrix);

		var view = this.mirrorWorldPosition.clone().sub(this.cameraWorldPosition);
		view.reflect(this.mirrorNormal).negate();
		view.add(this.mirrorWorldPosition);

		this.rotationMatrix.extractRotation(camera.matrixWorld);

		this.lookAtPosition.set(0, 0, -1);
		this.lookAtPosition.applyMatrix4(this.rotationMatrix);
		this.lookAtPosition.add(this.cameraWorldPosition);

		var target = this.mirrorWorldPosition.clone().sub(this.lookAtPosition);
		target.reflect(this.mirrorNormal).negate();
		target.add(this.mirrorWorldPosition);

		this.up.set(0, -1, 0);
		this.up.applyMatrix4(this.rotationMatrix);
		this.up.reflect(this.mirrorNormal).negate();

		this.mirrorCamera.position.copy(view);
		this.mirrorCamera.up = this.up;
		this.mirrorCamera.lookAt(target);
		this.mirrorCamera.fov = camera.fov;
		this.mirrorCamera.near = camera.near;
		this.mirrorCamera.far = camera.far;
		this.mirrorCamera.aspect = camera.aspect;

		this.mirrorCamera.updateProjectionMatrix();
		this.mirrorCamera.updateMatrixWorld();
		this.mirrorCamera.matrixWorldInverse.getInverse(this.mirrorCamera.matrixWorld);

		// Update the texture matrix
		this.reflectionTextureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
		this.reflectionTextureMatrix.multiply(this.mirrorCamera.projectionMatrix);
		this.reflectionTextureMatrix.multiply(this.mirrorCamera.matrixWorldInverse);

		this.mirrorPlane.setFromNormalAndCoplanarPoint(this.mirrorNormal, this.mirrorWorldPosition);
		this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse);

		this.material.uniforms['mirrorCameraProjectionMatrix'].value.copy(this.mirrorCamera.projectionMatrix);
		this.material.uniforms['mirrorCameraInverseProjectionMatrix'].value.getInverse(this.mirrorCamera.projectionMatrix);

		this.material.uniforms['mirrorCameraWorldMatrix'].value.copy(camera.matrixWorld);
		this.material.uniforms['mirrorCameraNear'].value = this.mirrorCamera.near;
		this.material.uniforms['mirrorCameraFar'].value = this.mirrorCamera.far;

		this.material.uniforms['mirrorNormal'].value = this.mirrorNormal;
		this.material.uniforms['mirrorWorldPosition'].value = this.mirrorWorldPosition;
		this.material.transparent = true;
	},

	render: function render(renderer, scene, camera, width, height) {

		if (!camera instanceof THREE.PerspectiveCamera) console.error("THREE.GlossyMirror: camera is not a Perspective Camera!");

		this.setSize(width, height);

		if (!this.mirrorCamera) {
			this.mirrorCamera = camera.clone();
			this.mirrorCamera.matrixAutoUpdate = true;
		}

		if (this.matrixNeedsUpdate) this.updateReflectionTextureMatrix(camera);

		this.matrixNeedsUpdate = true;

		// Render the mirrored view of the current scene into the target texture


		if (this.clipPlane !== undefined) {

			this.clipPlane.copy(this.originalClipPlane);

			this.clipPlane.applyMatrix4(this.matrixWorld);
			this.clippingPlanes = [this.clipPlane];
		}

		renderer.clippingPlanes = this.clippingPlanes;

		if (scene !== undefined && scene instanceof THREE.Scene) {

			// We can't render ourself to ourself
			var visible = this.material.visible;
			this.material.visible = false;

			renderer.render(scene, this.mirrorCamera, this.mirrorRenderTarget, true);

			this.material.visible = visible;
		}
		scene.overrideMaterial = this.depthMaterial;

		var visible = this.material.visible;

		var oldClearColor = renderer.getClearColor(),
		    oldClearAlpha = renderer.getClearAlpha();

		renderer.setClearColor(0xffffff, 1);
		this.material.visible = false;

		renderer.render(scene, this.mirrorCamera, this.depthRenderTarget, true);

		scene.overrideMaterial = null;
		renderer.setClearColor(oldClearColor, oldClearAlpha);

		this.material.visible = visible;
		this.material.uniforms.distanceFade.value = this.distanceFade;
		this.material.uniforms.metalness.value = this.metalness;
		this.material.uniforms.fresnelStrength.value = this.fresnelStrength;
		this.material.uniforms.specularColor.value.copy(this.specularColor);
		this.material.uniforms.roughness.value = this.roughness;

		if (this.clipPlane !== undefined) {

			this.clipPlane.copy(this.falseClipPlane);
		}
		if (this.mirrorHelper !== undefined) {

			this.mirrorHelper.update(renderer);
		}
	}

});

// File:examples/js/controls/OrbitControls.js

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finger swipe

THREE.OrbitControls = function (object, domElement) {

	this.object = object;

	this.domElement = domElement !== undefined ? domElement : document;

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the object orbits around
	this.target = new THREE.Vector3();

	// How far you can dolly in and out ( PerspectiveCamera only )
	this.minDistance = 0;
	this.maxDistance = Infinity;

	// How far you can zoom in and out ( OrthographicCamera only )
	this.minZoom = 0;
	this.maxZoom = Infinity;

	// How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI; // radians

	// How far you can orbit horizontally, upper and lower limits.
	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	this.minAzimuthAngle = -Infinity; // radians
	this.maxAzimuthAngle = Infinity; // radians

	// Set to true to enable damping (inertia)
	// If damping is enabled, you must call controls.update() in your animation loop
	this.enableDamping = false;
	this.dampingFactor = 0.25;

	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	// Set to false to disable zooming
	this.enableZoom = true;
	this.zoomSpeed = 1.0;

	// Set to false to disable rotating
	this.enableRotate = true;
	this.rotateSpeed = 1.0;

	// Set to false to disable panning
	this.enablePan = true;
	this.keyPanSpeed = 7.0; // pixels moved per arrow key push

	// Set to true to automatically rotate around the target
	// If auto-rotate is enabled, you must call controls.update() in your animation loop
	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

	// for reset
	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.zoom0 = this.object.zoom;

	//
	// public methods
	//

	this.getPolarAngle = function () {

		return spherical.phi;
	};

	this.getAzimuthalAngle = function () {

		return spherical.theta;
	};

	this.reset = function () {

		scope.target.copy(scope.target0);
		scope.object.position.copy(scope.position0);
		scope.object.zoom = scope.zoom0;

		scope.object.updateProjectionMatrix();
		scope.dispatchEvent(changeEvent);

		scope.update();

		state = STATE.NONE;
	};

	// this method is exposed, but perhaps it would be better if we can make it private...
	this.update = function () {

		var offset = new THREE.Vector3();

		// so camera.up is the orbit axis
		var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
		var quatInverse = quat.clone().inverse();

		var lastPosition = new THREE.Vector3();
		var lastQuaternion = new THREE.Quaternion();

		return function update() {

			var position = scope.object.position;

			offset.copy(position).sub(scope.target);

			// rotate offset to "y-axis-is-up" space
			offset.applyQuaternion(quat);

			// angle from z-axis around y-axis
			spherical.setFromVector3(offset);

			if (scope.autoRotate && state === STATE.NONE) {

				rotateLeft(getAutoRotationAngle());
			}

			spherical.theta += sphericalDelta.theta;
			spherical.phi += sphericalDelta.phi;

			// restrict theta to be between desired limits
			spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));

			// restrict phi to be between desired limits
			spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));

			spherical.makeSafe();

			spherical.radius *= scale;

			// restrict radius to be between desired limits
			spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

			// move target to panned location
			scope.target.add(panOffset);

			offset.setFromSpherical(spherical);

			// rotate offset back to "camera-up-vector-is-up" space
			offset.applyQuaternion(quatInverse);

			position.copy(scope.target).add(offset);

			scope.object.lookAt(scope.target);

			if (scope.enableDamping === true) {

				sphericalDelta.theta *= 1 - scope.dampingFactor;
				sphericalDelta.phi *= 1 - scope.dampingFactor;
			} else {

				sphericalDelta.set(0, 0, 0);
			}

			scale = 1;
			panOffset.set(0, 0, 0);

			// update condition is:
			// min(camera displacement, camera rotation in radians)^2 > EPS
			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

			if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {

				scope.dispatchEvent(changeEvent);

				lastPosition.copy(scope.object.position);
				lastQuaternion.copy(scope.object.quaternion);
				zoomChanged = false;

				return true;
			}

			return false;
		};
	}();

	this.dispose = function () {

		scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
		scope.domElement.removeEventListener('mousedown', onMouseDown, false);
		scope.domElement.removeEventListener('wheel', onMouseWheel, false);

		scope.domElement.removeEventListener('touchstart', onTouchStart, false);
		scope.domElement.removeEventListener('touchend', onTouchEnd, false);
		scope.domElement.removeEventListener('touchmove', onTouchMove, false);

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);

		window.removeEventListener('keydown', onKeyDown, false);

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

	var state = STATE.NONE;

	var EPS = 0.000001;

	// current position in spherical coordinates
	var spherical = new THREE.Spherical();
	var sphericalDelta = new THREE.Spherical();

	var scale = 1;
	var panOffset = new THREE.Vector3();
	var zoomChanged = false;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var panStart = new THREE.Vector2();
	var panEnd = new THREE.Vector2();
	var panDelta = new THREE.Vector2();

	var dollyStart = new THREE.Vector2();
	var dollyEnd = new THREE.Vector2();
	var dollyDelta = new THREE.Vector2();

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
	}

	function getZoomScale() {

		return Math.pow(0.95, scope.zoomSpeed);
	}

	function rotateLeft(angle) {

		sphericalDelta.theta -= angle;
	}

	function rotateUp(angle) {

		sphericalDelta.phi -= angle;
	}

	var panLeft = function () {

		var v = new THREE.Vector3();

		return function panLeft(distance, objectMatrix) {

			v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
			v.multiplyScalar(-distance);

			panOffset.add(v);
		};
	}();

	var panUp = function () {

		var v = new THREE.Vector3();

		return function panUp(distance, objectMatrix) {

			v.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix
			v.multiplyScalar(distance);

			panOffset.add(v);
		};
	}();

	// deltaX and deltaY are in pixels; right and down are positive
	var pan = function () {

		var offset = new THREE.Vector3();

		return function pan(deltaX, deltaY) {

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			if (scope.object instanceof THREE.PerspectiveCamera) {

				// perspective
				var position = scope.object.position;
				offset.copy(position).sub(scope.target);
				var targetDistance = offset.length();

				// half of the fov is center to top of screen
				targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

				// we actually don't use screenWidth, since perspective camera is fixed to screen height
				panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
				panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
			} else if (scope.object instanceof THREE.OrthographicCamera) {

				// orthographic
				panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
				panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
			} else {

				// camera neither orthographic nor perspective
				console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
				scope.enablePan = false;
			}
		};
	}();

	function dollyIn(dollyScale) {

		if (scope.object instanceof THREE.PerspectiveCamera) {

			scale /= dollyScale;
		} else if (scope.object instanceof THREE.OrthographicCamera) {

			scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		} else {

			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
			scope.enableZoom = false;
		}
	}

	function dollyOut(dollyScale) {

		if (scope.object instanceof THREE.PerspectiveCamera) {

			scale *= dollyScale;
		} else if (scope.object instanceof THREE.OrthographicCamera) {

			scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		} else {

			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
			scope.enableZoom = false;
		}
	}

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate(event) {

		//console.log( 'handleMouseDownRotate' );

		rotateStart.set(event.clientX, event.clientY);
	}

	function handleMouseDownDolly(event) {

		//console.log( 'handleMouseDownDolly' );

		dollyStart.set(event.clientX, event.clientY);
	}

	function handleMouseDownPan(event) {

		//console.log( 'handleMouseDownPan' );

		panStart.set(event.clientX, event.clientY);
	}

	function handleMouseMoveRotate(event) {

		//console.log( 'handleMouseMoveRotate' );

		rotateEnd.set(event.clientX, event.clientY);
		rotateDelta.subVectors(rotateEnd, rotateStart);

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

		rotateStart.copy(rotateEnd);

		scope.update();
	}

	function handleMouseMoveDolly(event) {

		//console.log( 'handleMouseMoveDolly' );

		dollyEnd.set(event.clientX, event.clientY);

		dollyDelta.subVectors(dollyEnd, dollyStart);

		if (dollyDelta.y > 0) {

			dollyIn(getZoomScale());
		} else if (dollyDelta.y < 0) {

			dollyOut(getZoomScale());
		}

		dollyStart.copy(dollyEnd);

		scope.update();
	}

	function handleMouseMovePan(event) {

		//console.log( 'handleMouseMovePan' );

		panEnd.set(event.clientX, event.clientY);

		panDelta.subVectors(panEnd, panStart);

		pan(panDelta.x, panDelta.y);

		panStart.copy(panEnd);

		scope.update();
	}

	function handleMouseUp(event) {

		// console.log( 'handleMouseUp' );

	}

	function handleMouseWheel(event) {

		// console.log( 'handleMouseWheel' );

		if (event.deltaY < 0) {

			dollyOut(getZoomScale());
		} else if (event.deltaY > 0) {

			dollyIn(getZoomScale());
		}

		scope.update();
	}

	function handleKeyDown(event) {

		//console.log( 'handleKeyDown' );

		switch (event.keyCode) {

			case scope.keys.UP:
				pan(0, scope.keyPanSpeed);
				scope.update();
				break;

			case scope.keys.BOTTOM:
				pan(0, -scope.keyPanSpeed);
				scope.update();
				break;

			case scope.keys.LEFT:
				pan(scope.keyPanSpeed, 0);
				scope.update();
				break;

			case scope.keys.RIGHT:
				pan(-scope.keyPanSpeed, 0);
				scope.update();
				break;

		}
	}

	function handleTouchStartRotate(event) {

		//console.log( 'handleTouchStartRotate' );

		rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
	}

	function handleTouchStartDolly(event) {

		//console.log( 'handleTouchStartDolly' );

		var dx = event.touches[0].pageX - event.touches[1].pageX;
		var dy = event.touches[0].pageY - event.touches[1].pageY;

		var distance = Math.sqrt(dx * dx + dy * dy);

		dollyStart.set(0, distance);
	}

	function handleTouchStartPan(event) {

		//console.log( 'handleTouchStartPan' );

		panStart.set(event.touches[0].pageX, event.touches[0].pageY);
	}

	function handleTouchMoveRotate(event) {

		//console.log( 'handleTouchMoveRotate' );

		rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
		rotateDelta.subVectors(rotateEnd, rotateStart);

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

		rotateStart.copy(rotateEnd);

		scope.update();
	}

	function handleTouchMoveDolly(event) {

		//console.log( 'handleTouchMoveDolly' );

		var dx = event.touches[0].pageX - event.touches[1].pageX;
		var dy = event.touches[0].pageY - event.touches[1].pageY;

		var distance = Math.sqrt(dx * dx + dy * dy);

		dollyEnd.set(0, distance);

		dollyDelta.subVectors(dollyEnd, dollyStart);

		if (dollyDelta.y > 0) {

			dollyOut(getZoomScale());
		} else if (dollyDelta.y < 0) {

			dollyIn(getZoomScale());
		}

		dollyStart.copy(dollyEnd);

		scope.update();
	}

	function handleTouchMovePan(event) {

		//console.log( 'handleTouchMovePan' );

		panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

		panDelta.subVectors(panEnd, panStart);

		pan(panDelta.x, panDelta.y);

		panStart.copy(panEnd);

		scope.update();
	}

	function handleTouchEnd(event) {}

	//console.log( 'handleTouchEnd' );

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onMouseDown(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		if (event.button === scope.mouseButtons.ORBIT) {

			if (scope.enableRotate === false) return;

			handleMouseDownRotate(event);

			state = STATE.ROTATE;
		} else if (event.button === scope.mouseButtons.ZOOM) {

			if (scope.enableZoom === false) return;

			handleMouseDownDolly(event);

			state = STATE.DOLLY;
		} else if (event.button === scope.mouseButtons.PAN) {

			if (scope.enablePan === false) return;

			handleMouseDownPan(event);

			state = STATE.PAN;
		}

		if (state !== STATE.NONE) {

			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('mouseup', onMouseUp, false);

			scope.dispatchEvent(startEvent);
		}
	}

	function onMouseMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		if (state === STATE.ROTATE) {

			if (scope.enableRotate === false) return;

			handleMouseMoveRotate(event);
		} else if (state === STATE.DOLLY) {

			if (scope.enableZoom === false) return;

			handleMouseMoveDolly(event);
		} else if (state === STATE.PAN) {

			if (scope.enablePan === false) return;

			handleMouseMovePan(event);
		}
	}

	function onMouseUp(event) {

		if (scope.enabled === false) return;

		handleMouseUp(event);

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);

		scope.dispatchEvent(endEvent);

		state = STATE.NONE;
	}

	function onMouseWheel(event) {

		if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;

		event.preventDefault();
		event.stopPropagation();

		handleMouseWheel(event);

		scope.dispatchEvent(startEvent); // not sure why these are here...
		scope.dispatchEvent(endEvent);
	}

	function onKeyDown(event) {

		if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;

		handleKeyDown(event);
	}

	function onTouchStart(event) {

		if (scope.enabled === false) return;

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.enableRotate === false) return;

				handleTouchStartRotate(event);

				state = STATE.TOUCH_ROTATE;

				break;

			case 2:
				// two-fingered touch: dolly

				if (scope.enableZoom === false) return;

				handleTouchStartDolly(event);

				state = STATE.TOUCH_DOLLY;

				break;

			case 3:
				// three-fingered touch: pan

				if (scope.enablePan === false) return;

				handleTouchStartPan(event);

				state = STATE.TOUCH_PAN;

				break;

			default:

				state = STATE.NONE;

		}

		if (state !== STATE.NONE) {

			scope.dispatchEvent(startEvent);
		}
	}

	function onTouchMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.enableRotate === false) return;
				if (state !== STATE.TOUCH_ROTATE) return; // is this needed?...

				handleTouchMoveRotate(event);

				break;

			case 2:
				// two-fingered touch: dolly

				if (scope.enableZoom === false) return;
				if (state !== STATE.TOUCH_DOLLY) return; // is this needed?...

				handleTouchMoveDolly(event);

				break;

			case 3:
				// three-fingered touch: pan

				if (scope.enablePan === false) return;
				if (state !== STATE.TOUCH_PAN) return; // is this needed?...

				handleTouchMovePan(event);

				break;

			default:

				state = STATE.NONE;

		}
	}

	function onTouchEnd(event) {

		if (scope.enabled === false) return;

		handleTouchEnd(event);

		scope.dispatchEvent(endEvent);

		state = STATE.NONE;
	}

	function onContextMenu(event) {

		event.preventDefault();
	}

	//

	scope.domElement.addEventListener('contextmenu', onContextMenu, false);

	scope.domElement.addEventListener('mousedown', onMouseDown, false);
	scope.domElement.addEventListener('wheel', onMouseWheel, false);

	scope.domElement.addEventListener('touchstart', onTouchStart, false);
	scope.domElement.addEventListener('touchend', onTouchEnd, false);
	scope.domElement.addEventListener('touchmove', onTouchMove, false);

	window.addEventListener('keydown', onKeyDown, false);

	// force an update at start

	this.update();
};

THREE.OrbitControls.prototype = (0, _create2.default)(THREE.EventDispatcher.prototype);
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

(0, _defineProperties2.default)(THREE.OrbitControls.prototype, {

	center: {

		get: function get() {

			console.warn('THREE.OrbitControls: .center has been renamed to .target');
			return this.target;
		}

	},

	// backward compatibility

	noZoom: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
			return !this.enableZoom;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
			this.enableZoom = !value;
		}

	},

	noRotate: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
			return !this.enableRotate;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
			this.enableRotate = !value;
		}

	},

	noPan: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
			return !this.enablePan;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
			this.enablePan = !value;
		}

	},

	noKeys: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
			return !this.enableKeys;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
			this.enableKeys = !value;
		}

	},

	staticMoving: {

		get: function get() {

			console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
			return !this.enableDamping;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
			this.enableDamping = !value;
		}

	},

	dynamicDampingFactor: {

		get: function get() {

			console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
			return this.dampingFactor;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
			this.dampingFactor = value;
		}

	}

});

// File:examples/js/ColorToJsonOverride.js

//override the toJSON function to return serialization to its previous state
THREE.Color.prototype.toJSON = function () {
	return { r: this.r, g: this.g, b: this.b };
};

// File:examples/js/loaders/RGBELoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 */

// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

THREE.HDRLoader = THREE.RGBELoader = function (manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

// extend THREE.DataTextureLoader
THREE.RGBELoader.prototype = (0, _create2.default)(THREE.DataTextureLoader.prototype);

// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
THREE.RGBELoader.prototype._parser = function (buffer) {

	var
	/* return codes for rgbe routines */
	RGBE_RETURN_SUCCESS = 0,
	    RGBE_RETURN_FAILURE = -1,


	/* default error routine.  change this to change error handling */
	rgbe_read_error = 1,
	    rgbe_write_error = 2,
	    rgbe_format_error = 3,
	    rgbe_memory_error = 4,
	    rgbe_error = function rgbe_error(rgbe_error_code, msg) {

		switch (rgbe_error_code) {
			case rgbe_read_error:
				console.error("THREE.RGBELoader Read Error: " + (msg || ''));
				break;
			case rgbe_write_error:
				console.error("THREE.RGBELoader Write Error: " + (msg || ''));
				break;
			case rgbe_format_error:
				console.error("THREE.RGBELoader Bad File Format: " + (msg || ''));
				break;
			default:
			case rgbe_memory_error:
				console.error("THREE.RGBELoader: Error: " + (msg || ''));
		}
		return RGBE_RETURN_FAILURE;
	},


	/* offsets to red, green, and blue components in a data (float) pixel */
	RGBE_DATA_RED = 0,
	    RGBE_DATA_GREEN = 1,
	    RGBE_DATA_BLUE = 2,


	/* number of floats per pixel, use 4 since stored in rgba image format */
	RGBE_DATA_SIZE = 4,


	/* flags indicating which fields in an rgbe_header_info are valid */
	RGBE_VALID_PROGRAMTYPE = 1,
	    RGBE_VALID_FORMAT = 2,
	    RGBE_VALID_DIMENSIONS = 4,
	    NEWLINE = "\n",
	    fgets = function fgets(buffer, lineLimit, consume) {

		lineLimit = !lineLimit ? 1024 : lineLimit;
		var p = buffer.pos,
		    i = -1,
		    len = 0,
		    s = '',
		    chunkSize = 128,
		    chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
		while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {

			s += chunk;len += chunk.length;
			p += chunkSize;
			chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
		}

		if (-1 < i) {

			/*for (i=l-1; i>=0; i--) {
   	byteCode = m.charCodeAt(i);
   	if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
   	else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
   	if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
   }*/
			if (false !== consume) buffer.pos += len + i + 1;
			return s + chunk.slice(0, i);
		}
		return false;
	},


	/* minimal header reading.  modify if you want to parse more information */
	RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {

		var line,
		    match,


		// regexes to parse header info fields
		magic_token_re = /^#\?(\S+)$/,
		    gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
		    exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
		    format_re = /^\s*FORMAT=(\S+)\s*$/,
		    dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,


		// RGBE format header struct
		header = {

			valid: 0, /* indicate which fields are valid */

			string: '', /* the actual header string */

			comments: '', /* comments found in header */

			programtype: 'RGBE', /* listed at beginning of file to identify it
                        * after "#?".  defaults to "RGBE" */

			format: '', /* RGBE format, default 32-bit_rle_rgbe */

			gamma: 1.0, /* image has already been gamma corrected with
               * given gamma.  defaults to 1.0 (no correction) */

			exposure: 1.0, /* a value of 1.0 in an image corresponds to
                  * <exposure> watts/steradian/m^2.
                  * defaults to 1.0 */

			width: 0, height: 0 /* image dimensions, width/height */

		};

		if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {

			return rgbe_error(rgbe_read_error, "no header found");
		}
		/* if you want to require the magic token then uncomment the next line */
		if (!(match = line.match(magic_token_re))) {

			return rgbe_error(rgbe_format_error, "bad initial token");
		}
		header.valid |= RGBE_VALID_PROGRAMTYPE;
		header.programtype = match[1];
		header.string += line + "\n";

		while (true) {

			line = fgets(buffer);
			if (false === line) break;
			header.string += line + "\n";

			if ('#' === line.charAt(0)) {

				header.comments += line + "\n";
				continue; // comment line
			}

			if (match = line.match(gamma_re)) {

				header.gamma = parseFloat(match[1], 10);
			}
			if (match = line.match(exposure_re)) {

				header.exposure = parseFloat(match[1], 10);
			}
			if (match = line.match(format_re)) {

				header.valid |= RGBE_VALID_FORMAT;
				header.format = match[1]; //'32-bit_rle_rgbe';
			}
			if (match = line.match(dimensions_re)) {

				header.valid |= RGBE_VALID_DIMENSIONS;
				header.height = parseInt(match[1], 10);
				header.width = parseInt(match[2], 10);
			}

			if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
		}

		if (!(header.valid & RGBE_VALID_FORMAT)) {

			return rgbe_error(rgbe_format_error, "missing format specifier");
		}
		if (!(header.valid & RGBE_VALID_DIMENSIONS)) {

			return rgbe_error(rgbe_format_error, "missing image size specifier");
		}

		return header;
	},
	    RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {

		var data_rgba,
		    offset,
		    pos,
		    count,
		    byteValue,
		    scanline_buffer,
		    ptr,
		    ptr_end,
		    i,
		    l,
		    off,
		    isEncodedRun,
		    scanline_width = w,
		    num_scanlines = h,
		    rgbeStart;

		if (
		// run length encoding is not allowed so read flat
		scanline_width < 8 || scanline_width > 0x7fff ||
		// this file is not run length encoded
		2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {

			// return the flat buffer
			return new Uint8Array(buffer);
		}

		if (scanline_width !== (buffer[2] << 8 | buffer[3])) {

			return rgbe_error(rgbe_format_error, "wrong scanline width");
		}

		data_rgba = new Uint8Array(4 * w * h);

		if (!data_rgba || !data_rgba.length) {

			return rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
		}

		offset = 0;pos = 0;ptr_end = 4 * scanline_width;
		rgbeStart = new Uint8Array(4);
		scanline_buffer = new Uint8Array(ptr_end);

		// read in each successive scanline
		while (num_scanlines > 0 && pos < buffer.byteLength) {

			if (pos + 4 > buffer.byteLength) {

				return rgbe_error(rgbe_read_error);
			}

			rgbeStart[0] = buffer[pos++];
			rgbeStart[1] = buffer[pos++];
			rgbeStart[2] = buffer[pos++];
			rgbeStart[3] = buffer[pos++];

			if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {

				return rgbe_error(rgbe_format_error, "bad rgbe scanline format");
			}

			// read each of the four channels for the scanline into the buffer
			// first red, then green, then blue, then exponent
			ptr = 0;
			while (ptr < ptr_end && pos < buffer.byteLength) {

				count = buffer[pos++];
				isEncodedRun = count > 128;
				if (isEncodedRun) count -= 128;

				if (0 === count || ptr + count > ptr_end) {

					return rgbe_error(rgbe_format_error, "bad scanline data");
				}

				if (isEncodedRun) {

					// a (encoded) run of the same value
					byteValue = buffer[pos++];
					for (i = 0; i < count; i++) {

						scanline_buffer[ptr++] = byteValue;
					}
					//ptr += count;
				} else {

					// a literal-run
					scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);
					ptr += count;pos += count;
				}
			}

			// now convert data from buffer into rgba
			// first red, then green, then blue, then exponent (alpha)
			l = scanline_width; //scanline_buffer.byteLength;
			for (i = 0; i < l; i++) {

				off = 0;
				data_rgba[offset] = scanline_buffer[i + off];
				off += scanline_width; //1;
				data_rgba[offset + 1] = scanline_buffer[i + off];
				off += scanline_width; //1;
				data_rgba[offset + 2] = scanline_buffer[i + off];
				off += scanline_width; //1;
				data_rgba[offset + 3] = scanline_buffer[i + off];
				offset += 4;
			}

			num_scanlines--;
		}

		return data_rgba;
	};

	var byteArray = new Uint8Array(buffer),
	    byteLength = byteArray.byteLength;
	byteArray.pos = 0;
	var rgbe_header_info = RGBE_ReadHeader(byteArray);

	if (RGBE_RETURN_FAILURE !== rgbe_header_info) {

		var w = rgbe_header_info.width,
		    h = rgbe_header_info.height,
		    image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
		if (RGBE_RETURN_FAILURE !== image_rgba_data) {

			return {
				width: w, height: h,
				data: image_rgba_data,
				header: rgbe_header_info.string,
				gamma: rgbe_header_info.gamma,
				exposure: rgbe_header_info.exposure,
				format: THREE.RGBEFormat, // handled as THREE.RGBAFormat in shaders
				type: THREE.UnsignedByteType
			};
		}
	}
	return null;
};

// File:examples/js/cameras/CombinedCamera.js

/**
 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog
 *
 *		A general perpose camera, for setting FOV, Lens Focal Length,
 *		and switching between perspective and orthographic views easily.
 *		Use this only if you do not wish to manage
 *		both a Orthographic and Perspective Camera
 *
 */

THREE.CombinedCamera = function (width, height, fov, near, far) {

	THREE.Camera.call(this);
	// perspective
	this.fov = fov;
	this.far = far;
	this.near = near;
	//orthographic
	this.left = -width / 2;
	this.right = width / 2;
	this.top = height / 2;
	this.bottom = -height / 2;

	this.aspect = width / height;
	this.zoom = 1;
	this.focus = 10;
	this.view = null;
	this.hyperfocusOffset = 0;
	this.hyperfocusScale = 0.5;
	// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects

	this.cameraO = new THREE.OrthographicCamera(this.left, this.right, this.top, this.bottom, this.near, this.far);
	this.cameraP = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far);

	this.toPerspective();
};

THREE.CombinedCamera.prototype = (0, _create2.default)(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.constructor = THREE.CombinedCamera;

THREE.CombinedCamera.prototype.toPerspective = function () {

	// Switches to the Perspective Camera

	this.cameraP.near = this.near;
	this.cameraP.far = this.far;
	this.cameraP.aspect = this.aspect;
	this.cameraP.fov = this.fov;
	this.cameraP.zoom = this.zoom;
	this.cameraP.view = this.view;
	this.cameraP.focus = this.focus;

	this.cameraP.updateProjectionMatrix();

	this.projectionMatrix = this.cameraP.projectionMatrix;

	this.inPerspectiveMode = true;
	this.inOrthographicMode = false;
};

THREE.CombinedCamera.prototype.toOrthographic = function () {

	// Switches to the Orthographic camera estimating viewport from Perspective

	var fov = this.fov;
	var aspect = this.aspect;

	var halfHeight = Math.tan(fov * Math.PI / 180 / 2) * (this.hyperfocusOffset + this.hyperfocusScale * (this.near + this.far));
	var halfWidth = halfHeight * aspect;

	this.cameraO.near = this.near;
	this.cameraO.far = this.far;
	this.cameraO.left = -halfWidth;
	this.cameraO.right = halfWidth;
	this.cameraO.top = halfHeight;
	this.cameraO.bottom = -halfHeight;

	this.cameraO.zoom = this.zoom;
	this.cameraO.view = this.view;

	this.cameraO.updateProjectionMatrix();

	this.projectionMatrix = this.cameraO.projectionMatrix;

	this.inPerspectiveMode = false;
	this.inOrthographicMode = true;
};

THREE.CombinedCamera.prototype.setSize = function (width, height) {

	this.aspect = width / height;
	this.left = -width / 2;
	this.right = width / 2;
	this.top = height / 2;
	this.bottom = -height / 2;
};

THREE.CombinedCamera.prototype.setFov = function (fov) {

	this.fov = fov;

	if (this.inPerspectiveMode) {

		this.toPerspective();
	} else {

		this.toOrthographic();
	}
};

THREE.CombinedCamera.prototype.copy = function (source) {

	THREE.Camera.prototype.copy.call(this, source);

	this.fov = source.fov;
	this.far = source.far;
	this.near = source.near;

	this.left = source.left;
	this.right = source.right;
	this.top = source.top;
	this.bottom = source.bottom;

	this.zoom = source.zoom;
	this.view = source.view === null ? null : (0, _assign2.default)({}, source.view);
	this.aspect = source.aspect;
	this.hyperfocusOffset = source.hyperfocusOffset;
	this.hyperfocusScale = source.hyperfocusScale;

	this.cameraO.copy(source.cameraO);
	this.cameraP.copy(source.cameraP);

	this.inOrthographicMode = source.inOrthographicMode;
	this.inPerspectiveMode = source.inPerspectiveMode;

	return this;
};

THREE.CombinedCamera.prototype.setViewOffset = function (fullWidth, fullHeight, x, y, width, height) {

	this.view = {
		fullWidth: fullWidth,
		fullHeight: fullHeight,
		offsetX: x,
		offsetY: y,
		width: width,
		height: height
	};

	if (this.inPerspectiveMode) {

		this.aspect = fullWidth / fullHeight;

		this.toPerspective();
	} else {

		this.toOrthographic();
	}
};

THREE.CombinedCamera.prototype.clearViewOffset = function () {

	this.view = null;
	this.updateProjectionMatrix();
};
// For maintaining similar API with PerspectiveCamera

THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {

	if (this.inPerspectiveMode) {

		this.toPerspective();
	} else {

		this.toPerspective();
		this.toOrthographic();
	}
};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (full frame) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
THREE.CombinedCamera.prototype.setLens = function (focalLength, filmGauge) {

	if (filmGauge === undefined) filmGauge = 35;

	var vExtentSlope = 0.5 * filmGauge / (focalLength * Math.max(this.cameraP.aspect, 1));

	var fov = THREE.Math.RAD2DEG * 2 * Math.atan(vExtentSlope);

	this.setFov(fov);

	return fov;
};

THREE.CombinedCamera.prototype.setZoom = function (zoom) {

	this.zoom = zoom;

	if (this.inPerspectiveMode) {

		this.toPerspective();
	} else {

		this.toOrthographic();
	}
};

THREE.CombinedCamera.prototype.toFrontView = function () {

	this.rotation.x = 0;
	this.rotation.y = 0;
	this.rotation.z = 0;

	this.position.x = 0;
	this.position.y = 0;
	this.position.z = -15;
	// should we be modifing the matrix instead?
};

THREE.CombinedCamera.prototype.toBackView = function () {

	this.rotation.x = 0;
	this.rotation.y = Math.PI;
	this.rotation.z = 0;

	this.position.x = 0;
	this.position.y = 0;
	this.position.z = 15;
};

THREE.CombinedCamera.prototype.toLeftView = function () {

	this.rotation.x = 0;
	this.rotation.y = -Math.PI / 2;
	this.rotation.z = 0;

	this.position.x = -15;
	this.position.y = 0;
	this.position.z = 0;
};

THREE.CombinedCamera.prototype.toRightView = function () {

	this.rotation.x = 0;
	this.rotation.y = Math.PI / 2;
	this.rotation.z = 0;

	this.position.x = 15;
	this.position.y = 0;
	this.position.z = 0;
};

THREE.CombinedCamera.prototype.toTopView = function () {

	this.rotation.x = -Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;

	this.position.x = 0;
	this.position.y = 15;
	this.position.z = 0;
};

THREE.CombinedCamera.prototype.toBottomView = function () {

	this.rotation.x = Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;

	this.position.x = 0;
	this.position.y = -15;
	this.position.z = 0;
};

THREE.CombinedCamera.prototype.toPerspectiveView = function () {

	this.rotation.x = -Math.PI / 4;
	this.rotation.y = -Math.PI / 4;
	this.rotation.z = 0;

	this.position.x = 4;
	this.position.y = 4;
	this.position.z = 4;
};

// File:examples/js/effects/ParallaxBarrierEffect.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author marklundin / http://mark-lundin.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ParallaxBarrierEffect = function (renderer) {

	var _camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

	var _scene = new THREE.Scene();

	var _stereo = new THREE.StereoCamera();

	var _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };

	var _renderTargetL = new THREE.WebGLRenderTarget(512, 512, _params);
	var _renderTargetR = new THREE.WebGLRenderTarget(512, 512, _params);

	var _material = new THREE.ShaderMaterial({

		uniforms: {

			'mapLeft': { value: _renderTargetL.texture },
			'mapRight': { value: _renderTargetR.texture },
			'resolution': { value: new THREE.Vector2(512, 512) }

		},

		vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = vec2( uv.x, uv.y );', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n'),

		fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', ' vec2 uv = vUv;', ' if ( ( mod( gl_FragCoord.x + 1.0, 2.0 ) ) > 1.00 ) {', '   gl_FragColor = texture2D( mapLeft, uv );', ' } else {', '   gl_FragColor = texture2D( mapRight, uv - vec2( resolution.x, 0 ) );', ' }', '}'].join('\n')

	});

	var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _material);
	_scene.add(mesh);

	this.setSize = function (width, height) {

		renderer.setSize(width, height);

		var pixelRatio = renderer.getPixelRatio();

		_material.uniforms['resolution'].value.set(1.0 / width, 1.0 / height);

		_renderTargetL.setSize(width * pixelRatio / 2 + 1, height * pixelRatio);
		_renderTargetR.setSize(width * pixelRatio / 2 + 1, height * pixelRatio);
	};

	this.render = function (scene, camera) {

		scene.updateMatrixWorld();

		if (camera.parent === null) camera.updateMatrixWorld();

		_stereo.update(camera);

		renderer.render(scene, _stereo.cameraL, _renderTargetL, true);
		renderer.render(scene, _stereo.cameraR, _renderTargetR, true);
		renderer.render(_scene, _camera);
	};
};

// File:examples/js/effects/StereoEffect.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @authod mrdoob / http://mrdoob.com/
 * @authod arodic / http://aleksandarrodic.com/
 * @authod fonserbc / http://fonserbc.github.io/
*/

THREE.StereoEffect = function (renderer) {

	var _stereo = new THREE.StereoCamera();
	_stereo.aspect = 0.5;

	this.setEyeSeparation = function (eyeSep) {

		_stereo.eyeSep = eyeSep;
	};

	this.setSize = function (width, height) {

		renderer.setSize(width, height);
	};

	this.updateStereo = function (camera) {

		_stereo.update(camera);
	};

	this.getCameraL = function () {

		return _stereo.cameraL;
	};

	this.getCameraR = function () {

		return _stereo.cameraR;
	};

	this.render = function (scene, camera) {

		scene.updateMatrixWorld();

		if (camera.parent === null) camera.updateMatrixWorld();

		_stereo.update(camera);

		var size = renderer.getSize();

		if (renderer.autoClear) renderer.clear();
		renderer.setScissorTest(true);

		renderer.setScissor(0, 0, size.width / 2, size.height);
		renderer.setViewport(0, 0, size.width / 2, size.height);
		renderer.render(scene, _stereo.cameraL);

		renderer.setScissor(size.width / 2, 0, size.width / 2, size.height);
		renderer.setViewport(size.width / 2, 0, size.width / 2, size.height);
		renderer.render(scene, _stereo.cameraR);

		renderer.setScissorTest(false);
	};
};

// File:examples/js/shaders/FXAAShader.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author davidedc / http://www.sketchpatch.net/
 *
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 */

THREE.FXAAShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"resolution": { value: new THREE.Vector2(1 / 1024, 1 / 512) }

	},

	vertexShader: ["void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "#define FXAA_REDUCE_MIN   (1.0/128.0)", "#define FXAA_REDUCE_MUL   (1.0/8.0)", "#define FXAA_SPAN_MAX     8.0", "void main() {", "vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;", "vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;", "vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );", "vec3 rgbM  = rgbaM.xyz;", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float lumaNW = dot( rgbNW, luma );", "float lumaNE = dot( rgbNE, luma );", "float lumaSW = dot( rgbSW, luma );", "float lumaSE = dot( rgbSE, luma );", "float lumaM  = dot( rgbM,  luma );", "float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );", "float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );", "vec2 dir;", "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));", "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));", "float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );", "float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );", "dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),", "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),", "dir * rcpDirMin)) * resolution;", "vec4 rgbA = (1.0/2.0) * (", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));", "vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));", "float lumaB = dot(rgbB, vec4(luma, 0.0));", "if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {", "gl_FragColor = rgbA;", "} else {", "gl_FragColor = rgbB;", "}", "}"].join("\n")

};

// File:examples/js/postprocessing/OutlinePass.js

/**
 * @author spidersharma / http://eduperiment.com/
 */

THREE.OutlinePass = function (resolution, scene, camera, selectedObjects) {

	this.renderScene = scene;
	this.camera = camera;
	this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];
	this.visibleEdgeColor = new THREE.Color(1, 1, 1);
	this.hiddenEdgeColor = new THREE.Color(0.1, 0.04, 0.02);
	this.edgeGlow = 0.0;
	this.usePatternTexture = false;
	this.edgeThickness = 1.0;
	this.edgeStrength = 3.0;
	this.downSampleRatio = 2;
	this.pulsePeriod = 0;

	THREE.Pass.call(this);

	this.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);

	var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };

	var resx = Math.round(this.resolution.x / this.downSampleRatio);
	var resy = Math.round(this.resolution.y / this.downSampleRatio);

	this.maskBufferMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
	this.maskBufferMaterial.side = THREE.DoubleSide;
	this.renderTargetMaskBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);
	this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask";
	this.renderTargetMaskBuffer.texture.generateMipmaps = false;

	this.depthMaterial = new THREE.MeshDepthMaterial();
	this.depthMaterial.side = THREE.DoubleSide;
	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	this.depthMaterial.blending = THREE.NoBlending;

	this.prepareMaskMaterial = this.getPrepareMaskMaterial();
	this.prepareMaskMaterial.side = THREE.DoubleSide;

	this.renderTargetDepthBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);
	this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth";
	this.renderTargetDepthBuffer.texture.generateMipmaps = false;

	this.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget(resx, resy, pars);
	this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample";
	this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;

	this.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);
	this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1";
	this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
	this.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);
	this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2";
	this.renderTargetBlurBuffer2.texture.generateMipmaps = false;

	this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();
	this.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);
	this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1";
	this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
	this.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);
	this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2";
	this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;

	var MAX_EDGE_THICKNESS = 4;
	var MAX_EDGE_GLOW = 4;

	this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);
	this.separableBlurMaterial1.uniforms["texSize"].value = new THREE.Vector2(resx, resy);
	this.separableBlurMaterial1.uniforms["kernelRadius"].value = 1;
	this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);
	this.separableBlurMaterial2.uniforms["texSize"].value = new THREE.Vector2(Math.round(resx / 2), Math.round(resy / 2));
	this.separableBlurMaterial2.uniforms["kernelRadius"].value = MAX_EDGE_GLOW;

	// Overlay material
	this.overlayMaterial = this.getOverlayMaterial();

	// copy material
	if (THREE.CopyShader === undefined) console.error("THREE.OutlinePass relies on THREE.CopyShader");

	var copyShader = THREE.CopyShader;

	this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);
	this.copyUniforms["opacity"].value = 1.0;

	this.materialCopy = new THREE.ShaderMaterial({
		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.NoBlending,
		depthTest: false,
		depthWrite: false,
		transparent: true
	});

	this.enabled = true;
	this.needsSwap = false;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);

	this.tempPulseColor1 = new THREE.Color();
	this.tempPulseColor2 = new THREE.Color();
	this.textureMatrix = new THREE.Matrix4();
};

THREE.OutlinePass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.OutlinePass,

	dispose: function dispose() {

		this.renderTargetMaskBuffer.dispose();
		this.renderTargetDepthBuffer.dispose();
		this.renderTargetMaskDownSampleBuffer.dispose();
		this.renderTargetBlurBuffer1.dispose();
		this.renderTargetBlurBuffer2.dispose();
		this.renderTargetEdgeBuffer1.dispose();
		this.renderTargetEdgeBuffer2.dispose();
	},

	setSize: function setSize(width, height) {

		this.renderTargetMaskBuffer.setSize(width, height);

		var resx = Math.round(width / this.downSampleRatio);
		var resy = Math.round(height / this.downSampleRatio);
		this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);
		this.renderTargetBlurBuffer1.setSize(resx, resy);
		this.renderTargetEdgeBuffer1.setSize(resx, resy);
		this.separableBlurMaterial1.uniforms["texSize"].value = new THREE.Vector2(resx, resy);

		resx = Math.round(resx / 2);
		resy = Math.round(resy / 2);

		this.renderTargetBlurBuffer2.setSize(resx, resy);
		this.renderTargetEdgeBuffer2.setSize(resx, resy);

		this.separableBlurMaterial2.uniforms["texSize"].value = new THREE.Vector2(resx, resy);
	},

	updateTextureMatrix: function updateTextureMatrix() {

		this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
		this.textureMatrix.multiply(this.camera.projectionMatrix);
		this.textureMatrix.multiply(this.camera.matrixWorldInverse);
	},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		if (this.selectedObjects.length === 0) return;
		var self = this;
		var selectedObjectsFilter = function selectedObjectsFilter(object) {
			for (var i = 0; i < self.selectedObjects.length; i++) {
				var selectedObject = self.selectedObjects[i];
				if (object.uuid === selectedObject.uuid) return true;
			}
			return false;
		};
		var nonSelectedObjectsFilter = function nonSelectedObjectsFilter(object) {
			for (var i = 0; i < self.selectedObjects.length; i++) {
				var selectedObject = self.selectedObjects[i];
				if (object.uuid === selectedObject.uuid) return false;
			}
			return true;
		};

		this.oldClearColor.copy(renderer.getClearColor());
		this.oldClearAlpha = renderer.getClearAlpha();
		var oldAutoClear = renderer.autoClear;

		renderer.autoClear = false;

		if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);

		renderer.setClearColor(0xffffff, 1);

		// Make selected objects invisible
		// 1. Draw Non Selected objects in the depth buffer
		this.renderScene.overrideMaterial = this.depthMaterial;
		renderer.render(this.renderScene, this.camera, this.renderTargetDepthBuffer, true, nonSelectedObjectsFilter);

		// Update Texture Matrix for Depth compare
		this.updateTextureMatrix();

		// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects
		this.renderScene.overrideMaterial = this.prepareMaskMaterial;
		this.prepareMaskMaterial.uniforms["cameraNearFar"].value = new THREE.Vector2(this.camera.near, this.camera.far);
		this.prepareMaskMaterial.uniforms["depthTexture"].value = this.renderTargetDepthBuffer.texture;
		this.prepareMaskMaterial.uniforms["textureMatrix"].value = this.textureMatrix;
		renderer.render(this.renderScene, this.camera, this.renderTargetMaskBuffer, true, selectedObjectsFilter);
		this.renderScene.overrideMaterial = null;

		// 2. Downsample to Half resolution
		this.quad.material = this.materialCopy;
		this.copyUniforms["tDiffuse"].value = this.renderTargetMaskBuffer.texture;
		renderer.render(this.scene, this.orthoCamera, this.renderTargetMaskDownSampleBuffer, true);

		this.tempPulseColor1.copy(this.visibleEdgeColor);
		this.tempPulseColor2.copy(this.hiddenEdgeColor);

		if (this.pulsePeriod > 0) {

			var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;
			this.tempPulseColor1.multiplyScalar(scalar);
			this.tempPulseColor2.multiplyScalar(scalar);
		}

		// 3. Apply Edge Detection Pass
		this.quad.material = this.edgeDetectionMaterial;
		this.edgeDetectionMaterial.uniforms["maskTexture"].value = this.renderTargetMaskDownSampleBuffer.texture;
		this.edgeDetectionMaterial.uniforms["texSize"].value = new THREE.Vector2(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);
		this.edgeDetectionMaterial.uniforms["visibleEdgeColor"].value = this.tempPulseColor1;
		this.edgeDetectionMaterial.uniforms["hiddenEdgeColor"].value = this.tempPulseColor2;
		renderer.render(this.scene, this.orthoCamera, this.renderTargetEdgeBuffer1, true);

		// 4. Apply Blur on Half res
		this.quad.material = this.separableBlurMaterial1;
		this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
		this.separableBlurMaterial1.uniforms["direction"].value = THREE.OutlinePass.BlurDirectionX;
		this.separableBlurMaterial1.uniforms["kernelRadius"].value = this.edgeThickness;
		renderer.render(this.scene, this.orthoCamera, this.renderTargetBlurBuffer1, true);
		this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetBlurBuffer1.texture;
		this.separableBlurMaterial1.uniforms["direction"].value = THREE.OutlinePass.BlurDirectionY;
		renderer.render(this.scene, this.orthoCamera, this.renderTargetEdgeBuffer1, true);

		// Apply Blur on quarter res
		this.quad.material = this.separableBlurMaterial2;
		this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
		this.separableBlurMaterial2.uniforms["direction"].value = THREE.OutlinePass.BlurDirectionX;
		renderer.render(this.scene, this.orthoCamera, this.renderTargetBlurBuffer2, true);
		this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetBlurBuffer2.texture;
		this.separableBlurMaterial2.uniforms["direction"].value = THREE.OutlinePass.BlurDirectionY;
		renderer.render(this.scene, this.orthoCamera, this.renderTargetEdgeBuffer2, true);

		// Blend it additively over the input texture
		this.quad.material = this.overlayMaterial;
		this.overlayMaterial.uniforms["maskTexture"].value = this.renderTargetMaskBuffer.texture;
		this.overlayMaterial.uniforms["edgeTexture1"].value = this.renderTargetEdgeBuffer1.texture;
		this.overlayMaterial.uniforms["edgeTexture2"].value = this.renderTargetEdgeBuffer2.texture;
		this.overlayMaterial.uniforms["patternTexture"].value = this.patternTexture;
		this.overlayMaterial.uniforms["edgeStrength"].value = this.edgeStrength;
		this.overlayMaterial.uniforms["edgeGlow"].value = this.edgeGlow;
		this.overlayMaterial.uniforms["usePatternTexture"].value = this.usePatternTexture;

		if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);

		renderer.render(this.scene, this.orthoCamera, readBuffer, false);

		renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
		renderer.autoClear = oldAutoClear;
	},

	getPrepareMaskMaterial: function getPrepareMaskMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"depthTexture": { value: null },
				"cameraNearFar": { value: new THREE.Vector2(0.5, 0.5) },
				"textureMatrix": { value: new THREE.Matrix4() }
			},

			vertexShader: "varying vec2 vUv;\
				varying vec4 projTexCoord;\
				varying vec4 vPosition;\
				uniform mat4 textureMatrix;\
				void main() {\
					vUv = uv;\
					vPosition = modelViewMatrix * vec4( position, 1.0 );\
					vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\
					projTexCoord = textureMatrix * worldPosition;\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <packing>\
				varying vec2 vUv;\
				varying vec4 vPosition;\
				varying vec4 projTexCoord;\
				uniform sampler2D depthTexture;\
				uniform vec2 cameraNearFar;\
				\
				void main() {\
					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\
					float viewZ = -perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );\
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\
				}"
		});
	},

	getEdgeDetectionMaterial: function getEdgeDetectionMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"maskTexture": { value: null },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) },
				"visibleEdgeColor": { value: new THREE.Vector3(1.0, 1.0, 1.0) },
				"hiddenEdgeColor": { value: new THREE.Vector3(1.0, 1.0, 1.0) }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "varying vec2 vUv;\
				uniform sampler2D maskTexture;\
				uniform vec2 texSize;\
				uniform vec3 visibleEdgeColor;\
				uniform vec3 hiddenEdgeColor;\
				\
				void main() {\n\
					vec2 invSize = 1.0 / texSize;\
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\
					float diff1 = (c1.r - c2.r)*0.5;\
					float diff2 = (c3.r - c4.r)*0.5;\
					float d = length( vec2(diff1, diff2) );\
					float a1 = min(c1.g, c2.g);\
					float a2 = min(c3.g, c4.g);\
					float visibilityFactor = min(a1, a2);\
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\
				}"
		});
	},

	getSeperableBlurMaterial: function getSeperableBlurMaterial(maxRadius) {

		return new THREE.ShaderMaterial({

			defines: {
				"MAX_RADIUS": maxRadius
			},

			uniforms: {
				"colorTexture": { value: null },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) },
				"direction": { value: new THREE.Vector2(0.5, 0.5) },
				"kernelRadius": { value: 1.0 }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\
				varying vec2 vUv;\
				uniform sampler2D colorTexture;\
				uniform vec2 texSize;\
				uniform vec2 direction;\
				uniform float kernelRadius;\
				\
				float gaussianPdf(in float x, in float sigma) {\
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
				}\
				void main() {\
					vec2 invSize = 1.0 / texSize;\
					float weightSum = gaussianPdf(0.0, kernelRadius);\
					vec4 diffuseSum = texture2D( colorTexture, vUv)* weightSum;\
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\
					vec2 uvOffset = delta;\
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {\
						float w = gaussianPdf(uvOffset.x, kernelRadius);\
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\
						diffuseSum += ((sample1 + sample2) * w);\
						weightSum += (2.0 * w);\
						uvOffset += delta;\
					}\
					gl_FragColor = diffuseSum/weightSum;\
				}"
		});
	},

	getOverlayMaterial: function getOverlayMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"maskTexture": { value: null },
				"edgeTexture1": { value: null },
				"edgeTexture2": { value: null },
				"patternTexture": { value: null },
				"edgeStrength": { value: 1.0 },
				"edgeGlow": { value: 1.0 },
				"usePatternTexture": { value: 0.0 }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "varying vec2 vUv;\
				uniform sampler2D maskTexture;\
				uniform sampler2D edgeTexture1;\
				uniform sampler2D edgeTexture2;\
				uniform sampler2D patternTexture;\
				uniform float edgeStrength;\
				uniform float edgeGlow;\
				uniform bool usePatternTexture;\
				\
				void main() {\
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);\
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);\
					vec4 maskColor = texture2D(maskTexture, vUv);\
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;\
					if(usePatternTexture)\
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\
					gl_FragColor = finalColor;\
				}",
			depthTest: false,
			depthWrite: false,
			transparent: true
		});
	}

});

THREE.OutlinePass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);
THREE.OutlinePass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);

// File:examples/js/effects/VREffect.js

/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 *
 * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html
 *
 * Firefox: http://mozvr.com/downloads/
 * Chromium: https://webvr.info/get-chrome
 *
 */

THREE.VREffect = function (renderer, onError) {

	var vrDisplay, vrDisplays;
	var eyeTranslationL = new THREE.Vector3();
	var eyeTranslationR = new THREE.Vector3();
	var renderRectL, renderRectR;

	var frameData = null;

	if ('VRFrameData' in window) {

		frameData = new window.VRFrameData();
	}

	function gotVRDisplays(displays) {

		vrDisplays = displays;

		if (displays.length > 0) {

			vrDisplay = displays[0];
		} else {

			if (onError) onError('HMD not available');
		}
	}

	if (navigator.getVRDisplays) {

		navigator.getVRDisplays().then(gotVRDisplays).catch(function () {

			console.warn('THREE.VREffect: Unable to get VR Displays');
		});
	}

	//

	this.isPresenting = false;
	this.scale = 1;

	var scope = this;

	var rendererSize = renderer.getSize();
	var rendererUpdateStyle = false;
	var rendererPixelRatio = renderer.getPixelRatio();

	this.getVRDisplay = function () {

		return vrDisplay;
	};

	this.setVRDisplay = function (value) {

		vrDisplay = value;
	};

	this.getVRDisplays = function () {

		console.warn('THREE.VREffect: getVRDisplays() is being deprecated.');
		return vrDisplays;
	};

	this.setSize = function (width, height, updateStyle) {

		rendererSize = { width: width, height: height };
		rendererUpdateStyle = updateStyle;

		if (scope.isPresenting) {

			var eyeParamsL = vrDisplay.getEyeParameters('left');
			renderer.setPixelRatio(1);
			renderer.setSize(eyeParamsL.renderWidth * 2, eyeParamsL.renderHeight, false);
		} else {

			renderer.setPixelRatio(rendererPixelRatio);
			renderer.setSize(width, height, updateStyle);
		}
	};

	// VR presentation

	var canvas = renderer.domElement;
	var defaultLeftBounds = [0.0, 0.0, 0.5, 1.0];
	var defaultRightBounds = [0.5, 0.0, 0.5, 1.0];

	function onVRDisplayPresentChange() {

		var wasPresenting = scope.isPresenting;
		scope.isPresenting = vrDisplay !== undefined && vrDisplay.isPresenting;

		if (scope.isPresenting) {

			var eyeParamsL = vrDisplay.getEyeParameters('left');
			var eyeWidth = eyeParamsL.renderWidth;
			var eyeHeight = eyeParamsL.renderHeight;

			if (!wasPresenting) {

				rendererPixelRatio = renderer.getPixelRatio();
				rendererSize = renderer.getSize();

				renderer.setPixelRatio(1);
				renderer.setSize(eyeWidth * 2, eyeHeight, false);
			}
		} else if (wasPresenting) {

			renderer.setPixelRatio(rendererPixelRatio);
			renderer.setSize(rendererSize.width, rendererSize.height, rendererUpdateStyle);
		}
	}

	window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);

	this.setFullScreen = function (boolean) {

		return new _promise2.default(function (resolve, reject) {

			if (vrDisplay === undefined) {

				reject(new Error('No VR hardware found.'));
				return;
			}

			if (scope.isPresenting === boolean) {

				resolve();
				return;
			}

			if (boolean) {

				resolve(vrDisplay.requestPresent([{ source: canvas }]));
			} else {

				resolve(vrDisplay.exitPresent());
			}
		});
	};

	this.requestPresent = function () {

		return this.setFullScreen(true);
	};

	this.exitPresent = function () {

		return this.setFullScreen(false);
	};

	this.requestAnimationFrame = function (f) {

		if (vrDisplay !== undefined) {

			return vrDisplay.requestAnimationFrame(f);
		} else {

			return window.requestAnimationFrame(f);
		}
	};

	this.cancelAnimationFrame = function (h) {

		if (vrDisplay !== undefined) {

			vrDisplay.cancelAnimationFrame(h);
		} else {

			window.cancelAnimationFrame(h);
		}
	};

	this.submitFrame = function () {

		if (vrDisplay !== undefined && scope.isPresenting) {

			vrDisplay.submitFrame();
		}
	};

	this.autoSubmitFrame = true;

	// render

	var cameraL = new THREE.PerspectiveCamera();
	cameraL.layers.enable(1);

	var cameraR = new THREE.PerspectiveCamera();
	cameraR.layers.enable(2);

	this.getCameraL = function () {
		return cameraL;
	};

	this.getCameraR = function () {
		return cameraR;
	};

	this.render = function (scene, camera, renderTarget, forceClear) {

		if (vrDisplay && scope.isPresenting) {

			var autoUpdate = scene.autoUpdate;

			if (autoUpdate) {

				scene.updateMatrixWorld();
				scene.autoUpdate = false;
			}

			var eyeParamsL = vrDisplay.getEyeParameters('left');
			var eyeParamsR = vrDisplay.getEyeParameters('right');

			eyeTranslationL.fromArray(eyeParamsL.offset);
			eyeTranslationR.fromArray(eyeParamsR.offset);

			if (Array.isArray(scene)) {

				console.warn('THREE.VREffect.render() no longer supports arrays. Use object.layers instead.');
				scene = scene[0];
			}

			// When rendering we don't care what the recommended size is, only what the actual size
			// of the backbuffer is.
			var size = renderer.getSize();
			var layers = vrDisplay.getLayers();
			var leftBounds;
			var rightBounds;

			if (layers.length) {

				var layer = layers[0];

				leftBounds = layer.leftBounds !== null && layer.leftBounds.length === 4 ? layer.leftBounds : defaultLeftBounds;
				rightBounds = layer.rightBounds !== null && layer.rightBounds.length === 4 ? layer.rightBounds : defaultRightBounds;
			} else {

				leftBounds = defaultLeftBounds;
				rightBounds = defaultRightBounds;
			}

			renderRectL = {
				x: Math.round(size.width * leftBounds[0]),
				y: Math.round(size.height * leftBounds[1]),
				width: Math.round(size.width * leftBounds[2]),
				height: Math.round(size.height * leftBounds[3])
			};
			renderRectR = {
				x: Math.round(size.width * rightBounds[0]),
				y: Math.round(size.height * rightBounds[1]),
				width: Math.round(size.width * rightBounds[2]),
				height: Math.round(size.height * rightBounds[3])
			};

			if (renderTarget) {

				renderer.setRenderTarget(renderTarget);
				renderTarget.scissorTest = true;
			} else {

				renderer.setRenderTarget(null);
				renderer.setScissorTest(true);
			}

			if (renderer.autoClear || forceClear) renderer.clear();

			if (camera.parent === null) camera.updateMatrixWorld();

			camera.matrixWorld.decompose(cameraL.position, cameraL.quaternion, cameraL.scale);
			camera.matrixWorld.decompose(cameraR.position, cameraR.quaternion, cameraR.scale);

			var scale = this.scale;
			cameraL.translateOnAxis(eyeTranslationL, scale);
			cameraR.translateOnAxis(eyeTranslationR, scale);

			if (vrDisplay.getFrameData) {

				vrDisplay.depthNear = camera.near;
				vrDisplay.depthFar = camera.far;

				vrDisplay.getFrameData(frameData);

				cameraL.projectionMatrix.elements = frameData.leftProjectionMatrix;
				cameraR.projectionMatrix.elements = frameData.rightProjectionMatrix;
			} else {

				cameraL.projectionMatrix = fovToProjection(eyeParamsL.fieldOfView, true, camera.near, camera.far);
				cameraR.projectionMatrix = fovToProjection(eyeParamsR.fieldOfView, true, camera.near, camera.far);
			}

			// render left eye
			if (renderTarget) {

				renderTarget.viewport.set(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
				renderTarget.scissor.set(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
			} else {

				renderer.setViewport(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
				renderer.setScissor(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
			}
			renderer.render(scene, cameraL, renderTarget, forceClear);

			// render right eye
			if (renderTarget) {

				renderTarget.viewport.set(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
				renderTarget.scissor.set(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
			} else {

				renderer.setViewport(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
				renderer.setScissor(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
			}
			renderer.render(scene, cameraR, renderTarget, forceClear);

			if (renderTarget) {

				renderTarget.viewport.set(0, 0, size.width, size.height);
				renderTarget.scissor.set(0, 0, size.width, size.height);
				renderTarget.scissorTest = false;
				renderer.setRenderTarget(null);
			} else {

				renderer.setViewport(0, 0, size.width, size.height);
				renderer.setScissorTest(false);
			}

			if (autoUpdate) {

				scene.autoUpdate = true;
			}

			if (scope.autoSubmitFrame) {

				scope.submitFrame();
			}

			return;
		}

		// Regular render mode if not HMD

		renderer.render(scene, camera, renderTarget, forceClear);
	};

	this.dispose = function () {

		window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);
	};

	//

	function fovToNDCScaleOffset(fov) {

		var pxscale = 2.0 / (fov.leftTan + fov.rightTan);
		var pxoffset = (fov.leftTan - fov.rightTan) * pxscale * 0.5;
		var pyscale = 2.0 / (fov.upTan + fov.downTan);
		var pyoffset = (fov.upTan - fov.downTan) * pyscale * 0.5;
		return { scale: [pxscale, pyscale], offset: [pxoffset, pyoffset] };
	}

	function fovPortToProjection(fov, rightHanded, zNear, zFar) {

		rightHanded = rightHanded === undefined ? true : rightHanded;
		zNear = zNear === undefined ? 0.01 : zNear;
		zFar = zFar === undefined ? 10000.0 : zFar;

		var handednessScale = rightHanded ? -1.0 : 1.0;

		// start with an identity matrix
		var mobj = new THREE.Matrix4();
		var m = mobj.elements;

		// and with scale/offset info for normalized device coords
		var scaleAndOffset = fovToNDCScaleOffset(fov);

		// X result, map clip edges to [-w,+w]
		m[0 * 4 + 0] = scaleAndOffset.scale[0];
		m[0 * 4 + 1] = 0.0;
		m[0 * 4 + 2] = scaleAndOffset.offset[0] * handednessScale;
		m[0 * 4 + 3] = 0.0;

		// Y result, map clip edges to [-w,+w]
		// Y offset is negated because this proj matrix transforms from world coords with Y=up,
		// but the NDC scaling has Y=down (thanks D3D?)
		m[1 * 4 + 0] = 0.0;
		m[1 * 4 + 1] = scaleAndOffset.scale[1];
		m[1 * 4 + 2] = -scaleAndOffset.offset[1] * handednessScale;
		m[1 * 4 + 3] = 0.0;

		// Z result (up to the app)
		m[2 * 4 + 0] = 0.0;
		m[2 * 4 + 1] = 0.0;
		m[2 * 4 + 2] = zFar / (zNear - zFar) * -handednessScale;
		m[2 * 4 + 3] = zFar * zNear / (zNear - zFar);

		// W result (= Z in)
		m[3 * 4 + 0] = 0.0;
		m[3 * 4 + 1] = 0.0;
		m[3 * 4 + 2] = handednessScale;
		m[3 * 4 + 3] = 0.0;

		mobj.transpose();

		return mobj;
	}

	function fovToProjection(fov, rightHanded, zNear, zFar) {

		var DEG2RAD = Math.PI / 180.0;

		var fovPort = {
			upTan: Math.tan(fov.upDegrees * DEG2RAD),
			downTan: Math.tan(fov.downDegrees * DEG2RAD),
			leftTan: Math.tan(fov.leftDegrees * DEG2RAD),
			rightTan: Math.tan(fov.rightDegrees * DEG2RAD)
		};

		return fovPortToProjection(fovPort, rightHanded, zNear, zFar);
	}
};

// File:examples/js/controls/VRControls.js

/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 */

THREE.VRControls = function (object, onError) {

	var scope = this;

	var vrDisplay, vrDisplays;

	var standingMatrix = new THREE.Matrix4();

	var frameData = null;

	if ('VRFrameData' in window) {

		frameData = new VRFrameData();
	}

	function gotVRDisplays(displays) {

		vrDisplays = displays;

		if (displays.length > 0) {

			vrDisplay = displays[0];
		} else {

			if (onError) onError('VR input not available.');
		}
	}

	if (navigator.getVRDisplays) {

		navigator.getVRDisplays().then(gotVRDisplays).catch(function () {

			console.warn('THREE.VRControls: Unable to get VR Displays');
		});
	}

	// the Rift SDK returns the position in meters
	// this scale factor allows the user to define how meters
	// are converted to scene units.

	this.scale = 1;

	// If true will use "standing space" coordinate system where y=0 is the
	// floor and x=0, z=0 is the center of the room.
	this.standing = false;

	// Distance from the users eyes to the floor in meters. Used when
	// standing=true but the VRDisplay doesn't provide stageParameters.
	this.userHeight = 1.6;

	this.getVRDisplay = function () {

		return vrDisplay;
	};

	this.setVRDisplay = function (value) {

		vrDisplay = value;
	};

	this.getVRDisplays = function () {

		console.warn('THREE.VRControls: getVRDisplays() is being deprecated.');
		return vrDisplays;
	};

	this.getStandingMatrix = function () {

		return standingMatrix;
	};

	this.update = function () {

		if (vrDisplay) {

			var pose;

			if (vrDisplay.getImmediatePose) {

				pose = vrDisplay.getImmediatePose();
			} else if (vrDisplay.getFrameData) {

				vrDisplay.getFrameData(frameData);
				pose = frameData.pose;
			} else if (vrDisplay.getPose) {

				pose = vrDisplay.getPose();
			}

			if (pose.orientation !== null) {

				object.quaternion.fromArray(pose.orientation);
			} else {

				object.quaternion.set(0, 0, 0, 1);
			}

			if (pose.position !== null) {

				object.position.fromArray(pose.position);
			} else {

				object.position.set(0, 0, 0);
			}

			if (this.standing) {

				if (vrDisplay.stageParameters) {

					object.updateMatrix();

					standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
					object.applyMatrix(standingMatrix);
				} else {

					object.position.setY(object.position.y + this.userHeight);
				}
			}

			object.position.multiplyScalar(scope.scale);
		}
	};

	this.resetPose = function () {

		if (vrDisplay) {

			vrDisplay.resetPose();
		}
	};

	this.resetSensor = function () {

		console.warn('THREE.VRControls: .resetSensor() is now .resetPose().');
		this.resetPose();
	};

	this.zeroSensor = function () {

		console.warn('THREE.VRControls: .zeroSensor() is now .resetPose().');
		this.resetPose();
	};

	this.dispose = function () {

		vrDisplay = null;
	};
};

// File:examples/js/vr/VRController.js

/**
 * @author mrdoob / http://mrdoob.com
 * @author stewdio / http://stewd.io
 */

THREE.VRController = function (id, index) {

	THREE.Object3D.call(this);

	var scope = this;
	var gamepad;

	var axes = [0, 0];
	var thumbpadIsPressed = false;
	var triggerIsPressed = false;
	var gripsArePressed = false;
	var menuIsPressed = false;
	if (index === undefined) index = 0;
	function findGamepad(id) {

		// Iterate across gamepads as Vive Controllers may not be
		// in position 0 and 1.

		var gamepads = navigator.getGamepads();

		for (var i = 0, j = 0; i < 4; i++) {

			var gamepad = gamepads[i];

			if (gamepad && gamepad.id === id) {

				if (j === index) return gamepad;

				j++;
			}
		}
	}

	this.matrixAutoUpdate = false;
	this.standingMatrix = new THREE.Matrix4();

	this.getGamepad = function () {

		return gamepad;
	};

	this.getButtonState = function (button) {

		if (button === 'thumbpad') return thumbpadIsPressed;
		if (button === 'trigger') return triggerIsPressed;
		if (button === 'grips') return gripsArePressed;
		if (button === 'menu') return menuIsPressed;
	};

	this.update = function () {

		gamepad = findGamepad(id, index);

		if (gamepad !== undefined && gamepad.pose) {

			//  Position and orientation.

			var pose = gamepad.pose;
			if (gamepad.pose.position !== null) {
				scope.position.fromArray(pose.position);
			} else {
				scope.position.fromArray([0, 1, 0.0]);
			}

			if (gamepad.pose.orientation !== null) {
				scope.quaternion.fromArray(pose.orientation);
			} else {
				scope.quaternion.set(0, 0, 0, 1);
			}
			scope.matrix.compose(scope.position, scope.quaternion, scope.scale);
			scope.matrix.multiplyMatrices(scope.standingMatrix, scope.matrix);
			scope.matrix.decompose(scope.position, scope.quaternion, scope.scale);
			scope.matrixWorldNeedsUpdate = true;
			scope.visible = true;
		} else {

			scope.visible = false;
		}

		//  Thumbpad and Buttons.
		if (gamepad) {

			if (gamepad.axes && (axes[0] !== gamepad.axes[0] || axes[1] !== gamepad.axes[1])) {

				axes[0] = gamepad.axes[0]; //  X axis: -1 = Left, +1 = Right.
				axes[1] = gamepad.axes[1]; //  Y axis: -1 = Bottom, +1 = Top.
				scope.dispatchEvent({ type: 'axischanged', axes: axes });
			}

			if (gamepad.buttons[0] && thumbpadIsPressed !== gamepad.buttons[0].pressed) {

				thumbpadIsPressed = gamepad.buttons[0].pressed;
				var event = new Event(thumbpadIsPressed ? 'thumbpaddown' : 'thumbpadup');
				//window.dispatchEvent( { type: thumbpadIsPressed ? 'thumbpaddown' : 'thumbpadup' } );
				window.dispatchEvent(event);
			}

			if (gamepad.buttons[1] && triggerIsPressed !== gamepad.buttons[1].pressed) {

				triggerIsPressed = gamepad.buttons[1].pressed;
				//scope.dispatchEvent( { type: triggerIsPressed ? 'triggerdown' : 'triggerup' } );
				var event = new Event(triggerIsPressed ? 'triggerdown' : 'triggerup');
				window.dispatchEvent(event);
			}

			if (gamepad.buttons[2] && gripsArePressed !== gamepad.buttons[2].pressed) {

				gripsArePressed = gamepad.buttons[2].pressed;
				//scope.dispatchEvent( { type: gripsArePressed ? 'gripsdown' : 'gripsup' } );
				var event = new Event(gripsArePressed ? 'gripsdown' : 'gripsup');
				window.dispatchEvent(event);
			}

			if (gamepad.buttons[3] && menuIsPressed !== gamepad.buttons[3].pressed) {

				menuIsPressed = gamepad.buttons[3].pressed;
				//scope.dispatchEvent( { type: menuIsPressed ? 'menudown' : 'menuup' } );
				var event = new Event(menuIsPressed ? 'menudown' : 'menuup');
				window.dispatchEvent(event);
			}
		}
	};
};

THREE.VRController.prototype = (0, _create2.default)(THREE.Object3D.prototype);
THREE.VRController.prototype.constructor = THREE.VRController;

// File:examples/js/shaders/GeometricRefractionShader.js

/**
 * @author prashantsharma
 * @author bhouston
 *
 * Geometric refraction shader
 */

THREE.GeometricRefractionShader = {

	defines: {
		'NUM_BOUNCES': 4
	},

	extensions: {
		'derivatives': true
	},

	side: THREE.DoubleSide,

	uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, {
		normalCubeMap: { value: null },
		bDebugBounces: { value: false },
		rIndexDelta: { value: 0.03 },
		envMapIntensity: { value: 1.0 },
		gemIOR: { value: 1.0 },
		absorption: { value: new THREE.Vector3(0.0, 0.8, 0.8) },
		boostFactor: { value: 1.0 },
		boostColor: { value: new THREE.Vector3(1.0, 1.0, 1.0) },
		spectrumSpread: { value: 0.0 },
		sphereSquish: { value: new THREE.Vector3(1.0, 1.0, 1.0) },
		boundingSphere: { value: new THREE.Vector4(0.0, 0.0, 0.0, 1.0) }
	}]),

	vertexShader: ["varying vec3 vPosition;", "varying vec3 vNormal;", "void main() {", "vPosition = position;", "vNormal = normal;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#include <common>", "#include <bsdfs>", "#include <packing>", "varying vec3 vPosition;", "varying vec3 vNormal;", "uniform float gemIOR;", "uniform float boostFactor;", "uniform vec3 boostColor;", "uniform float spectrumSpread;", "uniform vec3 absorption;", "uniform vec3 sphereSquish;", "uniform vec4 boundingSphere;", // xyz: Position, w: Radius

	"uniform samplerCube normalCubeMap;", "uniform mat4 modelMatrix;", "uniform mat4 modelMatrixInverse;", "const float airIOR = 1.0;", "#include <envmap_pars_fragment>", "#include <cube_uv_reflection_fragment>", "struct Ray3 { vec3 origin; vec3 direction; };", "void setRay( out Ray3 resultRay, in vec3 origin, in vec3 direction ) {", "resultRay.origin = origin;", "resultRay.direction = normalize( direction );", "}", "vec3 rayIntersectSquishedSphere( in Ray3 ray ) {", "vec3 squishedDirection = ray.direction / sphereSquish;", "float A = dot( squishedDirection, squishedDirection );", "float B = 2.0 * dot( ray.origin, squishedDirection );", "float C = dot( ray.origin, ray.origin ) - 1.0;", "float disc = pow2( B ) - 4.0 * A * C;", "if( disc > 0.0 ) {", "disc = sqrt( disc );", "float t1 = ( -B + disc ) * 0.5 / A;", "float t2 = ( -B - disc ) * 0.5 / A;", "float t = ( t1 > t2 ) ? t1 : t2;", "return vec3( ray.origin + ray.direction * t );", "}", "return vec3( 0.0 );", "}", "vec3 queryEnvMapLocal( vec3 localNormal ) {", "vec3 worldNormal = transformDirection( localNormal, modelMatrix );", "vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.y, flipEnvMap * worldNormal.z );", "#ifdef ENVMAP_TYPE_CUBE", "vec3 envColor = envMapIntensity * envMapTexelToLinear( textureCube( envMap, queryVec ) ).rgb;", "#elif defined( ENVMAP_TYPE_CUBE_UV )", "vec3 envColor = envMapIntensity * textureCubeUV(queryVec, localNormal, 0.0).rgb;", "#endif", "return envColor;", "}",

	// https://en.wikipedia.org/wiki/Fresnel_equations
	"float fresnelReflectance( float n0, float n1, vec3 incident, vec3 refracted, vec3 normal ) {", "float cosI = dot( incident, normal );", "float cosT = dot( refracted, normal );", "float Rs = pow2( ( n0 * cosI - n1 * cosT ) / ( abs( n0 * cosI + n1 * cosT ) + 0.000001 ) );", "float Rp = pow2( ( n0 * cosT - n1 * cosI ) / ( abs( n0 * cosT + n1 * cosI ) + 0.000001 ) );", "return 0.5 * ( Rs + Rp );", "}", "vec3 traceRay( Ray3 incidentRay, vec3 diamondNormal ) {", "float reflectance;", "vec3 result = vec3( 0.0 );", "vec3 transmittance = vec3( 1.0 );", "Ray3 refractedRay, reflectedRay;",

	// external ray hitting the surface of the diamond

	"setRay( refractedRay, incidentRay.origin, refract( incidentRay.direction, diamondNormal, airIOR/gemIOR ) );", "setRay( reflectedRay, incidentRay.origin, reflect( incidentRay.direction, diamondNormal ) );", "reflectance = fresnelReflectance( airIOR, gemIOR, incidentRay.direction, refractedRay.direction, diamondNormal );", "result += queryEnvMapLocal( reflectedRay.direction ) * reflectance;", "transmittance *= ( 1.0 - reflectance );",

	// refracted ray becomes the incident ray once we are inside the diamond
	"incidentRay = refractedRay;", "for( int bounce = 0; bounce < NUM_BOUNCES; bounce ++ ) {",

	// figure out bounce location
	"vec3 pointOnUnitSphere = rayIntersectSquishedSphere( incidentRay );",
	// get diamond normal and invert it to be inward facing
	"vec4 gemstoneNormal = textureCube( normalCubeMap, pointOnUnitSphere );", "vec3 inwardDiamondNormal = - normalize( unpackRGBToNormal( gemstoneNormal.rgb ) );",

	// advance the start point of the next ray cast to the surface of the diamond gem,
	// reduces the size of the point when viewing the front of round diamonds.
	"vec3 pointOnGemStone = pointOnUnitSphere;// * gemstoneNormal.a;",

	// absorption along this ray segment.
	"float raySegmentLength = length( pointOnGemStone - incidentRay.origin );", "transmittance *= exp( -raySegmentLength * absorption );",

	// internal ray hitting the surface of the diamond
	"setRay( refractedRay, pointOnGemStone, refract( incidentRay.direction, inwardDiamondNormal, gemIOR/airIOR ) );", "setRay( reflectedRay, pointOnGemStone, reflect( incidentRay.direction, inwardDiamondNormal ) );", "reflectance = fresnelReflectance( gemIOR, airIOR, -incidentRay.direction, refractedRay.direction, inwardDiamondNormal );",

	// another check for internal reflection? argh.
	"if( reflectance >= 0.0 && reflectance < 0.99 ) {", "vec3 refractedColor = vec3( 0 );", "refractedColor.g = queryEnvMapLocal( refractedRay.direction ).g;", "setRay( refractedRay, pointOnGemStone, refract( incidentRay.direction, inwardDiamondNormal, (gemIOR+spectrumSpread*0.075)/airIOR ) );", "refractedColor.r = queryEnvMapLocal( refractedRay.direction ).r;", "setRay( refractedRay, pointOnGemStone, refract( incidentRay.direction, inwardDiamondNormal, (gemIOR-spectrumSpread*0.05)/airIOR ) );", "refractedColor.b = queryEnvMapLocal( refractedRay.direction ).b;", "result += refractedColor * transmittance * ( 1.0 - reflectance ) * boostFactor * boostColor;", "}", "else {", "reflectance = 1.0;", "if( bounce == NUM_BOUNCES - 1 ) {", "result += queryEnvMapLocal( incidentRay.direction )* transmittance * boostFactor * boostColor;", "}", "}",

	// light further backtraced has to reflect off this surface.
	"transmittance *= reflectance;", "incidentRay = reflectedRay;", "}", "return result;", "}", "void main() {",

	// worldToLocal
	"vec3 localCameraPosition = transformPosition( cameraPosition, modelMatrixInverse );", "vec3 localRayDirection = normalize( vPosition - localCameraPosition );",

	// localToUnit
	// NOTE: this normalization is incorrect, but it reduces the visibility of the point from the front of round diamonds.
	"vec3 unitPosition = ( vPosition - boundingSphere.xyz ) / boundingSphere.w;", "Ray3 incidentRay;", "setRay( incidentRay, unitPosition, localRayDirection );", "vec3 color = traceRay( incidentRay, vNormal );", "gl_FragColor = vec4( toneMapping( color.rgb ), 1.0 );", "}"].join("\n\n")

};

// File:examples/js/shaders/GeometricNormalCaptureShader.js

/**
 * @author prashantsharma
 * @author bhouston
 *
 * Geometric normal capture shader
 */

THREE.GeometricNormalCaptureShader = {

	side: THREE.DoubleSide,

	vertexShader: ["varying vec3 vNormal;", "varying vec3 vPosition;", "void main() {", "vNormal = normal;", "vec4 tempPosition = modelViewMatrix * vec4( position, 1.0 );", "gl_Position = projectionMatrix * tempPosition;", "vPosition = tempPosition.xyz;", "}"].join("\n"),

	fragmentShader: ["#include <packing>", "varying vec3 vNormal;", "varying vec3 vPosition;", "void main() {", "float offsetDistance = max( length( vPosition ), 0.0 );", "gl_FragColor = vec4( packNormalToRGB( vNormal ), offsetDistance );", "}"].join("\n")

};

// File:examples/js/shaders/NoiseShader.js

/**
 * Full-screen noise texture
 */

THREE.NoiseShader = {

	uniforms: {},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join("\n"),

	fragmentShader: ["#include <common>", "varying vec2 vUv;", "void main() {", "gl_FragColor = vec4(rand(vUv), vec3(0.0));", "}"].join("\n")

};

// File:examples/js/diamond/Sparkles.js


var SparkleMaterial = (_SparkleMaterial = {
	blending: THREE.NormalBlending,
	side: THREE.DoubleSide,

	premultipliedAlpha: true

}, (0, _defineProperty3.default)(_SparkleMaterial, 'side', THREE.DoubleSide), (0, _defineProperty3.default)(_SparkleMaterial, 'depthTest', false), (0, _defineProperty3.default)(_SparkleMaterial, 'depthWrite', false), (0, _defineProperty3.default)(_SparkleMaterial, 'transparent', true), (0, _defineProperty3.default)(_SparkleMaterial, 'uniforms', {
	"ModelViewMatrix": { type: "m4", value: new THREE.Matrix4().identity() },
	"sparkleTexture": { type: "t", value: null },
	"screenTexture": { type: "t", value: null },
	"noiseTexture": { type: "t", value: null },
	"scale": { type: "f", value: 1.0 },
	"intensity": { type: "f", value: 1.0 }
}), (0, _defineProperty3.default)(_SparkleMaterial, 'vertexShader', "varying vec2 vUv;\n\
      varying vec2 sparkleCentreUV;\n\
      uniform mat4 ModelViewMatrix;\n\
      uniform float scale;\n\
      \n\
      void main() {\n\
          vUv = uv;\n\
          vec2 alignedPosition = position.xy * scale;\n\
          vec4 finalPosition = ModelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\
          finalPosition.xy += alignedPosition;\n\
          finalPosition = projectionMatrix * finalPosition;\n\
          vec4 sparkleProjectedCentre = projectionMatrix * ModelViewMatrix * vec4(0.0,0.0,0.0,1.0);\n\
          sparkleCentreUV = (sparkleProjectedCentre.xy/sparkleProjectedCentre.w + 1.0)*0.5;\n\
          gl_Position = finalPosition;\n\
      }"), (0, _defineProperty3.default)(_SparkleMaterial, 'fragmentShader', "#include <common>\n\
     varying vec2 vUv;\n\
     varying vec2 sparkleCentreUV;\n\
     uniform sampler2D sparkleTexture;\n\
     uniform sampler2D screenTexture;\n\
     uniform sampler2D noiseTexture;\n\
     uniform float intensity;\n\
     \n\
     void main() {\n\
          vec4 screenColor = texture2D( screenTexture, sparkleCentreUV );\n\
          float screenIntensity = pow( average( screenColor.xyz ), 3.0 );\n\
          float noise = texture2D( noiseTexture, sparkleCentreUV ).r;\n\
          gl_FragColor = vec4( texture2D( sparkleTexture, vUv ).a * screenIntensity * noise * intensity );\n\
    }"), _SparkleMaterial);

THREE.Sparkle = function (sparkleTexture) {
	this.texture = sparkleTexture;
	this.geometry = new THREE.PlaneGeometry(1, 1, 0);

	this.material = new THREE.ShaderMaterial(SparkleMaterial);

	this.material.uniforms = THREE.UniformsUtils.clone(SparkleMaterial.uniforms);
	if (this.texture !== undefined) {
		this.material.uniforms["sparkleTexture"].value = sparkleTexture;
	}

	this.mesh = new THREE.Mesh(this.geometry, this.material);
	this.rotationSpeedFactor = 5;
};

THREE.Sparkle.prototype = {
	constructor: THREE.Sparkle,

	shallowCopy: function shallowCopy() {
		var sparkle = new THREE.Sparkle(this.texture);
		sparkle.mesh.position.copy(this.mesh.position);
		sparkle.mesh.quaternion.copy(this.mesh.quaternion);
		sparkle.mesh.scale.copy(this.mesh.scale);
		sparkle.material.uniforms["scale"].value = this.material.uniforms["scale"].value;
		sparkle.material.uniforms["intensity"].value = this.material.uniforms["intensity"].value;
		sparkle.material.uniforms["screenTexture"].value = this.material.uniforms["screenTexture"].value;
		sparkle.material.uniforms["noiseTexture"].value = this.material.uniforms["noiseTexture"].value;
		sparkle.material.uniforms["ModelViewMatrix"].value.copy(this.material.uniforms["ModelViewMatrix"].value);
		sparkle.rotationSpeedFactor = this.rotationSpeedFactor;
		return sparkle;
	},

	setScale: function setScale(scale) {
		this.material.uniforms["scale"].value = scale;
	},
	setIntensity: function setIntensity(intensity) {
		this.material.uniforms["intensity"].value = intensity;
	},

	alignWithCamera: function alignWithCamera(camera, originalMesh) {
		this.mesh.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, originalMesh.matrixWorld);
		this.mesh.modelViewMatrix.multiplyMatrices(this.mesh.modelViewMatrix, this.mesh.matrix);
		this.material.uniforms["ModelViewMatrix"].value.copy(this.mesh.modelViewMatrix);
	}
};

// File:examples/js/diamond/NormalCubeMapBaker.js

THREE.NormalCubeMapBaker = function (renderer, geometry, isFlat) {

	var normalCaptureMaterial = new THREE.ShaderMaterial(THREE.GeometricNormalCaptureShader);
	normalCaptureMaterial.blending = THREE.NoBlending;

	var localGeometry = geometry; //.clone();
	// localGeometry.center();
	localGeometry.computeBoundingSphere();
	// console.log( 'geometry.boundingSphere', localGeometry.boundingSphere );
	var translationMatrix = new THREE.Matrix4().setPosition(localGeometry.boundingSphere.center.clone().negate());
	var scaleFactor = 1.0 / localGeometry.boundingSphere.radius;
	var scaleMatrix = new THREE.Matrix4().makeScale(scaleFactor, scaleFactor, scaleFactor);
	var combinedXfrm = new THREE.Matrix4().multiplyMatrices(scaleMatrix, translationMatrix);

	var position = new THREE.Vector3(),
	    quaternion = new THREE.Quaternion(),
	    scale = new THREE.Vector3();
	combinedXfrm.decompose(position, quaternion, scale);
	var mesh = new THREE.Mesh(localGeometry, normalCaptureMaterial);
	mesh.position.copy(position);
	mesh.scale.copy(scale);
	// console.log( 'mesh', mesh );

	var bakeScene = new THREE.Scene();
	bakeScene.add(mesh);

	var floatLinearTextureSupport = renderer.extensions.get('OES_texture_float') && renderer.extensions.get('OES_texture_float_linear');
	var cubeCamera = new THREE.CubeCamera(0.01, 100, 512);
	cubeCamera.renderTarget.texture.generateMipmaps = false; //true;
	//cubeCamera.renderTarget.texture.anisotropy = 16;

	// should be linear if smooth, nearest if flat sided.
	cubeCamera.renderTarget.texture.magFilter = isFlat ? THREE.NearestFilter : THREE.LinearFilter;
	cubeCamera.renderTarget.texture.minFilter = isFlat ? THREE.NearestFilter : THREE.LinearFilter;
	cubeCamera.renderTarget.texture.format = THREE.RGBAFormat;
	// NOTE: THREE.FloatType is failing on iOS for some reason.
	cubeCamera.renderTarget.texture.type = floatLinearTextureSupport && !isFlat ? THREE.FloatType : THREE.UnsignedByteType;

	cubeCamera.updateCubeMap(renderer, bakeScene);

	this.texture = cubeCamera.renderTarget.texture;

	// console.log( "NormalCubeMapBaker result: ", this.texture );
};

// File:examples/js/postprocessing/OITRenderPass.js


THREE.OITRenderPass = function (scene, camera, renderer, overrideMaterial, clearColor, clearAlpha) {

	var extensions = renderer.extensions;
	var params = {};
	var halfFloatFragmentTextures = !!extensions.get('OES_texture_half_float');
	if (halfFloatFragmentTextures) {
		params.type = THREE.HalfFloatType;
	} else {
		var floatFragmentTextures = !!extensions.get('OES_texture_float');
		if (floatFragmentTextures) {
			params.type = THREE.FloatType;
		} else {
			console.log("OIT Needs either Float or Half Float texture support, using general render");
		}
	}

	var depthTextureSupport = !!extensions.get('WEBGL_depth_texture');
	if (!depthTextureSupport) {
		console.warn("OIT Needs support of Depth Texture");
	}

	this.scene = scene;
	this.camera = camera;
	this.renderOver = false;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;

	this.clear = false;
	this.clearDepth = false;
	this.needsSwap = false;

	this.opaqueRT = new THREE.WebGLRenderTarget(0, 0, { type: THREE.UnsignedByteType });
	this.accumulateRT = new THREE.WebGLRenderTarget(0, 0, params);
	this.revealageRT = new THREE.WebGLRenderTarget(0, 0, { type: THREE.UnsignedByteType });
	this.depthTexture = new THREE.DepthTexture();

	this.opaqueRT.depthTexture = this.depthTexture;
	this.accumulateRT.depthTexture = this.depthTexture;
	this.revealageRT.depthTexture = this.depthTexture;

	this.mergeMaterial = new THREE.ShaderMaterial({
		uniforms: {
			"accumulationTexture": { value: null },
			"revealageTexture": { value: null },
			"opaqueTexture": { value: null }
		},

		vertexShader: "varying vec2 vUv;\n\
    void main() {\n\
      vUv = uv;\n\
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
    }",

		fragmentShader: "varying vec2 vUv;\
    uniform sampler2D opaqueTexture;\
    uniform sampler2D accumulationTexture;\
    uniform sampler2D revealageTexture;\
    void main() { \
      vec4 accumulationColor = texture2D( accumulationTexture, vUv );\
      vec4 revealage = texture2D( revealageTexture, vUv );\
      vec4 opaqueColor = texture2D( opaqueTexture, vUv );\
      vec3 transparentColor = pow(vec3(accumulationColor.rgb / max(accumulationColor.a, 1e-5)), vec3(1.0));\
      vec3 finalColor = opaqueColor.rgb * revealage.r + (1.0 - revealage.r) * transparentColor;\
      gl_FragColor = vec4( finalColor, opaqueColor.a + accumulationColor.a);\
    }\
    "
	});

	this.mergeMaterial.uniforms["accumulationTexture"].value = this.accumulateRT.texture;
	this.mergeMaterial.uniforms["revealageTexture"].value = this.revealageRT.texture;
	this.mergeMaterial.uniforms["opaqueTexture"].value = this.opaqueRT.texture;

	this.copyMaterial = new THREE.ShaderMaterial(THREE.CopyShader);
	this.copyMaterial.uniforms = THREE.UniformsUtils.clone(this.copyMaterial.uniforms);

	if (THREE.CopyShader === undefined) console.error("THREE.OITRenderPass relies on THREE.CopyShader");

	this.blendFactorsMap = [];
	this.PASS_TYPE_ACCUM = 0;
	this.PASS_TYPE_REVEALAGE = 1;
	this.BlendStates = [];
	this.BlendStates[this.PASS_TYPE_ACCUM] = {
		blending: THREE.NormalBlending,
		premultipliedAlpha: false
	};
	this.BlendStates[this.PASS_TYPE_REVEALAGE] = {
		blending: THREE.CustomBlending,
		blendEquation: THREE.AddEquation,
		blendSrc: THREE.ZeroFactor,
		blendDst: THREE.OneMinusSrcAlphaFactor,
		blendEquationAlpha: THREE.AddEquation,
		blendSrcAlpha: THREE.OneFactor,
		blendDstAlpha: THREE.OneFactor,
		premultipliedAlpha: false
	};
};

THREE.OITRenderPass.prototype = {
	constructor: THREE.OITRenderPass,

	setSize: function setSize(width, height) {
		this.opaqueRT.setSize(width, height);
		this.accumulateRT.setSize(width, height);
		this.revealageRT.setSize(width, height);
	},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var autoClear = renderer.autoClear;
		renderer.autoClear = false;

		var autoClearDepth = renderer.autoClearDepth;
		var autoClearColor = renderer.autoCleraColor;
		var transparentFilter = function transparentFilter(obj) {
			return obj.material.transparent;
		};
		var opaqueFilter = function opaqueFilter(obj) {
			return !obj.material.transparent;
		};
		//----------------------------------------------------------------------------------------
		renderer.projectObject(this.scene, this.camera);

		if (renderer.transparentObjects.length === 0) {
			renderer.autoClearColor = false;
			renderer.render(this.scene, this.camera, readBuffer, true, false, true);
			renderer.autoClearColor = autoClearColor;
			return;
		}
		// Copy the readBuffer into opaque target. This is needed to copy the result of earlier passes(eg Texture Pass).
		// TODO. Should use the readbuffer itself to render the opaque objects into. depthTexture can be assigned to readbuffer
		// for the purpose of depth comparisions for transparent objects. I spent some time on it, but something was wrong with the
		// depth texture and it wasn't working properly. IF it works, it can save us a copy pass, and memory of a renderTarget.
		this.copyMaterial.uniforms["tDiffuse"].value = readBuffer.texture;
		renderer.renderPass(this.copyMaterial, this.opaqueRT);

		// Render Opaque objects.
		renderer.autoClearColor = false;
		renderer.render(this.scene, this.camera, this.opaqueRT, true, opaqueFilter);
		renderer.autoClearColor = autoClearColor;

		// Render Transparent objects, and accumulate colors in accumulation, and alpha in revealage.
		renderer.autoClearDepth = false;

		this.changeBlendState(renderer.transparentObjects, this.PASS_TYPE_ACCUM);
		renderer.oitMode = 0;
		renderer.setClearColor(0xffffff, 0);
		renderer.render(this.scene, this.camera, this.accumulateRT, true, transparentFilter);

		this.changeBlendState(renderer.transparentObjects, this.PASS_TYPE_REVEALAGE);
		renderer.oitMode = 1;
		renderer.setClearColor(0xffffff, 1);
		renderer.render(this.scene, this.camera, this.revealageRT, true, transparentFilter);

		this.restoreBlendState(renderer.transparentObjects);

		renderer.autoClearDepth = autoClearDepth;

		renderer.renderPass(this.mergeMaterial, readBuffer, false);
		//----------------------------------------------------------------------------------------
		renderer.autoClear = autoClear;
		renderer.oitMode = 2;
	},

	changeBlendState: function changeBlendState(transparentList, passType) {
		if (passType === undefined || passType !== this.PASS_TYPE_ACCUM && passType !== this.PASS_TYPE_REVEALAGE) {
			console.log("WebGLOrderIndependentTransparency::Invalid passType");
			return;
		}

		this.blendFactorsMap = [];
		var newBlendState = this.BlendStates[passType];
		for (var i = 0, l = transparentList.length; i < l; i++) {

			var renderItem = transparentList[i];
			var material = renderItem.material;
			var blendState = { blending: material.blending, blendEquation: material.blendEquation,
				blendSrc: material.blendSrc, blendDst: material.blendDst, blendEquationAlpha: material.blendEquationAlpha,
				blendSrcAlpha: material.blendSrcAlpha, blendDstAlpha: material.blendDstAlpha, premultipliedAlpha: material.premultipliedAlpha,
				needsUpdate: material.needsUpdate, depthWrite: material.depthWrite, depthTest: material.depthTest
			};
			this.blendFactorsMap[material.uuid] = blendState;
			material.blending = newBlendState.blending;
			material.blendEquation = newBlendState.blendEquation;
			material.blendSrc = newBlendState.blendSrc;
			material.blendDst = newBlendState.blendDst;
			material.blendEquationAlpha = newBlendState.blendEquationAlpha;
			material.blendSrcAlpha = newBlendState.blendSrcAlpha;
			material.blendDstAlpha = newBlendState.blendDstAlpha;
			material.premultipliedAlpha = newBlendState.premultipliedAlpha;
			material.depthWrite = false;
			material.depthTest = true;

			material.needsUpdate = true;
		}
	},

	restoreBlendState: function restoreBlendState(transparentList) {
		for (var i = 0, l = transparentList.length; i < l; i++) {

			var renderItem = transparentList[i];
			var material = renderItem.material;
			var originalBlendState = this.blendFactorsMap[material.uuid];
			material.blending = originalBlendState.blending;
			material.blendEquation = originalBlendState.blendEquation;
			material.blendSrc = originalBlendState.blendSrc;
			material.blendDst = originalBlendState.blendDst;
			material.blendEquationAlpha = originalBlendState.blendEquationAlpha;
			material.blendSrcAlpha = originalBlendState.blendSrcAlpha;
			material.blendDstAlpha = originalBlendState.blendDstAlpha;
			material.premultipliedAlpha = originalBlendState.premultipliedAlpha;
			material.needsUpdate = originalBlendState.needsUpdate;
			material.depthWrite = originalBlendState.depthWrite;
			material.depthTest = originalBlendState.depthTest;
			material.needsUpdate = true;
		}
	},

	isSupport: function isSupport(renderer) {

		var extensions = renderer.extensions;
		var halfFloatFragmentTextures = !!extensions.get('OES_texture_half_float');
		var depthTextureSupport = !!extensions.get('WEBGL_depth_texture');
		if (!depthTextureSupport) {
			console.warn("OIT Needs support of Depth Texture");
			return false;
		}
		if (halfFloatFragmentTextures) {
			return true;
		} else {
			var floatFragmentTextures = !!extensions.get('OES_texture_float');
			if (floatFragmentTextures) {
				return true;
			} else {
				console.log("OIT Needs either Float or Half Float texture support, using general render");
				return false;
			}
		}
	}

	// File:examples/js/postprocessing/IndexPass.js

	/**
  * @author godlzr / http://godlzr.com/
  */

};THREE.IndexPass = function (scene, camera, idType) {

	THREE.Pass.call(this);

	this.camera = camera;
	this.idType = idType || 'uuid';
	this.meshMatMap = {};
	this.indexColorScene = scene;
};

THREE.IndexPass.prototype = (0, _assign2.default)((0, _create2.default)(THREE.Pass.prototype), {

	constructor: THREE.IndexPass,

	switchMaterial: function switchMaterial() {

		if (this.indexColorScene) {

			var idType = this.idType;
			var self = this;

			this.indexColorScene.traverse(function (object) {

				if (object.type === 'Mesh') {

					if (object[idType]) {

						if (self.meshMatMap[object[idType]]) {

							object.material = self.enabled ? self.meshMatMap[object[idType]].index : self.meshMatMap[object[idType]].original;
						} else {

							var map = {};

							map.original = object.material;

							var id = object[idType];
							var color = id.slice(0, 6);

							map.index = new THREE.MeshBasicMaterial({

								color: '#' + color,
								side: THREE.DoubleSide

							});

							self.meshMatMap[id] = map;
						}
					}
				}
			});
		}
	},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		if (this.indexColorScene) {

			renderer.toneMapping = THREE.NoToneMapping;
			renderer.gammaInput = false;
			renderer.gammaOutput = false;
			renderer.setClearColor(0xffffff, 0);
			renderer.autoClear = true;

			this.switchMaterial();

			if (this.renderToScreen) {

				renderer.render(this.indexColorScene, this.camera);
			} else {

				renderer.render(this.indexColorScene, this.camera, writeBuffer, this.clear);
			}
		}
	}

});

module.exports = THREE;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(197)('wks');
var uid = __webpack_require__(78);
var Symbol = __webpack_require__(13).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Parser = undefined;

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Retrieve an unsigned byte from the DataView.
function getByte(dataView, offset) {
    return dataView.getUint8(offset);
}

// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
// Parsing utility functions

function getUShort(dataView, offset) {
    return dataView.getUint16(offset, false);
}

// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
function getShort(dataView, offset) {
    return dataView.getInt16(offset, false);
}

// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
function getULong(dataView, offset) {
    return dataView.getUint32(offset, false);
}

// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
function getFixed(dataView, offset) {
    var decimal = dataView.getInt16(offset, false);
    var fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
}

// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
function getTag(dataView, offset) {
    var tag = '';
    for (var i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }

    return tag;
}

// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
function getOffset(dataView, offset, offSize) {
    var v = 0;
    for (var i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }

    return v;
}

// Retrieve a number of bytes from start offset to the end offset from the DataView.
function getBytes(dataView, startOffset, endOffset) {
    var bytes = [];
    for (var i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }

    return bytes;
}

// Convert the list of bytes to a string.
function bytesToString(bytes) {
    var s = '';
    for (var i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }

    return s;
}

var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};

// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}

Parser.prototype.parseByte = function () {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseChar = function () {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseCard8 = Parser.prototype.parseByte;

Parser.prototype.parseUShort = function () {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

Parser.prototype.parseShort = function () {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseF2Dot14 = function () {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseULong = function () {
    var v = getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseFixed = function () {
    var v = getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseString = function (length) {
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    var string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }

    return string;
};

Parser.prototype.parseTag = function () {
    return this.parseString(4);
};

// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
// + Since until 2038 those bits will be filled by zeros we can ignore them.
Parser.prototype.parseLongDateTime = function () {
    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
    // Subtract seconds between 01/01/1904 and 01/01/1970
    // to convert Apple Mac timestamp to Standard Unix timestamp
    v -= 2082844800;
    this.relativeOffset += 8;
    return v;
};

Parser.prototype.parseVersion = function () {
    var major = getUShort(this.data, this.offset + this.relativeOffset);

    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // This returns the correct number if minor = 0xN000 where N is 0-9
    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    return major + minor / 0x1000 / 10;
};

Parser.prototype.skip = function (type, amount) {
    if (amount === undefined) {
        amount = 1;
    }

    this.relativeOffset += typeOffsets[type] * amount;
};

///// Parsing lists and records ///////////////////////////////

// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
// or provided as an argument.
Parser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function (count) {
    if (count === undefined) {
        count = this.parseUShort();
    }
    var offsets = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = dataView.getUint16(offset);
        offset += 2;
    }

    this.relativeOffset += count * 2;
    return offsets;
};

// Parses a list of 16 bit signed integers.
Parser.prototype.parseShortList = function (count) {
    var list = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        list[i] = dataView.getInt16(offset);
        offset += 2;
    }

    this.relativeOffset += count * 2;
    return list;
};

// Parses a list of bytes.
Parser.prototype.parseByteList = function (count) {
    var list = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        list[i] = dataView.getUint8(offset++);
    }

    this.relativeOffset += count;
    return list;
};

/**
 * Parse a list of items.
 * Record count is optional, if omitted it is read from the stream.
 * itemCallback is one of the Parser methods.
 */
Parser.prototype.parseList = function (count, itemCallback) {
    if (!itemCallback) {
        itemCallback = count;
        count = this.parseUShort();
    }
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        list[i] = itemCallback.call(this);
    }
    return list;
};

/**
 * Parse a list of records.
 * Record count is optional, if omitted it is read from the stream.
 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
 */
Parser.prototype.parseRecordList = function (count, recordDescription) {
    // If the count argument is absent, read it in the stream.
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseUShort();
    }
    var records = new Array(count);
    var fields = (0, _keys2.default)(recordDescription);
    for (var i = 0; i < count; i++) {
        var rec = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this);
        }
        records[i] = rec;
    }
    return records;
};

// Parse a data structure into an object
// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
Parser.prototype.parseStruct = function (description) {
    if (typeof description === 'function') {
        return description.call(this);
    } else {
        var fields = (0, _keys2.default)(description);
        var struct = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = description[fieldName];
            struct[fieldName] = fieldType.call(this);
        }
        return struct;
    }
};

Parser.prototype.parsePointer = function (description) {
    var structOffset = this.parseOffset16();
    if (structOffset > 0) {
        // NULL offset => return undefined
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    }
    return undefined;
};

/**
 * Parse a list of offsets to lists of 16-bit integers,
 * or a list of offsets to lists of offsets to any kind of items.
 * If itemCallback is not provided, a list of list of UShort is assumed.
 * If provided, itemCallback is called on each item and must parse the item.
 * See examples in tables/gsub.js
 */
Parser.prototype.parseListOfLists = function (itemCallback) {
    var offsets = this.parseOffset16List();
    var count = offsets.length;
    var relativeOffset = this.relativeOffset;
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        var start = offsets[i];
        if (start === 0) {
            // NULL offset
            list[i] = undefined; // Add i as owned property to list. Convenient with assert.
            continue;
        }
        this.relativeOffset = start;
        if (itemCallback) {
            var subOffsets = this.parseOffset16List();
            var subList = new Array(subOffsets.length);
            for (var j = 0; j < subOffsets.length; j++) {
                this.relativeOffset = start + subOffsets[j];
                subList[j] = itemCallback.call(this);
            }
            list[i] = subList;
        } else {
            list[i] = this.parseUShortList();
        }
    }
    this.relativeOffset = relativeOffset;
    return list;
};

///// Complex tables parsing //////////////////////////////////

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
// parser.offset must point to the start of the table containing the coverage.
Parser.prototype.parseCoverage = function () {
    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    var count = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            glyphs: this.parseUShortList(count)
        };
    } else if (format === 2) {
        var ranges = new Array(count);
        for (var i = 0; i < count; i++) {
            ranges[i] = {
                start: this.parseUShort(),
                end: this.parseUShort(),
                index: this.parseUShort()
            };
        }
        return {
            format: 2,
            ranges: ranges
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
};

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
Parser.prototype.parseClassDef = function () {
    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            startGlyph: this.parseUShort(),
            classes: this.parseUShortList()
        };
    } else if (format === 2) {
        return {
            format: 2,
            ranges: this.parseRecordList({
                start: Parser.uShort,
                end: Parser.uShort,
                classId: Parser.uShort
            })
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
};

///// Static methods ///////////////////////////////////
// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

Parser.list = function (count, itemCallback) {
    return function () {
        return this.parseList(count, itemCallback);
    };
};

Parser.recordList = function (count, recordDescription) {
    return function () {
        return this.parseRecordList(count, recordDescription);
    };
};

Parser.pointer = function (description) {
    return function () {
        return this.parsePointer(description);
    };
};

Parser.tag = Parser.prototype.parseTag;
Parser.byte = Parser.prototype.parseByte;
Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
Parser.uShortList = Parser.prototype.parseUShortList;
Parser.struct = Parser.prototype.parseStruct;
Parser.coverage = Parser.prototype.parseCoverage;
Parser.classDef = Parser.prototype.parseClassDef;

///// Script, Feature, Lookup lists ///////////////////////////////////////////////
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm

var langSysTable = {
    reserved: Parser.uShort,
    reqFeatureIndex: Parser.uShort,
    featureIndexes: Parser.uShortList
};

Parser.prototype.parseScriptList = function () {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        script: Parser.pointer({
            defaultLangSys: Parser.pointer(langSysTable),
            langSysRecords: Parser.recordList({
                tag: Parser.tag,
                langSys: Parser.pointer(langSysTable)
            })
        })
    }));
};

Parser.prototype.parseFeatureList = function () {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        feature: Parser.pointer({
            featureParams: Parser.offset16,
            lookupListIndexes: Parser.uShortList
        })
    }));
};

Parser.prototype.parseLookupList = function (lookupTableParsers) {
    return this.parsePointer(Parser.list(Parser.pointer(function () {
        var lookupType = this.parseUShort();
        _check2.default.argument(1 <= lookupType && lookupType <= 8, 'GSUB lookup type ' + lookupType + ' unknown.');
        var lookupFlag = this.parseUShort();
        var useMarkFilteringSet = lookupFlag & 0x10;
        return {
            lookupType: lookupType,
            lookupFlag: lookupFlag,
            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
        };
    })));
};

exports.default = {
    getByte: getByte,
    getCard8: getByte,
    getUShort: getUShort,
    getCard16: getUShort,
    getShort: getShort,
    getULong: getULong,
    getFixed: getFixed,
    getTag: getTag,
    getOffset: getOffset,
    getBytes: getBytes,
    bytesToString: bytesToString,
    Parser: Parser
};
exports.Parser = Parser;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ObjectsByName;
/**
 * This class works around the problem that {@code for .. in} loops poison
 * the surrounding function and inhibit all optimizations with V8. This is
 * of course undesirable, especially since some data processing may happen
 * in the same function, and redundant workarounds would obscure the code.
 *
 * Therefore we use an extra data structure with an array of names.
 *
 * A noteworthy property is that there is no reliance on the indices, so
 * {@code .namesByIndex} can be sorted (unless within an ongoing iteration,
 * of course) in-place, e.g. alphabetically or by use frequency for UI or
 * caching purposes.
 *
 * Further, we provide a nested {@code Iterator} class that treats {@code
 * null} values gracefully.
 *
 * Example:
 * <pre>
 * // Create an iterator
 * const iterator = new ObjectsByName.Iterator( objects );
 *
 * // Iterate when this.objects is an ObjectsByName instance, do nothing
 * // in case it is null
 * for ( iterator.next(); ) {
 *     // [... use iterator.name, iterator.index and iterator.element ...]
 * }
 * </pre>
 *
 * @template T
 * @constructor
 */
function ObjectsByName() {
  /** @const @type {!Object<!string,T>} */
  this.byName = {};

  /** @const @type {!Array<T>} */
  this.namesByIndex = [];
}

ObjectsByName.prototype = {
  constructor: ObjectsByName,

  /** @type {!number} */
  get length() {
    return this.namesByIndex.length;
  },

  set: function set(name, object) {
    var byName = this.byName;
    if (name in byName === false) this.namesByIndex.push(name);
    byName[name] = object;
  }
};

/**
 * @template T
 * @constructor
 * @param {ObjectsByName<T>=} optionalContainer
 */
ObjectsByName.Iterator = function (optionalContainer) {
  this.reset(optionalContainer || null);
};

ObjectsByName.Iterator.prototype = {
  constructor: ObjectsByName.Iterator,

  /**
   * @param {ObjectsByName<T>=} optionalContainer
   * @return {!ObjectsByName.Iterator<T>}
   */
  reset: function reset(optionalContainer) {
    if (optionalContainer !== undefined) this.container = optionalContainer;

    this.name = null;
    this.index = -1;
    this.element = null;
    return this;
  },

  /**
   * @return {!boolean}
   */
  next: function next() {
    var map = this.container;
    if (map === null) return false;

    var names = map.namesByIndex;
    var index = ++this.index;

    if (index >= names.length) {
      this.name = null;
      return false;
    }

    this.element = map.byName[this.name = names[index]];
    return true;
  },

  /**
   * @param {!string} name
   * @param {T} element
   * @return {!ObjectsByName<T>}
   */
  add: function add(name, element) {
    // TODO if ( this === null ) this = new ObjectsByName();

    var namesByIndex = this.namesByIndex;

    if (namesByIndex.indexOf(name) !== -1) throw Error("ObjectsByName: Name '" + name + "' not unique!");

    namesByIndex.push(name);
    this.byName[name] = element;

    return this;
  }
};

ObjectsByName.shallowClone = function () {
  var i = new ObjectsByName.Iterator();

  return function shallowClone(that) {
    var newMap = new ObjectsByName();

    if (!that) return newMap;

    var byName = newMap.byName;
    var names = newMap.namesByIndex;

    names.length = that.namesByIndex.length;

    for (i.reset(that); i.next();) {
      var name = i.name;
      byName[name] = i.element;
      names[i.index] = name;
    }

    i.reset(null); // (!)

    return newMap;
  };
}();

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(129);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SCENE_PHASES = undefined;

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _stringify = __webpack_require__(47);

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _createReducer;

exports.reportError = reportError;
exports.useScene = useScene;
exports.getSceneId = getSceneId;
exports.loadScene = loadScene;
exports.errorLoadingScene = errorLoadingScene;
exports.markRenderingScene = markRenderingScene;
exports.markRenderedScene = markRenderedScene;
exports.prefetch = prefetch;
exports.getFetchedHash = getFetchedHash;
exports.fetch = fetch;
exports.savePublished = savePublished;
exports.fetchAndUse = fetchAndUse;
exports.fetchForEditing = fetchForEditing;
exports.loadingProgress = loadingProgress;
exports.isAssetLoading = isAssetLoading;
exports.areAssetsLoaded = areAssetsLoaded;
exports.areAssetsPreloaded = areAssetsPreloaded;
exports.isSceneLoaded = isSceneLoaded;
exports.isSceneRendered = isSceneRendered;
exports.markPreloaded = markPreloaded;
exports.preloadCommand = preloadCommand;
exports.markLoaded = markLoaded;
exports.markLoadingFile = markLoadingFile;
exports.markLoadedFile = markLoadedFile;
exports.convertFromJSON = convertFromJSON;
exports.writeScene = writeScene;
exports.exportJSON = exportJSON;
exports.numErrors = numErrors;
exports.getErrors = getErrors;
exports.getScenePhase = getScenePhase;
exports.whenLoaded = whenLoaded;
exports.clearScene = clearScene;

var _immutable = __webpack_require__(32);

var _createReducer2 = __webpack_require__(46);

var _createReducer3 = _interopRequireDefault(_createReducer2);

var _mapObjIndexed = __webpack_require__(106);

var _mapObjIndexed2 = _interopRequireDefault(_mapObjIndexed);

var _omit = __webpack_require__(485);

var _omit2 = _interopRequireDefault(_omit);

var _sceneGraph = __webpack_require__(10);

var _scene = __webpack_require__(7);

var _assets = __webpack_require__(33);

var _animation = __webpack_require__(67);

var _actionTypes = __webpack_require__(58);

var _apiBase = __webpack_require__(254);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Loading, reading, exporting of the scene.
 *
 * @module sceneIO
 * @public
 */

var LOADING_SCENEGRAPH = 'LOADING_SCENEGRAPH';
var LOADED_SCENEGRAPH = 'LOADED_SCENEGRAPH';
var ERROR_LOADING_SCENEGRAPH = 'ERROR_LOADING_SCENEGRAPH';
var RENDERING_SCENE = 'RENDERING_SCENE';
var RENDERED_SCENE = 'RENDERED_SCENE';
var PRELOADING_SCENE = 'PRELOADING_SCENE';
var LOADED_SCENE = 'LOADED_SCENE';
var SCENE_ERROR = 'SCENE_ERROR';
var PRELOAD_COMMAND = 'PRELOAD_COMMAND';
var SET_FETCHED_HASH = 'SET_FETCHED_HASH';
var SET_META = 'SET_META';

var SCENE_PHASES = exports.SCENE_PHASES = {
  FAILED: -1,
  UNKNOWN: 0,
  LOADING_SCENEGRAPH: 1,
  LOADED_SCENEGRAPH: 2,
  RENDERING: 3,
  PRELOADING: 4,
  PRELOADED: 5,
  LOADED: 6,
  RENDERED: 7
};

var initialState = (0, _immutable.Map)({
  id: null, // Active scene id
  errors: (0, _immutable.List)(), // List of scene errors
  phase: SCENE_PHASES.UNKNOWN,
  progress: 0,
  loadingFiles: (0, _immutable.Map)(),
  loadedFiles: (0, _immutable.Map)(),
  loaded: false,
  preloadCommands: (0, _immutable.List)(),
  fetchedHashes: (0, _immutable.Map)(),
  meta: (0, _immutable.Map)(), // { [id]: Map }
  fetchAssetsStart: null
});

function setProgress(state, createEvent) {
  if (state.get('phase') !== SCENE_PHASES.RENDERING) return state;

  var loadingFiles = state.get('loadingFiles').size;
  var loadedFiles = state.get('loadedFiles').size;
  var totalFiles = loadingFiles + loadedFiles;
  var progress = totalFiles === 0 ? 1 : (1 + loadedFiles / totalFiles) / 2;
  //console.log('progress: ', loadingFiles, loadedFiles, progress);

  if (progress < 1) {
    createEvent('loading', progress);
    return state.set('progress', progress);
  }

  createEvent('loading', 1);
  return state.set('progress', 1);
}

var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, _actionTypes.USE_SCENE, function (state, id) {
  return state.set('id', id).set('fetchAssetsStart', new Date());
}), (0, _defineProperty3.default)(_createReducer, LOADING_SCENEGRAPH, function (state, id) {
  var hasActiveScene = state.get('loaded') || state.get('id') && state.get('id') !== id;
  return hasActiveScene ? state : state.set('phase', SCENE_PHASES.LOADING_SCENEGRAPH).set('progress', 1 / 4);
}), (0, _defineProperty3.default)(_createReducer, LOADED_SCENEGRAPH, function (state, id) {
  var hasActiveScene = state.get('loaded') || state.get('id') && state.get('id') !== id;
  return hasActiveScene ? state : state.set('phase', SCENE_PHASES.LOADED_SCENEGRAPH).set('progress', 1 / 2);
}), (0, _defineProperty3.default)(_createReducer, ERROR_LOADING_SCENEGRAPH, function (state, xhr, _ref) {
  var action = _ref.action;
  var error = action.error,
      ignoreErrorMessage = action.ignoreErrorMessage;

  var msg = 'Error Loading Scene: ' + error.status + ' ' + error.statusText; //' + (error && error.response ? ': '+error.response : '');
  return ignoreErrorMessage ? state : state.updateIn(['errors'], (0, _immutable.List)(), function (list) {
    return list.push(msg);
  });
  //return state;
}), (0, _defineProperty3.default)(_createReducer, RENDERING_SCENE, function (state, payload, _ref2) {
  var createEvent = _ref2.createEvent;

  return setProgress(state.set('phase', SCENE_PHASES.RENDERING), createEvent);
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADING_FILE, function (state, id) {
  return state.setIn(['loadingFiles', id], true);
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADED_FILE, function (state, id, _ref3) {
  var createEvent = _ref3.createEvent;

  return setProgress(state.deleteIn(['loadingFiles', id]).setIn(['loadedFiles', id], true), createEvent);
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOADING_FILE_ERROR, function (state, id, _ref4) {
  var createEvent = _ref4.createEvent;

  return setProgress(state.deleteIn(['loadingFiles', id]), createEvent);
}), (0, _defineProperty3.default)(_createReducer, PRELOADING_SCENE, function (state, _, _ref5) {
  var createEvent = _ref5.createEvent;

  createEvent('preloading');
  return state.set('phase', SCENE_PHASES.PRELOADING);
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.PRELOADED_SCENE, function (state, _, _ref6) {
  var createEvent = _ref6.createEvent;

  createEvent('preloaded');
  return state.set('phase', SCENE_PHASES.PRELOADED);
}), (0, _defineProperty3.default)(_createReducer, PRELOAD_COMMAND, function (state, fn) {
  return state.updateIn(['preloadCommands'], (0, _immutable.List)(), function (list) {
    return list.push(fn);
  });
}), (0, _defineProperty3.default)(_createReducer, LOADED_SCENE, function (state, _, _ref7) {
  var createEvent = _ref7.createEvent,
      trackEvent = _ref7.trackEvent;

  createEvent('loaded');
  var loadedFiles = state.get('loadedFiles');
  var fetchAssetsStart = state.get('fetchAssetsStart');
  trackEvent('Assets Loaded', 'Number of loaded assets', loadedFiles.size);
  trackEvent('Assets Loaded', 'Assets loaded time', new Date() - fetchAssetsStart);
  return state.set('loaded', true).set('phase', SCENE_PHASES.LOADED);
}), (0, _defineProperty3.default)(_createReducer, RENDERED_SCENE, function (state, _, _ref8) {
  var createEvent = _ref8.createEvent;

  createEvent('rendered');
  return state.set('phase', SCENE_PHASES.RENDERED);
}), (0, _defineProperty3.default)(_createReducer, SCENE_ERROR, function (state, msg) {
  return state.updateIn(['errors'], (0, _immutable.List)(), function (list) {
    return list.push(msg);
  });
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state) {
  return initialState;
}), (0, _defineProperty3.default)(_createReducer, SET_FETCHED_HASH, function (state, _ref9) {
  var sceneId = _ref9.sceneId,
      fetchedHash = _ref9.fetchedHash;

  return state.setIn(['fetchedHashes', sceneId], fetchedHash);
}), (0, _defineProperty3.default)(_createReducer, SET_META, function (state, _ref10) {
  var id = _ref10.id,
      meta = _ref10.meta;

  return state.setIn(['meta', id], meta);
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOAD_SCENE, function (state, _ref11) {
  var id = _ref11.id,
      meta = _ref11.meta;

  return id && meta ? state.setIn(['meta', id], meta) : state;
}), _createReducer));

var threehubApiRoot = '/api/v2';

function reportError(msg) {
  return { type: SCENE_ERROR, payload: msg };
}

/**
 * sets the active scene.
 *
 * @param {string} id the scene uuid
 */
function useScene(id) {
  return { type: _actionTypes.USE_SCENE, payload: id };
}

/**
 * Returns the active scene Id
 *
 * @public
 * @returns {uuid}
 *
 */
function getSceneId(store) {
  return store.getIn(['sceneIO', 'id']);
}

/**
 * Loads the published scene
 *
 * @public
 * @param {string} id the scene uuid.
 * @param {string} transitString the published, exported scene
 * @returns {Promise}
 *
 */
function loadScene(id, transitString, loadTime) {
  return function (store) {
    var payload = store.read(transitString);
    store.trackEvent('SceneGraph Loaded', 'Load Time', loadTime);
    store.trackEvent('SceneGraph Loaded', 'File Size', transitString.length);
    var rate = Math.round(transitString.length / loadTime);
    store.trackEvent('SceneGraph Loaded', 'Download Rate', rate);
    store.logPageView('/player/v2/' + id, loadTime);
    var username = payload.meta && payload.meta.get('owner');
    if (username) store.trackEvent('Scene Owner', username);

    return store.dispatch({ type: _actionTypes.LOAD_SCENE, payload: payload })
    // careful, here be dragons -- only reading from the store is allowed in reducers, dont' dispatch
    .then(store.dispatch({ type: _actionTypes.INITIALIZE_SCENE, payload: { id: id, store: store } })).then(function () {
      return id;
    });
  };
}

function errorLoadingScene(id) {
  return reportError('Error Loading Scene');
}

function markRenderingScene() {
  return { type: RENDERING_SCENE };
}

function markRenderedScene() {
  return { type: RENDERED_SCENE };
}

var LOAD_SLOW_THRESHOLD = 10000;
var LOAD_FAIL_THRESHOLD = 30000;

/**
 * This will fetch the published scene, but will not do anything with it. This is useful
 * if you wish to warm the cache in order to speed up the loading of the next scene, without
 * loading the scene into memory.
 *
 * If `hash` is provided it will fetch directly from resources, otherwise it will fetch from
 * the api. By default, it will fetch the latest published version. If you
 *  wish to ensure you are fetching the latest scene version, set `waitForPublish: true`.
 *
 *  @public
 *  @param {uuid} sceneId
 *  @param {String} hash - md5 hash of published content (Optional)
 *  @param {Object} options
 *  @param {Boolean} options.waitForPublish Wait for the latest scene version to be published (default false);
 *
 */
function prefetch(sceneId, hash) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var wait = options.waitForPublish;
  var ignoreErrorMessage = options.ignoreErrorMessage;


  return function (store) {
    if (store.getIn(['sceneGraph', sceneId])) return _promise2.default.resolve(true);
    if (options.threehub) return store.dispatch(fetchFromThreehub(sceneId, options));

    var fetchedHash = hash;

    var fetch = hash ? (0, _assets.fetchText)(hash)(store) : store.callApi({
      contentType: 'text',
      types: ['IGN', 'IGN', ERROR_LOADING_SCENEGRAPH],
      url: "https://editor.vimarket.io/api" + '/scenes/' + sceneId + '/published?wait=' + (wait ? 'true' : 'false'),
      queryKey: 'SCENE' + sceneId,
      payload: sceneId,
      onReadyStateChange: onReadyStateChange,
      ignoreCache: true,
      ignoreErrorMessage: ignoreErrorMessage,
      responseURL: function responseURL(url) {
        var segments = url.split('/');
        fetchedHash = segments[segments.length - 1];
      }
    });

    function onReadyStateChange(xhr) {
      if (xhr.readyState > 1) {
        clearTimeout(slowLoadTimeout);
        clearTimeout(loadFailureTimeout);
      }
    }

    var slowLoadTimeout = setTimeout(function () {
      if (true) {
        store.error(new Error('Slow Load'), null, { sceneId: sceneId });
      } else {
        console.log('Slow Load');
      }
    }, LOAD_SLOW_THRESHOLD);

    var loadFailureTimeout = setTimeout(function () {
      if (true) {
        store.error(new Error('Load Failure'), null, { sceneId: sceneId });
      } else {
        console.log('Really Slow Load');
      }
    }, LOAD_FAIL_THRESHOLD);

    store.dispatch(markLoadingFile(sceneId));
    store.dispatch({ type: LOADING_SCENEGRAPH, payload: sceneId });
    return fetch.then(function (transit) {
      clearTimeout(slowLoadTimeout);
      clearTimeout(loadFailureTimeout);
      store.dispatch({ type: LOADED_SCENEGRAPH, payload: sceneId });
      store.dispatch(markLoadedFile(sceneId));
      store.dispatch({
        type: SET_FETCHED_HASH,
        payload: { sceneId: sceneId, fetchedHash: fetchedHash }
      });
      return transit;
    });
  };
}

function getFetchedHash(store, sceneId) {
  return store.getIn(['sceneIO', 'fetchedHashes', sceneId]);
}

/**
 * Fetch the scene
 *
 * If `hash` is provided it will fetch directly from resources, otherwise it will fetch from
 * the api. By default, it will fetch the latest published version. If you
 * wish to ensure you are fetching the latest scene version, set `waitForPublish: true`.
 *
 *  @public
 *  @param {uuid} sceneId
 *  @param {String} hash - md5 hash of published content (Optional)
 *  @param {Object} options
 *  @param {Boolean} options.waitForPublish Wait for the latest scene version to be published (default false);
 *
 */
function fetch(sceneId, hash) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var startTime = new Date();

  return function (store) {
    if (store.getIn(['sceneGraph', sceneId])) return _promise2.default.resolve(true);

    return store.dispatch(prefetch(sceneId, hash, options)).then(function (transit, responseHash) {
      return store.dispatch(loadScene(sceneId, transit, new Date() - startTime));
    });
  };
}

function fetchFromThreehub(sceneId, options) {
  return function (store) {
    // console.log('fetch from threehub', `${threehubApiRoot}/scene/${sceneId}`);
    return store.callApi({
      types: [LOADING_SCENEGRAPH, LOADED_SCENEGRAPH, ERROR_LOADING_SCENEGRAPH],
      url: threehubApiRoot + '/scene/' + sceneId,
      payload: sceneId
    }).then(function (result) {
      store.dispatch(useScene(sceneId));
      var HEAD = result.HEAD,
          objects = result.objects;

      store.dispatch((0, _sceneGraph.setContentStore)({ objects: objects, origin: { HEAD: HEAD } }));
      return store.dispatch((0, _sceneGraph.checkout)(HEAD));
    });
  };
}

function savePublished() {
  return function (store) {
    var transit = writeScene(store);
    var sceneId = getSceneId(store);

    return store.callApi({
      contentType: 'text',
      url: "https://editor.vimarket.io/api" + '/scenes/' + sceneId + '/published',
      method: 'PUT',
      body: (0, _stringify2.default)({ content: transit })
    });
  };
}

/**
 * Fetch, Load and Use published scene
 *
 * If `hash` is provided it will fetch directly from resources, otherwise it will fetch from
 * `/api/scenes/:uuid/published`.
 *
 *  @public
 *  @param {uuid} sceneId
 *  @param {String} hash - md5 hash of published content (Optional)
 *  @param {Object} options
 *  @param {Boolean} options.waitForPublish Wait for the latest scene version to be published (default false);
 *
 */
function fetchAndUse(sceneId, hash) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return function (store) {
    return store.dispatch(fetch(sceneId, hash, options)).then(function () {
      return store.dispatch(useScene(sceneId));
    });
  };
}

function watchScene(store, socketApi, sceneId) {
  var notifyChannel = socketApi.subscribe('notify:' + sceneId);
  notifyChannel.watch(function (info) {
    console.log('notify scene: ', sceneId, info);

    var origin = info.origin;

    if (origin && origin.HEAD !== sceneGraph.refs.HEAD) {
      console.log('sync to latest: ', origin.HEAD, 'from', sceneGraph.refs.HEAD);
      store.dispatch((0, _sceneGraph.syncToLatest)());
    }
  });
}

function fetchForEditing(sceneId) {
  return function (store) {
    var sceneGraph = store.get('sceneGraph');
    console.log('fetch for editing', sceneId);
    return store.dispatch(fetchAndUse(sceneId, null, { threehub: true })).then(function () {
      var socketApi = store.getSocketApi();
      if (socketApi) {
        watchScene(store, socketApi, sceneId);
      } else {
        // setInterval(() => {
        //   syncToLatest(store, sceneId);
        // }, 10000);
      }
    });
  };
}

function loadingProgress(_ref12) {
  var getIn = _ref12.getIn,
      dispatch = _ref12.dispatch;

  return getIn(['sceneIO', 'progress']);
}

function isAssetLoading(store, id) {
  return !!store.getIn(['sceneIO', 'loadingFiles', id]);
}

/*
 * Have preloaded commands run, and are all assets loaded
 */
function areAssetsLoaded(store) {
  return store.getIn(['sceneIO', 'phase']) >= SCENE_PHASES.PRELOADED && store.getIn(['sceneIO', 'loadingFiles']).size === 0;
}

/*
 * Are all assets loaded before preload commands are run
 */
function areAssetsPreloaded(store) {
  return store.getIn(['sceneIO', 'phase']) >= SCENE_PHASES.RENDERING && store.getIn(['sceneIO', 'loadingFiles']).size === 0;
}

function isSceneLoaded(store) {
  return store.getIn(['sceneIO', 'loaded']);
}

function isSceneRendered(store) {
  return store.getIn(['sceneIO', 'phase']) >= SCENE_PHASES.RENDERED;
}

function markPreloaded() {
  return function (store) {
    var mark = function mark() {
      return store.dispatch({
        type: _actionTypes.PRELOADED_SCENE,
        payload: { id: getSceneId(store), store: store }
      });
    };
    var preloadCommands = store.getIn(['sceneIO', 'preloadCommands']);
    if (!preloadCommands.size) return mark();

    store.dispatch({ type: PRELOADING_SCENE });

    _promise2.default.all(preloadCommands.map(function (fn) {
      return _promise2.default.resolve(fn());
    }).toArray()).then(function () {
      mark();
    }).catch(function (err) {
      console.log('Caught plugin error: ', err.message);
      console.log('Caught plugin error, stack: ', err.stack);
      mark();
    });
  };
}

function preloadCommand(fn) {
  return { type: PRELOAD_COMMAND, payload: fn };
}

function markLoaded() {
  return { type: LOADED_SCENE };
}

function markLoadingFile(id) {
  return { type: _actionTypes.LOADING_FILE, payload: id };
}

function markLoadedFile(id) {
  return { type: _actionTypes.LOADED_FILE, payload: id };
}

function convertPlugs(plugArray) {
  var plugs = {};
  plugArray.forEach(function (plug) {
    plugs[plug.type] = plug.operators.map(function (op) {
      var name = op.name;
      var type = op.type || name;
      return [type, (0, _omit2.default)(['_id', 'primitive', 'name', 'type'], op), name];
    });
  });
  return plugs;
}

var convertNode = function convertNode(store, sceneJSON, parent) {
  return function (json) {
    var id = json._id;
    var name = json.name;
    var type = json.type;

    var plugs = convertPlugs(json.plugs);

    store.dispatch((0, _sceneGraph.addNode)({ id: id, name: name, type: type, plugs: plugs, parent: parent }));

    json.nodes.forEach(convertNode(store, sceneJSON, id));
  };
};

function convertFiles(store, files) {
  files.forEach(function (file) {
    store.dispatch((0, _assets.addFile)((0, _assign2.default)({ id: file._id }, (0, _omit2.default)(['_id', '__v'], file))));
  });
}

function convertFromJSON(json) {
  return function (store) {
    convertNode(store, json, null)(json);
    convertFiles(store, json.files);
    store.dispatch(setMeta(json._id, (0, _immutable.Map)({ owner: json.owner })));

    var useBufferClips = (0, _scene.get)(store, {
      plug: 'Timeline',
      property: 'useBufferClips'
    });

    (0, _mapObjIndexed2.default)(function (clip, id) {
      if (!useBufferClips) store.dispatch((0, _animation.addClip)(clip, id));
      store.dispatch((0, _animation.makeReducedClip)(clip, id));
    }, json.clips);
  };
}

function writeScene(store) {
  var sceneGraph = (0, _sceneGraph.getEvalSceneGraph)(store);
  var id = getSceneId(store);

  return store.write({
    id: id,
    meta: getMeta(store),
    nodes: (0, _stringify2.default)(sceneGraph.nodes),
    assets: (0, _assets.getActiveAssets)(store),
    clips: store.getIn(['animation', 'clips']),
    bufferClips: store.getIn(['animation', 'bufferClips'])
  });
}

function exportJSON(store) {
  return {
    scene: store.get('sceneGraph').toJS(),
    assets: (0, _assets.getActiveAssets)(store).toJS()
  };
}

function numErrors(store) {
  return store.getIn(['sceneIO', 'errors']).size;
}

function getErrors(store) {
  return store.getIn(['sceneIO', 'errors']);
}

function getScenePhase(store) {
  return store.getIn(['sceneIO', 'phase']);
}

/**
 * This selector will return a promise that resolves when all assets in the
 * scene have been fetched and rendered.
 *
 * @param {Function=} callback If provided, will be called with the number of
 *   assets remaining to be loaded as the first argument.
 * @public
 *
 */
function whenLoaded(store, callback) {
  var fn = callback || function () {};
  var numLoading = 0;

  return new _promise2.default(function (resolve, reject) {
    // Force translation so that any assets that need to be fetched are queued.
    store.getEvaluatedTranslator();
    var check = function check() {
      if (!areAssetsLoaded(store)) {
        var nowLoading = store.getIn(['sceneIO', 'loadingFiles']).size;
        if (nowLoading !== numLoading) {
          fn(nowLoading);
          numLoading = nowLoading;
        }
        return setTimeout(check, 100);
      }
      // Ensure new assets have been translated.
      store.getEvaluatedTranslator();
      fn(0);
      resolve();
    };
    check();
  });
}

/**
 *  Clears current scene
 *
 *  @public
 *  @returns {Promise}
 */
function clearScene() {
  return function (store) {
    var translator = store.getTranslator();
    if (translator) translator.reset();
    (0, _apiBase.clearCache)();
    return store.dispatch({ type: _actionTypes.CLEAR_SCENE });
  };
}

function setMeta(id, meta) {
  return { type: SET_META, payload: { id: id, meta: meta } };
}

function getMeta(store, sceneId) {
  var id = sceneId || getSceneId(store);
  return store.getIn(['sceneIO', 'meta', id]);
}

var publicApi = {
  reducer: reducer,
  actions: {
    fetch: fetch,
    fetchAndUse: fetchAndUse,
    loadScene: loadScene,
    useScene: useScene,
    reportError: reportError,
    prefetch: prefetch,
    preloadCommand: preloadCommand,
    savePublished: savePublished,
    clearScene: clearScene
  },
  selectors: {
    getFetchedHash: getFetchedHash,
    isSceneLoaded: isSceneLoaded,
    isSceneRendered: isSceneRendered,
    loadingProgress: loadingProgress,
    getErrors: getErrors,
    numErrors: numErrors,
    getSceneId: getSceneId,
    writeScene: writeScene,
    whenLoaded: whenLoaded
  }
};
exports.default = publicApi;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
// Run-time checking of preconditions.

function fail(message) {
    throw new Error(message);
}

// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
function argument(predicate, message) {
    if (!predicate) {
        fail(message);
    }
}

exports.fail = fail;
exports.argument = argument;
exports.assert = argument;
exports.default = { fail: fail, argument: argument, assert: argument };

/***/ }),
/* 23 */
/***/ (function(module, exports) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = window.Util || {};

Util.MIN_TIMESTEP = 0.001;
Util.MAX_TIMESTEP = 1;

Util.base64 = function(mimeType, base64) {
  return 'data:' + mimeType + ';base64,' + base64;
};

Util.clamp = function(value, min, max) {
  return Math.min(Math.max(min, value), max);
};

Util.lerp = function(a, b, t) {
  return a + ((b - a) * t);
};

/**
 * Light polyfill for `Promise.race`. Returns
 * a promise that resolves when the first promise
 * provided resolves.
 *
 * @param {Array<Promise>} promises
 */
Util.race = function(promises) {
  if (Promise.race) {
    return Promise.race(promises);
  }

  return new Promise(function (resolve, reject) {
    for (var i = 0; i < promises.length; i++) {
      promises[i].then(resolve, reject);
    }
  });
};

Util.isIOS = (function() {
  var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
  return function() {
    return isIOS;
  };
})();

Util.isWebViewAndroid = (function() {
  var isWebViewAndroid = navigator.userAgent.indexOf('Version') !== -1 &&
      navigator.userAgent.indexOf('Android') !== -1 &&
      navigator.userAgent.indexOf('Chrome') !== -1;
  return function() {
    return isWebViewAndroid;
  };
})();

Util.isSafari = (function() {
  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  return function() {
    return isSafari;
  };
})();

Util.isFirefoxAndroid = (function() {
  var isFirefoxAndroid = navigator.userAgent.indexOf('Firefox') !== -1 &&
      navigator.userAgent.indexOf('Android') !== -1;
  return function() {
    return isFirefoxAndroid;
  };
})();

Util.isLandscapeMode = function() {
  return (window.orientation == 90 || window.orientation == -90);
};

// Helper method to validate the time steps of sensor timestamps.
Util.isTimestampDeltaValid = function(timestampDeltaS) {
  if (isNaN(timestampDeltaS)) {
    return false;
  }
  if (timestampDeltaS <= Util.MIN_TIMESTEP) {
    return false;
  }
  if (timestampDeltaS > Util.MAX_TIMESTEP) {
    return false;
  }
  return true;
};

Util.getScreenWidth = function() {
  return Math.max(window.screen.width, window.screen.height) *
      window.devicePixelRatio;
};

Util.getScreenHeight = function() {
  return Math.min(window.screen.width, window.screen.height) *
      window.devicePixelRatio;
};

Util.requestFullscreen = function(element) {
  if (Util.isWebViewAndroid()) {
      return false;
  }
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  } else {
    return false;
  }

  return true;
};

Util.exitFullscreen = function() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  } else {
    return false;
  }

  return true;
};

Util.getFullscreenElement = function() {
  return document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement ||
      document.msFullscreenElement;
};

Util.linkProgram = function(gl, vertexSource, fragmentSource, attribLocationMap) {
  // No error checking for brevity.
  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vertexSource);
  gl.compileShader(vertexShader);

  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fragmentSource);
  gl.compileShader(fragmentShader);

  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);

  for (var attribName in attribLocationMap)
    gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);

  gl.linkProgram(program);

  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);

  return program;
};

Util.getProgramUniforms = function(gl, program) {
  var uniforms = {};
  var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  var uniformName = '';
  for (var i = 0; i < uniformCount; i++) {
    var uniformInfo = gl.getActiveUniform(program, i);
    uniformName = uniformInfo.name.replace('[0]', '');
    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
  }
  return uniforms;
};

Util.orthoMatrix = function (out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right),
      bt = 1 / (bottom - top),
      nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
};

Util.copyArray = function (source, dest) {
  for (var i = 0, n = source.length; i < n; i++) {
    dest[i] = source[i];
  }
};

Util.isMobile = function() {
  var check = false;
  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
  return check;
};

Util.extend = function(dest, src) {
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      dest[key] = src[key];
    }
  }

  return dest;
}

Util.safariCssSizeWorkaround = function(canvas) {
  // TODO(smus): Remove this workaround when Safari for iOS is fixed.
  // iOS only workaround (for https://bugs.webkit.org/show_bug.cgi?id=152556).
  //
  // "To the last I grapple with thee;
  //  from hell's heart I stab at thee;
  //  for hate's sake I spit my last breath at thee."
  // -- Moby Dick, by Herman Melville
  if (Util.isIOS()) {
    var width = canvas.style.width;
    var height = canvas.style.height;
    canvas.style.width = (parseInt(width) + 1) + 'px';
    canvas.style.height = (parseInt(height)) + 'px';
    setTimeout(function() {
      canvas.style.width = width;
      canvas.style.height = height;
    }, 100);
  }

  // Debug only.
  window.Util = Util;
  window.canvas = canvas;
};

Util.isDebug = function() {
  return Util.getQueryParameter('debug');
};

Util.getQueryParameter = function(name) {
  var name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
      results = regex.exec(location.search);
  return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
};

Util.frameDataFromPose = (function() {
  var piOver180 = Math.PI / 180.0;
  var rad45 = Math.PI * 0.25;

  // Borrowed from glMatrix.
  function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov ? (fov.upDegrees * piOver180) : rad45),
    downTan = Math.tan(fov ? (fov.downDegrees * piOver180) : rad45),
    leftTan = Math.tan(fov ? (fov.leftDegrees * piOver180) : rad45),
    rightTan = Math.tan(fov ? (fov.rightDegrees * piOver180) : rad45),
    xScale = 2.0 / (leftTan + rightTan),
    yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
  }

  function mat4_fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
  };

  function mat4_translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
      a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
      a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

      out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
      out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
      out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  };

  function mat4_invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
  };

  var defaultOrientation = new Float32Array([0, 0, 0, 1]);
  var defaultPosition = new Float32Array([0, 0, 0]);

  function updateEyeMatrices(projection, view, pose, parameters, vrDisplay) {
    mat4_perspectiveFromFieldOfView(projection, parameters ? parameters.fieldOfView : null, vrDisplay.depthNear, vrDisplay.depthFar);

    var orientation = pose.orientation || defaultOrientation;
    var position = pose.position || defaultPosition;

    mat4_fromRotationTranslation(view, orientation, position);
    if (parameters)
      mat4_translate(view, view, parameters.offset);
    mat4_invert(view, view);
  }

  return function(frameData, pose, vrDisplay) {
    if (!frameData || !pose)
      return false;

    frameData.pose = pose;
    frameData.timestamp = pose.timestamp;

    updateEyeMatrices(
        frameData.leftProjectionMatrix, frameData.leftViewMatrix,
        pose, vrDisplay.getEyeParameters("left"), vrDisplay);
    updateEyeMatrices(
        frameData.rightProjectionMatrix, frameData.rightViewMatrix,
        pose, vrDisplay.getEyeParameters("right"), vrDisplay);

    return true;
  };
})();

Util.isInsideCrossDomainIFrame = function() {
  var isFramed = (window.self !== window.top);
  var refDomain = Util.getDomainFromUrl(document.referrer);
  var thisDomain = Util.getDomainFromUrl(window.location.href);

  return isFramed && (refDomain !== thisDomain);
};

// From http://stackoverflow.com/a/23945027.
Util.getDomainFromUrl = function(url) {
  var domain;
  // Find & remove protocol (http, ftp, etc.) and get domain.
  if (url.indexOf("://") > -1) {
    domain = url.split('/')[2];
  }
  else {
    domain = url.split('/')[0];
  }

  //find & remove port number
  domain = domain.split(':')[0];

  return domain;
}

module.exports = Util;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(509), __esModule: true };

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(177)('wks');
var uid = __webpack_require__(137);
var Symbol = __webpack_require__(29).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(12);
var IE8_DOM_DEFINE = __webpack_require__(285);
var toPrimitive = __webpack_require__(119);
var dP = Object.defineProperty;

exports.f = __webpack_require__(35) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _create = __webpack_require__(48);

var _create2 = _interopRequireDefault(_create);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _types = __webpack_require__(151);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @exports opentype.Table
 * @class
 * @param {string} tableName
 * @param {Array} fields
 * @param {Object} options
 * @constructor
 */
// Table metadata

function Table(tableName, fields, options) {
    for (var i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        this[field.name] = field.value;
    }

    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = (0, _keys2.default)(options);
        for (var _i = 0; _i < optionKeys.length; _i += 1) {
            var k = optionKeys[_i];
            var v = options[k];
            if (this[k] !== undefined) {
                this[k] = v;
            }
        }
    }
}

/**
 * Encodes the table and returns an array of bytes
 * @return {Array}
 */
Table.prototype.encode = function () {
    return _types.encode.TABLE(this);
};

/**
 * Get the size of the table.
 * @return {number}
 */
Table.prototype.sizeOf = function () {
    return _types.sizeOf.TABLE(this);
};

/**
 * @private
 */
function ushortList(itemName, list, count) {
    if (count === undefined) {
        count = list.length;
    }
    var fields = new Array(list.length + 1);
    fields[0] = { name: itemName + 'Count', type: 'USHORT', value: count };
    for (var i = 0; i < list.length; i++) {
        fields[i + 1] = { name: itemName + i, type: 'USHORT', value: list[i] };
    }
    return fields;
}

/**
 * @private
 */
function tableList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = new Array(count + 1);
    fields[0] = { name: itemName + 'Count', type: 'USHORT', value: count };
    for (var i = 0; i < count; i++) {
        fields[i + 1] = { name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i) };
    }
    return fields;
}

/**
 * @private
 */
function recordList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = [];
    fields[0] = { name: itemName + 'Count', type: 'USHORT', value: count };
    for (var i = 0; i < count; i++) {
        fields = fields.concat(itemCallback(records[i], i));
    }
    return fields;
}

// Common Layout Tables

/**
 * @exports opentype.Coverage
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */
function Coverage(coverageTable) {
    if (coverageTable.format === 1) {
        Table.call(this, 'coverageTable', [{ name: 'coverageFormat', type: 'USHORT', value: 1 }].concat(ushortList('glyph', coverageTable.glyphs)));
    } else {
        _check2.default.assert(false, 'Can\'t create coverage table format 2 yet.');
    }
}
Coverage.prototype = (0, _create2.default)(Table.prototype);
Coverage.prototype.constructor = Coverage;

function ScriptList(scriptListTable) {
    Table.call(this, 'scriptListTable', recordList('scriptRecord', scriptListTable, function (scriptRecord, i) {
        var script = scriptRecord.script;
        var defaultLangSys = script.defaultLangSys;
        _check2.default.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
        return [{ name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag }, { name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [{ name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [{ name: 'lookupOrder', type: 'USHORT', value: 0 }, { name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex }].concat(ushortList('featureIndex', defaultLangSys.featureIndexes))) }].concat(recordList('langSys', script.langSysRecords, function (langSysRecord, i) {
                var langSys = langSysRecord.langSys;
                return [{ name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag }, { name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [{ name: 'lookupOrder', type: 'USHORT', value: 0 }, { name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex }].concat(ushortList('featureIndex', langSys.featureIndexes))) }];
            }))) }];
    }));
}
ScriptList.prototype = (0, _create2.default)(Table.prototype);
ScriptList.prototype.constructor = ScriptList;

/**
 * @exports opentype.FeatureList
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */
function FeatureList(featureListTable) {
    Table.call(this, 'featureListTable', recordList('featureRecord', featureListTable, function (featureRecord, i) {
        var feature = featureRecord.feature;
        return [{ name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag }, { name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [{ name: 'featureParams', type: 'USHORT', value: feature.featureParams }].concat(ushortList('lookupListIndex', feature.lookupListIndexes))) }];
    }));
}
FeatureList.prototype = (0, _create2.default)(Table.prototype);
FeatureList.prototype.constructor = FeatureList;

/**
 * @exports opentype.LookupList
 * @class
 * @param {opentype.Table}
 * @param {Object}
 * @constructor
 * @extends opentype.Table
 */
function LookupList(lookupListTable, subtableMakers) {
    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function (lookupTable) {
        var subtableCallback = subtableMakers[lookupTable.lookupType];
        _check2.default.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
        return new Table('lookupTable', [{ name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType }, { name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag }].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
    }));
}
LookupList.prototype = (0, _create2.default)(Table.prototype);
LookupList.prototype.constructor = LookupList;

// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
// Don't use offsets inside Records (probable bug), only in Tables.
exports.default = {
    Table: Table,
    Record: Table,
    Coverage: Coverage,
    ScriptList: ScriptList,
    FeatureList: FeatureList,
    LookupList: LookupList,
    ushortList: ushortList,
    tableList: tableList,
    recordList: recordList
};

/***/ }),
/* 29 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(76);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _create = __webpack_require__(48);

var _create2 = _interopRequireDefault(_create);

exports.default = PolyMaps;

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _three = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PolyMaps() {
  _ObjectsByName2.default.call(this);
}

PolyMaps.prototype = (0, _create2.default)(_ObjectsByName2.default.prototype);
PolyMaps.prototype.constructor = PolyMaps;

// Pretty much an alias to ObjectsByName, adding a static interface
// and a custom iterator for uniform access of maps within a mesh...

(0, _assign2.default)(PolyMaps, {
  TypePosition: 1,
  TypeNormal: 2,
  TypeTangent: 4,
  TypeUV: 8,
  TypeColor: 16,

  id: function id(typeId, name) {
    var anchorName = PolyMaps.TypeInfo[typeId].AnchorName;
    return name != null ? anchorName + '.' + name : anchorName;
  },

  checkId: function checkId(id) {
    var anchorName = PolyMaps.getAnchorName(id);
    var mapName = PolyMaps.getMapName(id, anchorName);
    var typeInfo = PolyMaps.getTypeInfo(anchorName);

    if (typeInfo === null || mapName === '') throw Error("Invalid PolyMap ID '" + id + "'!");

    return id;
  },

  getAnchorName: function getAnchorName(id) {
    var dot = id.indexOf('.');
    return dot === -1 ? id : id.slice(0, dot);
  },

  getMapName: function getMapName(id, anchorName) {
    return id === anchorName ? null : id.slice(anchorName.length + 1);
  },

  getTypeInfo: function getTypeInfo(anchorName) {
    var info = PolyMaps.TypeInfo;
    for (var i = 0, n = info.length; i !== n; ++i) {
      var entry = info[i];
      if (entry !== null && entry.AnchorName === anchorName) return info[i];
    }

    return null;
  },

  resolveMap: function resolveMap(mesh, id) {
    var anchorName = PolyMaps.getAnchorName(id);
    if (id === anchorName) return mesh[anchorName];

    var maps = mesh[anchorName];
    return maps && maps.byName[id.slice(anchorName.length + 1)];
  },

  assignMap: function assignMap(mesh, id, map) {
    var anchorName = PolyMaps.getAnchorName(id);
    var mapName = PolyMaps.getMapName(id, anchorName);

    if (mapName === null) {
      mesh[anchorName] = map;
    } else {
      var maps = mesh[anchorName];

      if (!maps) {
        maps = new PolyMaps();
        mesh[anchorName] = maps;
      }

      maps.set(mapName, map);
    }
  },

  Iterator: function Iterator(mesh) {
    _ObjectsByName2.default.Iterator.call(this);
    this.reset(mesh || null);
  }
});

PolyMaps.TypeInfo = [null, {
  // 1
  Type: PolyMaps.TypePosition,
  AnchorName: 'positions',
  ElementType: _three.Vector3
}, {
  // 2
  Type: PolyMaps.TypeNormal,
  AnchorName: 'normalMap',
  ElementType: _three.Vector3
}, null, {
  // 4
  Type: PolyMaps.TypeTangent,
  AnchorName: 'tangentMap',
  ElementType: _three.Vector4
}, null, null, null, {
  // 8
  Type: PolyMaps.TypeUV,
  AnchorName: 'uvMaps',
  ElementType: _three.Vector2
}, null, null, null, null, null, null, null, {
  Type: PolyMaps.TypeColor,
  AnchorName: 'colorMaps',
  ElementType: _three.Color
}];

(0, _assign2.default)(PolyMaps, {
  IdPositions: PolyMaps.id(PolyMaps.TypePosition),
  IdNormals: PolyMaps.id(PolyMaps.TypeNormal),
  IdTangents: PolyMaps.id(PolyMaps.TypeTangent)
});

PolyMaps.Iterator.prototype = (0, _assign2.default)((0, _create2.default)(_ObjectsByName2.default.Iterator.prototype), {
  constructor: PolyMaps.Iterator,
  _super: _ObjectsByName2.default.Iterator.prototype,

  reset: function reset(optionalMesh) {
    this._super.reset.call(this, null);

    var mesh = optionalMesh || null;
    this.mesh = mesh;
    this.byName = mesh;
    this.typeId = 0;
  },

  getId: function getId() {
    return PolyMaps.id(this.typeId, this.name);
  },

  next: function next() {
    // Note: Not using dynamic resolution here because it may impact
    // compiler optimizations in a negative way.

    // If iterating a collection, keep going:

    if (this._super.next.call(this)) return true;

    // Otherwise count up the id:

    var mesh = this.mesh;
    var type = this.typeId;

    var elem = null;
    var object = null;

    type <<= 1;

    switch (type) {
      case 0:
        type = 1;
      // v-v-v

      case PolyMaps.TypePosition:
        elem = mesh.positions;
        break;

      case PolyMaps.TypeNormal:
        elem = mesh.normalMap;
        break;

      case PolyMaps.TypeTangent:
        elem = mesh.tangentMap;
        break;

      case PolyMaps.TypeUV:
        object = mesh.uvMaps;
        break;

      case PolyMaps.TypeColor:
        object = mesh.colorMaps;
        break;

      default:
        this.reset(null);
        return false;
    }

    this.typeId = type;

    if (object !== null && object !== undefined) {
      this.byName = object.byName;
      return this._super.reset.call(this, object).next();
    } else if (elem !== null && elem !== undefined) {
      this.element = elem;
      this.index = type;
      this.name = null;
      return true;
    }

    return this.next();
  }
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/**
 *  Copyright (c) 2014-2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

(function (global, factory) {
   true ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Immutable = factory());
}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

  function createClass(ctor, superClass) {
    if (superClass) {
      ctor.prototype = Object.create(superClass.prototype);
    }
    ctor.prototype.constructor = ctor;
  }

  function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }


  createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }


  createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }


  createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }



  function isIterable(maybeIterable) {
    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  }

  function isKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  }

  function isIndexed(maybeIndexed) {
    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  function isOrdered(maybeOrdered) {
    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  }

  Iterable.isIterable = isIterable;
  Iterable.isKeyed = isKeyed;
  Iterable.isIndexed = isIndexed;
  Iterable.isAssociative = isAssociative;
  Iterable.isOrdered = isOrdered;

  Iterable.Keyed = KeyedIterable;
  Iterable.Indexed = IndexedIterable;
  Iterable.Set = SetIterable;


  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  // Used for setting prototype methods that IE8 chokes on.
  var DELETE = 'delete';

  // Constants describing the size of trie nodes.
  var SHIFT = 5; // Resulted in best performance after ______?
  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1;

  // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.
  var NOT_SET = {};

  // Boolean references, Rough equivalent of `bool &`.
  var CHANGE_LENGTH = { value: false };
  var DID_ALTER = { value: false };

  function MakeRef(ref) {
    ref.value = false;
    return ref;
  }

  function SetRef(ref) {
    ref && (ref.value = true);
  }

  // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.
  function OwnerID() {}

  // http://jsperf.com/copy-array-inline
  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }
    return newArr;
  }

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^321.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }
      index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (begin === 0 || (size !== undefined && begin <= -size)) &&
      (end === undefined || (size !== undefined && end >= size));
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    return index === undefined ?
      defaultIndex :
      index < 0 ?
        Math.max(0, size + index) :
        size === undefined ?
          index :
          Math.min(size, index);
  }

  /* global Symbol */

  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;

  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


  function Iterator(next) {
      this.next = next;
    }

    Iterator.prototype.toString = function() {
      return '[Iterator]';
    };


  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect =
  Iterator.prototype.toSource = function () { return this.toString(); }
  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };


  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
      value: value, done: false
    });
    return iteratorResult;
  }

  function iteratorDone() {
    return { value: undefined, done: true };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn = iterable && (
      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]
    );
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isArrayLike(value) {
    return value && typeof value.length === 'number';
  }

  createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() :
        isIterable(value) ? value.toSeq() : seqFromValue(value);
    }

    Seq.of = function(/*...values*/) {
      return Seq(arguments);
    };

    Seq.prototype.toSeq = function() {
      return this;
    };

    Seq.prototype.toString = function() {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, true);
    };



  createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ?
        emptySequence().toKeyedSeq() :
        isIterable(value) ?
          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
          keyedSeqFromValue(value);
    }

    KeyedSeq.prototype.toKeyedSeq = function() {
      return this;
    };



  createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }

    IndexedSeq.of = function(/*...values*/) {
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function() {
      return this;
    };

    IndexedSeq.prototype.toString = function() {
      return this.__toString('Seq [', ']');
    };

    IndexedSeq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };

    IndexedSeq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, false);
    };



  createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (
        value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value
      ).toSetSeq();
    }

    SetSeq.of = function(/*...values*/) {
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function() {
      return this;
    };



  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;

  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

  Seq.prototype[IS_SEQ_SENTINEL] = true;



  createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    ArraySeq.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function(fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ArraySeq.prototype.__iterator = function(type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(function() 
        {return ii > maxIndex ?
          iteratorDone() :
          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
      );
    };



  createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    ObjectSeq.prototype.get = function(key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };

    ObjectSeq.prototype.__iterate = function(fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ObjectSeq.prototype.__iterator = function(type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, key, object[key]);
      });
    };

  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }

    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };



  createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }

    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };

    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function()  {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };




  // # pragma Helper functions

  function isSeq(maybeSeq) {
    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  }

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq =
      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
      typeof value === 'object' ? new ObjectSeq(value) :
      undefined;
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of [k, v] entries, '+
        'or keyed object: ' + value
      );
    }
    return seq;
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values: ' + value
      );
    }
    return seq;
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value) ||
      (typeof value === 'object' && new ObjectSeq(value));
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values, or keyed object: ' + value
      );
    }
    return seq;
  }

  function maybeIndexedSeqFromValue(value) {
    return (
      isArrayLike(value) ? new ArraySeq(value) :
      isIterator(value) ? new IteratorSeq(value) :
      hasIterator(value) ? new IterableSeq(value) :
      undefined
    );
  }

  function seqIterate(seq, fn, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var entry = cache[reverse ? maxIndex - ii : ii];
        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
          return ii + 1;
        }
      }
      return ii;
    }
    return seq.__iterateUncached(fn, reverse);
  }

  function seqIterator(seq, type, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var entry = cache[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
      });
    }
    return seq.__iteratorUncached(type, reverse);
  }

  function fromJS(json, converter) {
    return converter ?
      fromJSWith(converter, json, '', {'': json}) :
      fromJSDefault(json);
  }

  function fromJSWith(converter, json, key, parentJSON) {
    if (Array.isArray(json)) {
      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    if (isPlainObj(json)) {
      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    return json;
  }

  function fromJSDefault(json) {
    if (Array.isArray(json)) {
      return IndexedSeq(json).map(fromJSDefault).toList();
    }
    if (isPlainObj(json)) {
      return KeyedSeq(json).map(fromJSDefault).toMap();
    }
    return json;
  }

  function isPlainObj(value) {
    return value && (value.constructor === Object || value.constructor === undefined);
  }

  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if the it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections implement `equals` and `hashCode`.
   *
   */
  function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
    if (typeof valueA.valueOf === 'function' &&
        typeof valueB.valueOf === 'function') {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
    }
    if (typeof valueA.equals === 'function' &&
        typeof valueB.equals === 'function' &&
        valueA.equals(valueB)) {
      return true;
    }
    return false;
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (
      !isIterable(b) ||
      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
      isKeyed(a) !== isKeyed(b) ||
      isIndexed(a) !== isIndexed(b) ||
      isOrdered(a) !== isOrdered(b)
    ) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return b.every(function(v, k)  {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done;
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;
    var bSize = b.__iterate(function(v, k)  {
      if (notAssociative ? !a.has(v) :
          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  createClass(Repeat, IndexedSeq);

    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    Repeat.prototype.toString = function() {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function(searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this :
        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };

    Repeat.prototype.reverse = function() {
      return this;
    };

    Repeat.prototype.indexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function(fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
      var ii = 0;
      return new Iterator(function() 
        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
      );
    };

    Repeat.prototype.equals = function(other) {
      return other instanceof Repeat ?
        is(this._value, other._value) :
        deepEqual(other);
    };


  var EMPTY_REPEAT;

  function invariant(condition, error) {
    if (!condition) throw new Error(error);
  }

  createClass(Range, IndexedSeq);

    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    Range.prototype.toString = function() {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' +
        this._start + '...' + this._end +
        (this._step !== 1 ? ' by ' + this._step : '') +
      ' ]';
    };

    Range.prototype.get = function(index, notSetValue) {
      return this.has(index) ?
        this._start + wrapIndex(this, index) * this._step :
        notSetValue;
    };

    Range.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 &&
        possibleIndex < this.size &&
        possibleIndex === Math.floor(possibleIndex);
    };

    Range.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };

    Range.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function(fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };

    Range.prototype.__iterator = function(type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function()  {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };

    Range.prototype.equals = function(other) {
      return other instanceof Range ?
        this._start === other._start &&
        this._end === other._end &&
        this._step === other._step :
        deepEqual(this, other);
    };


  var EMPTY_RANGE;

  createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }


  createClass(KeyedCollection, Collection);function KeyedCollection() {}

  createClass(IndexedCollection, Collection);function IndexedCollection() {}

  createClass(SetCollection, Collection);function SetCollection() {}


  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;

  var imul =
    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
    Math.imul :
    function imul(a, b) {
      a = a | 0; // int
      b = b | 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
    };

  // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.
  function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }
    if (typeof o.valueOf === 'function') {
      o = o.valueOf();
      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }
    if (o === true) {
      return 1;
    }
    var type = typeof o;
    if (type === 'number') {
      if (o !== o || o === Infinity) {
        return 0;
      }
      var h = o | 0;
      if (h !== o) {
        h ^= o * 0xFFFFFFFF;
      }
      while (o > 0xFFFFFFFF) {
        o /= 0xFFFFFFFF;
        h ^= o;
      }
      return smi(h);
    }
    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
    }
    if (typeof o.hashCode === 'function') {
      return o.hashCode();
    }
    if (type === 'object') {
      return hashJSObj(o);
    }
    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }
    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hash = stringHashCache[string];
    if (hash === undefined) {
      hash = hashString(string);
      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }
      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hash;
    }
    return hash;
  }

  // http://jsperf.com/hashing-strings
  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hash = 0;
    for (var ii = 0; ii < string.length; ii++) {
      hash = 31 * hash + string.charCodeAt(ii) | 0;
    }
    return smi(hash);
  }

  function hashJSObj(obj) {
    var hash;
    if (usingWeakMap) {
      hash = weakMap.get(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = obj[UID_HASH_KEY];
    if (hash !== undefined) {
      return hash;
    }

    if (!canDefineProperty) {
      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }

      hash = getIENodeHash(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = ++objHashUID;
    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hash);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': hash
      });
    } else if (obj.propertyIsEnumerable !== undefined &&
               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function() {
        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
      };
      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hash;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hash;
  }

  // Get references to ES5 object methods.
  var isExtensible = Object.isExtensible;

  // True if Object.defineProperty works as expected. IE8 fails this test.
  var canDefineProperty = (function() {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  }());

  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.
  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1: // Element
          return node.uniqueID;
        case 9: // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  }

  // If possible, use a WeakMap.
  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;
  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;

  var UID_HASH_KEY = '__immutablehash__';
  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  function assertNotInfinite(size) {
    invariant(
      size !== Infinity,
      'Cannot perform this action with an infinite size.'
    );
  }

  createClass(Map, KeyedCollection);

    // @pragma Construction

    function Map(value) {
      return value === null || value === undefined ? emptyMap() :
        isMap(value) && !isOrdered(value) ? value :
        emptyMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
      return emptyMap().withMutations(function(map ) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };

    Map.prototype.toString = function() {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function(k, notSetValue) {
      return this._root ?
        this._root.get(0, undefined, k, notSetValue) :
        notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function(k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function()  {return v});
    };

    Map.prototype.remove = function(k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function()  {return NOT_SET});
    };

    Map.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ?
        k(this) :
        this.updateIn([k], notSetValue, updater);
    };

    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(
        this,
        forceIterator(keyPath),
        notSetValue,
        updater
      );
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };

    Map.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.merge = function(/*...iters*/) {
      return mergeIntoMapWith(this, undefined, arguments);
    };

    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };

    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.merge === 'function' ?
          m.merge.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };

    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };

    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.mergeDeep === 'function' ?
          m.mergeDeep.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.sort = function(comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    // @pragma Mutability

    Map.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };

    Map.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };

    Map.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };

    Map.prototype.wasAltered = function() {
      return this.__altered;
    };

    Map.prototype.__iterator = function(type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry ) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };


  function isMap(maybeMap) {
    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  }

  Map.isMap = isMap;

  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SENTINEL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeIn = MapPrototype.deleteIn;


  // #pragma Trie Nodes



    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }

    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && entries.length === 1) {
        return; // undefined
      }

      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new ArrayMapNode(ownerID, newEntries);
    };




    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }

    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue :
        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
    };

    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;

      if (!exists && value === NOT_SET) {
        return this;
      }

      var idx = popCount(bitmap & (bit - 1));
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

      if (newNode === node) {
        return this;
      }

      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }

      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }

      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ?
        setIn(nodes, idx, newNode, isEditable) :
        spliceOut(nodes, idx, isEditable) :
        spliceIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }

      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };




    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }

    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };

    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];

      if (removed && !node) {
        return this;
      }

      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }

      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }

      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };




    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }

    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }

      var removed = value === NOT_SET;

      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };




    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }

    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };

    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }

      SetRef(didAlter);

      if (removed) {
        SetRef(didChangeSize);
        return; // undefined
      }

      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }

      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };



  // #pragma Iterators

  ArrayMapNode.prototype.iterate =
  HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;
    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  }

  BitmapIndexedNode.prototype.iterate =
  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  }

  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  }

  createClass(MapIterator, Iterator);

    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    MapIterator.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };


  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;
  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }
      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef(CHANGE_LENGTH);
      var didAlter = MakeRef(DID_ALTER);
      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
      if (!didAlter.value) {
        return map;
      }
      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }
    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  }

  function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

    var newNode;
    var nodes = idx1 === idx2 ?
      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];
      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function mergeIntoMapWith(map, merger, iterables) {
    var iters = [];
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = KeyedIterable(value);
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    return mergeIntoCollectionWith(map, merger, iters);
  }

  function deepMerger(existing, value, key) {
    return existing && existing.mergeDeep && isIterable(value) ?
      existing.mergeDeep(value) :
      is(existing, value) ? existing : value;
  }

  function deepMergerWith(merger) {
    return function(existing, value, key)  {
      if (existing && existing.mergeDeepWith && isIterable(value)) {
        return existing.mergeDeepWith(merger, value);
      }
      var nextValue = merger(existing, value, key);
      return is(existing, nextValue) ? existing : nextValue;
    };
  }

  function mergeIntoCollectionWith(collection, merger, iters) {
    iters = iters.filter(function(x ) {return x.size !== 0});
    if (iters.length === 0) {
      return collection;
    }
    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
      return collection.constructor(iters[0]);
    }
    return collection.withMutations(function(collection ) {
      var mergeIntoMap = merger ?
        function(value, key)  {
          collection.update(key, NOT_SET, function(existing )
            {return existing === NOT_SET ? value : merger(existing, value, key)}
          );
        } :
        function(value, key)  {
          collection.set(key, value);
        }
      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoMap);
      }
    });
  }

  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
    var isNotSet = existing === NOT_SET;
    var step = keyPathIter.next();
    if (step.done) {
      var existingValue = isNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }
    invariant(
      isNotSet || (existing && existing.set),
      'invalid keyPath'
    );
    var key = step.value;
    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
    var nextUpdated = updateInDeepMap(
      nextExisting,
      keyPathIter,
      notSetValue,
      updater
    );
    return nextUpdated === nextExisting ? existing :
      nextUpdated === NOT_SET ? existing.remove(key) :
      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  }

  function popCount(x) {
    x = x - ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x7f;
  }

  function setIn(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }
    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }
      newArray[ii] = array[ii + after];
    }
    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  createClass(List, IndexedCollection);

    // @pragma Construction

    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function(list ) {
        list.setSize(size);
        iter.forEach(function(v, i)  {return list.set(i, v)});
      });
    }

    List.of = function(/*...values*/) {
      return this(arguments);
    };

    List.prototype.toString = function() {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function(index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function(index) {
      return !this.has(index) ? this :
        index === 0 ? this.shift() :
        index === this.size - 1 ? this.pop() :
        this.splice(index, 1);
    };

    List.prototype.insert = function(index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function(/*...values*/) {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list ) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function() {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function(/*...values*/) {
      var values = arguments;
      return this.withMutations(function(list ) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function() {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.merge = function(/*...iters*/) {
      return mergeIntoListWith(this, undefined, arguments);
    };

    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };

    List.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoListWith(this, deepMerger, arguments);
    };

    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };

    List.prototype.setSize = function(size) {
      return setListBounds(this, 0, size);
    };

    // @pragma Iteration

    List.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };

    List.prototype.__iterator = function(type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function()  {
        var value = values();
        return value === DONE ?
          iteratorDone() :
          iteratorValue(type, index++, value);
      });
    };

    List.prototype.__iterate = function(fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };


  function isList(maybeList) {
    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  }

  List.isList = isList;

  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SENTINEL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.setIn = MapPrototype.setIn;
  ListPrototype.deleteIn =
  ListPrototype.removeIn = MapPrototype.removeIn;
  ListPrototype.update = MapPrototype.update;
  ListPrototype.updateIn = MapPrototype.updateIn;
  ListPrototype.mergeIn = MapPrototype.mergeIn;
  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  ListPrototype.withMutations = MapPrototype.withMutations;
  ListPrototype.asMutable = MapPrototype.asMutable;
  ListPrototype.asImmutable = MapPrototype.asImmutable;
  ListPrototype.wasAltered = MapPrototype.wasAltered;



    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }

    // TODO: seems like these methods are very similar

    VNode.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level : 0 || this.array.length === 0) {
        return this;
      }
      var originIndex = (index >>> level) & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };

    VNode.prototype.removeAfter = function(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = ((index - 1) >>> level) & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }

      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }

      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };



  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;

    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0 ?
        iterateLeaf(node, offset) :
        iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : (left - offset) >> level;
      var to = ((right - offset) >> level) + 1;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        do {
          if (values) {
            var value = values();
            if (value !== DONE) {
              return value;
            }
            values = null;
          }
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(
            array && array[idx], level - SHIFT, offset + (idx << level)
          );
        } while (true);
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;
  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function(list ) {
        index < 0 ?
          setListBounds(list, index).set(0, value) :
          setListBounds(list, 0, index + 1).set(index, value)
      });
    }

    index += list._origin;

    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef(DID_ALTER);
    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
      if (newLowerNode === lowerNode) {
        return node;
      }
      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    SetRef(didAlter);

    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }
    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
      var node = list._root;
      var level = list._level;
      while (node && level > 0) {
        node = node.array[(rawIndex >>> level) & MASK];
        level -= SHIFT;
      }
      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      end = end | 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    }

    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root;

    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);

    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
      newLevel += SHIFT;
    }

    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset ?
      listNodeFor(list, newCapacity - 1) :
      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

    // Merge Tail into tree.
    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;
      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = (oldTailOffset >>> level) & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }
      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }

    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }

    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0;

      // Identify the new top root node of the subtree of the old root.
      while (newRoot) {
        var beginIndex = (newOrigin >>> newLevel) & MASK;
        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
          break;
        }
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      }

      // Trim the new sides of the new root.
      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }
      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
      }
      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function mergeIntoListWith(list, merger, iterables) {
    var iters = [];
    var maxSize = 0;
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = IndexedIterable(value);
      if (iter.size > maxSize) {
        maxSize = iter.size;
      }
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    if (maxSize > list.size) {
      list = list.setSize(maxSize);
    }
    return mergeIntoCollectionWith(list, merger, iters);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
  }

  createClass(OrderedMap, Map);

    // @pragma Construction

    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() :
        isOrderedMap(value) ? value :
        emptyOrderedMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    OrderedMap.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedMap.prototype.toString = function() {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function(k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function(k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };

    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._list.__iterate(
        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
        reverse
      );
    };

    OrderedMap.prototype.__iterator = function(type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };


  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  OrderedMap.isOrderedMap = isOrderedMap;

  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;
  function emptyOrderedMap() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) { // removed
      if (!has) {
        return omap;
      }
      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else {
      if (has) {
        if (v === list.get(i)[1]) {
          return omap;
        }
        newMap = map;
        newList = list.set(i, [k, v]);
      } else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
      }
    }
    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }
    return makeOrderedMap(newMap, newList);
  }

  createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    ToKeyedSequence.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function(key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var ii;
      return this._iter.__iterate(
        this._useKeys ?
          function(v, k)  {return fn(v, k, this$0)} :
          ((ii = reverse ? resolveSize(this) : 0),
            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
        reverse
      );
    };

    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };

  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToIndexedSequence.prototype.includes = function(value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
    };

    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, iterations++, step.value, step)
      });
    };



  createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToSetSequence.prototype.has = function(key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
    };

    ToSetSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, step.value, step.value, step);
      });
    };



  createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    FromEntriesSequence.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(entry ) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(
            indexedIterable ? entry.get(1) : entry[1],
            indexedIterable ? entry.get(0) : entry[0],
            this$0
          );
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(
              type,
              indexedIterable ? entry.get(0) : entry[0],
              indexedIterable ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };


  ToIndexedSequence.prototype.cacheResult =
  ToKeyedSequence.prototype.cacheResult =
  ToSetSequence.prototype.cacheResult =
  FromEntriesSequence.prototype.cacheResult =
    cacheResultThrough;


  function flipFactory(iterable) {
    var flipSequence = makeSequence(iterable);
    flipSequence._iter = iterable;
    flipSequence.size = iterable.size;
    flipSequence.flip = function()  {return iterable};
    flipSequence.reverse = function () {
      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
      reversedSequence.flip = function()  {return iterable.reverse()};
      return reversedSequence;
    };
    flipSequence.has = function(key ) {return iterable.includes(key)};
    flipSequence.includes = function(key ) {return iterable.has(key)};
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
    }
    flipSequence.__iteratorUncached = function(type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = iterable.__iterator(type, reverse);
        return new Iterator(function()  {
          var step = iterator.next();
          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }
          return step;
        });
      }
      return iterable.__iterator(
        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
        reverse
      );
    }
    return flipSequence;
  }


  function mapFactory(iterable, mapper, context) {
    var mappedSequence = makeSequence(iterable);
    mappedSequence.size = iterable.size;
    mappedSequence.has = function(key ) {return iterable.has(key)};
    mappedSequence.get = function(key, notSetValue)  {
      var v = iterable.get(key, NOT_SET);
      return v === NOT_SET ?
        notSetValue :
        mapper.call(context, v, key, iterable);
    };
    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(
        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
        reverse
      );
    }
    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        return iteratorValue(
          type,
          key,
          mapper.call(context, entry[1], key, iterable),
          step
        );
      });
    }
    return mappedSequence;
  }


  function reverseFactory(iterable, useKeys) {
    var reversedSequence = makeSequence(iterable);
    reversedSequence._iter = iterable;
    reversedSequence.size = iterable.size;
    reversedSequence.reverse = function()  {return iterable};
    if (iterable.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(iterable);
        flipSequence.reverse = function()  {return iterable.flip()};
        return flipSequence;
      };
    }
    reversedSequence.get = function(key, notSetValue) 
      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
    reversedSequence.has = function(key )
      {return iterable.has(useKeys ? key : -1 - key)};
    reversedSequence.includes = function(value ) {return iterable.includes(value)};
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
    };
    reversedSequence.__iterator =
      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
    return reversedSequence;
  }


  function filterFactory(iterable, predicate, context, useKeys) {
    var filterSequence = makeSequence(iterable);
    if (useKeys) {
      filterSequence.has = function(key ) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
      };
      filterSequence.get = function(key, notSetValue)  {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
          v : notSetValue;
      };
    }
    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      }, reverse);
      return iterations;
    };
    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          var value = entry[1];
          if (predicate.call(context, value, key, iterable)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    }
    return filterSequence;
  }


  function countByFactory(iterable, grouper, context) {
    var groups = Map().asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        0,
        function(a ) {return a + 1}
      );
    });
    return groups.asImmutable();
  }


  function groupByFactory(iterable, grouper, context) {
    var isKeyedIter = isKeyed(iterable);
    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
      );
    });
    var coerce = iterableClass(iterable);
    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
  }


  function sliceFactory(iterable, begin, end, useKeys) {
    var originalSize = iterable.size;

    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      if (end === Infinity) {
        end = originalSize;
      } else {
        end = end | 0;
      }
    }

    if (wholeSlice(begin, end, originalSize)) {
      return iterable;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);

    // begin or end will be NaN if they were provided as negative numbers and
    // this iterable's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
    }

    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(iterable);

    // If iterable.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize ?
          iterable.get(index + resolvedBegin, notSetValue) :
          notSetValue;
      }
    }

    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (sliceSize === 0) {
        return 0;
      }
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k)  {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
                 iterations !== sliceSize;
        }
      });
      return iterations;
    };

    sliceSeq.__iteratorUncached = function(type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      // Don't bother instantiating parent iterator if taking 0.
      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
      var skipped = 0;
      var iterations = 0;
      return new Iterator(function()  {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }
        if (++iterations > sliceSize) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (useKeys || type === ITERATE_VALUES) {
          return step;
        } else if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        } else {
          return iteratorValue(type, iterations - 1, step.value[1], step);
        }
      });
    }

    return sliceSeq;
  }


  function takeWhileFactory(iterable, predicate, context) {
    var takeSequence = makeSequence(iterable);
    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      iterable.__iterate(function(v, k, c) 
        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
      );
      return iterations;
    };
    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterating = true;
      return new Iterator(function()  {
        if (!iterating) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var k = entry[0];
        var v = entry[1];
        if (!predicate.call(context, v, k, this$0)) {
          iterating = false;
          return iteratorDone();
        }
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return takeSequence;
  }


  function skipWhileFactory(iterable, predicate, context, useKeys) {
    var skipSequence = makeSequence(iterable);
    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      });
      return iterations;
    };
    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var skipping = true;
      var iterations = 0;
      return new Iterator(function()  {
        var step, k, v;
        do {
          step = iterator.next();
          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            } else if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            } else {
              return iteratorValue(type, iterations++, step.value[1], step);
            }
          }
          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$0));
        } while (skipping);
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return skipSequence;
  }


  function concatFactory(iterable, values) {
    var isKeyedIterable = isKeyed(iterable);
    var iters = [iterable].concat(values).map(function(v ) {
      if (!isIterable(v)) {
        v = isKeyedIterable ?
          keyedSeqFromValue(v) :
          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedIterable) {
        v = KeyedIterable(v);
      }
      return v;
    }).filter(function(v ) {return v.size !== 0});

    if (iters.length === 0) {
      return iterable;
    }

    if (iters.length === 1) {
      var singleton = iters[0];
      if (singleton === iterable ||
          isKeyedIterable && isKeyed(singleton) ||
          isIndexed(iterable) && isIndexed(singleton)) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);
    if (isKeyedIterable) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(iterable)) {
      concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(
      function(sum, seq)  {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      },
      0
    );
    return concatSeq;
  }


  function flattenFactory(iterable, depth, useKeys) {
    var flatSequence = makeSequence(iterable);
    flatSequence.__iterateUncached = function(fn, reverse) {
      var iterations = 0;
      var stopped = false;
      function flatDeep(iter, currentDepth) {var this$0 = this;
        iter.__iterate(function(v, k)  {
          if ((!depth || currentDepth < depth) && isIterable(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
            stopped = true;
          }
          return !stopped;
        }, reverse);
      }
      flatDeep(iterable, 0);
      return iterations;
    }
    flatSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(type, reverse);
      var stack = [];
      var iterations = 0;
      return new Iterator(function()  {
        while (iterator) {
          var step = iterator.next();
          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }
          var v = step.value;
          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }
          if ((!depth || stack.length < depth) && isIterable(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }
        return iteratorDone();
      });
    }
    return flatSequence;
  }


  function flatMapFactory(iterable, mapper, context) {
    var coerce = iterableClass(iterable);
    return iterable.toSeq().map(
      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
    ).flatten(true);
  }


  function interposeFactory(iterable, separator) {
    var interposedSequence = makeSequence(iterable);
    interposedSequence.size = iterable.size && iterable.size * 2 -1;
    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k) 
        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
        fn(v, iterations++, this$0) !== false},
        reverse
      );
      return iterations;
    };
    interposedSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      var step;
      return new Iterator(function()  {
        if (!step || iterations % 2) {
          step = iterator.next();
          if (step.done) {
            return step;
          }
        }
        return iterations % 2 ?
          iteratorValue(type, iterations++, separator) :
          iteratorValue(type, iterations++, step.value, step);
      });
    };
    return interposedSequence;
  }


  function sortFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    var isKeyedIterable = isKeyed(iterable);
    var index = 0;
    var entries = iterable.toSeq().map(
      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
    ).toArray();
    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
      isKeyedIterable ?
      function(v, i)  { entries[i].length = 2; } :
      function(v, i)  { entries[i] = v[1]; }
    );
    return isKeyedIterable ? KeyedSeq(entries) :
      isIndexed(iterable) ? IndexedSeq(entries) :
      SetSeq(entries);
  }


  function maxFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    if (mapper) {
      var entry = iterable.toSeq()
        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
      return entry && entry[0];
    } else {
      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
    }
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
  }


  function zipWithFactory(keyIter, zipper, iters) {
    var zipSequence = makeSequence(keyIter);
    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function(fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    zipSequence.__iteratorUncached = function(type, reverse) {
      var iterators = iters.map(function(i )
        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
      );
      var iterations = 0;
      var isDone = false;
      return new Iterator(function()  {
        var steps;
        if (!isDone) {
          steps = iterators.map(function(i ) {return i.next()});
          isDone = steps.some(function(s ) {return s.done});
        }
        if (isDone) {
          return iteratorDone();
        }
        return iteratorValue(
          type,
          iterations++,
          zipper.apply(null, steps.map(function(s ) {return s.value}))
        );
      });
    };
    return zipSequence
  }


  // #pragma Helper Functions

  function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function resolveSize(iter) {
    assertNotInfinite(iter.size);
    return ensureSize(iter);
  }

  function iterableClass(iterable) {
    return isKeyed(iterable) ? KeyedIterable :
      isIndexed(iterable) ? IndexedIterable :
      SetIterable;
  }

  function makeSequence(iterable) {
    return Object.create(
      (
        isKeyed(iterable) ? KeyedSeq :
        isIndexed(iterable) ? IndexedSeq :
        SetSeq
      ).prototype
    );
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  }

  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  function forceIterator(keyPath) {
    var iter = getIterator(keyPath);
    if (!iter) {
      // Array might not be iterable in this environment, so we need a fallback
      // to our wrapped type.
      if (!isArrayLike(keyPath)) {
        throw new TypeError('Expected iterable or array-like: ' + keyPath);
      }
      iter = getIterator(Iterable(keyPath));
    }
    return iter;
  }

  createClass(Record, KeyedCollection);

    function Record(defaultValues, name) {
      var hasInitialized;

      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map(values);
      };

      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;

      return RecordType;
    }

    Record.prototype.toString = function() {
      return this.__toString(recordName(this) + ' {', '}');
    };

    // @pragma Access

    Record.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };

    Record.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };

    // @pragma Modification

    Record.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };

    Record.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      if (this._map && !this._map.has(k)) {
        var defaultVal = this._defaultValues[k];
        if (v === defaultVal) {
          return this;
        }
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
    };

    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
    };

    Record.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };


  var RecordPrototype = Record.prototype;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn =
  RecordPrototype.removeIn = MapPrototype.removeIn;
  RecordPrototype.merge = MapPrototype.merge;
  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  RecordPrototype.setIn = MapPrototype.setIn;
  RecordPrototype.update = MapPrototype.update;
  RecordPrototype.updateIn = MapPrototype.updateIn;
  RecordPrototype.withMutations = MapPrototype.withMutations;
  RecordPrototype.asMutable = MapPrototype.asMutable;
  RecordPrototype.asImmutable = MapPrototype.asImmutable;


  function makeRecord(likeRecord, map, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._map = map;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function setProps(prototype, names) {
    try {
      names.forEach(setProp.bind(undefined, prototype));
    } catch (error) {
      // Object.defineProperty failed. Probably IE8.
    }
  }

  function setProp(prototype, name) {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  }

  createClass(Set, SetCollection);

    // @pragma Construction

    function Set(value) {
      return value === null || value === undefined ? emptySet() :
        isSet(value) && !isOrdered(value) ? value :
        emptySet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    Set.of = function(/*...values*/) {
      return this(arguments);
    };

    Set.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    Set.prototype.toString = function() {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function(value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function(value) {
      return updateSet(this, this._map.set(value, true));
    };

    Set.prototype.remove = function(value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function() {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x ) {return x.size !== 0});
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set ) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
        }
      });
    };

    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (!iters.every(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (iters.some(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };

    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };

    Set.prototype.sort = function(comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
    };

    Set.prototype.__iterator = function(type, reverse) {
      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };


  function isSet(maybeSet) {
    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  }

  Set.isSet = isSet;

  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SENTINEL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.mergeDeep = SetPrototype.merge;
  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  SetPrototype.withMutations = MapPrototype.withMutations;
  SetPrototype.asMutable = MapPrototype.asMutable;
  SetPrototype.asImmutable = MapPrototype.asImmutable;

  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }
    return newMap === set._map ? set :
      newMap.size === 0 ? set.__empty() :
      set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;
  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  createClass(OrderedSet, Set);

    // @pragma Construction

    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() :
        isOrderedSet(value) ? value :
        emptyOrderedSet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    OrderedSet.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedSet.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    OrderedSet.prototype.toString = function() {
      return this.__toString('OrderedSet {', '}');
    };


  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  OrderedSet.isOrderedSet = isOrderedSet;

  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;
  function emptyOrderedSet() {
    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  }

  createClass(Stack, IndexedCollection);

    // @pragma Construction

    function Stack(value) {
      return value === null || value === undefined ? emptyStack() :
        isStack(value) ? value :
        emptyStack().unshiftAll(value);
    }

    Stack.of = function(/*...values*/) {
      return this(arguments);
    };

    Stack.prototype.toString = function() {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function() {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function(/*...values*/) {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value ) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function() {
      return this.slice(1);
    };

    Stack.prototype.unshift = function(/*...values*/) {
      return this.push.apply(this, arguments);
    };

    Stack.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };

    Stack.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };

    Stack.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function(fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function(type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function()  {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };


  function isStack(maybeStack) {
    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  }

  Stack.isStack = isStack;

  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SENTINEL] = true;
  StackPrototype.withMutations = MapPrototype.withMutations;
  StackPrototype.asMutable = MapPrototype.asMutable;
  StackPrototype.asImmutable = MapPrototype.asImmutable;
  StackPrototype.wasAltered = MapPrototype.wasAltered;


  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;
  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }

  /**
   * Contributes additional methods to a constructor
   */
  function mixin(ctor, methods) {
    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  Iterable.Iterator = Iterator;

  mixin(Iterable, {

    // ### Conversion to other types

    toArray: function() {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);
      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
      return array;
    },

    toIndexedSeq: function() {
      return new ToIndexedSequence(this);
    },

    toJS: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
      ).__toJS();
    },

    toJSON: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
      ).__toJS();
    },

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, true);
    },

    toMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },

    toObject: function() {
      assertNotInfinite(this.size);
      var object = {};
      this.__iterate(function(v, k)  { object[k] = v; });
      return object;
    },

    toOrderedMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },

    toOrderedSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },

    toSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },

    toSetSeq: function() {
      return new ToSetSequence(this);
    },

    toSeq: function() {
      return isIndexed(this) ? this.toIndexedSeq() :
        isKeyed(this) ? this.toKeyedSeq() :
        this.toSetSeq();
    },

    toStack: function() {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },

    toList: function() {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },


    // ### Common JavaScript methods and properties

    toString: function() {
      return '[Iterable]';
    },

    __toString: function(head, tail) {
      if (this.size === 0) {
        return head + tail;
      }
      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    concat: function() {var values = SLICE$0.call(arguments, 0);
      return reify(this, concatFactory(this, values));
    },

    includes: function(searchValue) {
      return this.some(function(value ) {return is(value, searchValue)});
    },

    entries: function() {
      return this.__iterator(ITERATE_ENTRIES);
    },

    every: function(predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;
      this.__iterate(function(v, k, c)  {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });
      return returnValue;
    },

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },

    find: function(predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },

    forEach: function(sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },

    join: function(separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;
      this.__iterate(function(v ) {
        isFirst ? (isFirst = false) : (joined += separator);
        joined += v !== null && v !== undefined ? v.toString() : '';
      });
      return joined;
    },

    keys: function() {
      return this.__iterator(ITERATE_KEYS);
    },

    map: function(mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },

    reduce: function(reducer, initialReduction, context) {
      assertNotInfinite(this.size);
      var reduction;
      var useFirst;
      if (arguments.length < 2) {
        useFirst = true;
      } else {
        reduction = initialReduction;
      }
      this.__iterate(function(v, k, c)  {
        if (useFirst) {
          useFirst = false;
          reduction = v;
        } else {
          reduction = reducer.call(context, reduction, v, k, c);
        }
      });
      return reduction;
    },

    reduceRight: function(reducer, initialReduction, context) {
      var reversed = this.toKeyedSeq().reverse();
      return reversed.reduce.apply(reversed, arguments);
    },

    reverse: function() {
      return reify(this, reverseFactory(this, true));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },

    some: function(predicate, context) {
      return !this.every(not(predicate), context);
    },

    sort: function(comparator) {
      return reify(this, sortFactory(this, comparator));
    },

    values: function() {
      return this.__iterator(ITERATE_VALUES);
    },


    // ### More sequential methods

    butLast: function() {
      return this.slice(0, -1);
    },

    isEmpty: function() {
      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
    },

    count: function(predicate, context) {
      return ensureSize(
        predicate ? this.toSeq().filter(predicate, context) : this
      );
    },

    countBy: function(grouper, context) {
      return countByFactory(this, grouper, context);
    },

    equals: function(other) {
      return deepEqual(this, other);
    },

    entrySeq: function() {
      var iterable = this;
      if (iterable._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(iterable._cache);
      }
      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
      return entriesSequence;
    },

    filterNot: function(predicate, context) {
      return this.filter(not(predicate), context);
    },

    findEntry: function(predicate, context, notSetValue) {
      var found = notSetValue;
      this.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });
      return found;
    },

    findKey: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },

    findLast: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },

    findLastEntry: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
    },

    findLastKey: function(predicate, context) {
      return this.toKeyedSeq().reverse().findKey(predicate, context);
    },

    first: function() {
      return this.find(returnTrue);
    },

    flatMap: function(mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, true));
    },

    fromEntrySeq: function() {
      return new FromEntriesSequence(this);
    },

    get: function(searchKey, notSetValue) {
      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
    },

    getIn: function(searchKeyPath, notSetValue) {
      var nested = this;
      // Note: in an ES6 environment, we would prefer:
      // for (var key of searchKeyPath) {
      var iter = forceIterator(searchKeyPath);
      var step;
      while (!(step = iter.next()).done) {
        var key = step.value;
        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
        if (nested === NOT_SET) {
          return notSetValue;
        }
      }
      return nested;
    },

    groupBy: function(grouper, context) {
      return groupByFactory(this, grouper, context);
    },

    has: function(searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },

    hasIn: function(searchKeyPath) {
      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
    },

    isSubset: function(iter) {
      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
      return this.every(function(value ) {return iter.includes(value)});
    },

    isSuperset: function(iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
      return iter.isSubset(this);
    },

    keyOf: function(searchValue) {
      return this.findKey(function(value ) {return is(value, searchValue)});
    },

    keySeq: function() {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },

    last: function() {
      return this.toSeq().reverse().first();
    },

    lastKeyOf: function(searchValue) {
      return this.toKeyedSeq().reverse().keyOf(searchValue);
    },

    max: function(comparator) {
      return maxFactory(this, comparator);
    },

    maxBy: function(mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },

    min: function(comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },

    minBy: function(mapper, comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },

    rest: function() {
      return this.slice(1);
    },

    skip: function(amount) {
      return this.slice(Math.max(0, amount));
    },

    skipLast: function(amount) {
      return reify(this, this.toSeq().reverse().skip(amount).reverse());
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },

    skipUntil: function(predicate, context) {
      return this.skipWhile(not(predicate), context);
    },

    sortBy: function(mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },

    take: function(amount) {
      return this.slice(0, Math.max(0, amount));
    },

    takeLast: function(amount) {
      return reify(this, this.toSeq().reverse().take(amount).reverse());
    },

    takeWhile: function(predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },

    takeUntil: function(predicate, context) {
      return this.takeWhile(not(predicate), context);
    },

    valueSeq: function() {
      return this.toIndexedSeq();
    },


    // ### Hashable Object

    hashCode: function() {
      return this.__hash || (this.__hash = hashIterable(this));
    }


    // ### Internal

    // abstract __iterate(fn, reverse)

    // abstract __iterator(type, reverse)
  });

  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  var IterablePrototype = Iterable.prototype;
  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  IterablePrototype.__toJS = IterablePrototype.toArray;
  IterablePrototype.__toStringMapper = quoteString;
  IterablePrototype.inspect =
  IterablePrototype.toSource = function() { return this.toString(); };
  IterablePrototype.chain = IterablePrototype.flatMap;
  IterablePrototype.contains = IterablePrototype.includes;

  mixin(KeyedIterable, {

    // ### More sequential methods

    flip: function() {
      return reify(this, flipFactory(this));
    },

    mapEntries: function(mapper, context) {var this$0 = this;
      var iterations = 0;
      return reify(this,
        this.toSeq().map(
          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
        ).fromEntrySeq()
      );
    },

    mapKeys: function(mapper, context) {var this$0 = this;
      return reify(this,
        this.toSeq().flip().map(
          function(k, v)  {return mapper.call(context, k, v, this$0)}
        ).flip()
      );
    }

  });

  var KeyedIterablePrototype = KeyedIterable.prototype;
  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



  mixin(IndexedIterable, {

    // ### Conversion to other types

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, false);
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },

    findIndex: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    indexOf: function(searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    lastIndexOf: function(searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    reverse: function() {
      return reify(this, reverseFactory(this, false));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },

    splice: function(index, removeNum /*, ...values*/) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum | 0, 0);
      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
        return this;
      }
      // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.
      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(
        this,
        numArgs === 1 ?
          spliced :
          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
      );
    },


    // ### More collection methods

    findLastIndex: function(predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    first: function() {
      return this.get(0);
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, false));
    },

    get: function(index, notSetValue) {
      index = wrapIndex(this, index);
      return (index < 0 || (this.size === Infinity ||
          (this.size !== undefined && index > this.size))) ?
        notSetValue :
        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
    },

    has: function(index) {
      index = wrapIndex(this, index);
      return index >= 0 && (this.size !== undefined ?
        this.size === Infinity || index < this.size :
        this.indexOf(index) !== -1
      );
    },

    interpose: function(separator) {
      return reify(this, interposeFactory(this, separator));
    },

    interleave: function(/*...iterables*/) {
      var iterables = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
      var interleaved = zipped.flatten(true);
      if (zipped.size) {
        interleaved.size = zipped.size * iterables.length;
      }
      return reify(this, interleaved);
    },

    keySeq: function() {
      return Range(0, this.size);
    },

    last: function() {
      return this.get(-1);
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },

    zip: function(/*, ...iterables */) {
      var iterables = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, iterables));
    },

    zipWith: function(zipper/*, ...iterables */) {
      var iterables = arrCopy(arguments);
      iterables[0] = this;
      return reify(this, zipWithFactory(this, zipper, iterables));
    }

  });

  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



  mixin(SetIterable, {

    // ### ES6 Collection methods (ES6 Array and Map)

    get: function(value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },

    includes: function(value) {
      return this.has(value);
    },


    // ### More sequential methods

    keySeq: function() {
      return this.valueSeq();
    }

  });

  SetIterable.prototype.has = IterablePrototype.includes;
  SetIterable.prototype.contains = SetIterable.prototype.includes;


  // Mixin subclasses

  mixin(KeyedSeq, KeyedIterable.prototype);
  mixin(IndexedSeq, IndexedIterable.prototype);
  mixin(SetSeq, SetIterable.prototype);

  mixin(KeyedCollection, KeyedIterable.prototype);
  mixin(IndexedCollection, IndexedIterable.prototype);
  mixin(SetCollection, SetIterable.prototype);


  // #pragma Helper functions

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    }
  }

  function neg(predicate) {
    return function() {
      return -predicate.apply(this, arguments);
    }
  }

  function quoteString(value) {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashIterable(iterable) {
    if (iterable.size === Infinity) {
      return 0;
    }
    var ordered = isOrdered(iterable);
    var keyed = isKeyed(iterable);
    var h = ordered ? 1 : 0;
    var size = iterable.__iterate(
      keyed ?
        ordered ?
          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
        ordered ?
          function(v ) { h = 31 * h + hash(v) | 0; } :
          function(v ) { h = h + hash(v) | 0; }
    );
    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xCC9E2D51);
    h = imul(h << 15 | h >>> -15, 0x1B873593);
    h = imul(h << 13 | h >>> -13, 5);
    h = (h + 0xE6546B64 | 0) ^ size;
    h = imul(h ^ h >>> 16, 0x85EBCA6B);
    h = imul(h ^ h >>> 13, 0xC2B2AE35);
    h = smi(h ^ h >>> 16);
    return h;
  }

  function hashMerge(a, b) {
    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  }

  var Immutable = {

    Iterable: Iterable,

    Seq: Seq,
    Collection: Collection,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,

    Record: Record,
    Range: Range,
    Repeat: Repeat,

    is: is,
    fromJS: fromJS

  };

  return Immutable;

}));

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NULL_SCENE_ID = undefined;

var _stringify = __webpack_require__(47);

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _toConsumableArray2 = __webpack_require__(149);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _createReducer;

exports.hasFile = hasFile;
exports.getFile = getFile;
exports.addFile = addFile;
exports.removeFile = removeFile;
exports.urlsFor = urlsFor;
exports.isLoading = isLoading;
exports.getImage = getImage;
exports.getOrFetchImage = getOrFetchImage;
exports.fetchImage = fetchImage;
exports.fetchBinary = fetchBinary;
exports.getOrFetchBinary = getOrFetchBinary;
exports.getOrFetchFont = getOrFetchFont;
exports.getHash = getHash;
exports.getUrl = getUrl;
exports.getImageUrl = getImageUrl;
exports.fetchText = fetchText;
exports.fetchTransit = fetchTransit;
exports.find = find;
exports.filter = filter;
exports.exportJSON = exportJSON;
exports.getActiveAssets = getActiveAssets;
exports.importImage = importImage;
exports.importFile = importFile;
exports.addRoot = addRoot;

var _immutable = __webpack_require__(32);

var _v = __webpack_require__(79);

var _v2 = _interopRequireDefault(_v);

var _createReducer2 = __webpack_require__(46);

var _createReducer3 = _interopRequireDefault(_createReducer2);

var _sceneGraph = __webpack_require__(10);

var _scene = __webpack_require__(7);

var _actionTypes = __webpack_require__(58);

var _sceneIO = __webpack_require__(20);

var _selectors = __webpack_require__(123);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Managing assets
 *
 * @module assets
 * @public
 */

var ADD_FILE = 'ADD_FILE';
var REMOVE_FILE = 'REMOVE_FILE';

var IMPORTING_FILE = 'IMPORTING_FILE';
var IMPORTED_FILE = 'IMPORTED_FILE';
var IMPORT_FILE_ERROR = 'IMPORT_FILE_ERROR';

var ADD_ROOT = 'ADD_ROOT';

var initialState = (0, _immutable.Map)({
  fileRoots: ["https://di2xnf34q86h1.cloudfront.net","https://editor.vimarket.io/resources"],
  assets: (0, _immutable.Map)()
});

var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, ADD_FILE, function (state, attrs) {
  var id = attrs.id;

  return state.setIn(['assets', id], (0, _immutable.Map)(attrs));
}), (0, _defineProperty3.default)(_createReducer, REMOVE_FILE, function (state, id) {
  return state.deleteIn(['assets', id]);
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOAD_SCENE, function (state, _ref) {
  var assets = _ref.assets;

  return state.set('assets', state.get('assets').merge(assets));
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state) {
  return state.set('assets', (0, _immutable.Map)());
}), (0, _defineProperty3.default)(_createReducer, ADD_ROOT, function (state, root) {
  var roots = state.get('fileRoots').slice();
  roots.unshift(root);
  return state.set('fileRoots', roots);
}), _createReducer));

function hasFile(store, id) {
  return !!store.getIn(['assets', 'assets', id]);
}

function getFile(store, id) {
  var asset = store.getIn(['assets', 'assets', id]);
  return asset ? asset.toJS() : {};
}

function addFile(attrs) {
  return { type: ADD_FILE, payload: attrs };
}

function removeFile(id) {
  return { type: REMOVE_FILE, payload: id };
}

function imageUrls(store, file, options) {
  var resizeImage = options.resizeImage,
      resizeWidth = options.resizeWidth,
      resizeHeight = options.resizeHeight,
      optimizeFormat = options.optimizeFormat;


  if (!resizeImage && optimizeFormat === '') return urlsFor(store, file);

  var resizePath = resizeImage ? resizeWidth + 'x' + resizeHeight + '/' : '';
  var formatPath = optimizeFormat !== '' ? 'filters:format(' + optimizeFormat + ')/' : '';
  return  true ? ["https://editor.vimarket.io/resources"].map(function (host) {
    return host + '/images/' + resizePath + formatPath + file.get('hash') + '?filename=' + file.get('name');
  }) : [];
}

function urlsFor(store, file) {
  return store.getIn(['assets', 'fileRoots']).map(function (host) {
    return host + '/' + file.get('hash') + file.get('suffix') + '?filename=' + file.get('name');
  });
}

function isLoading(id) {
  return function (_ref2) {
    var getIn = _ref2.getIn;
    return getIn(['sceneIO', 'loadingFiles', id]);
  };
}

function getImage(id) {
  return images[id];
}

var localImageCache = {};

// Take in a `File`, read to data url and return an Image.
function createImageFromLocal(store, id, file) {
  if (localImageCache[id]) return localImageCache[id];

  store.dispatch((0, _sceneIO.markLoadingFile)(id));
  var img = new Image();
  var reader = new FileReader();
  reader.addEventListener('load', function () {
    img.src = reader.result;
    localImageCache[id] = img;
    store.dispatch((0, _sceneIO.markLoadedFile)(id));
  });
  reader.readAsDataURL(file);
  return null;
}

function getOrFetchImage(id) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return function (store) {
    var file = store.getIn(['assets', 'assets', id]);
    if (!file) return;

    var localFile = file.get('localFile');
    if (localFile) return createImageFromLocal(store, id, localFile);

    var urls = options.optimizeImage ? imageUrls(store, file, options) : [];
    urls.push.apply(urls, (0, _toConsumableArray3.default)(urlsFor(store, file)));
    return store.callApi((0, _assign2.default)({
      types: [_actionTypes.LOADING_FILE, _actionTypes.LOADED_FILE, _actionTypes.LOADING_FILE_ERROR],
      url: urls,
      contentType: 'img',
      payload: id,
      queryKey: 'IMAGE' + file.get('hash'),
      fireAndForget: typeof attrs.fireAndForget === 'undefined' ? true : false
    }, attrs));
  };
}

function fetchImage(store, id) {
  return id && getOrFetchImage(id, { fireAndForget: false })(store);
}

function fetchBinary(store, id, options) {
  return id && getOrFetchBinary(id, (0, _assign2.default)({ fireAndForget: false }, options))(store);
}

var THRESHOLD = 100000; // 100 kB
function getOrFetchBinary(id) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var file = store.getIn(['assets', 'assets', id]);
    if (!file) {
      store.error(new Error('target file not found'), null, { fileId: id });
      return null;
    }
    if (file.get('content')) {
      return file.get('content');
    } else {
      var translator = store.getTranslator();
      var isLZMA = file.get('lzma') && !(translator && translator.externals.isMobile) && file.get('size') >= THRESHOLD;
      var lzmaFile = isLZMA ? file.set('suffix', 'lzma1') : file;

      var decompress = typeof attrs.decompress === 'undefined' ? isLZMA : false;
      return store.callApi((0, _assign2.default)({
        types: [_actionTypes.LOADING_FILE, _actionTypes.LOADED_FILE, _actionTypes.LOADING_FILE_ERROR],
        url: urlsFor(store, lzmaFile),
        contentType: 'binary',
        payload: id,
        queryKey: 'FILE' + lzmaFile.get('hash') + decompress,
        decompress: decompress,
        fireAndForget: typeof attrs.fireAndForget === 'undefined' ? true : false
      }, attrs));
    }
  };
}

function getOrFetchFont(id) {
  return function (store) {
    var file = store.getIn(['assets', 'assets', id]);
    if (!file) {
      store.error(new Error('target file not found'), null, { fileId: id });
      return null;
    }
    return store.callApi({
      types: [_actionTypes.LOADING_FILE, _actionTypes.LOADED_FILE, _actionTypes.LOADING_FILE_ERROR],
      url: urlsFor(store, file),
      contentType: 'font',
      payload: id,
      queryKey: 'FILE' + file.get('hash'),
      fireAndForget: true
    });
  };
}

function getHash(store, id) {
  return store.getIn(['assets', 'assets', id, 'hash']);
}

/**
 * get the url for the asset.
 *
 * @public
 * @param {String} id
 * @returns {String} the url pointing to the asset.
 *
 */
function getUrl(store, id) {
  var asset = store.getIn(['assets', 'assets', id]);
  if (asset) {
    var urls = urlsFor(store, asset);
    return urls[urls.length - 1];
  } else {
    return asset;
  }
}

/**
 * get the url for optimized images.
 *
 * @public
 * @param {String} id
 * @param {Object} options options for optimize image with thumbor
 * @returns {String} the url pointing to the asset.
 *
 */

function getImageUrl(store, id, options) {
  var image = store.getIn(['assets', 'assets', id]);
  if (image) {
    var urls = imageUrls(store, image, options);
    return urls[0];
  } else {
    return image;
  }
}

function fetchText(hash) {
  return function (store) {
    return store.callApi({
      contentType: 'text',
      url: store.getIn(['assets', 'fileRoots']).map(function (host) {
        return host + '/' + hash;
      })
    });
  };
}

function fetchTransit(uuid) {
  return function (store) {
    return store.callApi({
      contentType: 'text',
      url: '/api/scenes/' + uuid
    });
  };
}

function find(store, fn) {
  return store.getIn(['assets', 'assets']).find(fn);
}

function filter(store, fn) {
  return store.getIn(['assets', 'assets']).filter(fn || function () {
    return true;
  });
}

function exportJSON(store) {
  return store.getIn(['assets', 'assets']).map(function (asset) {
    var json = asset.toJS();
    json._id = json.id;
    delete json.id;
    return json;
  }).toArray();
}

function getActiveAssets(store) {
  var sceneGraph = (0, _sceneGraph.getEvalSceneGraph)(store);
  return filter(store, function (v, k) {
    return !!sceneGraph.fileReferences.from[k];
  });
}

function logBase(value, base) {
  return Math.log(value) / Math.log(base);
}

function ceilPower2(value) {
  return Math.pow(2, Math.ceil(logBase(value, 2)));
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(value, max));
}

function computeNewSize(imgInfo, maxSize) {
  var newSize = {};
  newSize.width = clamp(ceilPower2(imgInfo.width), 1, maxSize.width);
  newSize.height = clamp(ceilPower2(imgInfo.height), 1, maxSize.height);
  return newSize;
}

function resizeImage(file, maxWidth, maxHeight) {
  return new _promise2.default(function (resolve, reject) {
    var img = document.createElement('img');
    var reader = new FileReader();
    reader.onload = function (e) {
      img.src = e.target.result;

      img.onload = function () {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);

        var width = img.width;
        var height = img.height;
        var newSize = computeNewSize({ width: width, height: height }, { width: maxWidth, height: maxHeight });
        canvas.width = newSize.width;
        canvas.height = newSize.height;

        var ctx2 = canvas.getContext('2d');
        ctx2.drawImage(img, 0, 0, newSize.width, newSize.height);

        resolve(canvas.toDataURL(file.type));
      };
    };

    reader.readAsDataURL(file);
  });
}

var MAX_IMG_SIZE = 4096;
var NULL_SCENE_ID = exports.NULL_SCENE_ID = '00000000-0000-0000-0000-000000000000';

var acceptType = {
  'image/jpeg': true,
  'image/png': true,
  'application/pdf': true,
  'image/svg+xml': true
};

/**
 *
 * This will upload an image, add an image node to the scene graph, and return
 * an object with the id of the new node, and the id of the uploaded asset.
 *
 * If you save the assetId, that assetId can be passed into this function
 * to get a new image node for the scene. That means you can restore the state of
 * a scene without having to reimport the previous image.
 *
 * See [The demo example](tutorial-demo-ImportImage.html) for an example of usage.
 *
 * @public
 * @param {(File|String)} image A [File](https://developer.mozilla.org/en/docs/Web/API/File) to import, an assetId from a previous import, or url src of image.
 * @param {Object} options
 * @param {Number} options.resizeTo A max width/height to resize the
 *   image to (preserves aspect ratio of image)
 * @param {String} options.targetFormat  the format of the result image when importing
 * @param {Number} options.quality compression level of the result image
 * @param {Number} options.dpi dpi of the result image, default is 72
 * @param {Number} options.scale index to scale the picture
 * @param {Boolean} options.keepAspectRatio 
 * @returns Promise resolve to an object with `assetId` and `imageNodeId` keys
 *
 */
function importImage(file) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    function fetchAsset(uuid) {
      return store.callApi({
        types: [_actionTypes.LOADING_FILE, _actionTypes.LOADED_FILE, _actionTypes.LOADING_FILE_ERROR],
        url: "https://editor.vimarket.io/api" + '/files/' + uuid + '/asset',
        payload: uuid
      });
    }

    function importImageURL(url) {
      var body = (0, _stringify2.default)((0, _assign2.default)({
        url: url,
        maxSize: options.resizeTo || MAX_IMG_SIZE,
        sceneId: NULL_SCENE_ID
      }, options));

      return store.callApi({
        types: [IMPORTING_FILE, IMPORTED_FILE, IMPORT_FILE_ERROR],
        method: 'POST',
        url: "https://editor.vimarket.io/api" + '/files/image',
        body: body
      });
    }

    // Post to the server to create the image asset
    function importImage(image, id) {
      var body = new FormData();
      var resize = typeof options.keepAspectRatio === 'boolean' ? !options.keepAspectRatio : true;
      body.append('file', image);
      body.append('name', image.name);
      body.append('sceneId', NULL_SCENE_ID);
      body.append('type', image.type);
      body.append('targetFormat', options.targetFormat || 'png');
      body.append('quality', options.quality || 60);
      body.append('maxSize', options.resizeTo);
      body.append('density', options.dpi);
      body.append('scale', options.scale);
      if (id) body.append('convertToFileId', id);
      body.append('resize', resize);
      return importFile(store, { body: body, type: image.type });
    }

    // Add an asset that references the client side added file.
    function createLocalImageAsset(file) {
      return store.dispatch(addFile({
        id: (0, _v2.default)(),
        name: file.name,
        localFile: file,
        size: file.size,
        type: file.type
      }));
    }

    // Add the asset to the store.
    function addImageAsset(image) {
      return store.dispatch(addFile((0, _assign2.default)({ id: image._id }, image)));
    }

    // Create the image node from given asset
    function createImageNode(imageAsset) {
      var imageNodeProps = {
        name: imageAsset.name || file.name,
        type: 'Image',
        parent: (0, _scene.find)(store, { name: 'Material Library' }),
        plugs: {
          Image: [['Image', { glBitmapFile: imageAsset.id, glOption: 1 }]],
          Properties: [['ImageProperties', {}]]
        }
      };
      if (options.imageNodeId) imageNodeProps.id = options.imageNodeId;

      return store.dispatch((0, _sceneGraph.addNode)(imageNodeProps)).then(function (imageNodeId) {
        return {
          id: imageNodeId,
          imageNodeId: imageNodeId,
          assetId: imageAsset.id,
          imageSize: {
            width: imageAsset.height,
            height: imageAsset.width,
            originalWidth: imageAsset.originalWidth,
            originalHeight: imageAsset.originalHeight
          },
          url: imageAsset.original
        };
      });
    }

    if (typeof file === 'string') {
      if ((0, _selectors.isUuid)(file)) {
        return fetchAsset(file).then(addImageAsset).then(createImageNode);
      } else {
        return importImageURL(file).then(addImageAsset).then(createImageNode).catch(function (err) {
          var errMessage = void 0;

          if (err.status && err.status < 500) errMessage = 'Image not imported, bad url';else if (err.status && err.status >= 500) errMessage = 'Image not imported, internal error';else errMessage = err;

          return _promise2.default.reject(errMessage);
        });
      }
    }

    if (!file.type) return _promise2.default.reject('Expect a File');
    if (!acceptType[file.type]) return _promise2.default.reject('File format not supported');

    var MAX_LOCAL_SIZE = 5000000; // 5MB max size
    if (file.type.match(/image\/(jpeg|png)/) && file.size < MAX_LOCAL_SIZE) {
      // use as a local file, import in the background
      return createLocalImageAsset(file).then(createImageNode).then(function (result) {
        // import after the fact.
        importImage(file, result.assetId).then(function (importedAsset) {});
        return result;
      });
    } else {
      // import image first, then use the result from the api.
      return importImage(file).then(addImageAsset).then(createImageNode);
    }
  };
}

function importFile(store) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var url = "https://editor.vimarket.io/api" + '/files';
  if (acceptType[attrs.type]) url += '/image';
  return store.callApi((0, _assign2.default)({
    types: [IMPORTING_FILE, IMPORTED_FILE, IMPORT_FILE_ERROR],
    method: 'POST',
    url: url
  }, attrs));
}

/**
 * Add a location to search for scene assets.
 * @public
 * @param {string} urlRoot - URL root of location
 */
function addRoot(urlRoot) {
  return { type: ADD_ROOT, payload: urlRoot };
}

var publicApi = {
  reducer: reducer,
  actions: { addFile: addFile, removeFile: removeFile, importImage: importImage, addRoot: addRoot },
  selectors: {
    _getHash: getHash,
    getUrl: getUrl,
    filter: filter,
    find: find,
    getActiveAssets: getActiveAssets,
    exportJSON: exportJSON,
    fetchImage: fetchImage,
    fetchBinary: fetchBinary
  }
};
exports.default = publicApi;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _freeze = __webpack_require__(166);

var _freeze2 = _interopRequireDefault(_freeze);

var _Orders = __webpack_require__(229);

var _Orders2 = _interopRequireDefault(_Orders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {(function(new:Array)|Array)} ArrayOrType
 */

/**
 * Various utilities for working with arrays.
 *
 * @namespace
 */
var Arrays = {
  /**
   * Empty arrays.
   *
   * @namespace
   */
  Empty: (0, _freeze2.default)({
    /** @const @type {!Array} */
    Array: (0, _freeze2.default)(new Array(0)),

    // Note: Typed arrays can't - and don't have to frozen, since
    // they have an immutable length.

    /** @const @type {!Array<!number>} */
    Float64Array: new Float64Array(0),
    /** @const @type {!Array<!number>} */
    Float32Array: new Float32Array(0),
    /** @const @type {!Array<!number>} */
    Uint32Array: new Uint32Array(0),
    /** @const @type {!Array<!number>} */
    Int32Array: new Int32Array(0)
  }),

  //

  rangeCopy: function rangeCopy(src, srcOffset, dst, dstOffset, length) {
    for (var i = 0; i !== length; ++i) {
      dst[dstOffset + i] = src[srcOffset + i];
    }return dst;
  },

  rangeEquals: function rangeEquals(a, aStart, b, bStart, length) {
    for (var i = 0; i !== length; ++i) {
      if (a[aStart + i] !== b[bStart + i]) return false;
    }return true;
  },

  stridedCopy: function stridedCopy(src, srcOffset, srcStride, dst, dstOffset, dstStride, elementLength, numElements) {
    for (var i = 0; i !== numElements; ++i) {
      for (var j = 0; j !== elementLength; ++j) {
        dst[dstOffset + i * dstStride + j] = src[srcOffset + i * srcStride + j];
      }
    }return dst;
  },

  /**
   * For each element add the previous element.
   *
   * @param {!Array<!number>} array
   */
  accumulate: function accumulate(array) {
    for (var i = 1, n = array.length; i < n; ++i) {
      array[i] += array[i - 1];
    }return array;
  },

  slice: function slice(array, from, optionalTo) {
    // Not all browsers have .slice for typed arrays...

    return array.slice !== undefined ? array.slice(from, optionalTo) : new array.constructor(array.subarray(from, optionalTo));
  },

  clone: function clone(array) {
    // Not all browsers have .slice for typed arrays...

    return array !== null ? array.slice !== undefined ? array.slice(0) : new array.constructor(array) : null;
  },

  binarySearch: function binarySearch(array, elem, optionalBegin, optionalUntil) {
    var left = optionalBegin === undefined ? 0 : optionalBegin,
        right = optionalUntil === undefined ? array.length - left : optionalUntil,
        rightBound = right;

    while (left < right) {
      var mid = left + right >>> 1,
          midVal = array[mid];

      if (midVal < elem) left = mid + 1;else right = mid;
    }

    return left < rightBound && array[left] === elem ? left : ~left;
  },

  sort: function sort(array, optionalOrder) {
    // TODO: Optimized sorting - a likely and improvable bottleneck:
    //
    // - A customized sort beats Chrome by a factor of 18 at block
    //   sizes of 10.000 elements, where the performance is roughly
    //   equal for a few elements. At this scale Chrome is already
    //   3-4 times slower than Firefox - the more elements there are
    //   the worse it gets.
    //
    // - The same routine beats Firefox by a factor of 5 with small
    //   block sizes, where the performance becomes roughly equal at
    //   10.000 elements.
    //
    // My test code did not contain duplicate elements (and does not
    // handle them well, in the moment) and used a Quicksort with a
    // median index pivot (which is rather lousy). It did implement
    // a decent partitioner based on Hoare's algorithm, though.

    if (array.sort !== undefined) {
      return array.sort(optionalOrder || _Orders2.default.Numeric);
    } else {
      // some browsers may not yet support the above

      return Array.prototype.sort.call(array, optionalOrder || _Orders2.default.Numeric);
    }

    return array;
  },

  unique: function unique(sortedArray, optionalOrder) {
    var n = sortedArray.length;

    if (n <= 1) return sortedArray.length;

    var writeIndex = 0,
        prevValue = sortedArray[0];

    if (optionalOrder === undefined) {
      for (var i = 1; i !== n; ++i) {
        var value = sortedArray[i];
        if (value !== prevValue) {
          prevValue = value;

          if (++writeIndex !== i) sortedArray[writeIndex] = value;
        }
      }
    } else {
      var compare = optionalOrder;

      if (!optionallyBuiltMap) {
        for (var _i = 1; _i !== n; ++_i) {
          var _value = sortedArray[_i];
          if (compare(_value, prevValue) !== 0) {
            prevValue = _value;

            if (++writeIndex !== _i) sortedArray[writeIndex] = _value;
          }
        }
      }
    }

    return writeIndex + 1; // new length
  },

  //

  /**
   * Utiltiy function for taking an argument that is either an existing
   * array or an array type / constructor.
   *
   * Example:
   * <pre>
   * const array = Arrays.maybeCreate( arg || Uint32Array, n );
   * </pre>
   *
   * @param {!ArrayOrType} existingArrayOrType
   * @param {number=} requiredLength
   * @throws Error when argument missing or an array and too short
   */
  maybeCreate: function maybeCreate(existingArrayOrType, requiredLength) {
    if (!existingArrayOrType) throw Error('Missing array!');

    var validLength = requiredLength !== null && !isNaN(requiredLength);

    // Safari returns "object" for typeof Uint32Array, Float32Array, etc, so use instanceof
    if (typeof existingArrayOrType === 'function' || existingArrayOrType instanceof Function) {
      if (!validLength) throw Error('Missing or invalid length!');

      // Note: Browsers show wEirD behavior when it comes to
      // argument checks of typed array constructors...

      return new existingArrayOrType(requiredLength);
    }

    // otherwise assume we got an existing array

    if (validLength && existingArrayOrType.length < requiredLength) throw Error('Array too short: ' + existingArrayOrType.length + ' < ' + requiredLength);

    return existingArrayOrType;
  },

  copyObjects: function copyObjects(objects, array, optionalStride) {
    if (!objects) return null;

    var nObjects = objects.length;
    if (nObjects === 0) return array;

    var stride = objects[0].constructor.InstanceScalarSize || optionalStride;

    if (stride === undefined) throw Error('Arrays.fromObjects: Cannot determine stride!');

    var result = Arrays.maybeCreate(arrayOrType, nObjects * stride);

    for (var i = 0, offset = 0; i !== nObjects; ++i, offset += stride) {
      var object = objects[i];

      if (object === undefined) {
        console.warn('Arrays.fromObjects: Undefined object.');
        array.fill(0, offset, offset + stride);
        continue;
      }

      object.toArray(array, offset);
    }

    return array;
  }
};

exports.default = Arrays;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(21)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 36 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var VNode = __webpack_require__(311);
var is = __webpack_require__(205);

function addNS(data, children) {
  data.ns = 'http://www.w3.org/2000/svg';
  if (children !== undefined) {
    for (var i = 0; i < children.length; ++i) {
      addNS(children[i].data, children[i].children);
    }
  }
}

module.exports = function h(sel, b, c) {
  var data = {}, children, text, i;
  if (arguments.length === 3) {
    data = b;
    if (is.array(c)) { children = c; }
    else if (is.primitive(c)) { text = c; }
  } else if (arguments.length === 2) {
    if (is.array(b)) { children = b; }
    else if (is.primitive(b)) { text = b; }
    else { data = b; }
  }
  if (is.array(children)) {
    for (i = 0; i < children.length; ++i) {
      if (is.primitive(children[i])) children[i] = VNode(undefined, undefined, undefined, children[i]);
    }
  }
  if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g') {
    addNS(data, children);
  }
  return VNode(sel, data, children, text, undefined);
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(504);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(503);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(528), __esModule: true };

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(60)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(44);
var IE8_DOM_DEFINE = __webpack_require__(264);
var toPrimitive = __webpack_require__(180);
var dP = Object.defineProperty;

exports.f = __webpack_require__(40) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(26);
var createDesc = __webpack_require__(75);
module.exports = __webpack_require__(35) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MOUSE_CONTROLS = undefined;

var _values = __webpack_require__(130);

var _values2 = _interopRequireDefault(_values);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _createReducer;

exports.addCommand = addCommand;
exports.removeCommand = removeCommand;
exports.updateCommand = updateCommand;
exports.undoUpdateCommand = undoUpdateCommand;
exports.setCommandOptions = setCommandOptions;
exports.getTools = getTools;
exports.getCommands = getCommands;
exports.isCommandActive = isCommandActive;
exports.getActiveCommandsWithWidgets = getActiveCommandsWithWidgets;
exports.activateCommand = activateCommand;
exports.deactivateCommand = deactivateCommand;
exports.runCommand = runCommand;
exports.updateCommands = updateCommands;
exports.undoUpdateCommands = undoUpdateCommands;

var _immutable = __webpack_require__(32);

var _createReducer2 = __webpack_require__(46);

var _createReducer3 = _interopRequireDefault(_createReducer2);

var _player = __webpack_require__(8);

var _createStore = __webpack_require__(128);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MOUSE_CONTROLS = exports.MOUSE_CONTROLS = ['orbit', 'pan', 'zoom', 'home', 'fullscreen', 'configurator'];

/**
 * This module manages commands and tools of the player
 *
 * @module commands
 * @public
 */

var ADD_COMMAND = 'ADD_COMMAND';
var REMOVE_COMMAND = 'REMOVE_COMMAND';
var UPDATE_COMMAND = 'UPDATE_COMMAND';
var UNDO_UPDATE_COMMAND = 'UNDO_UPDATE_COMMAND';
var FAIL_COMMAND = 'FAIL_COMMAND';
var FINISH_COMMAND = 'FINISH_COMMAND';
var RUN_COMMAND = 'RUN_COMMAND';
var UPDATE_COMMAND_OPTIONS = 'UPDATE_COMMAND_OPTIONS;';

var defaultCommand = {
  enabled: true,
  display: {},
  options: {},

  isEnabled: function isEnabled(store, command) {
    return command.enabled;
  },
  isVisible: function isVisible(store, command) {
    return command.display;
  },

  command: null,
  widget: null
};

function makeCommand(state, command) {
  return state.set(command.name, command);
}

function newInitialState() {
  return (0, _immutable.Map)({
    all: {},
    prev: {},
    allCommands: (0, _immutable.List)(),
    tools: (0, _immutable.List)(),
    activeCommand: null,
    removedCommands: (0, _immutable.Map)()
  });
}

function initCommand(attrs, name) {
  var cmd = (0, _assign2.default)({}, defaultCommand, attrs, { name: name });
  if (cmd.display === true) cmd.display = { playerTools: true };
  return cmd;
}

var reducer = (0, _createReducer3.default)({}, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, _createStore.ActionTypes.INIT, function (state) {
  return newInitialState();
}), (0, _defineProperty3.default)(_createReducer, ADD_COMMAND, function (state, _ref) {
  var command = _ref.command,
      name = _ref.name;

  if (state.getIn(['removedCommands', name])) return state;

  var commands = state.get('all');
  commands[name] = (0, _assign2.default)(initCommand(command, name), commands[name] || {});
  var newState = state.updateIn(['allCommands'], (0, _immutable.List)(), function (list) {
    return list.push(name);
  });
  if (commands[name].tool) newState = newState.updateIn(['tools'], (0, _immutable.List)(), function (list) {
    return list.push(name);
  });
  return newState;
}), (0, _defineProperty3.default)(_createReducer, REMOVE_COMMAND, function (state, commandName) {
  var commands = state.get('all');
  delete commands[commandName];
  var idx = state.getIn(['tools']).indexOf(commandName);
  var idx2 = state.getIn(['allCommands']).indexOf(commandName);

  var newState = state;
  if (idx >= 0) newState = newState.deleteIn(['tools', idx]);
  if (idx2 >= 0) newState = newState.deleteIn(['allCommands', idx2]);
  newState = newState.setIn(['removedCommands', commandName], true);
  return newState;
  // FIXME: remove from commands/widgets
}), (0, _defineProperty3.default)(_createReducer, UPDATE_COMMAND, function (state, _ref2) {
  var name = _ref2.name,
      opts = _ref2.opts;

  var commands = state.get('all');
  if (!commands[name]) {
    commands[name] = initCommand(opts, name);
  }
  var command = commands[name];
  var prevCommands = state.get('prev');
  prevCommands[name] = (0, _assign2.default)({}, command);
  (0, _assign2.default)(command, opts);
  return state;
}), (0, _defineProperty3.default)(_createReducer, UPDATE_COMMAND_OPTIONS, function (state, _ref3) {
  var name = _ref3.name,
      opts = _ref3.opts;

  var command = state.get('all')[name];
  var prevCommands = state.get('prev');
  prevCommands[name] = (0, _assign2.default)({}, command);
  if (command) (0, _assign2.default)(command.options, opts);
  return state;
}), (0, _defineProperty3.default)(_createReducer, UNDO_UPDATE_COMMAND, function (state, _ref4) {
  var name = _ref4.name;

  var prevCommand = state.get('prev')[name];
  if (prevCommand) {
    var command = state.get('all')[name];
    if (command) (0, _assign2.default)(command, prevCommand);
  }
  return state;
}), _createReducer));

/**
 * Add a command
 *
 * @public
 * @param {Command} command Command to be added
 * @param {String} name provide a name for the tool to allow removing it.
 * @returns {Promise}
 *
 */
function addCommand(command, name) {
  return { type: ADD_COMMAND, payload: { command: command, name: name } };
}

/**
 * Remove a command
 *
 * @public
 * @param {String} name The name of the command to remove
 * @returns {Promise}
 */
function removeCommand(commandName) {
  return { type: REMOVE_COMMAND, payload: commandName };
}

/**
 * Updates Atributes of Command
 *
 * @public
 * @param {String} name The name of the command to be updated
 * @param {Object} opts Attributes to set in the command
 * @returns {Promise}
 *
 */
function updateCommand(name, opts) {
  return { type: UPDATE_COMMAND, payload: { name: name, opts: opts } };
}

function undoUpdateCommand(name) {
  return { type: UNDO_UPDATE_COMMAND, payload: { name: name } };
}

/**
 * Updates Options object of Command
 *
 * @public
 * @param {String} name The name of the command to be updated
 * @param {Object} opts Options to be set in the command
 * @returns {Promise}
 *
 */
function setCommandOptions(name, opts) {
  return { type: UPDATE_COMMAND_OPTIONS, payload: { name: name, opts: opts } };
}

function getTools(store) {
  return store.getIn(['commands', 'tools']);
}

function getCommands(store, displayLocation) {
  var commands = store.getIn(['commands', 'all']);
  return !displayLocation ? commands : (0, _keys2.default)(commands).reduce(function (cmds, key) {
    var cmd = commands[key];
    if (cmd.enabled && cmd.display[displayLocation]) cmds[key] = cmd;
    return cmds;
  }, {});
}

function _isCommandActive(store, command) {
  if (command.active) return true;
  if (command.isActive) return command.isActive(store);
  return false;
}

function isCommandActive(store, commandName) {
  var command = store.getIn(['commands', 'all'])[commandName];
  return command && _isCommandActive(store, command);
}

function getActiveCommandsWithWidgets(store) {
  var commands = getCommands(store);
  var result = {};
  (0, _values2.default)(commands).forEach(function (command) {
    if (command.widget && _isCommandActive(store, command)) result[command.name] = command;
  });
  return result;
}

/**
 * Activate a command, will deactivate the currently active command
 *
 * @public
 * @param {String} commandName The name of the command to be actived
 *
 */
function activateCommand(commandName) {
  return function (store) {
    var tools = getTools(store);
    var commands = getCommands(store);
    var command = commands[commandName];

    if (command.activate) {
      if (!_isCommandActive(store, command)) {
        command.activate.call(command);
        store.dispatch(updateCommand(commandName, { active: true }));
      }
    } else {
      tools.forEach(function (toolName) {
        var command = commands[toolName];
        if (command.active && command.name !== commandName) {
          store.dispatch(updateCommand(command.name, { active: false }));
        }

        if (command.name === commandName) {
          store.dispatch(updateCommand(command.name, { active: true }));
        }
      });
    }
  };
}

/**
 * Deactivate a command
 *
 * @public
 * @param {String} commandName The name of the command to be deactived
 *
 */
function deactivateCommand(commandName) {
  return function (store) {
    var commands = getCommands(store);
    var command = commands[commandName];
    if (!command) return;

    if (command.active) store.dispatch(updateCommand(command.name, { active: false }));
    if (command.deactivate) command.deactivate.call(command);
  };
}

/**
 * Executes, Activates/Deactivates, or makes Command Active
 *
 * @public
 * @param {String} commandName The name of the command to be run
 * @returns {Promise}
 *
 */
function runCommand(commandName) {
  return function (store) {
    var command = store.getIn(['commands', 'all'])[commandName];
    if (!command || !command.enabled) return;
    store.trackEvent('Execute Command', 'Run ' + commandName);
    if (command.execute) return command.execute(store);
    var isActive = _isCommandActive(store, command);
    if (command.deactivate && isActive) return store.dispatch(deactivateCommand(commandName));
    return store.dispatch(activateCommand(commandName));
  };
}

/**
 * Updates multiple commands with given Attributes
 *
 * @public
 * @param {String} commandList The name of the command to be run
 * @params {Object} attrs Attributes to be set in the command
 * @returns {Promise}
 *
 */
function updateCommands(commandList, attrs) {
  return function (store) {
    commandList.forEach(function (name) {
      store.dispatch(updateCommand(name, attrs));
    });
  };
}

function undoUpdateCommands(commandList) {
  return function (store) {
    commandList.forEach(function (name) {
      store.dispatch(undoUpdateCommand(name));
    });
  };
}

/**
 * Return a Map with the command commands.
 *
 * @private
 */
// export function getcommands(store) {
//   return store.get(['commands']).map((command) => command.get('command'));
// }

var publicApi = {
  reducer: reducer,
  actions: {
    activateCommand: activateCommand,
    addCommand: addCommand,
    deactivateCommand: deactivateCommand,
    runCommand: runCommand,
    setCommandOptions: setCommandOptions,
    updateCommand: updateCommand,
    undoUpdateCommand: undoUpdateCommand,
    updateCommands: updateCommands,
    removeCommand: removeCommand
  },
  selectors: {}
};

exports.default = publicApi;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(27);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _createReducer;

exports.createSelectionSet = createSelectionSet;
exports.removeSelectionSet = removeSelectionSet;
exports.touchSelectionSet = touchSelectionSet;
exports.getSelectionSets = getSelectionSets;
exports.selectNode = selectNode;
exports.isSelected = isSelected;
exports.lastSelectedNode = lastSelectedNode;
exports.getSelectedNodes = getSelectedNodes;
exports.deselectAll = deselectAll;
exports.getHighlighters = getHighlighters;
exports.touchHighlighter = touchHighlighter;
exports.setHighlighting = setHighlighting;
exports.setHighlightColor = setHighlightColor;
exports.getHighlightColor = getHighlightColor;
exports.setHighlightThickness = setHighlightThickness;
exports.getHighlightThickness = getHighlightThickness;
exports.isHighlighting = isHighlighting;

var _immutable = __webpack_require__(32);

var _createReducer2 = __webpack_require__(46);

var _createReducer3 = _interopRequireDefault(_createReducer2);

var _actionTypes = __webpack_require__(58);

var _SelectionSet = __webpack_require__(344);

var _SelectionSet2 = _interopRequireDefault(_SelectionSet);

var _Highlighter = __webpack_require__(343);

var _Highlighter2 = _interopRequireDefault(_Highlighter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SELECT_NODE = 'SELECT_NODE';
var DESELECT_ALL = 'DESELECT_ALL';
var SET_HIGHLIGHTING = 'SET_HIGHLIGHTING';
var SET_HIGHLIGHT_COLOR = 'SET_HIGHLIGHT_COLOR';
var SET_HIGHLIGHT_THICKNESS = 'SET_HIGHLIGHT_THICKNESS';

var ADD_SELECTION_SET = 'ADD_SELECTION_SET';
var REMOVE_SELECTION_SET = 'REMOVE_SELECTION_SET';
var TOUCH_SELECTION_SET = 'TOUCH_SELECTION_SET';
var ADD_HIGHLIGHTER = 'ADD_HIGHLIGHTER';
var REMOVE_HIGHLIGHTER = 'REMOVE_HIGHLIGHTER';
var TOUCH_HIGHLIGHTER = 'TOUCH_HIGHLIGHTER';

/**
 * Controls selection
 *
 * @module selection
 * @public
 */

var initialState = (0, _immutable.Map)({
  nodes: (0, _immutable.List)(),
  highlightNodes: false,
  highlightColor: '#00ff00',
  highlightThickness: 1,
  highlighters: (0, _immutable.Map)(),
  selectionSets: (0, _immutable.Map)()
});

var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, SELECT_NODE, function (state, nodeId) {
  var nodes = state.get('nodes');
  return state.set('nodes', !nodes.includes(nodeId) ? nodes.clear().push(nodeId) : nodes);
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.DELETE_NODE, function (state, nodeId) {
  var idx = state.get('nodes').indexOf(nodeId);
  return idx === -1 ? state : state.deleteIn(['nodes', idx]);
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state) {
  return state.set('nodes', state.get('nodes').clear());
}), (0, _defineProperty3.default)(_createReducer, DESELECT_ALL, function (state) {
  return state.set('nodes', state.get('nodes').clear());
}), (0, _defineProperty3.default)(_createReducer, SET_HIGHLIGHTING, function (state, highlight) {
  return state.set('highlightNodes', highlight);
}), (0, _defineProperty3.default)(_createReducer, SET_HIGHLIGHT_COLOR, function (state, color) {
  return state.set('highlightColor', color);
}), (0, _defineProperty3.default)(_createReducer, SET_HIGHLIGHT_THICKNESS, function (state, value) {
  return state.set('highlightThickness', value);
}), (0, _defineProperty3.default)(_createReducer, ADD_SELECTION_SET, function (state, ss) {
  return state.setIn(['selectionSets', ss.id], (0, _immutable.Map)({ set: ss, v: 0 }));
}), (0, _defineProperty3.default)(_createReducer, REMOVE_SELECTION_SET, function (state, id) {
  return state.deleteIn(['selectionSets', id]);
}), (0, _defineProperty3.default)(_createReducer, TOUCH_SELECTION_SET, function (state, ss) {
  var v = state.getIn(['selectionSets', ss.id, 'v']);
  console.log('ss version', ss.id, v + 1);
  return state.setIn(['selectionSets', ss.id, 'v'], v + 1);
}), (0, _defineProperty3.default)(_createReducer, ADD_HIGHLIGHTER, function (state, hl) {
  return state.setIn(['highlighters', hl.id], (0, _immutable.Map)({ hl: hl, v: 0 }));
}), (0, _defineProperty3.default)(_createReducer, REMOVE_HIGHLIGHTER, function (state, id) {
  return state.deleteIn(['highlighters', id]);
}), (0, _defineProperty3.default)(_createReducer, TOUCH_HIGHLIGHTER, function (state, hl) {
  var v = state.getIn(['highlighters', hl.id, 'v']);
  console.log('hl version', hl.id, v + 1);
  return state.setIn(['highlighters', hl.id, 'v'], v + 1);
}), _createReducer));

/**
 *
 * Create and returns a selection set. The SelectionSet may then
 * be manipulated by:
 *
 *  * `add(query)` - Add nodes to the SelectionSet
 *  * `remove(query)` - Remove nodes from the SelectionSet
 *  * `clear()` - Clear all nodes from the SelectionSet.
 *  * `destroy()` - deletes the SelectionSet.
 *
 * @public
 * @param {*} [ids] Array of node ids for selection set, or query to run
 * @returns {SelectionSet}
 *
 */
function createSelectionSet(ids, options) {
  return function (store) {
    var ss = new _SelectionSet2.default(store, ids, options);
    store.dispatch({ type: 'ADD_SELECTION_SET', payload: ss });
    return ss;
  };
}

function removeSelectionSet(id) {
  return { type: REMOVE_SELECTION_SET, payload: id };
}

function touchSelectionSet(ss) {
  return { type: 'TOUCH_SELECTION_SET', payload: ss };
}

function getSelectionSets(store) {
  var sets = store.getIn(['selection', 'selectionSets']);
  return sets.toArray().map(function (info) {
    return info.get('set');
  });
}

/**
 * Select node for highlight
 * @public
 * @param {String} nodeId - select the node with nodeId to be highlighted
*/
function selectNode(nodeId) {
  return { type: SELECT_NODE, payload: nodeId };
}

/**
 * Check if the node is selected
 * @public
 * @param {String} nodeId
 * @returns {Boolean}
*/
function isSelected(store, nodeId) {
  return store.getIn(['selection', 'nodes']).includes(nodeId);
}

/**
 * Return the last selected node Id
 * @public
 * @returns {String}
*/
function lastSelectedNode(store) {
  return store.getIn(['selection', 'nodes']).last();
}

/**
 * Return an array of selected nodes Id
 * @public
*/
function getSelectedNodes(store) {
  return store.getIn(['selection', 'nodes']).toArray();
}

/**
 * Deselect all nodes
 * @public
*/
function deselectAll() {
  return { type: DESELECT_ALL };
}

function getHighlighters(store) {
  var highlighters = store.getIn(['selection', 'highlighters']);
  return (0, _immutable.List)(highlighters.toArray().map(function (info) {
    return info.get('hl');
  }));
}

function touchHighlighter(highlighter) {
  return { type: 'TOUCH_HIGHLIGHTER', payload: highlighter };
}

/**
 *
 * Enable and disable highlight. If enabled, the return value
 * is a `Highlighter` that may be then manipulated:
 *
 * - `setSelectionSet(selectionSet)` - set the SelectionSet to be used by the highlighter.
 * - `setColor(color)` - update the color of the higlighter
 * - `setThickness(thickness)` - update the thickness of the highlighter
 *
 * @public
 * @param {Boolean} highlight - true/false for on/off
 * @returns {Highlighter}
 *
**/
function setHighlighting(highlight) {
  return function (store) {
    var highlighter = getHighlighters(store).first();
    if (highlight) {
      if (!highlighter) {
        highlighter = new _Highlighter2.default(store, {
          thickness: getHighlightThickness(store),
          color: getHighlightColor(store)
        });
        store.dispatch({ type: ADD_HIGHLIGHTER, payload: highlighter });
      }
      return highlighter;
    } else if (!highlight) {
      if (highlighter) store.dispatch({
        type: REMOVE_HIGHLIGHTER,
        payload: highlighter.id
      });
    }
  };
}

/**
 * Set highlight color
 * @public
 * @param {THREE.Color} color - color of the highlight
*/
function setHighlightColor(color) {
  return function (store) {
    var highlighter = getHighlighters(store).first();
    if (highlighter) highlighter.setColor(color);
    return store.dispatch({ type: SET_HIGHLIGHT_COLOR, payload: color });
  };
}

function getHighlightColor(store) {
  return store.getIn(['selection', 'highlightColor']);
}

function setHighlightThickness(value) {
  return function (store) {
    if (value > 5) value = 5;
    if (value <= 0) value = 0.1;
    var highlighter = getHighlighters(store).first();
    if (highlighter) highlighter.setThickness(value);
    return { type: SET_HIGHLIGHT_THICKNESS, payload: value };
  };
}

function getHighlightThickness(store) {
  return store.getIn(['selection', 'highlightThickness']);
}

function isHighlighting(store) {
  return store.getIn(['selection', 'highlightNodes']);
}

var publicApi = {
  reducer: reducer,
  actions: {
    selectNode: selectNode,
    deselectAll: deselectAll,
    setHighlighting: setHighlighting,
    setHighlightColor: setHighlightColor,
    setHighlightThickness: setHighlightThickness,
    createSelectionSet: createSelectionSet
  },
  selectors: {
    isSelected: isSelected,
    lastSelectedNode: lastSelectedNode,
    getHighlightColor: getHighlightColor,
    getHighlightThickness: getHighlightThickness,
    getSelectionSets: getSelectionSets
  }
};
exports.default = publicApi;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createReducer;
function createReducer(initialState, handlers) {
  return function reducer(state, action, allState, createEvent, trackEvent) {
    if (action && handlers.hasOwnProperty(action.type)) {
      return handlers[action.type](state, action.payload, {
        action: action,
        createEvent: createEvent,
        trackEvent: trackEvent,
        state: allState
      });
    } else {
      return state || initialState;
    }
  };
}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(511), __esModule: true };

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(520), __esModule: true };

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__(498);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.flatNormalMap = flatNormalMap;
exports.areaWeightedNormalMap = areaWeightedNormalMap;
exports.autoSmooth = autoSmooth;
exports.recalculateNormalsFromConnectivity = recalculateNormalsFromConnectivity;

var _three = __webpack_require__(0);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _removeDuplicateNormals = __webpack_require__(159);

var _removeDuplicateNormals2 = _interopRequireDefault(_removeDuplicateNormals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NormalType = {
  Default: -1,
  Average: 0,
  Flat: 1,
  AutoSmooth: 2,
  NoNormals: 3,
  FromConnectivity: 4
};

var Normals = {
  schema: {
    normalTypes: {
      label: 'Normal Type',
      type: 'Number',
      defaultValue: NormalType.Default
    },
    smoothingAngle: {
      label: 'Smooth Angle',
      type: 'Number',
      defaultValue: 30,
      step: 1,
      minValue: 0,
      maxValue: 180
    },
    flipfaces: { label: 'Flip Faces', type: 'Boolean', defaultValue: false }
    //indices: { label: "Selection", type: 'TextArea', defaultValue: "", display: 'indexStyle' } // face Indices
  },

  update: function update(operator, primitive) {
    var normalType = operator.normalTypes;
    var flipfaces = operator.flipfaces;
    var smoothingAngle = operator.smoothingAngle;
    var mesh = primitive.mesh;
    if (!mesh) return primitive;

    switch (normalType) {
      case NormalType.NoNormals:
        mesh = (0, _assign2.default)({}, mesh);
        mesh.normalMap = null;
        mesh = new _PolyMesh2.default(mesh);
        break;

      case NormalType.Flat:
        mesh = flatNormalMap(mesh);
        break;

      case NormalType.Average:
        mesh = areaWeightedNormalMap(mesh);
        break;

      case NormalType.AutoSmooth:
        mesh = autoSmooth(mesh, smoothingAngle);
        break;

      case NormalType.FromConnectivity:
        mesh = recalculateNormalsFromConnectivity(mesh);
        break;

      case NormalType.Default:
      default:
        //leave normals unchanged
        return primitive;
    }

    primitive.mesh = mesh;
    return primitive;
  }
};

function flatNormalMap(mesh) {
  var faceRangeOffsets = mesh.positions.faceRangeOffsets;
  var faceValueIndices = mesh.positions.faceValueIndices;
  var values = mesh.positions.values;
  var valueAdjacency = mesh.positions.valueAdjacency;
  var normalFaceValueIndices = new Uint32Array(faceValueIndices.length);
  var normals = new _ObjectArrayView2.default(_three.Vector3, faceValueIndices.length);

  var v1 = new _three.Vector3();
  var v2 = new _three.Vector3();
  var currentValue = new _three.Vector3();

  for (var i = 0; i < faceRangeOffsets.length; i++) {
    for (var j = faceRangeOffsets[i]; j < faceRangeOffsets[i + 1]; j++) {
      var adjacentValues = valueAdjacency.getAdjacentFaceValuesIndicesOnFace(j, i);

      values.getAt(faceValueIndices[j], currentValue);
      v1.multiplyScalar(0);
      v2.multiplyScalar(0);

      if (adjacentValues.length === 2) {
        values.getAt(faceValueIndices[adjacentValues[0]], v1);
        values.getAt(faceValueIndices[adjacentValues[1]], v2);
        v1.subVectors(currentValue, v1);
        v2.subVectors(currentValue, v2);
        currentValue.copy(v2.cross(v1));
      }

      currentValue.normalize();
      normalFaceValueIndices[j] = j;
      normals.setAt(j, currentValue);
    }
  }

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: mesh.positions.faceRangeOffsets,
    faceValueIndices: normalFaceValueIndices,
    values: normals
  });
  var resultMesh = new _PolyMesh2.default(mesh);
  resultMesh.normalMap = normalMap;

  return (0, _removeDuplicateNormals2.default)(resultMesh);
}

function areaWeightedNormalMap(mesh) {
  var faceValueIndices = mesh.positions.faceValueIndices;
  var values = mesh.positions.values;
  var valueAdjacency = mesh.positions.valueAdjacency;

  var v1 = new _three.Vector3();
  var v2 = new _three.Vector3();
  var accumulation = new _three.Vector3();
  var currentValue = new _three.Vector3();

  var normals = new _ObjectArrayView2.default(_three.Vector3, values.length);

  for (var i = 0; i < values.length; i++) {
    var numFacesOnVertex = valueAdjacency.getNumFacesForVertex(i);
    var facesOnVertex = [];

    //get faces on vertex
    for (var j = 0; j < numFacesOnVertex; j++) {
      facesOnVertex.push(valueAdjacency.getFaceForVertexId(i, j));
    }

    values.getAt(i, currentValue);
    accumulation.multiplyScalar(0);
    v1.multiplyScalar(0);
    v2.multiplyScalar(0);

    //get weighted accumulation of face normals for all faces on vertex
    for (var _j = 0; _j < facesOnVertex.length; _j++) {
      var adjacentValues = valueAdjacency.getAdjacentFaceValuesIndicesOnFace(getIndexOnFaceFromValue(mesh, i, facesOnVertex[_j]), facesOnVertex[_j]);
      if (adjacentValues.length === 2) {
        values.getAt(faceValueIndices[adjacentValues[0]], v1);
        values.getAt(faceValueIndices[adjacentValues[1]], v2);
        v1.subVectors(currentValue, v1);
        v2.subVectors(currentValue, v2);
        accumulation.add(v2.cross(v1));
      }
    }

    accumulation.normalize();
    normals.setAt(i, accumulation);
  }

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: mesh.positions.faceRangeOffsets,
    faceValueIndices: mesh.positions.faceValueIndices,
    values: normals
  });
  var resultMesh = new _PolyMesh2.default(mesh);
  resultMesh.normalMap = normalMap;

  return resultMesh;
}

function autoSmooth(mesh, smoothingAngle) {
  smoothingAngle = smoothingAngle || 30;
  var polyMesh = mesh;
  var smoothingAngleRad = smoothingAngle * _three.Math.DEG2RAD;
  var faceRangeOffsets = polyMesh.faceRangeOffsets;
  var faceValueIndices = polyMesh.positions.faceValueIndices;
  var values = polyMesh.positions.values;
  var normalMapFaceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices.length);
  var normalMapValuesArray = [];

  var v1 = new _three.Vector3();
  var v2 = new _three.Vector3();
  var currentValue = new _three.Vector3();

  var valueAdjacency = polyMesh.positions.valueAdjacency;
  var faceFaceAdjacency = polyMesh.positions.faceFaceAdjacency;

  var normalIndex = 0;

  function setNormalIndex(vertexIndex, face, index) {
    var faceArray = [];
    for (var j = faceRangeOffsets[face]; j < faceRangeOffsets[face + 1]; j++) {
      faceArray.push(faceValueIndices[j]);
      if (faceValueIndices[j] === vertexIndex) {
        normalMapFaceValueIndices[j] = index;
        return;
      }
    }

    console.error('index ' + vertexIndex + ' is not on face ' + face, faceArray);
  }

  //for every vertex
  for (var i = 0; i < values.length; i++) {
    var numFacesOnVertex = valueAdjacency.getNumFacesForVertex(i);
    var facesOnVertex = [];
    var faceNormalMapping = [];
    values.getAt(i, currentValue);

    //get faces on vertex
    for (var j = 0; j < numFacesOnVertex; j++) {
      facesOnVertex.push(valueAdjacency.getFaceForVertexId(i, j));
      faceNormalMapping.push(-1);
    }

    //for every face around vertex
    for (var _j2 = 0; _j2 < facesOnVertex.length; _j2++) {
      if (faceNormalMapping[_j2] > -1) continue;

      var startFace = facesOnVertex[_j2];
      var startFaceAdjacentFaces = faceFaceAdjacency.adjacentFacesOnVertex(facesOnVertex[_j2], i);

      var facesInGroup = [];
      facesInGroup.push(startFace);

      var current = startFace;
      var next = startFaceAdjacentFaces[0];
      var nextNext = -1;

      //walk around the left, and then the right
      for (var k = 0; k < startFaceAdjacentFaces.length; k++) {
        //walk around the faces around the vertex
        for (var f = 0; f < facesOnVertex.length; f++) {
          var adjacentValuesCurrent = valueAdjacency.getAdjacentFaceValuesIndicesOnFace(getIndexOnFaceFromValue(polyMesh, i, current), current);
          values.getAt(faceValueIndices[adjacentValuesCurrent[0]], v1);
          values.getAt(faceValueIndices[adjacentValuesCurrent[1]], v2);
          v1.subVectors(currentValue, v1);
          v2.subVectors(currentValue, v2);
          var currentN = new _three.Vector3().copy(v2.cross(v1));
          currentN.normalize();

          var adjacentValuesNext = valueAdjacency.getAdjacentFaceValuesIndicesOnFace(getIndexOnFaceFromValue(polyMesh, i, next), next);
          values.getAt(faceValueIndices[adjacentValuesNext[0]], v1);
          values.getAt(faceValueIndices[adjacentValuesNext[1]], v2);
          v1.subVectors(currentValue, v1);
          v2.subVectors(currentValue, v2);
          var nextN = new _three.Vector3().copy(v2.cross(v1));
          nextN.normalize();

          var currentNextNormalDot = currentN.dot(nextN);

          if (next === startFace || faceNormalMapping[facesOnVertex.indexOf(next)] > -1 || Math.acos(currentNextNormalDot) > smoothingAngleRad) {
            //full circle, already alocated or hard edge
            break;
          }
          //else face add to smoothing group
          facesInGroup.push(next);
          var nextAdjacentFaces = faceFaceAdjacency.adjacentFacesOnVertex(next, i);
          //edge found
          if (nextAdjacentFaces.length < 2) break;

          nextNext = nextAdjacentFaces[0] === current ? nextAdjacentFaces[1] : nextAdjacentFaces[0];
          current = next;
          next = nextNext;
        }

        //walk the other way on the next
        current = startFace;
        next = startFaceAdjacentFaces[1];
        nextNext = -1;
      }

      var accumulation = new _three.Vector3();
      for (var _k = 0; _k < facesInGroup.length; _k++) {
        setNormalIndex(i, facesInGroup[_k], normalIndex);
        faceNormalMapping[facesOnVertex.indexOf(facesInGroup[_k])] = normalIndex;

        //accumulate weighted normal
        var adjacentValues = valueAdjacency.getAdjacentFaceValuesIndicesOnFace(getIndexOnFaceFromValue(polyMesh, i, facesInGroup[_k]), facesInGroup[_k]);
        if (adjacentValues.length === 2) {
          values.getAt(faceValueIndices[adjacentValues[0]], v1);
          values.getAt(faceValueIndices[adjacentValues[1]], v2);
          v1.subVectors(currentValue, v1);
          v2.subVectors(currentValue, v2);
          accumulation.add(v2.cross(v1));
        }
      }

      accumulation.normalize();
      normalMapValuesArray.push(accumulation);
      if (facesInGroup.length > 0) normalIndex++;
    }
  }

  var normalMapValues = new _ObjectArrayView2.default(_three.Vector3, normalMapValuesArray.length);
  for (var _i = 0; _i < normalMapValuesArray.length; _i++) {
    normalMapValues.setAt(_i, normalMapValuesArray[_i]);
  }

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: polyMesh.faceRangeOffsets,
    faceValueIndices: normalMapFaceValueIndices,
    values: normalMapValues
  });

  var resultMesh = new _PolyMesh2.default(polyMesh);
  resultMesh.normalMap = normalMap;

  return resultMesh;
}

function getIndexOnFaceFromValue(mesh, vertexIndex, face) {
  var faceRangeOffsets = mesh.faceRangeOffsets;
  var faceValueIndices = mesh.positions.faceValueIndices;
  for (var i = faceRangeOffsets[face]; i < faceRangeOffsets[face + 1]; i++) {
    if (faceValueIndices[i] === vertexIndex) {
      return i;
    }
  }

  return -1;
}

function recalculateNormalsFromConnectivity(mesh) {
  if (!mesh || !mesh.normalMap || !mesh.normalMap.faceValueIndices) return mesh;

  var faceRangeOffsets = mesh.faceRangeOffsets;
  var faceValueIndices = mesh.positions.faceValueIndices;
  var normalFaceValueIndices = mesh.normalMap.faceValueIndices;
  var values = mesh.positions.values;
  var newNormalValues = new _ObjectArrayView2.default(_three.Vector3, mesh.normalMap.values.length);
  //newNormalValues.fromArray(mesh.normalMap.values.toArray());

  var v0 = new _three.Vector3();
  var v1 = new _three.Vector3();
  var v2 = new _three.Vector3();

  for (var i = 0; i < faceRangeOffsets.length - 1; i++) {
    //TODO check for face size of < 3
    values.getAt(faceValueIndices[faceRangeOffsets[i]], v1);
    values.getAt(faceValueIndices[faceRangeOffsets[i] + 1], v0);
    values.getAt(faceValueIndices[faceRangeOffsets[i] + 2], v2);

    v1.subVectors(v0, v1);
    v2.subVectors(v0, v2);
    v0.copy(v2.cross(v1));

    for (var j = faceRangeOffsets[i]; j < faceRangeOffsets[i + 1]; j++) {
      newNormalValues.getAt(normalFaceValueIndices[j], v1);
      newNormalValues.setAt(normalFaceValueIndices[j], v1.add(v0));
    }
  }

  for (var _i2 = 0; _i2 < newNormalValues.length; _i2++) {
    newNormalValues.getAt(_i2, v0);
    v0.normalize();
    newNormalValues.setAt(_i2, v0);
  }

  var resultMesh = new _PolyMesh2.default(mesh);
  resultMesh.normalMap.values = newNormalValues;

  return resultMesh;
}

exports.default = Normals;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = decompose;

var _three = __webpack_require__(0);

function decompose(matrix4) {
  var translation = new _three.Vector3();
  var rotQuat = new _three.Quaternion();
  var scale = new _three.Vector3();
  matrix4.decompose(translation, rotQuat, scale);
  var rotation = new _three.Vector3().copy(new _three.Euler().setFromQuaternion(rotQuat, 'ZYX'));
  rotation.multiplyScalar(180 / Math.PI); // convert to degrees
  return { translation: translation, rotation: rotation };
}

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(73);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(191);
var defined = __webpack_require__(74);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(35)) {
  var LIBRARY = __webpack_require__(90);
  var global = __webpack_require__(13);
  var fails = __webpack_require__(21);
  var $export = __webpack_require__(1);
  var $typed = __webpack_require__(201);
  var $buffer = __webpack_require__(302);
  var ctx = __webpack_require__(52);
  var anInstance = __webpack_require__(87);
  var propertyDesc = __webpack_require__(75);
  var hide = __webpack_require__(42);
  var redefineAll = __webpack_require__(92);
  var toInteger = __webpack_require__(76);
  var toLength = __webpack_require__(30);
  var toIndex = __webpack_require__(301);
  var toAbsoluteIndex = __webpack_require__(94);
  var toPrimitive = __webpack_require__(119);
  var has = __webpack_require__(36);
  var classof = __webpack_require__(186);
  var isObject = __webpack_require__(14);
  var toObject = __webpack_require__(77);
  var isArrayIter = __webpack_require__(192);
  var create = __webpack_require__(115);
  var getPrototypeOf = __webpack_require__(117);
  var gOPN = __webpack_require__(116).f;
  var getIterFn = __webpack_require__(202);
  var uid = __webpack_require__(78);
  var wks = __webpack_require__(16);
  var createArrayMethod = __webpack_require__(112);
  var createArrayIncludes = __webpack_require__(185);
  var speciesConstructor = __webpack_require__(198);
  var ArrayIterators = __webpack_require__(203);
  var Iterators = __webpack_require__(89);
  var $iterDetect = __webpack_require__(143);
  var setSpecies = __webpack_require__(145);
  var arrayFill = __webpack_require__(184);
  var arrayCopyWithin = __webpack_require__(281);
  var $DP = __webpack_require__(26);
  var $GOPD = __webpack_require__(63);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = __webpack_require__(23);
var WakeLock = __webpack_require__(717);

// Start at a higher number to reduce chance of conflict.
var nextDisplayId = 1000;
var hasShowDeprecationWarning = false;

var defaultLeftBounds = [0, 0, 0.5, 1];
var defaultRightBounds = [0.5, 0, 0.5, 1];

/**
 * The base class for all VR frame data.
 */

function VRFrameData() {
  this.leftProjectionMatrix = new Float32Array(16);
  this.leftViewMatrix = new Float32Array(16);
  this.rightProjectionMatrix = new Float32Array(16);
  this.rightViewMatrix = new Float32Array(16);
  this.pose = null;
};

/**
 * The base class for all VR displays.
 */
function VRDisplay() {
  this.isPolyfilled = true;
  this.displayId = nextDisplayId++;
  this.displayName = 'webvr-polyfill displayName';

  this.depthNear = 0.01;
  this.depthFar = 10000.0;

  this.isConnected = true;
  this.isPresenting = false;
  this.capabilities = {
    hasPosition: false,
    hasOrientation: false,
    hasExternalDisplay: false,
    canPresent: false,
    maxLayers: 1
  };
  this.stageParameters = null;

  // "Private" members.
  this.waitingForPresent_ = false;
  this.layer_ = null;

  this.fullscreenElement_ = null;
  this.fullscreenWrapper_ = null;
  this.fullscreenElementCachedStyle_ = null;

  this.fullscreenEventTarget_ = null;
  this.fullscreenChangeHandler_ = null;
  this.fullscreenErrorHandler_ = null;

  this.wakelock_ = new WakeLock();
}

VRDisplay.prototype.getFrameData = function(frameData) {
  // TODO: Technically this should retain it's value for the duration of a frame
  // but I doubt that's practical to do in javascript.
  return Util.frameDataFromPose(frameData, this.getPose(), this);
};

VRDisplay.prototype.getPose = function() {
  // TODO: Technically this should retain it's value for the duration of a frame
  // but I doubt that's practical to do in javascript.
  return this.getImmediatePose();
};

VRDisplay.prototype.requestAnimationFrame = function(callback) {
  return window.requestAnimationFrame(callback);
};

VRDisplay.prototype.cancelAnimationFrame = function(id) {
  return window.cancelAnimationFrame(id);
};

VRDisplay.prototype.wrapForFullscreen = function(element) {
  // Don't wrap in iOS.
  if (Util.isIOS()) {
    return element;
  }
  if (!this.fullscreenWrapper_) {
    this.fullscreenWrapper_ = document.createElement('div');
    var cssProperties = [
      'height: ' + Math.min(screen.height, screen.width) + 'px !important',
      'top: 0 !important',
      'left: 0 !important',
      'right: 0 !important',
      'border: 0',
      'margin: 0',
      'padding: 0',
      'z-index: 999999 !important',
      'position: fixed',
    ];
    this.fullscreenWrapper_.setAttribute('style', cssProperties.join('; ') + ';');
    this.fullscreenWrapper_.classList.add('webvr-polyfill-fullscreen-wrapper');
  }

  if (this.fullscreenElement_ == element) {
    return this.fullscreenWrapper_;
  }

  // Remove any previously applied wrappers
  this.removeFullscreenWrapper();

  this.fullscreenElement_ = element;
  var parent = this.fullscreenElement_.parentElement;
  parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
  parent.removeChild(this.fullscreenElement_);
  this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
  this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute('style');

  var self = this;
  function applyFullscreenElementStyle() {
    if (!self.fullscreenElement_) {
      return;
    }

    var cssProperties = [
      'position: absolute',
      'top: 0',
      'left: 0',
      'width: ' + Math.max(screen.width, screen.height) + 'px',
      'height: ' + Math.min(screen.height, screen.width) + 'px',
      'border: 0',
      'margin: 0',
      'padding: 0',
    ];
    self.fullscreenElement_.setAttribute('style', cssProperties.join('; ') + ';');
  }

  applyFullscreenElementStyle();

  return this.fullscreenWrapper_;
};

VRDisplay.prototype.removeFullscreenWrapper = function() {
  if (!this.fullscreenElement_) {
    return;
  }

  var element = this.fullscreenElement_;
  if (this.fullscreenElementCachedStyle_) {
    element.setAttribute('style', this.fullscreenElementCachedStyle_);
  } else {
    element.removeAttribute('style');
  }
  this.fullscreenElement_ = null;
  this.fullscreenElementCachedStyle_ = null;

  var parent = this.fullscreenWrapper_.parentElement;
  this.fullscreenWrapper_.removeChild(element);
  parent.insertBefore(element, this.fullscreenWrapper_);
  parent.removeChild(this.fullscreenWrapper_);

  return element;
};

VRDisplay.prototype.requestPresent = function(layers) {
  var wasPresenting = this.isPresenting;
  var self = this;

  if (!(layers instanceof Array)) {
    if (!hasShowDeprecationWarning) {
      console.warn("Using a deprecated form of requestPresent. Should pass in an array of VRLayers.");
      hasShowDeprecationWarning = true;
    }
    layers = [layers];
  }

  return new Promise(function(resolve, reject) {
    if (!self.capabilities.canPresent) {
      reject(new Error('VRDisplay is not capable of presenting.'));
      return;
    }

    if (layers.length == 0 || layers.length > self.capabilities.maxLayers) {
      reject(new Error('Invalid number of layers.'));
      return;
    }

    var incomingLayer = layers[0];
    if (!incomingLayer.source) {
      /*
      todo: figure out the correct behavior if the source is not provided.
      see https://github.com/w3c/webvr/issues/58
      */
      resolve();
      return;
    }

    var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
    var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
    if (wasPresenting) {
      // Already presenting, just changing configuration
      var layer = self.layer_;
      if (layer.source !== incomingLayer.source) {
        layer.source = incomingLayer.source;
      }

      for (var i = 0; i < 4; i++) {
        layer.leftBounds[i] = leftBounds[i];
        layer.rightBounds[i] = rightBounds[i];
      }

      resolve();
      return;
    }

    // Was not already presenting.
    self.layer_ = {
      predistorted: incomingLayer.predistorted,
      source: incomingLayer.source,
      leftBounds: leftBounds.slice(0),
      rightBounds: rightBounds.slice(0)
    };

    self.waitingForPresent_ = false;
    if (self.layer_ && self.layer_.source) {
      var fullscreenElement = self.wrapForFullscreen(self.layer_.source);

      var onFullscreenChange = function() {
        var actualFullscreenElement = Util.getFullscreenElement();

        self.isPresenting = (fullscreenElement === actualFullscreenElement);
        if (self.isPresenting) {
          if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape-primary').catch(function(error){
                    console.error('screen.orientation.lock() failed due to', error.message)
            });
          }
          self.waitingForPresent_ = false;
          self.beginPresent_();
          resolve();
        } else {
          if (screen.orientation && screen.orientation.unlock) {
            screen.orientation.unlock();
          }
          self.removeFullscreenWrapper();
          self.wakelock_.release();
          self.endPresent_();
          self.removeFullscreenListeners_();
        }
        self.fireVRDisplayPresentChange_();
      }
      var onFullscreenError = function() {
        if (!self.waitingForPresent_) {
          return;
        }

        self.removeFullscreenWrapper();
        self.removeFullscreenListeners_();

        self.wakelock_.release();
        self.waitingForPresent_ = false;
        self.isPresenting = false;

        reject(new Error('Unable to present.'));
      }

      self.addFullscreenListeners_(fullscreenElement,
          onFullscreenChange, onFullscreenError);

      if (Util.requestFullscreen(fullscreenElement)) {
        self.wakelock_.request();
        self.waitingForPresent_ = true;
      } else if (Util.isIOS() || Util.isWebViewAndroid()) {
        // *sigh* Just fake it.
        self.wakelock_.request();
        self.isPresenting = true;
        self.beginPresent_();
        self.fireVRDisplayPresentChange_();
        resolve();
      }
    }

    if (!self.waitingForPresent_ && !Util.isIOS()) {
      Util.exitFullscreen();
      reject(new Error('Unable to present.'));
    }
  });
};

VRDisplay.prototype.exitPresent = function() {
  var wasPresenting = this.isPresenting;
  var self = this;
  this.isPresenting = false;
  this.layer_ = null;
  this.wakelock_.release();

  return new Promise(function(resolve, reject) {
    if (wasPresenting) {
      if (!Util.exitFullscreen() && Util.isIOS()) {
        self.endPresent_();
        self.fireVRDisplayPresentChange_();
      }

      if (Util.isWebViewAndroid()) {
        self.removeFullscreenWrapper();
        self.removeFullscreenListeners_();
        self.endPresent_();
        self.fireVRDisplayPresentChange_();
      }

      resolve();
    } else {
      reject(new Error('Was not presenting to VRDisplay.'));
    }
  });
};

VRDisplay.prototype.getLayers = function() {
  if (this.layer_) {
    return [this.layer_];
  }
  return [];
};

VRDisplay.prototype.fireVRDisplayPresentChange_ = function() {
  // Important: unfortunately we cannot have full spec compliance here.
  // CustomEvent custom fields all go under e.detail (so the VRDisplay ends up
  // being e.detail.display, instead of e.display as per WebVR spec).
  var event = new CustomEvent('vrdisplaypresentchange', {detail: {display: this}});
  window.dispatchEvent(event);
};

VRDisplay.prototype.fireVRDisplayConnect_ = function() {
  // Important: unfortunately we cannot have full spec compliance here.
  // CustomEvent custom fields all go under e.detail (so the VRDisplay ends up
  // being e.detail.display, instead of e.display as per WebVR spec).
  var event = new CustomEvent('vrdisplayconnect', {detail: {display: this}});
  window.dispatchEvent(event);
};

VRDisplay.prototype.addFullscreenListeners_ = function(element, changeHandler, errorHandler) {
  this.removeFullscreenListeners_();

  this.fullscreenEventTarget_ = element;
  this.fullscreenChangeHandler_ = changeHandler;
  this.fullscreenErrorHandler_ = errorHandler;

  if (changeHandler) {
    if (document.fullscreenEnabled) {
      element.addEventListener('fullscreenchange', changeHandler, false);
    } else if (document.webkitFullscreenEnabled) {
      element.addEventListener('webkitfullscreenchange', changeHandler, false);
    } else if (document.mozFullScreenEnabled) {
      document.addEventListener('mozfullscreenchange', changeHandler, false);
    } else if (document.msFullscreenEnabled) {
      element.addEventListener('msfullscreenchange', changeHandler, false);
    }
  }

  if (errorHandler) {
    if (document.fullscreenEnabled) {
      element.addEventListener('fullscreenerror', errorHandler, false);
    } else if (document.webkitFullscreenEnabled) {
      element.addEventListener('webkitfullscreenerror', errorHandler, false);
    } else if (document.mozFullScreenEnabled) {
      document.addEventListener('mozfullscreenerror', errorHandler, false);
    } else if (document.msFullscreenEnabled) {
      element.addEventListener('msfullscreenerror', errorHandler, false);
    }
  }
};

VRDisplay.prototype.removeFullscreenListeners_ = function() {
  if (!this.fullscreenEventTarget_)
    return;

  var element = this.fullscreenEventTarget_;

  if (this.fullscreenChangeHandler_) {
    var changeHandler = this.fullscreenChangeHandler_;
    element.removeEventListener('fullscreenchange', changeHandler, false);
    element.removeEventListener('webkitfullscreenchange', changeHandler, false);
    document.removeEventListener('mozfullscreenchange', changeHandler, false);
    element.removeEventListener('msfullscreenchange', changeHandler, false);
  }

  if (this.fullscreenErrorHandler_) {
    var errorHandler = this.fullscreenErrorHandler_;
    element.removeEventListener('fullscreenerror', errorHandler, false);
    element.removeEventListener('webkitfullscreenerror', errorHandler, false);
    document.removeEventListener('mozfullscreenerror', errorHandler, false);
    element.removeEventListener('msfullscreenerror', errorHandler, false);
  }

  this.fullscreenEventTarget_ = null;
  this.fullscreenChangeHandler_ = null;
  this.fullscreenErrorHandler_ = null;
};

VRDisplay.prototype.beginPresent_ = function() {
  // Override to add custom behavior when presentation begins.
};

VRDisplay.prototype.endPresent_ = function() {
  // Override to add custom behavior when presentation ends.
};

VRDisplay.prototype.submitFrame = function(pose) {
  // Override to add custom behavior for frame submission.
};

VRDisplay.prototype.getEyeParameters = function(whichEye) {
  // Override to return accurate eye parameters if canPresent is true.
  return null;
};

/*
 * Deprecated classes
 */

/**
 * The base class for all VR devices. (Deprecated)
 */
function VRDevice() {
  this.isPolyfilled = true;
  this.hardwareUnitId = 'webvr-polyfill hardwareUnitId';
  this.deviceId = 'webvr-polyfill deviceId';
  this.deviceName = 'webvr-polyfill deviceName';
}

/**
 * The base class for all VR HMD devices. (Deprecated)
 */
function HMDVRDevice() {
}
HMDVRDevice.prototype = new VRDevice();

/**
 * The base class for all VR position sensor devices. (Deprecated)
 */
function PositionSensorVRDevice() {
}
PositionSensorVRDevice.prototype = new VRDevice();

module.exports.VRFrameData = VRFrameData;
module.exports.VRDisplay = VRDisplay;
module.exports.VRDevice = VRDevice;
module.exports.HMDVRDevice = HMDVRDevice;
module.exports.PositionSensorVRDevice = PositionSensorVRDevice;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

const browser = __webpack_require__(685);

/*
 * This module wraps the detect-browser library, giving it a better
 * api (So it's not undefined if no browser is matched), and also
 * contains our own checks for `isMobile`, `isIE`, `isIOS`, etc.
 */
const info = browser || { name: 'unknown', version: '0' };
info.isIE = info.name === 'ie';
info.isMobile = false;
info.isIOS = false;
info.isAndroid = false;
info.isAndroidTablet = false;

if (true && window.navigator) {
  const userAgent = window.navigator.userAgent;
  info.isIOS = /iPad|iPhone|iPod/.test(userAgent);
  info.isAndroid = /Android/i.test(userAgent);
  const isMSPhone = /IEMobile|Windows Phone|Lumia/i.test(userAgent);
  const isChromebook = /CrOS/i.test(userAgent);
  const isBlackberry = /Blackberry|webOS/i.test(userAgent);
  info.isMobile =
    info.isIOS || info.isAndroid || isMSPhone || isChromebook || isBlackberry;
  info.isAndroidTablet = info.isAndroid && /^(?!.*Mobile).*$/.test(userAgent);
  // window.runtimeInfo = info;
}

module.exports = info;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(107);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// shared:
//
var LOAD_SCENE = exports.LOAD_SCENE = 'LOAD_SCENE';
var ADD_NODE = exports.ADD_NODE = 'ADDNODE';
var ADD_VR_CAMERA = exports.ADD_VR_CAMERA = 'ADD_VR_CAMERA';
var DELETE_NODE = exports.DELETE_NODE = 'DELETE_NODE';
var LOADING_FILE = exports.LOADING_FILE = 'LOADING_FILE';
var LOADED_FILE = exports.LOADED_FILE = 'LOADED_FILE';
var LOADING_FILE_ERROR = exports.LOADING_FILE_ERROR = 'LOADING_FILE_ERROR';
var USE_SCENE = exports.USE_SCENE = 'USE_SCENE';
var INITIALIZE_SCENE = exports.INITIALIZE_SCENE = 'INITIALIZE_SCENE';
var CLEAR_SCENE = exports.CLEAR_SCENE = 'CLEAR_SCENE';
var PRELOADED_SCENE = exports.PRELOADED_SCENE = 'PRELOADED_SCENE';

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getTargetWorldMatrix;

var _three = __webpack_require__(0);

var _scene = __webpack_require__(7);

var _sceneGraph = __webpack_require__(10);

var _player = __webpack_require__(8);

var position = new _three.Vector3();
var rotation = new _three.Quaternion();
var scale = new _three.Vector3();
/**
 * If the Camera has a look at attached, return that, otherwise the
 * virtual target transform
 * @returns {Matrix4}
 */
function getTargetWorldMatrix(store, cameraId, initCameraTransform) {
  var cameraTransform = initCameraTransform || (0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' });
  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
  if (cameraTransform && cameraTransform.target) {
    var lookAtTarget = (0, _scene.getWorldTransform)(store, cameraTransform.target.nodeId);
    var offset = cameraData.offset;
    lookAtTarget.decompose(position, rotation, scale);
    return !offset ? lookAtTarget : lookAtTarget.compose(position.add(offset), rotation, scale);
  } else {
    var currentCammera = (0, _player.getCamera)(store);

    if (cameraId === currentCammera) {
      return (0, _scene.getWorldTransform)(store, _sceneGraph.virtualTargetId);
    } else {
      var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
      var cameraProperties = (0, _scene.get)(store, {
        id: cameraId,
        evalPlug: 'Properties'
      }) || { orbitTarget: _sceneGraph.virtualTargetId };
      var targetId = playerData.overrideNavigation ? playerData.orbitTarget : cameraProperties.orbitTarget;
      return (0, _scene.getWorldTransform)(store, targetId || _sceneGraph.virtualTargetId);
    }
  }
}

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 61 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(41);
var createDesc = __webpack_require__(110);
module.exports = __webpack_require__(40) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(118);
var createDesc = __webpack_require__(75);
var toIObject = __webpack_require__(53);
var toPrimitive = __webpack_require__(119);
var has = __webpack_require__(36);
var IE8_DOM_DEFINE = __webpack_require__(285);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(35) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(13);
var hide = __webpack_require__(42);
var has = __webpack_require__(36);
var SRC = __webpack_require__(78)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(113).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(171);
var defined = __webpack_require__(168);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 66 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(38);

var _typeof3 = _interopRequireDefault(_typeof2);

var _values = __webpack_require__(130);

var _values2 = _interopRequireDefault(_values);

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _createReducer;

exports.setFrameTime = setFrameTime;
exports.getTime = getTime;
exports.setTime = setTime;
exports.isPlaying = isPlaying;
exports.startPlaying = startPlaying;
exports.incrementTime = incrementTime;
exports.stopPlaying = stopPlaying;
exports.queueClip = queueClip;
exports.findClip = findClip;
exports.queueAnimation = queueAnimation;
exports.updateAnimationAttrs = updateAnimationAttrs;
exports.findAnimation = findAnimation;
exports.findAnimationIndex = findAnimationIndex;
exports.removeAnimation = removeAnimation;
exports.addClip = addClip;
exports.makeReducedClip = makeReducedClip;
exports.getClips = getClips;
exports.getTimelineAnimation = getTimelineAnimation;

var _v = __webpack_require__(79);

var _v2 = _interopRequireDefault(_v);

var _immutable = __webpack_require__(32);

var _createReducer2 = __webpack_require__(46);

var _createReducer3 = _interopRequireDefault(_createReducer2);

var _sceneGraph = __webpack_require__(10);

var _tweenFunctions = __webpack_require__(353);

var _tweenFunctions2 = _interopRequireDefault(_tweenFunctions);

var _actionTypes = __webpack_require__(58);

var _createStore = __webpack_require__(128);

var _scene = __webpack_require__(7);

var _physics = __webpack_require__(350);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SET_TIME = 'SET_TIME';
var SET_FRAME_TIME = 'SET_FRAME_TIME';
var START_PLAYING = 'START_PLAYING';
var STOP_PLAYING = 'STOP_PLAYING';
var UPDATE_TRACK = 'UPDATE_TRACK';
var UPDATE_ANIMATION = 'UPDATE_ANIMATION';
var REMOVE_ANIMATION = 'REMOVE_ANIMATION';
var QUEUE_ANIMATION = 'QUEUE_ANIMATION';
var QUEUE_TIMELINE_ANIMATION = 'QUEUE_TIMELINE_ANIMATION';
var ADD_CLIP = 'ADD_CLIP';
var ADD_BUFFER_CLIP = 'ADD_BUFFER_CLIP';
var INIT_PHYSICS = 'INIT_PHYSICS';

/**
 *
 * This module controls the animation happening. The properties of an
 * animation are [defined here in the Animation type](global.html#Animation).
 *
 * Animations can be queued dynamically with [`queueAnimation`](module-animation.html#.queueAnimation)
 * Or, to play existing clips, queue a clip for playing with [`queueClip`](module-animation.html#.queueClip).
 *
 * @module animation
 * @public
 *
 */

function nameOrIdFilter(nameOrId) {
  return function (attrs) {
    return attrs.id === nameOrId || attrs.name === nameOrId;
  };
}

function newInitialState() {
  var clips = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _immutable.Map)();

  return (0, _immutable.Map)({
    time: 0,
    startTime: null,
    playing: false,
    autoplay: false,
    frameTime: 0,
    animations: (0, _immutable.List)(),
    clips: clips,
    timelineAnimationIndex: -1,
    dynamicsWorld: null,
    dynamicBodies: {},
    kinematicBodies: {},
    bufferClips: (0, _immutable.Map)()
  });
}

var reducer = (0, _createReducer3.default)(newInitialState(), (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, _createStore.ActionTypes.INIT, function (state) {
  return newInitialState();
}), (0, _defineProperty3.default)(_createReducer, SET_TIME, function (state, _ref) {
  var time = _ref.time,
      startTime = _ref.startTime;

  return state.set('time', time).set('startTime', startTime);
}), (0, _defineProperty3.default)(_createReducer, SET_FRAME_TIME, function (state, frameTime) {
  var currentFrameTime = state.get('frameTime');
  // Apply a smoothing moving average to frameTime
  return state.set('frameTime', currentFrameTime + (frameTime - currentFrameTime) * 0.1);
}), (0, _defineProperty3.default)(_createReducer, START_PLAYING, function (state, autoplay) {
  return state.merge({ playing: true, autoplay: !!autoplay });
}), (0, _defineProperty3.default)(_createReducer, STOP_PLAYING, function (state) {
  return state.set('playing', false);
}), (0, _defineProperty3.default)(_createReducer, UPDATE_TRACK, function (state, _ref2) {
  var path = _ref2.path,
      attrs = _ref2.attrs;

  var anim = state.getIn(['animations', path[0]]);
  var track = anim && anim.tracks[path[1]];
  if (track) (0, _assign2.default)(track, attrs);
  return state;
}), (0, _defineProperty3.default)(_createReducer, UPDATE_ANIMATION, function (state, _ref3) {
  var index = _ref3.index,
      attrs = _ref3.attrs;

  var anim = state.getIn(['animations', index]);
  if (anim) (0, _assign2.default)(anim, attrs);
  return state;
}), (0, _defineProperty3.default)(_createReducer, REMOVE_ANIMATION, function (state, idx) {
  var newState = state;
  if (idx === state.get('timelineAnimationIndex')) newState = newState.set('timelineAnimationIndex', -1);
  return newState.deleteIn(['animations', idx]);
}), (0, _defineProperty3.default)(_createReducer, QUEUE_ANIMATION, function (state, animation) {
  return state.updateIn(['animations'], (0, _immutable.List)(), function (list) {
    return list.push(animation);
  });
}), (0, _defineProperty3.default)(_createReducer, QUEUE_TIMELINE_ANIMATION, function (state, animation) {
  return state.set('timelineAnimationIndex', state.get('animations').size - 1);
}), (0, _defineProperty3.default)(_createReducer, ADD_CLIP, function (state, _ref4) {
  var clip = _ref4.clip,
      id = _ref4.id;

  return state.setIn(['clips', id], (0, _immutable.Map)(clip).set('id', id));
}), (0, _defineProperty3.default)(_createReducer, ADD_BUFFER_CLIP, function (state, _ref5) {
  var clip = _ref5.clip,
      id = _ref5.id;

  return state.setIn(['bufferClips', id], (0, _immutable.Map)(clip).set('id', id));
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.LOAD_SCENE, function (state, _ref6) {
  var clips = _ref6.clips,
      bufferClips = _ref6.bufferClips;

  return clips ? state.mergeIn(['clips'], clips).mergeIn(['bufferClips'], bufferClips) : state;
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state) {
  return newInitialState();
}), (0, _defineProperty3.default)(_createReducer, INIT_PHYSICS, function (state, _ref7) {
  var dynamicsWorld = _ref7.dynamicsWorld,
      dynamicBodies = _ref7.dynamicBodies,
      kinematicBodies = _ref7.kinematicBodies;

  return state.set('dynamicsWorld', dynamicsWorld).set('dynamicBodies', dynamicBodies).set('kinematicBodies', kinematicBodies);
}), _createReducer));

function setFrameTime(frameTime) {
  return { type: SET_FRAME_TIME, payload: frameTime };
}

/**
 * Return the current animation time.
 * @returns {Number}
 * @public
 *
 */
function getTime(store) {
  return store.getIn(['animation', 'time']);
}

/**
 * Set the current animation time.
 * @public
 * @param {Number} time in seconds
 */
function setTime(time) {
  return function (store) {
    var startTime = new Date();
    var delta = time - store.getIn(['animation', 'time']);
    var dynamicsWorld = store.getIn(['animation', 'dynamicsWorld']);

    if (store.getIn(['animation', 'animations']).size) {
      var offsetIdx = 0;
      store.getIn(['animation', 'animations']).forEach(function (anim, animIdx) {
        var keepAnimation = updateAnimation(store, delta, time, anim, animIdx - offsetIdx);
        if (!keepAnimation) offsetIdx++;
      });
    } else {
      if (store.getIn(['animation', 'autoplay'])) {
        store.dispatch(stopPlaying());
      }
    }

    if (dynamicsWorld) {
      (0, _physics.updatePhysics)(store, delta, time, dynamicsWorld, store.getIn(['animation', 'dynamicBodies']), store.getIn(['animation', 'kinematicBodies']));
    }

    store.dispatch({ type: SET_TIME, payload: { time: time, startTime: startTime } });
  };
}

function getKeyframeValueFor(t, keyframes, tween, currentValue) {
  var vs = keyframes.vs,
      ts = keyframes.ts;


  if (!ts.length) return currentValue;

  var idx = ts.findIndex(function (kt) {
    return t <= kt;
  });
  if (idx === -1) return vs[vs.length - 1];

  // FIXME: Handle keyframe that hasn't started yet
  if (idx === 0) return vs[0];

  //console.log('tween?', frame1.v, frame2.v, frame2.t - frame1.t);
  var v = tween(t - ts[idx - 1], vs[idx - 1], vs[idx], ts[idx] - ts[idx - 1]);
  //console.log('getkeyframe value?', t, idx, v);
  return v;
}

function getKeyframeValue(t, keyframes, tween, currentValue) {
  //console.log('get keyframe value: ', t, keyframes, tween);
  if (keyframes.ts) return getKeyframeValueFor(t, keyframes, tween, currentValue);
  var result = {};
  var keys = (0, _keys2.default)(keyframes);
  for (var i = 0; i < keys.length; i++) {
    result[keys[i]] = getKeyframeValueFor(t, keyframes[keys[i]], tween, currentValue[keys[i]]);
  }

  return result;
}

function updateAnimation(store, delta, time, animation, animationIdx) {
  //console.log('updateAnimation', delta, time, animation.name, animationIdx);

  var tracks = animation.tracks,
      first = animation.first,
      iterations = animation.iterations,
      duration = animation.duration,
      easingFn = animation.easingFn,
      easingDuration = animation.easingDuration,
      playSpeed = animation.playSpeed;
  var easingTime = animation.easingTime;

  var animationStart = animation.start;
  var trackSet = animation.set;

  var animationTime = time;

  var isEasing = first && time < animationStart + easingDuration && time > animationStart;
  if (isEasing) {
    easingTime += delta * easingFn(time - animationStart, 0, 1, easingDuration);
    animationTime = animationStart + easingTime;
  } else if (easingTime) {
    animationTime = time - easingDuration + easingTime;
  }

  var reverse = playSpeed < 0;

  if (playSpeed !== 1) {
    animationTime = (animationTime - animationStart) * playSpeed + animationStart;
    if (reverse) animationTime = animationTime + duration;
  }

  var inProgress = false;
  var ops = [];

  var s = new Date();
  var track = void 0;
  for (var trackIdx = 0; trackIdx < tracks.length; trackIdx++) {
    track = tracks[trackIdx];
    var start = track.start + animationStart;
    var end = track.end + animationStart;
    if (reverse ? animationTime > end : animationTime < start) {
      inProgress = true;
      continue;
    }

    var endValue = track.value;
    var _track = track,
        tween = _track.tween,
        path = _track.path,
        keyframes = _track.keyframes,
        _duration = _track.duration,
        currentValue = _track.currentValue,
        _trackSet = _track.trackSet;

    var startValue = track.startValue;

    // TODO: this should be more efficient
    //let currentValue = endValue; //get(store, path);

    if (startValue == null && !keyframes) {
      startValue = (0, _sceneGraph.get)(store, path);
      store.dispatch({
        type: UPDATE_TRACK,
        payload: { path: [animationIdx, trackIdx], attrs: { startValue: startValue } }
      });
    }

    var v = keyframes ? getKeyframeValue(animationTime - start, keyframes, tween, currentValue) : animationTime > end ? endValue : tween(animationTime - start, startValue, endValue, _duration);

    var op = _trackSet(path, v);
    if (op) ops.push(op);

    if (reverse ? animationTime >= start : animationTime <= end) inProgress = true;
  }

  //console.log('dispatch animations',ops.length, 'in',  new Date() - s);
  if (ops.length) store.dispatch((0, _sceneGraph.multi)(ops));

  if (inProgress) {
    if (isEasing) {
      store.dispatch({
        type: UPDATE_ANIMATION,
        payload: {
          index: animationIdx,
          attrs: {
            easingTime: easingTime
          }
        }
      });
    }
  } else {
    if (iterations > 1) {
      store.dispatch({
        type: UPDATE_ANIMATION,
        payload: {
          index: animationIdx,
          attrs: {
            first: false,
            easingTime: 0,
            start: time,
            iterations: iterations - 1
          }
        }
      });
    } else {
      if (animation.onEnd) animation.onEnd();

      if (animationIdx !== store.getIn(['animation', 'timelineAnimationIndex'])) {
        store.dispatch({ type: REMOVE_ANIMATION, payload: animationIdx });
        return false;
      } else {
        store.dispatch({
          type: UPDATE_ANIMATION,
          payload: {
            index: animationIdx,
            attrs: { start: time }
          }
        });
        store.dispatch(stopPlaying());
      }
    }
  }
  return true;
}

/**
 * Are we currently playing
 * @returns {Boolean}
 */
function isPlaying(store) {
  return store.getIn(['animation', 'playing']);
}

/**
 * Start time
 * @public
 */
function startPlaying() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return function (store) {
    store.dispatch({ type: START_PLAYING, payload: options.autoplay });
    if (typeof Ammo !== 'undefined' && !store.getIn(['animation', 'dynamicsWorld'])) {
      store.dispatch({ type: INIT_PHYSICS, payload: (0, _physics.initPhysics)(store) });
    }
    store.dispatch(setTime(store.getIn(['animation', 'time'])));
  };
}

/*
 * If we are currently playing, increment time
 */
function incrementTime() {
  return function (store) {
    if (store.getIn(['animation', 'playing'])) {
      var startTime = store.getIn(['animation', 'startTime']);
      var time = store.getIn(['animation', 'time']);
      var delta = startTime ? new Date() - startTime : 0;
      store.dispatch(setTime(time + delta));
    }
  };
}

function getLastKeyframeTime(keyframes) {
  if (keyframes.ts) return keyframes.ts.length ? keyframes.ts[keyframes.ts.length - 1] : 0;
  var lastTime = 0;
  var times = void 0;
  var keys = (0, _keys2.default)(keyframes);
  for (var i = 0; i < keys.length; i++) {
    times = keyframes[keys[i]].ts;
    lastTime = times.length ? Math.max(times[times.length - 1], lastTime) : lastTime;
  }

  return lastTime;
}

/**
 * Stop time
 * @public
 */
function stopPlaying() {
  return { type: STOP_PLAYING };
}

function formatTrack(store, sceneTime, attrs) {
  var path = Array.isArray(attrs.path) ? attrs.path : attrs.path && (0, _scene.find)(store, attrs.path);
  if (!path && attrs.path && attrs.path.id) {
    delete attrs.path.id;
    path = (0, _scene.find)(store, attrs.path);
  }
  if (!path && !attrs.set) {
    console.log('path is not defined for track', attrs);
    return null;
  }

  var start = attrs.start || 0;
  var value = attrs.value;
  var tween = attrs.tween || getTweenFunction(value, attrs.easing || 'linear');
  var trackSet = attrs.set || _sceneGraph.set;
  var keyframes = attrs.keyframes;
  var duration = keyframes ? getLastKeyframeTime(keyframes) : attrs.duration || 0;
  var end = duration + start;
  var startValue = duration === 0 ? value : attrs.startValue;
  var currentValue = path && (0, _sceneGraph.get)(store, path);
  return {
    path: path,
    start: start,
    end: end,
    value: value,
    duration: duration,
    tween: tween,
    startValue: startValue,
    keyframes: keyframes,
    currentValue: currentValue,
    trackSet: trackSet
  };
}

/**
 * Queue a clip to be played
 *
 * @public
 * @param {String} clipId the id of the clip to be queued.
 * @param {Object} attrs Attrs to override the clip settings.
 * @param {Object} options
 * @param {Boolean} options.useTimeline Display the clip in the timeline
 * @returns {Promise}
 *
 * @example
 * var clips = animation.getClips();
 * animation.queueClip(clips[0].id, {autoplay: true});
 *
 */
function queueClip(clipId, attrs) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return function (store) {
    var clip = store.getIn(['animation', 'bufferClips', clipId]) || store.getIn(['animation', 'clips', clipId]);
    if (clip) {
      store.dispatch(queueAnimation((0, _assign2.default)({}, clip.toJS(), attrs)));
      if (options.useTimeline) store.dispatch({ type: QUEUE_TIMELINE_ANIMATION });
    }
  };
}

function findClip(store, clipId) {
  return store.getIn(['animation', 'clips', clipId]);
}

/**
 * Queue an animation
 *
 * @public
 * @param {Animation} attrs the animation object
 * @returns {Promise}
 */
function queueAnimation(attrs) {
  return function (store) {
    var sceneTime = store.getIn(['animation', 'time']);

    var id = (0, _v2.default)();
    var name = attrs.name || 'Animation';
    var iterations = attrs.iterations || 1;
    var start = attrs.start || sceneTime;
    var easing = attrs.easing || 'linear';
    var easingFn = getTweenFunction(1, easing);
    var easingDuration = attrs.easingDuration || 0;
    var playSpeed = typeof attrs.playSpeed !== 'undefined' ? attrs.playSpeed : 1;
    var trackList = attrs.tracks.map(function (attrs) {
      return formatTrack(store, sceneTime, attrs);
    }).filter(function (t) {
      return !!t;
    });
    var duration = trackList.reduce(function (lastEnd, track) {
      return Math.max(lastEnd, track.end);
    }, 0);
    var onEnd = attrs.onEnd || null;

    //let end = 0;
    //forEach((t) => { if (t.get('end') > end) end = t.get('end'); }, trackList);
    store.dispatch({
      type: QUEUE_ANIMATION,
      payload: {
        id: id,
        name: name,
        start: start,
        easingTime: 0,
        first: true,
        easing: easing,
        easingFn: easingFn,
        easingDuration: easingDuration,
        iterations: iterations,
        tracks: trackList,
        onEnd: onEnd,
        playSpeed: playSpeed,
        duration: duration
      }
    });

    if (attrs.autoplay && !isPlaying(store)) {
      store.dispatch(startPlaying({ autoplay: true }));
    }

    return _promise2.default.resolve(id);
  };
}

/**
 *
 * Update the attributes of a running animation.
 *
 *
 * @public
 * @param {String} name - the name of the animation to update
 * @param {Animation} attrs the animation object attributes
 */
function updateAnimationAttrs(name, attrs) {
  return function (store) {
    var index = findAnimationIndex(store, name);
    if (index !== -1) {
      return store.dispatch({
        type: UPDATE_ANIMATION,
        payload: { index: index, attrs: attrs }
      });
    }
  };
}

/**
 * Find and return an animation if it is currently runing.
 *
 * @public
 * @param {String} idOrName -- the id or name of the animation
 * @returns {Promise}
 */
function findAnimation(store, idOrName) {
  return store.getIn(['animation', 'animations']).find(nameOrIdFilter(idOrName));
}

function findAnimationIndex(store, idOrName) {
  return store.getIn(['animation', 'animations']).findIndex(nameOrIdFilter(idOrName));
}

/**
 * Remove an animation
 *
 * @public
 * @param {String} idOrName -- the id or name of the animation
 * @returns {Promise}
 */
function removeAnimation(idOrName) {
  return function (store) {
    var animationIdx = findAnimationIndex(store, idOrName);
    if (animationIdx !== -1) {
      return store.dispatch({ type: REMOVE_ANIMATION, payload: animationIdx });
    }
  };
}

/**
 * Add a clip to the store.
 * @param {Object} clip
 * @param {String} id
 * @returns {Promise}
 */
function addClip(clip, id) {
  return { type: ADD_CLIP, payload: { clip: clip, id: id } };
}

function makeReducedClip(clip, id) {
  return function (store) {
    var newTracks = clip.tracks.map(function (track) {
      var newKeys = {};
      if (track.keyframes) {
        var keys = track.keyframes;
        if (keys.ts) {
          var newTS = Float32Array.from(keys.ts);
          var newVS = Float32Array.from(keys.vs);
          newKeys = { ts: newTS, vs: newVS };
        } else {
          newKeys = (0, _keys2.default)(keys).reduce(function (obj, key) {
            var newTS = Float32Array.from(keys[key].ts);
            var newVS = Float32Array.from(keys[key].vs);
            obj[key] = { ts: newTS, vs: newVS };
            return obj;
          }, {});
        }
        return (0, _assign2.default)({}, track, { keyframes: newKeys });
      }
      return track;
    });

    var newClip = (0, _assign2.default)({}, clip, { tracks: newTracks });
    return store.dispatch({
      type: ADD_BUFFER_CLIP,
      payload: { clip: newClip, id: id }
    });
  };
}

/**
 * Return a list of clips available.
 *
 * @public
 * @returns {Clip[]}
 */
function getClips(store) {
  return (0, _values2.default)(store.getIn(['animation', 'clips']).toJS());
}

function getTweenFunction(value, easing) {
  var tweenFn = _tweenFunctions2.default[easing];
  if (!tweenFn) throw new Error('Unknown easing function: ' + easing);

  if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== 'object') return tweenFn;

  var keys = (0, _keys2.default)(value);

  return function (t, b, c, d) {
    var result = {};
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      result[key] = tweenFn(t, b[key], c[key], d);
    }

    return result;
  };
}

function getTimelineAnimation(store) {
  var index = store.getIn(['animation', 'timelineAnimationIndex']);
  if (index < 0) return null;
  return store.getIn(['animation', 'animations', index]);
}

var publicApi = {
  reducer: reducer,
  actions: {
    setTime: setTime,
    startPlaying: startPlaying,
    stopPlaying: stopPlaying,
    removeAnimation: removeAnimation,
    queueAnimation: queueAnimation,
    addClip: addClip,
    queueClip: queueClip,
    findClip: findClip,
    updateAnimationAttrs: updateAnimationAttrs
  },
  selectors: {
    findAnimation: findAnimation,
    getTime: getTime,
    getClips: getClips,
    getTimelineAnimation: getTimelineAnimation,
    isPlaying: isPlaying
  }
};

exports.default = publicApi;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _create = __webpack_require__(48);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = ObjectBuffer;

var _BlockBuffer = __webpack_require__(226);

var _BlockBuffer2 = _interopRequireDefault(_BlockBuffer);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ObjectBuffer(type, optionalArrayType, optionalElementSize) {
  _BlockBuffer2.default.call(this, optionalArrayType || Float32Array);

  this.elementSize = optionalElementSize || type.InstanceScalarSize;
  this.type = type;
}

ObjectBuffer.prototype = (0, _assign2.default)((0, _create2.default)(_BlockBuffer2.default.prototype), {
  constructor: ObjectBuffer,

  toObjectArrayViewAndClear: function toObjectArrayViewAndClear() {
    return new _ObjectArrayView2.default(this.type, null, this.toArrayAndClear());
  },

  getAt: function getAt(index, optionalValue) {
    var result = optionalValue || new this.type();

    var blockIndex = index >> this.intraBlockIndexBits;
    var blockOffset = index & this.intraBlockIndexMask;

    return result.fromArray(this.blocks[blockIndex], blockOffset * this.elementSize);
  },

  setAt: function setAt(index, value) {
    var blockIndex = index >> this.intraBlockIndexBits;
    var blockOffset = index & this.intraBlockIndexMask;

    value.toArray(this.blocks[blockIndex], blockOffset * this.elementSize);
  },

  push: function push(value) {
    var index = this.length++;
    var block = this.lastBlock;
    var blockOffset = index & this.intraBlockIndexMask;

    if (blockOffset === 0) {
      var blockSize = this.intraBlockIndexMask + 1;
      block = new this.arrayType(blockSize * this.elementSize);
      this.lastBlock = block;
      this.blocks.push(block);
    }

    value.toArray(block, blockOffset * this.elementSize);
    //Return new size
    return index + 1;
  }
});

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

exports.default = stringIndicesToArray;

var _RangeSet = __webpack_require__(416);

var _RangeSet2 = _interopRequireDefault(_RangeSet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Split string on ',' and build a sorted RangeSet of the individual values and
 * ranges, then return expanded array with all enumerated indices.
 *
 * @param {*} str
 */
function stringIndicesToArray() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  if (!str.length) {
    return [];
  }
  var indices = str.split(',');
  var start = void 0;
  var end = void 0;
  var v = void 0;
  var range = new _RangeSet2.default();
  for (var i = 0; i < indices.length; i++) {
    v = indices[i];
    if (v.indexOf('-') !== -1) {
      var _v$split = v.split('-');

      var _v$split2 = (0, _slicedToArray3.default)(_v$split, 2);

      start = _v$split2[0];
      end = _v$split2[1];

      start = Number(start);
      end = Number(end);
    } else {
      start = Number(v);
      end = start;
    }
    range.add(start, end);
  }

  return range.expanded();
}

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Selection;

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _ScalarBuffer = __webpack_require__(228);

var _ScalarBuffer2 = _interopRequireDefault(_ScalarBuffer);

var _BitSet = __webpack_require__(155);

var _BitSet2 = _interopRequireDefault(_BitSet);

var _IndexMappings = __webpack_require__(124);

var _IndexMappings2 = _interopRequireDefault(_IndexMappings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Selection(indices, meaning, optionalMapId) {
  this.indices = indices;
  this.meaning = meaning;
  this.mapId = optionalMapId || _PolyMaps2.default.IdPositions;
}

Selection.Faces = 0;
Selection.Vertices = 1;
Selection.Edges = 2;

Selection.prototype = {
  constructor: Selection,

  getIndices: function getIndices(mesh, meaning, optionalMapId) {
    var indices = this.indices,
        convTab = Selection.ConversionTable,
        convFunc = convTab[this.meaning][meaning];

    if (convFunc !== null) indices = convFunc.call(null, mesh, indices, this.mapId, optionalMapId || _PolyMaps2.default.IdPositions);

    return indices;
  }
};

Selection.newRandomSelection = function (seed, density, polyMesh, meaning, optionalMapId) {
  var n = Selection.getNumElements(polyMesh, meaning, optionalMapId),
      nPopulation = density * n | 0,
      bits = new _BitSet2.default(n).fill(0, nPopulation),
      prng = seed;

  for (var i = 0, e = n - 1; i < e; ++i) {
    // Magic constants taken from
    // https://en.wikipedia.org/wiki/Linear_congruential_generator
    prng = prng * 22695477 + 1 >>> 0;

    bits.swap(i, i + (prng & 0x3fffffff) % (n - i));
  }

  return new Selection(bits.toIndexArray(), meaning, optionalMapId);
};

// Provides an identity mapping in case a selection is not provided:

Selection.getIndices = function (mesh, meaning, optionalSelectionOrMapId, optionalSelection) {
  var mapId = _PolyMaps2.default.IdPositions,
      selection = optionalSelection;

  if (typeof optionalSelectionOrMapId === 'string') mapId = optionalSelectionOrMapId;else selection = optionalSelectionOrMapId;

  return !selection ? _IndexMappings2.default.identityForReading(Selection.getNumElements(mesh, meaning, mapId)) : selection.getIndices(mesh, meaning, mapId);
};

Selection.getNumElements = function (mesh, meaning, optionalMapId) {
  switch (meaning) {
    case Selection.Faces:
      return mesh.getNumFaces();

    case Selection.Vertices:
      return _PolyMaps2.default.resolveMap(mesh, optionalMapId || _PolyMaps2.default.IdPositions).values.length;

    case Selection.Edges:
      return _PolyMaps2.default.resolveMap(mesh, optionalMapId || _PolyMaps2.default.IdPositions).edgeVertexAdjacency.getNumEdges();

    default:
      throw Error('Bad meaning argument!');
  }
};

// Conversions:

Selection.convFacesToVertices = function (mesh, indices, _, mapId) {
  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapId),
      result = new _BitSet2.default(mapOut.values.length),
      faceRangeOffsets = mesh.faceRangeOffsets,
      mapValueIndices = mapOut.faceValueIndices;

  for (var i = 0, n = indices.length; i !== n; ++i) {
    var faceIndex = indices[i],
        begin = faceRangeOffsets[faceIndex],
        until = faceRangeOffsets[faceIndex + 1];

    result.includeFromArray(mapValueIndices, begin, until);
  }

  return result.toIndexArray();
};

Selection.convFacesToEdges = function (mesh, indices, _, mapId) {
  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapId),
      result = new _BitSet2.default(mapOut.edgeVertexAdjacency.getNumEdges()),
      faceRangeOffsets = mesh.faceRangeOffsets,
      mapValueIndices = mapOut.faceValueIndices;

  for (var i = 0, n = indices.length; i !== n; ++i) {
    var faceIndex = indices[i],
        begin = faceRangeOffsets[faceIndex],
        until = faceRangeOffsets[faceIndex + 1];

    if (begin !== until) {
      var vertexA = mapValueIndices[until - 1];

      for (var j = begin; j !== until; ++j) {
        var vertexB = mapValueIndices[j];
        result.include(mapOut.findEdgeId(vertexA, vertexB));
        vertexA = vertexB;
      }
    }
  }

  return result.toIndexArray();
};

//

Selection.convVerticesToFaces = function (mesh, indices, mapId, _) {
  var buffer = new _ScalarBuffer2.default(Uint32Array),
      faceRangeOffsets = mesh.faceRangeOffsets,
      mapValueIndices = _PolyMaps2.default.resolveMap(mesh, mapId).faceValueIndices,
      nFaces = mesh.getNumFaces();

  for (var faceIndex = 0; faceIndex !== nFaces; ++faceIndex) {
    var begin = faceRangeOffsets[faceIndex],
        until = faceRangeOffsets[faceIndex + 1],
        allVerticesFound = true;

    for (var i = begin; i !== until && allVerticesFound; ++i) {
      allVerticesFound = -1 < _Arrays2.default.binarySearch(indices, mapValueIndices[i]);
    }if (allVerticesFound) buffer.push(faceIndex);
  }

  return buffer.toArrayAndClear();
};

Selection.convVerticesToVertices = function (mesh, indices, mapIdIn, mapIdOut) {
  if (mapIdIn === mapIdOut) return indices;

  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapIdOut),
      result = new _BitSet2.default(mapOut.values.length),
      mapOutValueIndices = mapOut.faceValueIndices,
      mapIn = _PolyMaps2.default.resolveMap(mesh, mapIdIn).updateInverseIndex(),
      faceIndexOffsets = mapIn.valueFaceIndexOffsets,
      faceIndices = mapIn.valueFaceIndices;

  for (var i = 0, n = indices.length; i !== n; ++i) {
    var mapInValueIndex = indices[i],
        facesBegin = faceIndexOffsets[mapInValueIndex],
        facesUntil = faceIndexOffsets[mapInValueIndex + 1];

    for (var j = facesBegin; j !== facesUntil; ++j) {
      var vertexOffset = mapIn.findValueIndexOffset(faceIndices[j], mapInValueIndex);

      result.include(mapOutValueIndices[vertexOffset]);
    }
  }

  return result.toIndexArray();
};

Selection.convVerticesToEdges = function (mesh, indices, mapIdIn, mapIdOut) {
  var mapOut = _PolyMaps2.default.resolveMap(mesh, mapIdOut),
      result = new _BitSet2.default(mapOut.edgeVertexAdjacency.getNumEdges()),
      faceRangeOffsets = mesh.faceRangeOffsets,
      mapValueIndices = _PolyMaps2.default.resolveMap(mesh, mapIdIn).faceValueIndices,
      nFaces = mesh.getNumFaces();

  for (var faceIndex = 0; faceIndex !== nFaces; ++faceIndex) {
    var begin = faceRangeOffsets[faceIndex],
        until = faceRangeOffsets[faceIndex + 1];

    if (begin !== until) {
      var last = mapValueIndices[--until],
          lastSelected = -1 < _Arrays2.default.binarySearch(indices, last),
          vertexA = last,
          prevSelected = lastSelected;

      for (var j = begin; j !== until; ++j) {
        var vertexB = mapValueIndices[j],
            selected = -1 < _Arrays2.default.binarySearch(indices, vertexB);

        if (prevSelected && selected) result.include(mapOut.findEdgeId(vertexA, vertexB));

        vertexA = vertexB;
        prevSelected = selected;
      }

      if (prevSelected && lastSelected) result.include(mapOut.findEdgeId(vertexA, last));
    }
  }

  return result.toIndexArray();
};

//

Selection.convEdgesToFaces = function (mesh, indices, mapIdIn, _) {
  var tmp = Selection.convEdgesToVertices(mesh, indices, mapIdIn, mapIdIn);

  return Selection.convVerticesToFaces(mesh, tmp, mapIdIn, '');
};

Selection.convEdgesToVertices = function (mesh, indices, mapIdIn, mapIdOut) {
  var tmp = Selection.convEdgesToVerticesOfSameMap(mesh, indices, mapIdIn);

  return Selection.convVerticesToVertices(mesh, tmp, mapIdIn, mapIdOut);
};

Selection.convEdgesToEdges = function (mesh, indices, mapIdIn, mapIdOut) {
  if (mapIdIn === mapIdOut) return indices;

  var tmp = Selection.convEdgesToVerticesOfSameMap(mesh, indices, mapIdIn);

  return Selection.convVerticesToEdges(mesh, indices, mapIdIn, mapIdOut);
};

Selection.convEdgesToVerticesOfSameMap = function (mesh, indices, mapId) {
  var map = _PolyMaps2.default.resolveMap(mesh, mapId).updateEdgeMap(),
      edgeRangeOffsets = map.edgePivotRangeOffsets,
      highVertexIndices = map.edgeHighVertexIndices,
      result = new _BitSet2.default(map.values.length);

  for (var i = 0, n = indices.length; i !== n; ++i) {
    var edgeId = indices[i],
        hiVertex = highVertexIndices[edgeId],
        searchResult = _Arrays2.default.binarySearch(edgeRangeOffsets, edgeId + 1);

    if (searchResult < 0) searchResult = ~searchResult;

    var loVertex = searchResult - 1;

    result.include(hiVertex);
    result.include(loVertex);
  }

  return result.toIndexArray();
};

Selection.ConversionTable = [
// From Faces to...
[
// ... Faces
null,
// ... Vertices
Selection.convFacesToVertices,
// ... Edges
Selection.convFacesToEdges],
// From Vertices to...
[
// ... Faces
Selection.convVerticesToFaces,
// ... Vertices
Selection.convVerticesToVertices,
// ... Edges
Selection.convVerticesToEdges],
// From Edges to...
[
// ... Faces
Selection.convEdgesToFaces,
// ... Vertices
Selection.convEdgesToVertices,
// ... Edges
Selection.convEdgesToEdges]];

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateCameraLookAtTarget;

var _three = __webpack_require__(0);

var targetPosition = new _three.Vector3();
var cameraPosition = new _three.Vector3();
var targetUp = new _three.Vector3(0, 1, 1);
var lookAtMatrix = new _three.Matrix4();
var lookAtPosition = new _three.Vector3();
var lookAtScale = new _three.Vector3();
var lookAtRotation = new _three.Quaternion();
var cameraScale = new _three.Vector3();
var cameraRotation = new _three.Quaternion();

function updateCameraLookAtTarget(cameraWorldMatrix, targetWorldMatrix, upPosition) {
  // console.trace('navigator.updateCameraLookAtTarget');
  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
  targetPosition.setFromMatrixPosition(targetWorldMatrix);
  // var te = targetWorldMatrix.elements;
  //targetUp.set(0, 1, 0); // .applyMatrix4( targetWorldMatrix );
  // console.log( "targetUp", JSON.stringify( targetUp ) );
  //console.log(upPosition);
  lookAtMatrix.makeTranslation(cameraPosition.x, cameraPosition.y, cameraPosition.z);
  lookAtMatrix.lookAt(cameraPosition, targetPosition, upPosition || targetUp);
  lookAtMatrix.decompose(lookAtPosition, lookAtRotation, lookAtScale);

  cameraWorldMatrix.decompose(cameraPosition, cameraRotation, cameraScale);
  cameraWorldMatrix.compose(cameraPosition, lookAtRotation, cameraScale);
}

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(137)('meta');
var isObject = __webpack_require__(27);
var has = __webpack_require__(61);
var setDesc = __webpack_require__(41).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(60)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 74 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 76 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(74);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 78 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(700);
var bytesToUuid = __webpack_require__(699);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(57);
var call = __webpack_require__(267);
var isArrayIter = __webpack_require__(265);
var anObject = __webpack_require__(44);
var toLength = __webpack_require__(136);
var getIterFn = __webpack_require__(183);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(274);
var enumBugKeys = __webpack_require__(170);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(168);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(550)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(172)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(555);
var global = __webpack_require__(29);
var hide = __webpack_require__(62);
var Iterators = __webpack_require__(81);
var TO_STRING_TAG = __webpack_require__(25)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(16)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(42)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 88 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(296);
var enumBugKeys = __webpack_require__(189);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(64);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(26).f;
var has = __webpack_require__(36);
var TAG = __webpack_require__(16)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(76);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(14);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 96 */
/***/ (function(module, exports) {

/*
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MathUtil = window.MathUtil || {};

MathUtil.degToRad = Math.PI / 180;
MathUtil.radToDeg = 180 / Math.PI;

// Some minimal math functionality borrowed from THREE.Math and stripped down
// for the purposes of this library.


MathUtil.Vector2 = function ( x, y ) {
  this.x = x || 0;
  this.y = y || 0;
};

MathUtil.Vector2.prototype = {
  constructor: MathUtil.Vector2,

  set: function ( x, y ) {
    this.x = x;
    this.y = y;

    return this;
  },

  copy: function ( v ) {
    this.x = v.x;
    this.y = v.y;

    return this;
  },

  subVectors: function ( a, b ) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;
  },
};

MathUtil.Vector3 = function ( x, y, z ) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
};

MathUtil.Vector3.prototype = {
  constructor: MathUtil.Vector3,

  set: function ( x, y, z ) {
    this.x = x;
    this.y = y;
    this.z = z;

    return this;
  },

  copy: function ( v ) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;
  },

  length: function () {
    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
  },

  normalize: function () {
    var scalar = this.length();

    if ( scalar !== 0 ) {
      var invScalar = 1 / scalar;

      this.multiplyScalar(invScalar);
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }

    return this;
  },

  multiplyScalar: function ( scalar ) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
  },

  applyQuaternion: function ( q ) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector
    var ix =  qw * x + qy * z - qz * y;
    var iy =  qw * y + qz * x - qx * z;
    var iz =  qw * z + qx * y - qy * x;
    var iw = - qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    return this;
  },

  dot: function ( v ) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },

  crossVectors: function ( a, b ) {
    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;
  },
};

MathUtil.Quaternion = function ( x, y, z, w ) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = ( w !== undefined ) ? w : 1;
};

MathUtil.Quaternion.prototype = {
  constructor: MathUtil.Quaternion,

  set: function ( x, y, z, w ) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;

    return this;
  },

  copy: function ( quaternion ) {
    this.x = quaternion.x;
    this.y = quaternion.y;
    this.z = quaternion.z;
    this.w = quaternion.w;

    return this;
  },

  setFromEulerXYZ: function( x, y, z ) {
    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 + s1 * s2 * c3;
    this.w = c1 * c2 * c3 - s1 * s2 * s3;

    return this;
  },

  setFromEulerYXZ: function( x, y, z ) {
    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 - s1 * s2 * c3;
    this.w = c1 * c2 * c3 + s1 * s2 * s3;

    return this;
  },

  setFromAxisAngle: function ( axis, angle ) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized

    var halfAngle = angle / 2, s = Math.sin( halfAngle );

    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos( halfAngle );

    return this;
  },

  multiply: function ( q ) {
    return this.multiplyQuaternions( this, q );
  },

  multiplyQuaternions: function ( a, b ) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
    var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;

    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    return this;
  },

  inverse: function () {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;

    this.normalize();

    return this;
  },

  normalize: function () {
    var l = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    if ( l === 0 ) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    } else {
      l = 1 / l;

      this.x = this.x * l;
      this.y = this.y * l;
      this.z = this.z * l;
      this.w = this.w * l;
    }

    return this;
  },

  slerp: function ( qb, t ) {
    if ( t === 0 ) return this;
    if ( t === 1 ) return this.copy( qb );

    var x = this.x, y = this.y, z = this.z, w = this.w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

    if ( cosHalfTheta < 0 ) {
      this.w = - qb.w;
      this.x = - qb.x;
      this.y = - qb.y;
      this.z = - qb.z;

      cosHalfTheta = - cosHalfTheta;
    } else {
      this.copy( qb );
    }

    if ( cosHalfTheta >= 1.0 ) {
      this.w = w;
      this.x = x;
      this.y = y;
      this.z = z;

      return this;
    }

    var halfTheta = Math.acos( cosHalfTheta );
    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    if ( Math.abs( sinHalfTheta ) < 0.001 ) {
      this.w = 0.5 * ( w + this.w );
      this.x = 0.5 * ( x + this.x );
      this.y = 0.5 * ( y + this.y );
      this.z = 0.5 * ( z + this.z );

      return this;
    }

    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    this.w = ( w * ratioA + this.w * ratioB );
    this.x = ( x * ratioA + this.x * ratioB );
    this.y = ( y * ratioA + this.y * ratioB );
    this.z = ( z * ratioA + this.z * ratioB );

    return this;
  },

  setFromUnitVectors: function () {
    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;
    var EPS = 0.000001;

    return function ( vFrom, vTo ) {
      if ( v1 === undefined ) v1 = new MathUtil.Vector3();

      r = vFrom.dot( vTo ) + 1;

      if ( r < EPS ) {
        r = 0;

        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
          v1.set( - vFrom.y, vFrom.x, 0 );
        } else {
          v1.set( 0, - vFrom.z, vFrom.y );
        }
      } else {
        v1.crossVectors( vFrom, vTo );
      }

      this.x = v1.x;
      this.y = v1.y;
      this.z = v1.z;
      this.w = r;

      this.normalize();

      return this;
    }
  }(),
};

module.exports = MathUtil;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__(47);

var _stringify2 = _interopRequireDefault(_stringify);

var _values = __webpack_require__(130);

var _values2 = _interopRequireDefault(_values);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

var _typeof2 = __webpack_require__(38);

var _typeof3 = _interopRequireDefault(_typeof2);

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _createReducer;

exports.initConfigurator = initConfigurator;
exports.initConfiguration = initConfiguration;
exports.setAttributeVisibility = setAttributeVisibility;
exports.applyPreset = applyPreset;
exports.setConfiguration = setConfiguration;
exports.removeConfigurator = removeConfigurator;
exports.getConfigurationState = getConfigurationState;
exports.executeAttribute = executeAttribute;
exports.executeVariant = executeVariant;
exports.initializeAttribute = initializeAttribute;
exports.initializePreset = initializePreset;
exports.initializeConfiguration = initializeConfiguration;
exports.initializeConfig = initializeConfig;
exports.getConfigs = getConfigs;
exports.getAttributes = getAttributes;
exports.getAttribute = getAttribute;
exports.getAttributesByType = getAttributesByType;
exports.getForms = getForms;
exports.getFormState = getFormState;
exports.getForm = getForm;
exports.getConfigurator = getConfigurator;
exports.getConfigurators = getConfigurators;
exports.getPresets = getPresets;
exports.getPreset = getPreset;
exports.getScript = getScript;
exports.getScriptError = getScriptError;
exports.setScript = setScript;
exports.getProductTour = getProductTour;
exports.getProducts = getProducts;
exports.getProduct = getProduct;
exports.getExternalEl = getExternalEl;
exports.getConfiguration = getConfiguration;
exports.getConfigurations = getConfigurations;
exports.setSavingSceneId = setSavingSceneId;
exports.canUndo = canUndo;
exports.undo = undo;
exports.addAttribute = addAttribute;
exports.setAttribute = setAttribute;
exports.deleteAttribute = deleteAttribute;
exports.addForm = addForm;
exports.deleteForm = deleteForm;
exports.setForm = setForm;
exports.addPreset = addPreset;
exports.deletePreset = deletePreset;
exports.setPreset = setPreset;
exports.setFormState = setFormState;
exports.addProduct = addProduct;
exports.setProduct = setProduct;
exports.deleteProduct = deleteProduct;
exports.isSaved = isSaved;
exports.isSaving = isSaving;
exports.shouldSave = shouldSave;
exports.save = save;
exports.getBOM = getBOM;
exports.loadConfigurations = loadConfigurations;
exports.onChange = onChange;

var _v = __webpack_require__(79);

var _v2 = _interopRequireDefault(_v);

var _immutable = __webpack_require__(32);

var _createReducer2 = __webpack_require__(46);

var _createReducer3 = _interopRequireDefault(_createReducer2);

var _scene = __webpack_require__(7);

var _assets = __webpack_require__(33);

var _annotations = __webpack_require__(122);

var _player = __webpack_require__(8);

var _animation = __webpack_require__(67);

var _sceneIO = __webpack_require__(20);

var _commands = __webpack_require__(43);

var _selectors = __webpack_require__(123);

var _actionTypes = __webpack_require__(58);

var _schemaTypes = __webpack_require__(207);

var _schemaTypes2 = _interopRequireDefault(_schemaTypes);

var _operators = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * This module controls the configuration api.
 *
 * @module configuration
 * @public
 *
 */

function nameOrIdFilter(nameOrId) {
  return function (attrs) {
    return attrs.id === nameOrId || attrs.name === nameOrId;
  };
}

var initialState = (0, _immutable.Map)({
  configuration: (0, _immutable.Map)(), // [nodeId]: {}
  configs: (0, _immutable.Map)(), // [nodeId]: Map({ attributes: [], forms: [] })
  configsState: (0, _immutable.Map)(), // [nodeId]: Map({ scriptError, scriptActivated, ...})
  savingSceneId: null, // nodeId of config we are saving
  history: (0, _immutable.List)(), // An array representing the config. Used for undo
  savedConfig: (0, _immutable.Map)(), // Last saved config
  configurators: (0, _immutable.Map)(), // [ key ] : { activeForm, externalEl, skipModels }
  formState: (0, _immutable.Map)(), // [nodeId]: Map({ hidden: {} })
  productTour: null, // name of the active product tour
  products: (0, _immutable.Map)(), // [product-handle]: {}
  saving: false,
  numSaveErrors: 0,
  changeListeners: (0, _immutable.List)()
});

var emptyFormState = function emptyFormState() {
  return (0, _immutable.Map)({ hidden: {}, optionsVisible: {} });
};

var ADD_CONFIG = 'ADD_CONFIG';
var DEL_CONFIG = 'DEL_CONFIG';
var SET_CONFIG = 'SET_CONFIG';
var SET_CONFIGURATION = 'SET_CONFIGURATION';
var SET_SAVING_SCENE_ID = 'SET_SAVING_SCENE_ID';
var CONFIG_UNDO = 'CONFIG_UNDO';
var CONFIG_SAVING = 'CONFIG_SAVING';
var CONFIG_SAVED = 'CONFIG_SAVED';
var CONFIG_SAVE_ERROR = 'CONFIG_SAVE_ERROR';
var INIT_CONFIGURATOR = 'INIT_CONFIGURATOR';
var REMOVE_CONFIGURATOR = 'REMOVE_CONFIGURATOR';
var SET_CONFIGURATOR_FORM_STATE = 'SET_CONFIGURATOR_FORM_STATE';
var ADD_PRODUCT = 'ADD_PRODUCT';
var DEL_PRODUCT = 'DEL_PRODUCT';
var SET_PRODUCT = 'SET_PRODUCT';
var INITIALIZE_CONFIGURATION = 'INITIALIZE_CONFIGURATION';
var SET_SCRIPT_ERROR = 'SET_SCRIPT_ERROR';
var SET_SCRIPT_ACTIVATED = 'SET_SCRIPT_ACTIVATED';
var ADD_CHANGE_LISTENER = 'ADD_CHANGE_LISTENER';
var RESET_CHANGE_LISTENERS = 'RESET_CHANGE_LISTENERS';
var initialConfigState = (0, _immutable.Map)({
  scriptError: '',
  scriptActivated: false
});

var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, _actionTypes.INITIALIZE_SCENE, function (state, _ref) {
  var id = _ref.id,
      store = _ref.store;

  var config = initializeConfig(loadConfig(store, id));
  return state.setIn(['configs', id], config).setIn(['configsState', id], initialConfigState.set('sceneId', id));
}), (0, _defineProperty3.default)(_createReducer, INITIALIZE_CONFIGURATION, function (state, _ref2) {
  var id = _ref2.id,
      config = _ref2.config,
      sceneId = _ref2.sceneId;

  var configuration = config;
  try {
    if (typeof config === 'string') configuration = JSON.parse(config);
  } catch (e) {
    configuration = {};
  }
  var configMap = initializeConfig(configuration);
  return state.setIn(['configs', id], configMap).setIn(['configsState', id], initialConfigState.set('sceneId', sceneId));
}), (0, _defineProperty3.default)(_createReducer, SET_SCRIPT_ERROR, function (state, _ref3) {
  var id = _ref3.id,
      scriptError = _ref3.scriptError;

  return state.setIn(['configsState', id, 'scriptError'], scriptError);
}), (0, _defineProperty3.default)(_createReducer, SET_CONFIGURATION, function (state, _ref4) {
  var id = _ref4.id,
      attribute = _ref4.attribute,
      value = _ref4.value;

  var configuration = state.getIn(['configuration', id]) || (0, _immutable.Map)();
  return state.setIn(['configuration', id], configuration.set(attribute.name, value));
}), (0, _defineProperty3.default)(_createReducer, _actionTypes.CLEAR_SCENE, function (state) {
  return initialState;
}), (0, _defineProperty3.default)(_createReducer, ADD_CONFIG, function (state, _ref5) {
  var id = _ref5.id,
      key = _ref5.key,
      attrs = _ref5.attrs;

  var config = state.getIn(['configs', id]);
  var newState = state.get('savingSceneId') !== id ? state : state.set('history', state.get('history').push(config));
  var objs = [].concat(config.get(key));

  objs.push(attrs);
  return newState.setIn(['configs', id], config.set(key, objs));
}), (0, _defineProperty3.default)(_createReducer, SET_CONFIG, function (state, _ref6) {
  var attrId = _ref6.attrId,
      key = _ref6.key,
      id = _ref6.id,
      attrs = _ref6.attrs,
      script = _ref6.script,
      scriptError = _ref6.scriptError;

  var config = state.getIn(['configs', id]);
  var newState = state.get('savingSceneId') !== id ? state : state.set('history', state.get('history').push(config));

  if (key === 'script') {
    return newState.setIn(['configs', id], config.set(key, script)).setIn(['configsState', id, 'scriptError'], scriptError || '');
  } else {
    var objs = [].concat(config.get(key));
    var idx = objs.findIndex(nameOrIdFilter(attrId));
    objs[idx] = (0, _assign2.default)({}, objs[idx], attrs);
    return newState.setIn(['configs', id], config.set(key, objs));
  }
}), (0, _defineProperty3.default)(_createReducer, DEL_CONFIG, function (state, _ref7) {
  var id = _ref7.id,
      attrId = _ref7.attrId,
      key = _ref7.key;

  var config = state.getIn(['configs', id]);
  var newState = state.get('savingSceneId') !== id ? state : state.set('history', state.get('history').push(config));

  var objs = [].concat(config.get(key));
  var idx = objs.findIndex(nameOrIdFilter(attrId));
  objs.splice(idx, 1);
  var newConfig = config.set(key, objs);

  if (key === 'attributes') {
    // delete references to attribute
    newConfig = newConfig.set('forms', config.get('forms').map(function (form) {
      var f = (0, _assign2.default)({}, form);
      f.fields = [].concat((form.fields || []).filter(function (field) {
        return field.attributeId !== attrId;
      }));
      return f;
    }));
  }
  return newState.setIn(['configs', id], newConfig);
}), (0, _defineProperty3.default)(_createReducer, SET_SAVING_SCENE_ID, function (state, id) {
  var config = state.getIn(['configs', id]);
  return state.set('savingSceneId', id).set('history', (0, _immutable.List)([])).set('savedConfig', config);
}), (0, _defineProperty3.default)(_createReducer, CONFIG_UNDO, function (state) {
  var savingSceneId = state.get('savingSceneId');
  var history = state.get('history');

  if (!savingSceneId || history.size === 0) return state;

  return state.setIn(['configs', savingSceneId], history.last()).set('history', history.butLast());
}), (0, _defineProperty3.default)(_createReducer, CONFIG_SAVING, function (state) {
  return state.set('saving', true);
}), (0, _defineProperty3.default)(_createReducer, CONFIG_SAVE_ERROR, function (state) {
  return state.set('saving', false).set('numSaveErrors', state.get('numSaveErrors') + 1);
}), (0, _defineProperty3.default)(_createReducer, CONFIG_SAVED, function (state, payload) {
  return state.set('saving', false).set('savedConfig', payload).set('numSaveErrors', 0);
}), (0, _defineProperty3.default)(_createReducer, INIT_CONFIGURATOR, function (state, payload) {
  var id = payload.id,
      productTour = payload.productTour;

  var config = state.getIn(['configurators', id]) || (0, _immutable.Map)({ id: id });
  ['form', 'el', 'panel', 'skipModels'].forEach(function (attr) {
    if (payload[attr] !== undefined) config = config.set(attr, payload[attr]);
  });
  var formState = state.getIn(['formState', id]) || emptyFormState();
  return state.setIn(['configurators', id], config).set('productTour', productTour).setIn(['formState', id], formState);
}), (0, _defineProperty3.default)(_createReducer, REMOVE_CONFIGURATOR, function (state, id) {
  var el = state.getIn(['configurators', id, 'el']);
  // Clear render of external el;
  if (el) el.innerHTML = '';
  return state.deleteIn(['configurators', id]).deleteIn(['configuration', id]);
}), (0, _defineProperty3.default)(_createReducer, SET_CONFIGURATOR_FORM_STATE, function (state, _ref8) {
  var attrs = _ref8.attrs,
      id = _ref8.id;

  var prevState = state.getIn(['formState', id]) || emptyFormState();
  var hidden = attrs.hidden,
      optionsVisible = attrs.optionsVisible;

  return state.setIn(['formState', id], (0, _immutable.Map)({
    hidden: (0, _assign2.default)({}, prevState.get('hidden'), hidden),
    optionsVisible: (0, _assign2.default)({}, prevState.get('optionsVisible'), optionsVisible)
  }));
}), (0, _defineProperty3.default)(_createReducer, ADD_PRODUCT, function (state, attrs) {
  return state.setIn(['products', attrs.handle], attrs);
}), (0, _defineProperty3.default)(_createReducer, SET_PRODUCT, function (state, attrs) {
  var product = state.getIn(['products', attrs.handle]);
  return state.setIn(['products', attrs.handle], (0, _assign2.default)({}, product, attrs));
}), (0, _defineProperty3.default)(_createReducer, DEL_PRODUCT, function (state, handle) {
  return state.deleteIn(['products', handle]);
}), (0, _defineProperty3.default)(_createReducer, SET_SCRIPT_ACTIVATED, function (state, id) {
  return state.setIn(['configsState', id, 'scriptActivated'], true);
}), (0, _defineProperty3.default)(_createReducer, ADD_CHANGE_LISTENER, function (state, fn) {
  return state.updateIn(['changeListeners'], (0, _immutable.List)(), function (list) {
    return list.push(fn);
  });
}), (0, _defineProperty3.default)(_createReducer, RESET_CHANGE_LISTENERS, function (state) {
  return state.set('changeListeners', (0, _immutable.List)());
}), _createReducer));

/**
 * Initialize the configurator for a scene.
 *
 * @public
 * @param {Object} options
 * @param {String} options.id The node id of the configurator
 * @param {String} options.form The configurator form to use
 * @param {Object} options.configuration Initial configuration
 * @param {String} options.el
 * @param {String} options.preset
 *
 */
function initConfigurator(attrs) {
  return function (store) {
    var skipModels = attrs.skipModels,
        form = attrs.form,
        preset = attrs.preset,
        el = attrs.el,
        panel = attrs.panel,
        productTour = attrs.productTour,
        configuration = attrs.configuration,
        configurations = attrs.configurations;

    var id = attrs.id || (0, _sceneIO.getSceneId)(store);

    // Use configurator form if provided, or first available configurator form if not.
    var formObject = form && ((typeof form === 'undefined' ? 'undefined' : (0, _typeof3.default)(form)) === 'object' ? initializeForm(form, {
      attributes: getAttributes(store, { id: id })
    }) : getForm(store, form, { id: id }));

    store.dispatch({
      type: 'INIT_CONFIGURATOR',
      payload: {
        id: id,
        skipModels: skipModels === undefined ? true : skipModels,
        form: (typeof form === 'undefined' ? 'undefined' : (0, _typeof3.default)(form)) === 'object' ? formObject : form,
        el: el,
        panel: panel,
        productTour: productTour
      }
    });

    // First, apply a preset if it is given.
    if (preset) store.dispatch(applyPreset(preset, { id: id }));

    // If multi-config is provided, load it.
    if (configurations) {
      store.dispatch(loadConfigurations(configurations, { id: id }));
    }

    // Second, if a configurator form is available, set any missing values from defaults
    if (formObject) store.dispatch(initConfiguration({ id: id, form: formObject }));

    // Third, set the configuration if passed in. Move this to third to avoid hidden attributes override configruations passed in.
    if (configuration) store.dispatch(setConfiguration(configuration, { id: id }));

    return store.dispatch(executeScript({ id: id }));
  };
}

/**
 * Init the configuration of a form.
 *
 * @public
 * @param {Object} attrs
 * @param {String} attrs.id Scene id
 * @param {String} attrs.form The configurator form to use
 *
 */
function initConfiguration(attrs) {
  return function (store) {
    var id = attrs.id || (0, _sceneIO.getSceneId)(store);
    var activeConfiguration = getConfiguration(store, { id: id, all: true });
    var form = attrs.form && ((0, _typeof3.default)(attrs.form) === 'object' ? initializeForm(attrs.form, {
      attributes: getAttributes(store, { id: id })
    }) : getForm(store, attrs.form, { id: id }));

    if (!form) return _promise2.default.resolve(false);

    if (form.meta && form.meta.displayAs !== 'all') {
      (form.steps || []).forEach(function (_ref9) {
        var formId = _ref9.formId;

        if (formId) store.dispatch(initConfiguration({ id: id, form: formId }));
      });
    }

    var config = form.fields.reduce(function (attrs, field) {
      if (activeConfiguration[field.attribute.name] === undefined && field.attribute.defaultValue !== undefined) {
        attrs[field.attribute.name] = field.attribute.defaultValue;
      }
      return attrs;
    }, {});

    store.dispatch(setConfiguration(config, { id: id }));

    return store.dispatch(executeScript({ id: id }));
  };
}

/*********************************************************************************************
 * Configurator Actions
 *********************************************************************************************/

function filterNodesFromTags(store, tags, nodeId, skipModels) {
  var nodes = [];
  if (typeof tags === 'string') {
    nodes = (0, _scene.filter)(store, (0, _selectors.buildQueryObject)(tags, { from: nodeId, skipModels: skipModels }));
  } else if (Array.isArray(tags)) {
    var nested = tags.map(function (tag) {
      if (tag === '') return [];
      if ((0, _selectors.isUuid)(tag)) return [(0, _scene.find)(store, { id: tag })];
      return (0, _scene.filter)(store, (0, _selectors.buildQueryObject)(tag, { from: nodeId, skipModels: skipModels }));
    });
    nested.forEach(function (arr) {
      return nodes = nodes.concat(arr);
    }); // flatten nested array
  }
  nodes = nodes.filter(function (id) {
    return !!id;
  });
  return nodes;
}

function setVisibility(_ref10, _ref11) {
  var tags = _ref10.tags,
      value = _ref10.value;
  var id = _ref11.id,
      skipModels = _ref11.skipModels;

  return function (store) {
    var nodes = filterNodesFromTags(store, tags, id, skipModels);

    return _promise2.default.all(nodes.map(function (id) {
      return store.dispatch((0, _scene.set)({ id: id, plug: 'Properties', property: 'visible', skipModels: skipModels }, Boolean(value)));
    }));
  };
}

function annotationVisibility(_ref12, _ref13) {
  var tags = _ref12.tags,
      value = _ref12.value;
  var id = _ref13.id;

  return function (store) {
    var annotationId = (0, _selectors.isUuid)(tags) ? (0, _scene.find)(store, { id: tags }) : (0, _scene.find)(store, { from: id, name: tags, type: 'Annotation' });
    return annotationId ? store.dispatch(value ? (0, _annotations.openAnnotation)(annotationId) : (0, _annotations.closeAnnotation)(annotationId)) : _promise2.default.resolve(true);
  };
}

function moveCamera(_ref14, _ref15) {
  var tags = _ref14.tags,
      _ref14$value = _ref14.value,
      value = _ref14$value === undefined ? 500 : _ref14$value;
  var id = _ref15.id;

  return function (store) {
    var cameraId = (0, _selectors.isUuid)(tags) ? (0, _scene.find)(store, { id: tags }) : (0, _scene.find)(store, { from: id, name: tags, type: 'Camera' });
    return cameraId ? store.dispatch((0, _player.animateCameraTo)(cameraId, Number(value))) : _promise2.default.resolve(true);
  };
}

function assignMaterial(_ref16, _ref17) {
  var tags = _ref16.tags,
      value = _ref16.value;
  var id = _ref17.id,
      skipModels = _ref17.skipModels;

  return function (store) {
    var materialId = (0, _selectors.isUuid)(value) ? value : (0, _scene.find)(store, { from: id, type: 'Material', name: value });
    if (!materialId) return _promise2.default.resolve(true);
    var nodes = filterNodesFromTags(store, tags, id, skipModels);
    //console.log("assign material: ", materialId, 'to', tags, nodes);

    return _promise2.default.all(nodes.map(function (id) {
      return store.dispatch((0, _scene.set)({ id: id, plug: 'Material', property: 'reference' }, materialId));
    }));
  };
}

function playClip(_ref18, _ref19) {
  var tags = _ref18.tags;
  var id = _ref19.id;

  return function (store) {
    var allClips = (0, _animation.getClips)(store);
    var clips = (Array.isArray(tags) ? tags : [tags]).map(function (tag) {
      return allClips.find(function (clip) {
        return clip.name === tag;
      });
    }).filter(function (clip) {
      return !!clip;
    });

    return _promise2.default.all(clips.map(function (clip) {
      return store.dispatch((0, _animation.queueClip)(clip.id, { autoplay: true }));
    }));
  };
}

function setPropertyAction(_ref20, _ref21) {
  var tags = _ref20.tags,
      value = _ref20.value;
  var id = _ref21.id,
      skipModels = _ref21.skipModels;

  return function (store) {
    // only apply the property if we've specified name/plug/operator/property
    if (!tags || tags.split('[').length !== 3) {
      return;
    }
    var query = (0, _selectors.buildQueryObject)(tags, { from: id, skipModels: skipModels });
    store.dispatch((0, _scene.setAll)(query, value));
  };
}

function setVariable(_ref22, opts) {
  var tags = _ref22.tags,
      value = _ref22.value;

  //console.log('setVariable', tags, value, opts);
  return setConfiguration((0, _defineProperty3.default)({}, tags, value), opts);
}

function setFieldVisibility(_ref23, opts) {
  var tags = _ref23.tags,
      value = _ref23.value;

  return setFormState({ hidden: (0, _defineProperty3.default)({}, tags, !value) }, opts);
}

function setOptionsVisibility(_ref24, opts) {
  var tags = _ref24.tags,
      value = _ref24.value;

  return function (store) {
    var attribute = getAttribute(store, tags, opts);
    if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) !== 'object' || !attribute) return _promise2.default.resolve(true);
    var currentValue = getConfiguration(store, { all: true })[attribute.name];
    if (currentValue && !value[currentValue]) {
      var firstEnabled = attribute.values.find(function (v) {
        return value[v];
      });
      if (firstEnabled) {
        store.dispatch(setConfiguration((0, _defineProperty3.default)({}, tags, firstEnabled)));
      }
    }
    return store.dispatch(setFormState({ optionsVisible: (0, _defineProperty3.default)({}, tags, value) }));
  };
}

function setAttributeVisibility(attributeNameOrId, visible) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return function (store) {
    var attribute = getAttribute(store, attributeNameOrId, opts);
    return attribute ? store.dispatch(setFormState({ hidden: (0, _defineProperty3.default)({}, attribute.id, !visible) }, opts)) : _promise2.default.resolve(false);
  };
}

// Don't run bom actions: 'set-product', 'select-variant', 'select-quantity'...
var availableActions = {
  'set-visibility': setVisibility,
  'annotation-visibility': annotationVisibility,
  'set-property': setPropertyAction,
  'assign-material': assignMaterial,
  'move-camera': moveCamera,
  'play-clip': playClip,
  'set-variable': setVariable,
  'set-form-field-visibility': setFieldVisibility,
  'set-attribute-options-visibility': setOptionsVisibility
};

// Return the value to set for the attribute. Use the attribute's `set` function
// to format the value or return the default.
// In the case of Image attributes, check to ensure that the image node and
// asset exist in the scene, otherwise import them.
function getDefaultValue(store, attribute, value) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var options = (0, _assign2.default)({}, opts, { all: true });
  var val = value == undefined ? getConfiguration(store, options)[attribute.name] : value;

  if (attribute.type === 'Image') {
    if (!val || !val.id) return val;

    // Ensure we have the asset, or import it.
    var fileExists = (0, _assets.hasFile)(store, val.assetId);
    if (!fileExists && !(0, _sceneIO.isAssetLoading)(store, val.assetId)) {
      store.dispatch((0, _assets.importImage)(val.assetId, { imageNodeId: val.id })).then(function (props) {
        // Now that the image node and asset exist, set it again.
        store.dispatch(setConfiguration((0, _defineProperty3.default)({}, attribute.name, value)));
      });
    }
    return fileExists ? val.id : null;
  } else {
    return attribute.prop.set(val);
  }
}

/**
 * Apply the given preset
 * @param {String} presetIdOrName id or name of the preset.
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 *
 * @public
 */
function applyPreset(presetIdOrName) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var preset = getPreset(store, presetIdOrName, opts);
    var attributes = getAttributes(store, opts);
    if (!preset) return _promise2.default.resolve(false);
    var configuration = preset.fields.reduce(function (acc, preset) {
      var attribute = getAttribute(store, preset.attributeId, opts);
      acc[attribute.name] = preset.value;
      return acc;
    }, {});
    store.dispatch(setConfiguration(configuration, opts));
  };
}

/**
 * Set the configuration.
 *
 * @param {Object} configuration attribute 'name' as key, with attribute value as values.
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 * @public
 *
 * @example
 * configuration.setConfiguration({ Size: 'Medium', ProductColor: '#ff0000' });
 *
 */
function setConfiguration() {
  var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    var attributes = getAttributes(store, { id: id });
    var configurator = getConfigurator(store);
    var skipModels = configurator ? configurator.skipModels : true;
    var form = opts.form;

    var changeListeners = store.getIn(['configuration', 'changeListeners']);

    //console.log('setConfiguration', sceneId, configuration,  attributes.map((attr) => attr.name), form);

    return _promise2.default.all((0, _keys2.default)(configuration).map(function (key) {
      var attribute = attributes.find(nameOrIdFilter(key));
      if (!attribute) return _promise2.default.reject(new Error('Attribute: ' + key + ' does not exist'));
      var value = getDefaultValue(store, attribute, configuration[key], {
        id: id
      });

      var field = form && form.fields.find(function (field) {
        return field.attributeId === attribute.id;
      });
      store.dispatch({
        type: SET_CONFIGURATION,
        payload: {
          id: id,
          attribute: attribute,
          value: attribute.type === 'Image' ? configuration[key] : value
        }
      });
      store.createEvent('configurationChange', attribute, value, {
        field: field,
        id: id
      });

      var actions = (attribute.actions || []).concat(attribute.valueActions && attribute.valueActions[value] || []);
      return _promise2.default.all(actions.map(function (_ref25) {
        var action = _ref25.action,
            tags = _ref25.tags,
            value = _ref25.value,
            variable = _ref25.variable;

        var variableAttribute = variable && (attribute.id === attribute ? attribute : getAttribute(store, variable, { id: id }));
        var val = variableAttribute ? getDefaultValue(store, variableAttribute, null, { id: id }) : value;

        var actionFn = availableActions[action];
        //console.log('action:', action, 'tags:', tags, 'value:', value, !!actionFn, tags !== '', 'globalVariable', globalVariable);

        return actionFn && tags !== '' && store.dispatch(actionFn({ tags: tags, value: val }, { id: id, skipModels: skipModels }));
      })).then(function () {
        changeListeners.forEach(function (fn) {
          return fn(attribute, value, { field: field, id: id });
        });
      });
    }));
  };
}

function removeConfigurator(id) {
  return { type: REMOVE_CONFIGURATOR, payload: id };
}

function getConfigurationState(store) {
  return store.getIn(['configuration', 'configsState']).toJS();
}

/**
 * Sets the attribute.
 *
 * @param {String} attributeName
 * @param {?Any} value
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function executeAttribute(attributeName, value) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return setConfiguration((0, _defineProperty3.default)({}, attributeName, value), opts);
}

/**
 * DEPRECATED
 */
function executeVariant(attributeName, value) {
  console.log('DEPRECATED, use `executeAttribute`');
  return setConfiguration((0, _defineProperty3.default)({}, attributeName, value));
}

/*********************************************************************************************
 * Configurator Initialization
 *********************************************************************************************/

function defaultValueFor(type) {
  return {
    Number: 0,
    Boolean: false,
    Color: { a: 1, b: 0, g: 0, r: 0 }
  }[type];
}

// convert the old option format to the new.
function convertAttribute(opt) {
  var type = (opt.type === 'Option' ? 'Options' : opt.type) || 'Options';
  var info = { id: opt.id || (0, _v2.default)(), name: opt.name, type: type };
  var defaultValue = '';
  if (type === 'Options') {
    info.values = (opt.values || []).map(function (value) {
      return value.name;
    });
    defaultValue = info.values[0];
    info.valueActions = {};
    (opt.values || []).forEach(function (val) {
      info.valueActions[val.name] = val.actions || [];
    });
  } else if (type === 'Boolean') {
    info.values = [true, false];
    info.valueActions = opt.valueActions || { true: [], false: [] };
  }
  defaultValue = defaultValue || defaultValueFor(type);
  info.defaultValue = opt.value === undefined ? defaultValue : opt.value;
  info.actions = opt.actions || [];

  var schemaType = _schemaTypes2.default[type];
  if (!schemaType) throw new Error('Invalid attribute type for configuration: ' + type);
  info.prop = schemaType(info);

  return info;
}

function initializeAttribute(opt) {
  var type = opt.type;
  var info = {
    id: opt.id || (0, _v2.default)(),
    name: opt.name,
    type: type,
    metadata: opt.metadata
  };
  var defaultValue = '';
  if (type === 'Options') {
    info.values = opt.values || [];
    defaultValue = info.values[0];
    info.valueActions = opt.valueActions || {};
    (opt.values || []).forEach(function (v) {
      info.valueActions[v.name] = v.actions || [];
    });
  } else if (type === 'Boolean') {
    info.values = [true, false];
    info.valueActions = opt.valueActions || { true: [], false: [] };
  } else if (type === 'Number') {
    info.minValue = opt.minValue || 0;
    info.maxValue = opt.maxValue || 100;
    info.step = opt.step || 1;
  }

  defaultValue = defaultValue || defaultValueFor(type);
  info.defaultValue = opt.defaultValue === undefined ? defaultValue : opt.defaultValue;
  info.actions = opt.actions || [];

  var schemaType = _schemaTypes2.default[type];
  if (!schemaType) throw new Error('Invalid attribute type for configuration: ' + type);
  info.prop = schemaType(info);

  return info;
}

function initializeForm() {
  var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var meta = opt.meta || {};
  var info = {
    id: opt.id || (0, _v2.default)(),
    name: opt.name || 'Form1',
    type: 'Form',
    meta: {
      displayAs: meta.displayAs || 'all'
    }
  };

  var defaultStep = {
    title: 'Step',
    description: '',
    formId: ''
  };

  info.steps = (opt.steps || []).map(function (step) {
    if (step.formId === opt.id) return defaultStep;
    return {
      title: step.title || defaultStep.title,
      description: step.description || defaultStep.description,
      formId: step.formId || defaultStep.formId
    };
  });

  info.fields = (opt.fields || opt.values || []).map(function (field) {
    var bom = field.bom,
        displayAs = field.displayAs,
        optionId = field.optionId,
        attributeId = field.attributeId,
        metadata = field.metadata;

    var result = { bom: bom, displayAs: displayAs, attributeId: attributeId, metadata: metadata };
    if (optionId) result.attributeId = optionId;

    if (options.attributes) {
      result.attribute = options.attributes.find(nameOrIdFilter(result.attributeId));
    }

    return result;
  });
  return info;
}

function initializePreset() {
  var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var name = opt.name,
      fields = opt.fields;

  return {
    id: opt.id || (0, _v2.default)(),
    name: name || '',
    fields: fields || []
  };
}

function initializeProduct() {
  var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var title = opt.title,
      handle = opt.handle,
      price = opt.price,
      options = opt.options,
      variants = opt.variants;

  return {
    title: title || handle,
    handle: handle,
    price: price || 0,
    options: options || [],
    variants: variants && variants.length ? variants : [{}]
  };
}

// Default config object
function defaultConfig() {
  return {
    attributes: [],
    forms: [],
    presets: [],
    script: ''
  };
}

function loadConfig(store, id) {
  var config = (0, _scene.get)(store, { id: id, plug: 'Player', property: 'configurator' });
  try {
    config = JSON.parse(config);
  } catch (err) {
    config = defaultConfig();
  }
  return config;
}

function initializeConfiguration(_ref26) {
  var id = _ref26.id,
      config = _ref26.config,
      sceneId = _ref26.sceneId;

  return function (store) {
    return store.dispatch({
      type: INITIALIZE_CONFIGURATION,
      payload: { id: id, config: config, sceneId: sceneId }
    });
  };
}

/**
 * Return the scene configuration from the sceneGraph, sanitized
 * for proper format.
 *
 * @private
 * @returns {Immutable.Map}
 *
 */
function initializeConfig(config) {
  if (config && Array.isArray(config)) {
    //console.log('loading array fromat from config');
    config = { options: config };
  }

  // Something is wrong with the configuration, reset it
  if (!config.options && !config.attributes) config = defaultConfig();

  var onlyAttributes = function onlyAttributes(opt) {
    return opt.type !== 'Display' && opt.type !== 'Preset' && opt.type !== 'ProductTour';
  };

  var attributes = config.attributes ? config.attributes.map(initializeAttribute) : config.options.filter(onlyAttributes).map(convertAttribute);
  var forms = (config.forms || config.options.filter(function (opt) {
    return opt.type === 'Display';
  })).map(initializeForm);

  var presets = config.presets || [];

  var script = config.script || '';

  return (0, _immutable.Map)({ attributes: attributes, forms: forms, presets: presets, script: script });
}

function getConfigs(store) {
  return store.getIn(['configuration', 'configs']);
}

/*********************************************************************************************
 * Configurator API
 *********************************************************************************************/

/**
 * Returns the list of attributes.
 *
 * @public
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function getAttributes(store) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var id = opts.id || (0, _sceneIO.getSceneId)(store);
  return store.getIn(['configuration', 'configs', id, 'attributes']) || [];
}

/**
 * Returns the given attribute
 *
 * @public
 * @param {String} idOrName id or name of the attribute
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function getAttribute(store, idOrName) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return getAttributes(store, opts).find(nameOrIdFilter(idOrName));
}

/**
 * Returns the list of attributes of given type
 *
 * @public
 * @param {String} type type of the attributes to filter
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function getAttributesByType(store, type) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return getAttributes(store, opts).filter(function (attribute) {
    return attribute.type === type;
  });
}

/**
 * Returns the list of forms
 *
 * @public
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 * @param {String} opts.all Return all the forms, top level and children
 */
function getForms(store) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var id = opts.id || (0, _sceneIO.getSceneId)(store);
  var allForms = store.getIn(['configuration', 'configs', id, 'forms']) || [];
  if (opts.all) return allForms;

  var childForms = {};

  allForms.forEach(function (form) {
    var _ref27 = form.meta || {},
        displayAs = _ref27.displayAs;

    if (displayAs !== 'all' && form.steps) {
      form.steps.forEach(function (step) {
        return childForms[step.formId] = true;
      });
    }
  });

  return allForms.filter(function (form) {
    return !childForms[form.id];
  });
}

function getFormState(store) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var id = opts.id || (0, _sceneIO.getSceneId)(store);
  var formState = store.getIn(['configuration', 'formState', id]);
  return formState ? formState.toJS() : {};
}

/**
 * Return the form  with given idOrName. If `idOrName === true`,
 * then return a form with all attributes.
 *
 * @public
 * @param {String} idOrName id or name of the form
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function getForm(store, idOrName) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var id = opts.id || (0, _sceneIO.getSceneId)(store);
  var form = idOrName && getForms(store, { id: id, all: true }).find(nameOrIdFilter(idOrName));
  var attributes = getAttributes(store, { id: id });

  (form ? form.fields : []).forEach(function (field) {
    field.attribute = attributes.find(nameOrIdFilter(field.attributeId));
  });

  if (!form && idOrName === true) {
    // Display all attribute options for configurator form
    form = {
      id: (0, _v2.default)(),
      name: 'All',
      type: 'Form',
      fields: attributes.map(function (attribute) {
        return { name: attribute.name, attributeId: attribute.id, attribute: attribute };
      }),
      steps: [],
      meta: {
        displayAs: 'all'
      }
    };
  }
  if (form) form.nodeId = id; // attach the configurator node id to the form.
  return form;
}

/**
 * Return configurator info for id
 */
function getConfigurator(store, nodeId) {
  var id = nodeId || (0, _sceneIO.getSceneId)(store);
  var configurator = store.getIn(['configuration', 'configurators', id]);
  return configurator && configurator.toJS();
}

/**
 * Returns an array of active configurators
 */
function getConfigurators(store) {
  return (0, _values2.default)(store.getIn(['configuration', 'configurators']).toJS());
}

/**
 * Returns the list of presets
 *
 * @public
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function getPresets(store) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var id = opts.id || (0, _sceneIO.getSceneId)(store);
  return store.getIn(['configuration', 'configs', id, 'presets']) || [];
}

function getPreset(store, idOrName) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var id = opts.id || (0, _sceneIO.getSceneId)(store);
  return idOrName && getPresets(store, { id: id }).find(nameOrIdFilter(idOrName));
}

function getScript(store) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var id = opts.id || (0, _sceneIO.getSceneId)(store);
  return store.getIn(['configuration', 'configs', id, 'script']) || '';
}

function getScriptError(store) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var id = opts.id || (0, _sceneIO.getSceneId)(store);
  return store.getIn(['configuration', 'configsState', id, 'scriptError']);
}

// fetch script, if it exists, activate it
function executeScript() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    var script = getScript(store, { id: id });
    return script ? store.dispatch(activateScript(script, { id: id })) : _promise2.default.resolve(true);
  };
}

function isScriptActivated(store, id) {
  return store.getIn(['configuration', 'configsState', id, 'scriptActivated']);
}

// activate the given script, and set scriptError
function activateScript(script) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    var reinitialize = opts.reinitialize;

    var isActive = isScriptActivated(store, id);

    // Ensure we only run script once per configurator
    if (isActive && !reinitialize) return _promise2.default.resolve(true);

    store.dispatch(setScriptActivated(id));
    if (reinitialize) {
      store.api.off('configurationChange');
      store.dispatch({ type: RESET_CHANGE_LISTENERS });
    }

    try {
      var fn = new Function('api', script || '');
      return _promise2.default.resolve(fn(store.api)).then(function () {
        return store.dispatch({
          type: SET_SCRIPT_ERROR,
          payload: { id: id, scriptError: false }
        });
      });
    } catch (err) {
      return store.dispatch({
        type: SET_SCRIPT_ERROR,
        payload: { id: id, scriptError: err }
      });
    }
  };
}

function setScriptActivated(id) {
  return { type: SET_SCRIPT_ACTIVATED, payload: id };
}

function setScript(script) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    store.dispatch({
      type: SET_CONFIG,
      payload: { id: id, script: script, key: 'script' }
    });
    store.dispatch(activateScript(script, { id: id, reinitialize: true }));
    return _promise2.default.resolve(script);
  };
}

/**
 * Returns the active product tour.
 *
 * @public
 */
function getProductTour(store) {
  var productTour = store.getIn(['configuration', 'productTour']);
  // if productTour is false, we have disabled rendering any product tours.
  if (productTour === false) return false;
  var property = productTour && getAttribute(store, productTour);
  return !property || property.type !== 'Options' ? null : property;
}

/**
 * Returns the products as an array of objects
 *
 * @public
 */
function getProducts(store) {
  return store.getIn(['configuration', 'products']).toList().toArray();
}

/**
 * Returns the product
 *
 * @public
 * @param {String} handle
 */
function getProduct(store, handle) {
  return store.getIn(['configuration', 'products', handle]);
}

function getExternalEl(store) {
  return store.getIn(['configuration', 'externalEl']);
}

/**
 * Returns the active configuration.
 *
 * @public
 * @param {?Object} opts
 * @param {?String} opts.id  Optional id of the configurator node
 */
function getConfiguration(store) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var id = opts.id || (0, _sceneIO.getSceneId)(store);
  var configuration = store.getIn(['configuration', 'configuration', id]);
  if (opts.all || !configuration) {
    return configuration ? configuration.toJS() : {};
  }
  var hidden = store.getIn(['configuration', 'formState', id, 'hidden']) || {};
  var hiddenAttrs = (0, _keys2.default)(hidden).reduce(function (acc, id) {
    if (hidden[id]) acc[getAttribute(store, id, opts).name] = true;
    return acc;
  }, {});
  return configuration.filter(function (value, key) {
    return !hiddenAttrs[key];
  }).toJS();
}

/**
 *  Returns the active configurations, in a form that can be reinflated,
 *  including multi-model scenes and configurations.
 *
 */
function getConfigurations(store) {
  var sceneId = (0, _sceneIO.getSceneId)(store);
  var configsStates = store.getIn(['configuration', 'configsState']).toJS();
  var configurations = store.getIn(['configuration', 'configuration']).toJS();

  var result = {
    sceneId: sceneId,
    publishedHash: (0, _sceneIO.getFetchedHash)(store, sceneId),
    configuration: configurations[sceneId],
    models: []
  };
  (0, _keys2.default)(configurations).forEach(function (id) {
    if (id === sceneId) return;

    var modelSceneId = configsStates[id].sceneId;
    var transform = (0, _scene.get)(store, { id: id, plug: 'Transform', operatorIndex: 0 });
    var transformOperator = (0, _operators.lookupOperator)('Transform', 'Transform');
    result.models.push({
      sceneId: modelSceneId,
      publishedHash: (0, _sceneIO.getFetchedHash)(store, modelSceneId),
      transform: transformOperator.export(transform, { onlyChanged: true }),
      configuration: configurations[id],
      models: []
    });
  });
  return result;
}

/**
 * Set the id of the configurator node being edited (and saved).
 */
function setSavingSceneId(id) {
  return { type: SET_SAVING_SCENE_ID, payload: id };
}

/**
 * Is there history available to undo?
 */
function canUndo(store) {
  return store.getIn(['configuration', 'history']).size > 0;
}

/**
 * Undo the last change
 */
function undo() {
  return { type: CONFIG_UNDO };
}

/**
 * Adds an attribute.
 *
 * @param {Attribute} attribute
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function addAttribute(attribute) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    var attrs = initializeAttribute(attribute);
    store.dispatch({
      type: ADD_CONFIG,
      payload: { id: id, attrs: attrs, key: 'attributes' }
    });
    return _promise2.default.resolve(attrs.id);
  };
}

/**
 * Updates an attribute
 *
 * @param {String} attributeId
 * @param {Attribute} attribute
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function setAttribute(attributeId, attrs) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return function (store) {
    var attribute = getAttribute(store, attributeId, opts);
    var schemaType = _schemaTypes2.default[attribute.type];
    attrs.prop = schemaType(attrs);

    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    return store.dispatch({
      type: SET_CONFIG,
      payload: { attrId: attributeId, id: id, attrs: attrs, key: 'attributes' }
    });
  };
}

/**
 * Delete an attribute
 *
 * @param {String} attributeId  id or name of the attribute to delete
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function deleteAttribute(attributeId) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    return store.dispatch({
      type: DEL_CONFIG,
      payload: { id: id, attrId: attributeId, key: 'attributes' }
    });
  };
}

/**
 * Add a form
 *
 * @param {Object} form
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function addForm(form) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  //key === 'attributes' ? initializeAttribute(attrs) : initializeForm(attrs));
  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    var attrs = initializeForm(form);
    store.dispatch({ type: ADD_CONFIG, payload: { id: id, attrs: attrs, key: 'forms' } });
    return _promise2.default.resolve(attrs.id);
  };
}

/**
 * Delete a form
 *
 * @param {String} formId  id or name of the form to delete
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function deleteForm(formId) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    return store.dispatch({
      type: DEL_CONFIG,
      payload: { id: id, attrId: formId, key: 'forms' }
    });
  };
}

/**
 * Update a form
 *
 * @param {String} formId
 * @param {Object} attrs
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function setForm(formId, attrs) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    return store.dispatch({
      type: SET_CONFIG,
      payload: { id: id, attrId: formId, attrs: attrs, key: 'forms' }
    });
  };
}

/**
 * Add a preset
 *
 * @param {Object} preset
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function addPreset(preset) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    var attrs = initializePreset(preset);
    store.dispatch({
      type: ADD_CONFIG,
      payload: { id: id, attrs: attrs, key: 'presets' }
    });
    return _promise2.default.resolve(attrs.id);
  };
}

/**
 * Delete a preset
 *
 * @param {String} presetId  id or name of the preset to delete
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function deletePreset(presetId) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    return store.dispatch({
      type: DEL_CONFIG,
      payload: { id: id, attrId: presetId, key: 'presets' }
    });
  };
}

/**
 * Update a preset
 *
 * @param {String} presetId
 * @param {Object} attrs
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function setPreset(presetId, attrs) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    return store.dispatch({
      type: SET_CONFIG,
      payload: { id: id, attrId: presetId, attrs: attrs, key: 'presets' }
    });
  };
}

/**
 * Update the formState.
 *
 * @param {Object} attrs
 * @param {Object} opts
 * @param {String} opts.id  Optional id of the configurator node
 */
function setFormState(attrs) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    return store.dispatch({
      type: SET_CONFIGURATOR_FORM_STATE,
      payload: { attrs: attrs, id: id }
    });
  };
}

/**
 * Add a product
 *
 * @public
 * @param {Product} attrs
 */
function addProduct() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (!attrs.handle) return _promise2.default.reject('Required product handle');
  return { type: ADD_PRODUCT, payload: initializeProduct(attrs) };
}

/**
 * Update a product
 *
 * @public
 * @param {Product} attrs
 */
function setProduct() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return { type: SET_PRODUCT, payload: initializeProduct(attrs) };
}

/**
 * Delete a product
 *
 * @public
 * @param {String} handle
 */
function deleteProduct(handle) {
  return { type: DEL_PRODUCT, payload: handle };
}

function isSaved(store) {
  var savingSceneId = store.getIn(['configuration', 'savingSceneId']);
  if (!savingSceneId) return true;
  var current = store.getIn(['configuration', 'configs', savingSceneId]);
  var saved = store.getIn(['configuration', 'savedConfig']);
  return (0, _immutable.is)(current, saved);
}

function isSaving(store) {
  return store.getIn(['configuration', 'saving']);
}

function shouldSave(store) {
  if (isSaving(store) || isSaved(store)) return false;
  return store.getIn(['configuration', 'savingSceneId']);
}

function toSaveJS(config) {
  var configSave = config.toJS();
  delete configSave.scriptInitialized;
  delete configSave.scriptError;
  configSave.attributes = configSave.attributes.map(function (attribute) {
    var attr = (0, _assign2.default)({}, attribute);
    delete attr.prop;
    return attr;
  });
  configSave.forms = configSave.forms.map(function (form) {
    form.fields = form.fields.map(function (field) {
      field.attribute = undefined;
      return field;
    });
    return form;
  });
  return JSON.parse((0, _stringify2.default)(configSave));
}

/**
 * Save the active configurator, if required.
 */
function save() {
  return function (store) {
    var sceneId = shouldSave(store);
    if (!sceneId) return;

    var numSaveErrors = store.getIn(['configuration', 'numSaveErrors']);

    store.dispatch({ type: CONFIG_SAVING });

    // Exponential backoff in case of save errors
    setTimeout(function () {
      // dispatch the save
      var config = store.getIn(['configuration', 'configs', sceneId]);
      var configuration = toSaveJS(config);
      store.callApi({
        types: [CONFIG_SAVING, CONFIG_SAVED, CONFIG_SAVE_ERROR],
        url: "https://editor.vimarket.io/api" + '/scenes/' + sceneId + '/configuration',
        method: 'POST',
        payload: config,
        fireAndForget: true,
        body: { configuration: configuration }
      });
    }, 1000 * numSaveErrors * numSaveErrors);
  };
}

function bomActions(products, cart) {
  // always returns a product object, even if not in store. This allows configuring a bom, while
  // product info gets loaded separately.
  function findProduct(handle) {
    var product = products.find(function (info) {
      return info.handle === handle;
    });
    if (!product) products.push(initializeProduct({ handle: handle }));
    return product || products[products.length - 1];
  }

  function getOrAddProductFromCart(product, quantity) {
    var cartEntry = cart[cart.length - 1];
    if (!cartEntry || cartEntry.handle !== product.handle) {
      cart.push({ handle: product.handle, quantity: quantity, options: [], product: product });
      cartEntry = cart[cart.length - 1];
    }
    if (!cartEntry.properties) cartEntry.properties = {};
    if (!cartEntry.variant) cartEntry.variant = product.variants[0];
    if (!cartEntry.options) cartEntry.options = [];
    return cartEntry;
  }

  return {
    'set-product': function setProduct(action) {
      var handle = action.tags;
      if (!handle) return;
      var quantity = action.value;

      var product = findProduct(handle);
      cart.push({
        handle: handle,
        quantity: quantity,
        variant: product.variants[0],
        product: product,
        properties: {}
      });
    },
    'select-variant': function selectVariant(action, attribute, value) {
      var handle = action.tags;
      if (!handle) return;
      var product = findProduct(handle);
      var cartEntry = getOrAddProductFromCart(product, 1);

      var optionIndex = product.options.findIndex(function (opt) {
        return opt.name === attribute.name;
      });
      if (optionIndex >= 0) cartEntry.options[optionIndex] = value;

      var variant = product.variants.find(function (variant) {
        var match = true;
        for (var i = 0; i < product.options.length; i++) {
          match = match && variant.options[i] === cartEntry.options[i];
        }
        return match;
      });
      cartEntry.variant = variant;
    },
    'select-quantity': function selectQuantity(action, attribute, value) {
      var handle = action.tags;
      if (!handle) return;
      var product = findProduct(handle);
      var cartEntry = getOrAddProductFromCart(product, 1);
      // console.log('select-quantity', attribute.type, value, action.value);
      if (attribute.type === 'Boolean') {
        cartEntry.quantity = value ? 1 : 0;
      } else if (attribute.type === 'Number') {
        cartEntry.quantity = Number(value);
      } else {
        cartEntry.quantity = Number(action.value);
      }
    }
  };
}

// Return all the fields for a configurator's form in an array.
function getFields(store, _ref28) {
  var id = _ref28.id;

  var configurator = getConfigurator(store, id);
  var form = configurator && getForm(store, configurator.form, { id: id });
  var fields = [];
  if (!!form) {
    fields = form.fields;
    if (form.meta.displayAs !== 'all') {
      form.steps.forEach(function (step) {
        var stepForm = getForm(store, step.formId, { id: id });
        if (!!stepForm) fields = fields.concat(stepForm.fields);
      });
    }
  }
  return fields;
}

function calculatePrice(bom) {
  return bom.items.reduce(function (total, _ref29) {
    var variant = _ref29.variant,
        quantity = _ref29.quantity,
        product = _ref29.product,
        price = _ref29.price;

    var itemPrice = void 0;
    if (price !== undefined) itemPrice = price;else if (variant && variant.price !== undefined) itemPrice = variant.price;else itemPrice = product.price;

    return typeof itemPrice === 'number' ? total + itemPrice * quantity : total;
  }, 0);
}

/**
 * Returns the bill of materials for a configured scene(s).
 *
 * @public
 *
 */
function getBOM(store) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var id = opts.id || (0, _sceneIO.getSceneId)(store);
  var configurators = getConfigurators(store);
  var products = getProducts(store);

  var allFields = configurators.reduce(function (acc, _ref30) {
    var id = _ref30.id;

    acc[id] = getFields(store, { id: id });
    return acc;
  }, {});

  var bom = {
    products: products,
    items: []
  };

  var availableActions = bomActions(products, bom.items);

  configurators.forEach(function (_ref31) {
    var id = _ref31.id;

    var configuration = getConfiguration(store, { id: id, all: true });
    allFields[id].forEach(function (_ref32) {
      var attribute = _ref32.attribute;

      var name = attribute.name;
      var value = configuration[name];

      var actions = (attribute.actions || []).concat(attribute.valueActions && attribute.valueActions[value] || []);
      actions.forEach(function (action) {
        if (availableActions[action.action]) {
          // console.log('bom exec', action.action, action, attribute, value);
          availableActions[action.action](action, attribute, value);
        }
      });
      var lastCartItem = bom.items[bom.items.length - 1];
      if (lastCartItem) {
        lastCartItem.properties[name] = value;
      }
    });
  });

  // console.log('cart?', JSON.stringify(bom.items, null, '  '));

  // result.items = result.items.filter(info => info.quantity && info.variant);
  bom.price = calculatePrice(bom);

  return bom;
}

function loadConfigurations(configurations) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return function (store) {
    var id = opts.id || (0, _sceneIO.getSceneId)(store);
    var sceneId = configurations.sceneId,
        publishedHash = configurations.publishedHash,
        models = configurations.models,
        configuration = configurations.configuration;

    if (id && id !== sceneId) {
      throw new Error('Invalid base scene for configurations: ' + sceneId + ', is ' + id);
    }
    var load = id ? _promise2.default.resolve(true) : store.dispatch((0, _sceneIO.fetchAndUse)(sceneId, publishedHash));

    return load.then(function () {
      var modelScenes = models.reduce(function (acc, _ref33) {
        var sceneId = _ref33.sceneId,
            publishedHash = _ref33.publishedHash;

        if (!acc[sceneId]) acc[sceneId] = publishedHash;
        return acc;
      }, {});
      return _promise2.default.all((0, _keys2.default)(modelScenes).map(function (id) {
        return store.dispatch((0, _sceneIO.fetch)(id, modelScenes[id]));
      })).then(function () {
        return store.dispatch(initConfigurator({ configuration: configuration }));
      }).then(function () {
        return _promise2.default.all(models.map(function (_ref34) {
          var sceneId = _ref34.sceneId,
              transform = _ref34.transform,
              configuration = _ref34.configuration;

          // console.log('clone scene', sceneId);
          return store.dispatch((0, _scene.cloneModel)({ sceneId: sceneId })).then(function (id) {
            store.dispatch(initConfigurator({ id: id, configuration: configuration }));
            var query = { id: id, plug: 'Transform', operatorIndex: 0 };
            return store.dispatch((0, _scene.set)(query, transform));
          });
        }));
      });
    });
  };
}

/**
 * Register a listener that gets called when a configuration is changed.
 * This listener will be called after the configuration actions have been
 * run, but before the next render, so other changes can be made during
 * the same frame. Arguments to the handler function are
 *  (`attribute`, `value`).
 *
 * @public
 * @param {Function} fn
 *
 */
function onChange(fn) {
  return { type: ADD_CHANGE_LISTENER, payload: fn };
}

var publicApi = {
  reducer: reducer,
  actions: {
    applyPreset: applyPreset,
    executeAttribute: executeAttribute,
    executeVariant: executeVariant,
    initConfiguration: initConfiguration,
    initConfigurator: initConfigurator,
    addProduct: addProduct,
    setAttribute: setAttribute,
    setProduct: setProduct,
    deleteProduct: deleteProduct,
    setConfiguration: setConfiguration,
    setAttributeVisibility: setAttributeVisibility,
    loadConfigurations: loadConfigurations,
    removeConfigurator: removeConfigurator,
    onChange: onChange
  },
  selectors: {
    getConfigurationState: getConfigurationState,
    getAttribute: getAttribute,
    getAttributes: getAttributes,
    getAttributesByType: getAttributesByType,
    getForm: getForm,
    getForms: getForms,
    getConfiguration: getConfiguration,
    getBOM: getBOM,
    getExternalEl: getExternalEl,
    getPresets: getPresets,
    getProduct: getProduct,
    getProducts: getProducts,
    getProductTour: getProductTour,
    getFormState: getFormState,
    getConfigurations: getConfigurations
  }
};

exports.default = publicApi;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(506)
var ieee754 = __webpack_require__(687)
var isArray = __webpack_require__(688)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bbox = __webpack_require__(208);

var _bbox2 = _interopRequireDefault(_bbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A bzier path containing a set of path commands similar to a SVG path.
 * Paths can be drawn on a context using `draw`.
 * @exports opentype.Path
 * @class
 * @constructor
 */
function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}

/**
 * @param  {number} x
 * @param  {number} y
 */
// Geometric objects

Path.prototype.moveTo = function (x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};

/**
 * @param  {number} x
 * @param  {number} y
 */
Path.prototype.lineTo = function (x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};

/**
 * Draws cubic curve
 * @function
 * curveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */

/**
 * Draws cubic curve
 * @function
 * bezierCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 * @see curveTo
 */
Path.prototype.curveTo = Path.prototype.bezierCurveTo = function (x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};

/**
 * Draws quadratic curve
 * @function
 * quadraticCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */

/**
 * Draws quadratic curve
 * @function
 * quadTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */
Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function (x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};

/**
 * Closes the path
 * @function closePath
 * @memberof opentype.Path.prototype
 */

/**
 * Close the path
 * @function close
 * @memberof opentype.Path.prototype
 */
Path.prototype.close = Path.prototype.closePath = function () {
    this.commands.push({
        type: 'Z'
    });
};

/**
 * Add the given path or list of commands to the commands of this path.
 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
 */
Path.prototype.extend = function (pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    } else if (pathOrCommands instanceof _bbox2.default) {
        var box = pathOrCommands;
        this.moveTo(box.x1, box.y1);
        this.lineTo(box.x2, box.y1);
        this.lineTo(box.x2, box.y2);
        this.lineTo(box.x1, box.y2);
        this.close();
        return;
    }

    Array.prototype.push.apply(this.commands, pathOrCommands);
};

/**
 * Calculate the bounding box of the path.
 * @returns {opentype.BoundingBox}
 */
Path.prototype.getBoundingBox = function () {
    var box = new _bbox2.default();

    var startX = 0;
    var startY = 0;
    var prevX = 0;
    var prevY = 0;
    for (var i = 0; i < this.commands.length; i++) {
        var cmd = this.commands[i];
        switch (cmd.type) {
            case 'M':
                box.addPoint(cmd.x, cmd.y);
                startX = prevX = cmd.x;
                startY = prevY = cmd.y;
                break;
            case 'L':
                box.addPoint(cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Q':
                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'C':
                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Z':
                prevX = startX;
                prevY = startY;
                break;
            default:
                throw new Error('Unexpected path command ' + cmd.type);
        }
    }
    if (box.isEmpty()) {
        box.addPoint(0, 0);
    }
    return box;
};

/**
 * Draw the path to a 2D context.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
 */
Path.prototype.draw = function (ctx) {
    ctx.beginPath();
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }

    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }

    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};

/**
 * Convert the Path to a string of path data instructions
 * See http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */
Path.prototype.toPathData = function (decimalPlaces) {
    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

    function floatToString(v) {
        if (Math.round(v) === v) {
            return '' + Math.round(v);
        } else {
            return v.toFixed(decimalPlaces);
        }
    }

    function packValues() {
        var s = '';
        for (var i = 0; i < arguments.length; i += 1) {
            var v = arguments[i];
            if (v >= 0 && i > 0) {
                s += ' ';
            }

            s += floatToString(v);
        }

        return s;
    }

    var d = '';
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            d += 'M' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            d += 'L' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            d += 'Z';
        }
    }

    return d;
};

/**
 * Convert the path to an SVG <path> element, as a string.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */
Path.prototype.toSVG = function (decimalPlaces) {
    var svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill && this.fill !== 'black') {
        if (this.fill === null) {
            svg += ' fill="none"';
        } else {
            svg += ' fill="' + this.fill + '"';
        }
    }

    if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    }

    svg += '/>';
    return svg;
};

/**
 * Convert the path to a DOM element.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {SVGPathElement}
 */
Path.prototype.toDOMElement = function (decimalPlaces) {
    var temporaryPath = this.toPathData(decimalPlaces);
    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

    newPath.setAttribute('d', temporaryPath);

    return newPath;
};

exports.default = Path;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lookupOperator = lookupOperator;

var _makeAllOperatorsNonImmutable = __webpack_require__(412);

var _makeAllOperatorsNonImmutable2 = _interopRequireDefault(_makeAllOperatorsNonImmutable);

var _Annotation = __webpack_require__(354);

var _Annotation2 = _interopRequireDefault(_Annotation);

var _Camera = __webpack_require__(355);

var _Camera2 = _interopRequireDefault(_Camera);

var _Environment = __webpack_require__(356);

var _Environment2 = _interopRequireDefault(_Environment);

var _GeneralRenderer = __webpack_require__(358);

var _GeneralRenderer2 = _interopRequireDefault(_GeneralRenderer);

var _Image = __webpack_require__(359);

var _Image2 = _interopRequireDefault(_Image);

var _Light = __webpack_require__(360);

var _Light2 = _interopRequireDefault(_Light);

var _Material = __webpack_require__(361);

var _Material2 = _interopRequireDefault(_Material);

var _Pass = __webpack_require__(362);

var _Pass2 = _interopRequireDefault(_Pass);

var _Player = __webpack_require__(363);

var _Player2 = _interopRequireDefault(_Player);

var _PolyMesh = __webpack_require__(398);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _Properties = __webpack_require__(408);

var _Properties2 = _interopRequireDefault(_Properties);

var _Renderer = __webpack_require__(409);

var _Renderer2 = _interopRequireDefault(_Renderer);

var _Transform = __webpack_require__(411);

var _Transform2 = _interopRequireDefault(_Transform);

var _Font = __webpack_require__(357);

var _Font2 = _interopRequireDefault(_Font);

var _Timeline = __webpack_require__(410);

var _Timeline2 = _interopRequireDefault(_Timeline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NoOp = { schema: {} };

var Bone = { Bone: NoOp };
var Null = { Null: NoOp };
var Mixer = { Action: NoOp, Mixer: NoOp };
_Renderer2.default['vray/create'] = NoOp;
//const Timeline = { Timeline: NoOp };
var Viewport = { Viewport: NoOp };
var Clip = { Clip: NoOp };

var records = (0, _makeAllOperatorsNonImmutable2.default)({
  Annotation: _Annotation2.default,
  Bone: Bone,
  Camera: _Camera2.default,
  Environment: _Environment2.default,
  GeneralRenderer: _GeneralRenderer2.default,
  Light: _Light2.default,
  Material: _Material2.default,
  Mixer: Mixer,
  Null: Null,
  Pass: _Pass2.default,
  Player: _Player2.default,
  PolyMesh: _PolyMesh2.default,
  Properties: _Properties2.default,
  Renderer: _Renderer2.default,
  Timeline: _Timeline2.default,
  Transform: _Transform2.default,
  Image: _Image2.default,
  Viewport: Viewport,
  Font: _Font2.default,
  Clip: Clip
}, { withNone: true });

function lookupOperator(plugName, type, warnings) {
  var plug = records[plugName];
  if (!plug) {
    warnings.push('Unknown plug: ' + plugName);
    return records.None.NoOp;
  }

  var operator = plug[type];
  if (!operator) {
    warnings.push('Unknown Operator: ' + plugName + ', ' + type);
    return records.None.NoOp;
  }

  return operator;
}

exports.default = records;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cleanPolyMesh;

var _removeDuplicateValues = __webpack_require__(160);

var _removeDuplicateValues2 = _interopRequireDefault(_removeDuplicateValues);

var _removeDuplicateIndices = __webpack_require__(438);

var _removeDuplicateIndices2 = _interopRequireDefault(_removeDuplicateIndices);

var _removeInvalidSurfaces = __webpack_require__(439);

var _removeInvalidSurfaces2 = _interopRequireDefault(_removeInvalidSurfaces);

var _removeDuplicateNormals = __webpack_require__(159);

var _removeDuplicateNormals2 = _interopRequireDefault(_removeDuplicateNormals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cleanPolyMesh(polyMesh) {
  //not advisable to remove normals by default. can lead to fusing of normals on joints while doing animation
  //return removeDuplicateNormals(removeInvalidSurfaces(removeDuplicateIndices(removeDuplicateValues(polyMesh))));
  return (0, _removeInvalidSurfaces2.default)((0, _removeDuplicateIndices2.default)((0, _removeDuplicateValues2.default)(polyMesh)));
}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergeMeshes;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectBuffer = __webpack_require__(68);

var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _removeDuplicateValues = __webpack_require__(160);

var _removeDuplicateValues2 = _interopRequireDefault(_removeDuplicateValues);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Merges the passed array of polymaps into one poly map.
 * If an element in polymaps is undefined, a default map is created using options.defaultValue and the options.respectivePositions.
 * Therefore these must be passed when a polymap is missing.
 * @param polymaps - List of polymaps to merge. If any are missing, a default one is created.
 * @param options - Looks like {faceRangeOffsets, transforms, applyTransform, defaultValue, respectivePositions}
 * @returns a merged polymap
 */
function mergePolyMaps(polymaps, options) {
  if (polymaps.length <= 0) {
    return undefined;
  }
  var faceRangeOffsets = options.faceRangeOffsets,
      transforms = options.transforms,
      applyTransform = options.applyTransform,
      defaultValue = options.defaultValue,
      respectivePositions = options.respectivePositions;


  var valuesSize = 0;
  var offsetsSize = 0;
  var indicesSize = 0;

  var useDefault = false;
  //if defaultValue is passed we can use it to get the ValueType, otherwise we find it in loop below
  var ValueType = defaultValue && defaultValue.constructor;

  //loop through polymaps once to get the size of the merged polymap
  for (var i = 0; i < polymaps.length; ++i) {
    useDefault = polymaps[i] == null;
    if (useDefault && (!defaultValue || !respectivePositions)) {
      throw new Error('If any polymap does not exist, the defaultValue and respectivePositions must be passed');
      return new _PolyMap2.default();
    }
    if (useDefault) {
      offsetsSize += respectivePositions[i].faceRangeOffsets.length - 1;
      indicesSize += respectivePositions[i].faceValueIndices.length;
      valuesSize += respectivePositions[i].faceValueIndices.length;
    } else {
      if (!ValueType) {
        ValueType = polymaps[i].values.type;
      }
      offsetsSize += polymaps[i].faceRangeOffsets.length - 1;
      indicesSize += polymaps[i].faceValueIndices.length;
      valuesSize += polymaps[i].values.length;
    }
  }
  offsetsSize++;

  var mergedValues = new _ObjectArrayView2.default(ValueType, valuesSize);
  var mergedIndices = new Uint32Array(indicesSize);
  var mergedOffsets = faceRangeOffsets || new Uint32Array(offsetsSize);

  var tempVec = new ValueType();
  var offsetsOffset = 0; // great variable name, I know
  var indicesOffset = 0;
  var valuesOffset = 0;

  // merge each buffer of the polymaps
  for (var _i = 0; _i < polymaps.length; ++_i) {
    useDefault = polymaps[_i] == null;

    // Offsets - initialize if faceRangeOffsets wasn't passed
    var offsets = polymaps[_i] ? polymaps[_i].faceRangeOffsets : respectivePositions[_i].faceRangeOffsets;
    if (!faceRangeOffsets) {
      for (var _i2 = 1; _i2 < offsets.length; ++_i2) {
        //
        mergedOffsets[_i2 + offsetsOffset] = offsets[_i2] + mergedOffsets[offsetsOffset];
      }
    }
    offsetsOffset += offsets.length - 1;

    // Indices
    var indices = polymaps[_i] ? polymaps[_i].faceValueIndices : respectivePositions[_i].faceValueIndices;
    for (var _i3 = 0; _i3 < indices.length; ++_i3) {
      if (useDefault) {
        mergedIndices[_i3 + indicesOffset] = _i3 + valuesOffset;
      } else {
        mergedIndices[_i3 + indicesOffset] = indices[_i3] + valuesOffset;
      }
    }

    indicesOffset += indices.length;

    // Values
    var values = useDefault ? respectivePositions[_i].faceValueIndices : polymaps[_i].values;
    var transform = void 0;
    for (var j = 0; j < values.length; ++j) {
      if (useDefault) {
        mergedValues.setAt(j + valuesOffset, defaultValue);
      } else {
        polymaps[_i].values.getAt(j, tempVec);

        if (transforms) {
          transform = transforms[_i];
          if (!transform.isMatrix4 && !transform.isMatrix3 && !applyTransform) {
            throw new Error('Requires Matrix3 or Matrix4 with a applyTransform function to perform transform.');
          }
          applyTransform.call(tempVec, transform);
        }
        mergedValues.setAt(j + valuesOffset, tempVec);
      }
    }

    valuesOffset += values.length;
  }

  var mergedPolyMap = new _PolyMap2.default({
    faceRangeOffsets: mergedOffsets,
    faceValueIndices: mergedIndices,
    values: mergedValues
  });

  if (valuesSize !== mergedValues.length) throw new Error('mismatch between number of input and output values');

  return mergedPolyMap;
}

function mergeMeshes(mergeList, optionalWorldTransforms, withLogging) {
  if (!Array.isArray(mergeList)) {
    return mergeList;
  } else if (mergeList.length === 1) {
    return mergeList[0];
  }

  var l = withLogging || false;

  //if the map exist in at least one mesh, it should be merged
  var shouldBeMerged = function shouldBeMerged(mapName) {
    for (var i = 0; i < mergeList.length; ++i) {
      if (mergeList[i][mapName] !== undefined) return true;
    }
    return false;
  };

  var getMapList = function getMapList(mapName) {
    var maps = [];
    for (var i = 0; i < mergeList.length; ++i) {
      maps.push(mergeList[i][mapName]);
    }
    return maps;
  };

  var getMergedPolyMap = function getMergedPolyMap(mapName, mergeMapOptions) {
    if (shouldBeMerged(mapName)) {
      if (l) console.log('Merging ' + mapName + 's...');
      return mergePolyMaps(getMapList(mapName), mergeMapOptions);
    }
  };

  var from = {};

  var mergeMapOptions = {
    transforms: optionalWorldTransforms,
    applyTransform: _three.Vector3.prototype.applyMatrix4
  };
  from.positions = getMergedPolyMap('positions', mergeMapOptions);
  from.faceRangeOffsets = from.positions.faceRangeOffsets;

  if (optionalWorldTransforms) {
    for (var i = 0; i < optionalWorldTransforms.length; ++i) {
      optionalWorldTransforms[i] = new _three.Matrix3().getNormalMatrix(optionalWorldTransforms[i]);
    }
  }

  mergeMapOptions.faceRangeOffsets = from.faceRangeOffsets;

  mergeMapOptions.applyTransform = _three.Vector3.prototype.applyMatrix3;
  mergeMapOptions.defaultValue = new _three.Vector3(1, 0, 0);
  mergeMapOptions.respectivePositions = getMapList('positions');
  from.normalMap = getMergedPolyMap('normalMap', mergeMapOptions);

  mergeMapOptions.defaultValue = new _three.Vector4(1, 0, 0, 1);
  from.tangentMap = getMergedPolyMap('tangentMap', mergeMapOptions);

  //the ObjectsByName (uvMaps, colorMaps) have to be merged by channel
  var getMapListsByChannelName = function getMapListsByChannelName(polyMapList) {
    //find the channels that need to be merged (at least one ObjectsByName should have the channel)
    var channelsToMerge = {};
    var channelName = void 0;
    for (var _i4 = 0; _i4 < polyMapList.length; ++_i4) {
      var objectByName = polyMapList[_i4];
      if (objectByName) {
        for (var j = 0; j < objectByName.namesByIndex.length; ++j) {
          channelName = objectByName.namesByIndex[j];
          channelsToMerge[channelName] = true;
        }
      }
    }

    //filter the polymaps by channel names
    var mapListsByChannelName = {};
    for (var _channelName in channelsToMerge) {
      if (channelsToMerge.hasOwnProperty(_channelName)) {
        for (var _i5 = 0; _i5 < polyMapList.length; ++_i5) {
          var map = polyMapList[_i5];
          if (!mapListsByChannelName[_channelName]) {
            mapListsByChannelName[_channelName] = [];
          }
          mapListsByChannelName[_channelName].push(map.byName[_channelName]);
        }
      }
    }
    return mapListsByChannelName;
  };

  var getMergedObjectsByName = function getMergedObjectsByName(nameOfObjectsByName, mergeMapOptions) {
    var newObjectsByName = new _ObjectsByName2.default();
    if (l) console.log('Merging ' + nameOfObjectsByName);
    var channels = getMapListsByChannelName(getMapList(nameOfObjectsByName));
    for (var key in channels) {
      if (channels.hasOwnProperty(key)) {
        newObjectsByName.set(key, mergePolyMaps(channels[key], mergeMapOptions));
      }
    }

    return newObjectsByName;
  };

  mergeMapOptions.transforms = null;
  mergeMapOptions.defaultValue = new _three.Vector2(0, 0);
  from.uvMaps = getMergedObjectsByName('uvMaps', mergeMapOptions);

  mergeMapOptions.defaultValue = new _three.Color(0, 0, 0);
  from.colorMaps = getMergedObjectsByName('colorMaps', mergeMapOptions);

  //materialIds aren't polymaps, need to merge differently
  if (shouldBeMerged('materialIds')) {
    if (l) console.log('Merging Material Ids......');
    var inputMaterialIds = getMapList('materialIds');
    var arrayInsertOffset = 0;
    var currentTypedArray = void 0;
    from.materialIds = new Float32Array(from.faceRangeOffsets.length - 1);
    for (var _i6 = 0; _i6 < inputMaterialIds.length; ++_i6) {
      currentTypedArray = inputMaterialIds[_i6];
      if (currentTypedArray) {
        from.materialIds.set(currentTypedArray, arrayInsertOffset);
      }
      arrayInsertOffset += mergeList[_i6].faceRangeOffsets.length - 1;
    }
  }

  var mergedMesh = new _PolyMesh2.default(from);

  return (0, _removeDuplicateValues2.default)(mergedMesh, true);
}

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOrbitMode = getOrbitMode;
exports.getConstrainCameraY = getConstrainCameraY;
exports.setOrbitMode = setOrbitMode;
exports.getOrbitTarget = getOrbitTarget;

var _scene = __webpack_require__(7);

function getOrbitMode(store, cameraId) {
  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
  var cameraProperties = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Properties' });
  return playerData.overrideNavigation ? playerData.orbitMode : cameraProperties.orbitMode;
}

function getConstrainCameraY(store, cameraId) {
  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
  var cameraProperties = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Properties' });
  return playerData.overrideNavigation ? playerData.constraintCameraY : cameraProperties.constraintCameraY;
}

function setOrbitMode(store, cameraId, value) {
  var playerQuery = { scene: true, plug: 'Player' };
  var cameraQuery = { id: cameraId, plug: 'Properties' };
  var overrideNavigation = (0, _scene.get)(store, {
    scene: true,
    plug: 'Player',
    property: 'overrideNavigation'
  });
  var query = overrideNavigation ? playerQuery : cameraQuery;
  return (0, _scene.set)(query, value);
}

function getOrbitTarget(store, cameraId) {
  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
  var cameraProperties = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Properties' });
  return playerData.overrideNavigation ? playerData.orbitTarget : cameraProperties.orbitTarget;
}

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getProjectionMatrix;

var _three = __webpack_require__(0);

function getProjectionMatrix(cameraData) {
  var projectionMatrix = new _three.Matrix4();
  if (!cameraData) return projectionMatrix;

  if (cameraData.projection === 'Orthographic') {
    var size = computeCameraSize(true, cameraData) || { width: 1, height: 1 };
    projectionMatrix.makeOrthographic(-size.width, size.width, size.height, -size.height, cameraData.nearClip, cameraData.farClip);
  } else {
    // const filmSizeVec = new Vector2(cameraData.get('filmSize'),
    //     cameraData.get('filmSize') * cameraData.get('aspectRatio'));
    //  console.log(navigator.getProjectionMatrix:, data.fieldOfView, data.aspectRatio);

    var ymax = cameraData.nearClip * Math.tan(_three.Math.DEG2RAD * cameraData.fieldOfView * 0.5);
    var ymin = -ymax;
    var xmin = ymin * cameraData.aspectRatio;
    var xmax = ymax * cameraData.aspectRatio;

    //console.log( 'projectionMatrix.makePerspective', xmin, xmax, ymax, ymin, cameraData.nearClip, cameraData.farClip );
    //console.log( 'cameraData', cameraData );

    return projectionMatrix.makePerspective(xmin, xmax, ymax, ymin, cameraData.nearClip, cameraData.farClip);
  }

  return projectionMatrix;
}

function computeCameraSize(halfSize, cameraData) {
  if (!(cameraData && cameraData.fieldOfView && cameraData.orthoZoom && cameraData.aspectRatio)) return false;

  var tangent = Math.tan(_three.Math.degToRad(cameraData.fieldOfView / 2));
  var camHeight_half = tangent * cameraData.orthoZoom;
  var camWidth_half = camHeight_half * cameraData.aspectRatio;

  //  Horizontal fov ?
  // var hFOV_Half = Math.atan( Math.tan( this.fieldOfView / 2 ) * this.aspectRatio );
  // var camWidth = Math.tan( hFOV_Half ) * dist * 2;

  if (halfSize === true) {
    return { width: camWidth_half, height: camHeight_half };
  } else {
    return { width: camWidth_half * 2, height: camHeight_half * 2 };
  }
}

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

exports.default = mapObjIndexed;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mapObjIndexed(fn, obj) {
  var result = {};
  (0, _keys2.default)(obj).forEach(function (key, idx) {
    result[key] = fn(obj[key], key, idx);
  });
  return result;
}

/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 108 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 109 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(41).f;
var has = __webpack_require__(61);
var TAG = __webpack_require__(25)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(52);
var IObject = __webpack_require__(191);
var toObject = __webpack_require__(77);
var toLength = __webpack_require__(30);
var asc = __webpack_require__(586);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 113 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(78)('meta');
var isObject = __webpack_require__(14);
var has = __webpack_require__(36);
var setDesc = __webpack_require__(26).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(21)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(12);
var dPs = __webpack_require__(594);
var enumBugKeys = __webpack_require__(189);
var IE_PROTO = __webpack_require__(196)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(188)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(284).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(296);
var hiddenKeys = __webpack_require__(189).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(36);
var toObject = __webpack_require__(77);
var IE_PROTO = __webpack_require__(196)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 118 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(14);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(11);
var core = __webpack_require__(9);
var fails = __webpack_require__(60);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addGlyphNames = exports.GlyphNames = exports.CffEncoding = exports.CmapEncoding = exports.DefaultEncoding = exports.standardNames = exports.cffExpertEncoding = exports.cffStandardEncoding = exports.cffStandardStrings = undefined;

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Glyph encoding

var cffStandardStrings = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000', '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

var cffStandardEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger', 'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron', 'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '', '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '', 'lslash', 'oslash', 'oe', 'germandbls'];

var cffExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior', '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var standardNames = ['.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth', 'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior', 'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla', 'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

/**
 * This is the encoding used for fonts created from scratch.
 * It loops through all glyphs and finds the appropriate unicode value.
 * Since it's linear time, other encodings will be faster.
 * @exports opentype.DefaultEncoding
 * @class
 * @constructor
 * @param {opentype.Font}
 */
function DefaultEncoding(font) {
    this.font = font;
}

DefaultEncoding.prototype.charToGlyphIndex = function (c) {
    var code = c.charCodeAt(0);
    var glyphs = this.font.glyphs;
    if (glyphs) {
        for (var i = 0; i < glyphs.length; i += 1) {
            var glyph = glyphs.get(i);
            for (var j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    }
    return null;
};

/**
 * @exports opentype.CmapEncoding
 * @class
 * @constructor
 * @param {Object} cmap - a object with the cmap encoded data
 */
function CmapEncoding(cmap) {
    this.cmap = cmap;
}

/**
 * @param  {string} c - the character
 * @return {number} The glyph index.
 */
CmapEncoding.prototype.charToGlyphIndex = function (c) {
    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
};

/**
 * @exports opentype.CffEncoding
 * @class
 * @constructor
 * @param {string} encoding - The encoding
 * @param {Array} charset - The character set.
 */
function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}

/**
 * @param  {string} s - The character
 * @return {number} The index.
 */
CffEncoding.prototype.charToGlyphIndex = function (s) {
    var code = s.charCodeAt(0);
    var charName = this.encoding[code];
    return this.charset.indexOf(charName);
};

/**
 * @exports opentype.GlyphNames
 * @class
 * @constructor
 * @param {Object} post
 */
function GlyphNames(post) {
    switch (post.version) {
        case 1:
            this.names = standardNames.slice();
            break;
        case 2:
            this.names = new Array(post.numberOfGlyphs);
            for (var i = 0; i < post.numberOfGlyphs; i++) {
                if (post.glyphNameIndex[i] < standardNames.length) {
                    this.names[i] = standardNames[post.glyphNameIndex[i]];
                } else {
                    this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
                }
            }

            break;
        case 2.5:
            this.names = new Array(post.numberOfGlyphs);
            for (var _i = 0; _i < post.numberOfGlyphs; _i++) {
                this.names[_i] = standardNames[_i + post.glyphNameIndex[_i]];
            }

            break;
        case 3:
            this.names = [];
            break;
        default:
            this.names = [];
            break;
    }
}

/**
 * Gets the index of a glyph by name.
 * @param  {string} name - The glyph name
 * @return {number} The index
 */
GlyphNames.prototype.nameToGlyphIndex = function (name) {
    return this.names.indexOf(name);
};

/**
 * @param  {number} gid
 * @return {string}
 */
GlyphNames.prototype.glyphIndexToName = function (gid) {
    return this.names[gid];
};

/**
 * @alias opentype.addGlyphNames
 * @param {opentype.Font}
 */
function addGlyphNames(font) {
    var glyph = void 0;
    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
    var charCodes = (0, _keys2.default)(glyphIndexMap);

    for (var i = 0; i < charCodes.length; i += 1) {
        var c = charCodes[i];
        var glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs.get(glyphIndex);
        glyph.addUnicode(parseInt(c));
    }

    for (var _i2 = 0; _i2 < font.glyphs.length; _i2 += 1) {
        glyph = font.glyphs.get(_i2);
        if (font.cffEncoding) {
            if (font.isCIDFont) {
                glyph.name = 'gid' + _i2;
            } else {
                glyph.name = font.cffEncoding.charset[_i2];
            }
        } else if (font.glyphNames.names) {
            glyph.name = font.glyphNames.glyphIndexToName(_i2);
        }
    }
}

exports.cffStandardStrings = cffStandardStrings;
exports.cffStandardEncoding = cffStandardEncoding;
exports.cffExpertEncoding = cffExpertEncoding;
exports.standardNames = standardNames;
exports.DefaultEncoding = DefaultEncoding;
exports.CmapEncoding = CmapEncoding;
exports.CffEncoding = CffEncoding;
exports.GlyphNames = GlyphNames;
exports.addGlyphNames = addGlyphNames;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _createReducer;

exports.setAnnotationProperties = setAnnotationProperties;
exports.openAnnotation = openAnnotation;
exports.closeAnnotation = closeAnnotation;
exports.useCustomAnnotationFunction = useCustomAnnotationFunction;
exports.useCustomOverlayFunction = useCustomOverlayFunction;
exports.getCustomAnnotationFunction = getCustomAnnotationFunction;
exports.getCustomOverlayFunction = getCustomOverlayFunction;

var _immutable = __webpack_require__(32);

var _createReducer2 = __webpack_require__(46);

var _createReducer3 = _interopRequireDefault(_createReducer2);

var _actionTypes = __webpack_require__(58);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SET_ANNOTATION_PROPERTIES = 'SET_ANNOTATION_PROPERTIES';
var USE_CUSTOM_ANNOTATION_FUNCTION = 'USE_CUSTOM_ANNOTATION_FUNCTION';
var USE_CUSTOM_OVERLAY_FUNCTION = 'USE_CUSTOM_OVERLAY_FUNCTION';

/**
 * Annotations
 *
 * @module annotations
 * @public
 *
 */

var initialState = (0, _immutable.Map)({
  customAnnotationFn: null,
  customOverlayFn: null
});

var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, SET_ANNOTATION_PROPERTIES, function (state, _ref) {
  var id = _ref.id,
      attrs = _ref.attrs;

  var props = state.get('id') || (0, _immutable.Map)();
  return state.set(id, props.merge(attrs));
}), (0, _defineProperty3.default)(_createReducer, USE_CUSTOM_ANNOTATION_FUNCTION, function (state, annotationFn) {
  return state.set('customAnnotationFn', annotationFn);
}), (0, _defineProperty3.default)(_createReducer, USE_CUSTOM_OVERLAY_FUNCTION, function (state, overlayFn) {
  return state.set('customOverlayFn', overlayFn);
}), _createReducer));

function setAnnotationProperties(id, attrs) {
  return { type: SET_ANNOTATION_PROPERTIES, payload: { id: id, attrs: attrs } };
}

/**
 * Open annotation node in the player.
 * @param {String} id - id of the annotation node.
 * @public
 */
function openAnnotation(id) {
  return {
    type: SET_ANNOTATION_PROPERTIES,
    payload: { id: id, attrs: { pinned: true, open: true } }
  };
}

/**
 * Close annotation node.
 * @param {String} id - id of the annotation node.
 * @public
 */
function closeAnnotation(id) {
  return {
    type: SET_ANNOTATION_PROPERTIES,
    payload: { id: id, attrs: { pinned: false, open: false } }
  };
}

/**
 * Use custom annotations. Set a custom function that will be called for every
 * annotation on every scene update. The arguments passed to this function
 * will be the [annotation object](global.html#Annotation), and the div that
 * any annotations may be created under. This div has `pointer-events` set
 * to none so that the scene below it will receive all mouse/touch events.
 * If you wish to handle events in your annotations, make sure to set `pointer-events`.
 *
 * @public
 * @param {Function} fn The function to be called for every annotation update.
 *
 */
function useCustomAnnotationFunction(fn) {
  return { type: USE_CUSTOM_ANNOTATION_FUNCTION, payload: fn };
}

/**
 *
 * Set a custom function that will be called for a completely custom
 * annotation overlay. The argument passed to this function will be the
 * annotation parent div. This div has `pointer-events` set
 * to none so that the scene below it will receive all mouse/touch events.
 * If you wish to handle events in your UI, make sure to set `pointer-events`.
 *
 * @public
 * @param {Function} customFn Function will be called once for each change
 *
 */
function useCustomOverlayFunction(fn) {
  return { type: USE_CUSTOM_OVERLAY_FUNCTION, payload: fn };
}

function getCustomAnnotationFunction(store) {
  return store.getIn(['annotations', 'customAnnotationFn']);
}

function getCustomOverlayFunction(store) {
  return store.getIn(['annotations', 'customOverlayFn']);
}

var publicApi = {
  reducer: reducer,
  actions: {
    setAnnotationProperties: setAnnotationProperties,
    openAnnotation: openAnnotation,
    closeAnnotation: closeAnnotation,
    useCustomAnnotationFunction: useCustomAnnotationFunction,
    useCustomOverlayFunction: useCustomOverlayFunction
  },
  selectors: { getCustomAnnotationFunction: getCustomAnnotationFunction }
};

exports.default = publicApi;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = __webpack_require__(38);

var _typeof3 = _interopRequireDefault(_typeof2);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.isUuid = isUuid;
exports.buildQueryObject = buildQueryObject;
exports.getMatch = getMatch;
exports.matchChildren = matchChildren;
exports.findChild = findChild;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

/**
 * Test whether a string is a uuid or not.
 * @param {String} id
 */
function isUuid(id) {
  return uuidRegex.test(id);
}

function pathToRegExp(query) {
  if (query instanceof RegExp) return query;
  query = query.replace(/\*/g, '(.*)').replace(/^\"|\"$/g, '');
  return new RegExp('^' + query + '$', 'i');
}

var re = {
  bareName: '^([^!%[#:]*)*', // Match the name, up to % or #
  type: '(?:%([^#!:]*))*', // Match the type
  filter: '(?::([^#:]*))*', // Any filter?
  evalPlug: '(?:!([^#[]*))*', // Evaluated plug name
  plugName: '(?:#([^[]*))*', // Plug name
  attrs: '(.*)' // Any attribute selectors (entire match)
};

var queryRegex = new RegExp(re.bareName + re.type + re.filter + re.evalPlug + re.plugName + re.attrs);

var queryRegexNoName = new RegExp('()' + re.type + re.filter + re.evalPlug + re.plugName + re.attrs);

var attrsRegex = /(?:\[([^\]]*)\])/g;

/*
 * Parse "[translation][name='Transform']" and turn it into
 * operator/property/properties fields for matching.
 */
function parseOperatorAttributes(attrsString) {
  // Take "[translation][name='Transform']" and convert it into
  // a filter function that will match the specific operator
  var items, match;

  var property = void 0;
  var properties = void 0;

  while ((match = attrsRegex.exec(attrsString)) !== null) {
    items = match[1].split('=');
    if (items.length === 2) {
      if (!properties) properties = {};
      properties[items[0]] = items[1];
    } else {
      property = items[0];
    }
  }

  return { property: property, properties: properties };
}

function buildQueryObjectFromString(query, options) {
  // Support looking for the active scene node with '~'.
  var scene = query[0] === '~';
  var quotedIdx = !scene && query[0] === '"' && query.slice(1).indexOf('"');
  var quotedName = quotedIdx && quotedIdx !== -1;

  var matches = quotedName || scene ? queryRegexNoName.exec(query.slice(scene ? 1 : quotedIdx + 2)) : queryRegex.exec(query);
  var name = quotedName ? query.slice(1, quotedIdx + 1) : scene ? false : matches[1];
  var type = matches[2];
  var filter = matches[3];
  var evalPlug = matches[4];
  var plug = matches[5];
  var attrs = matches[6];
  var id = isUuid(name) ? name : undefined;
  var result = (0, _assign2.default)({
    scene: scene,
    id: id,
    name: id || !name ? undefined : pathToRegExp(name),
    type: type,
    filter: filter,
    evalPlug: evalPlug,
    plug: plug
  }, parseOperatorAttributes(attrs), { includeParent: true });
  if (result.name) result._name = name;
  (0, _assign2.default)(result, options);
  return result;
}

/**
 * Takes a query string, and returns an object with the attributes we are looking
 * for.
 */
function buildQueryObject(query) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof query === 'string') return buildQueryObjectFromString(query, options);
  if ((typeof query === 'undefined' ? 'undefined' : (0, _typeof3.default)(query)) === 'object') {
    //if (typeof query.name === 'string' && query.name.indexOf('*') !== -1)
    return (0, _assign2.default)({}, query, {
      name: query.name ? pathToRegExp(query.name) : undefined,
      names: query.names && Array.isArray(query.names) ? query.names.map(pathToRegExp) : undefined,
      // include parent by default if no from query is specified
      includeParent: query.includeParent === undefined ? !query.from : query.includeParent
    }, options);
  }

  return {};
}

/*
 * Given a QueryObject, will return a matching path for this node, or
 * null if the node does not match.
 */
function getMatch(node, queryObj, onlyNode) {
  var nodeMatch = getNodeMatch(node, queryObj);
  return !nodeMatch ? null : onlyNode ? nodeMatch.id : matchInside(node, queryObj);
}

/*
 * Given a QueryObject, will return the node if the node matches the
 * node query parameters (id, name, type).
 */
function getNodeMatch(node, queryObj) {
  if (queryObj.id !== undefined && queryObj.id !== node.id) return null;
  if (queryObj.name !== undefined && !queryObj.name.test(node.name)) return null;
  if (queryObj.type !== undefined) {
    if (typeof queryObj.type === 'string') {
      if (queryObj.type !== node.type) return null;
    } else if (Array.isArray(queryObj.type)) {
      if (queryObj.type.indexOf(node.type) === -1) return null;
    }
  }
  if (queryObj.hasPlug !== undefined && !node.plugs[queryObj.hasPlug]) return null;

  return node;
}

function hasAll(properties, op) {
  var keys = (0, _keys2.default)(properties);
  for (var i = 0; i < keys.length; i++) {
    if (op[keys[i]] !== properties[keys[i]]) return false;
  }
  return true;
}

function matchInside(node, queryObj) {
  var properties = queryObj.properties,
      property = queryObj.property,
      operator = queryObj.operator,
      operatorIndex = queryObj.operatorIndex;


  if (queryObj.evalPlug) {
    return property ? [node.id, 'eval', queryObj.evalPlug, property] : [node.id, 'eval', queryObj.evalPlug];
  }

  if (!queryObj.plug) {
    if (property === 'name' || property === 'type') {
      return [node.id, property];
    }

    return node.id;
  }

  var plug = node.plugs[queryObj.plug];
  if (!plug) return null;

  if (!properties && !property && !operator && operatorIndex === undefined) {
    return node.id; // No operator query provided.
  }

  var idx = queryObj.operatorIndex !== undefined ? queryObj.operatorIndex : plug.findIndex(function (op) {
    return (property && property !== 'active' ? op.hasOwnProperty(property) : true) && (properties ? hasAll(properties, op) : true);
  });

  if (idx === -1) return null;
  return property ? [node.id, queryObj.plug, idx, property] : [node.id, queryObj.plug, idx];
}

function matchChildren(store, node, queryObj, parentNodeToMatch, onlyNode) {
  var results = [];
  var sceneGraph = store.get('sceneGraph');

  var parentMatch = parentNodeToMatch && getMatch(parentNodeToMatch, queryObj, onlyNode);
  if (parentMatch) results.push(parentMatch);

  (node.children || []).forEach(function (childId) {
    var childNode = sceneGraph.nodes[childId];
    if (!childNode) throw new Error('Invalid child for \'' + node.get('name') + '\' - ' + childId);

    var match = getMatch(childNode, queryObj, onlyNode);
    if (match) results.push(match);
    if (!queryObj.shallow && !(queryObj.skipModels && childNode.type === 'Model')) {
      results = results.concat(matchChildren(store, childNode, queryObj, null, onlyNode));
    }
  });

  return results;
}

function findChild(store, node, queryObj, parentNodeToMatch, onlyNode) {
  var result = void 0;
  if (parentNodeToMatch) {
    result = getMatch(parentNodeToMatch, queryObj, onlyNode);
    if (result) return result;
  }

  var sceneGraph = store.get('sceneGraph');
  var query = (0, _assign2.default)({}, queryObj);
  if (query.names) {
    query.name = query.names[0];
    query.names = query.names.slice(1);
  }

  var match = (node.children || []).find(function (childId) {
    var childNode = sceneGraph.nodes[childId];
    result = getMatch(childNode, query, onlyNode || query.names && query.names.length);
    if (query.names) {
      // heirarchical search by name
      if (!result || !query.names.length) return !!result;
      result = findChild(store, childNode, query, null, onlyNode);
      if (result) return true;
    } else {
      if (result) return true;
      result = !query.shallow && findChild(store, childNode, query, null, onlyNode);
      if (result) return true;
    }
  });
  return match ? result : null;
}

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Utilties for working with arrays of indices that are broadly useful and not
 * tailored towards a specific purpose.
 *
 * @namespace
 */
var IndexMappings = {
  /**
   * Create or populate an array with elements equal to their indices.
   *
   * @param {!number} n
   * @param {ArrayOrType=} arrayOrType defaults to Uint32Array
   * @return {!Array<!number>}
   */
  identity: function identity(n, arrayOrType) {
    var result = _Arrays2.default.maybeCreate(arrayOrType || Uint32Array, n);
    for (var i = 0; i !== n; ++i) {
      result[i] = i;
    }return result;
  },

  /**
   * Get an identity map as a view onto a globally shared buffer which
   * must not be changed.
   *
   * @param {!number} n
   * @return {!Uint32Array}
   */
  identityForReading: function identityForReading(n) {
    var proto = IndexMappings._identityProto;

    if (n > proto.length) {
      proto = IndexMappings.identity(n * 5 / 4 | 0);
      IndexMappings._identityProto = proto;
    }

    return proto.subarray(0, n);
  },

  _identityProto: _Arrays2.default.Empty.Uint32Array,

  /**
   * Create an array where each index corresponds to the values and the
   * values map back to the index of the source array.
   *
   * For non-surjective mappings, the missing indices are not written to.
   * For non-injective mappings, duplicate indices will map to their last
   * position of occurence in the input.
   *
   * @param {!Array<!number>} source integer indices
   * @param {number} n
   *    maximum entry in source map + 1
   *    can be {@code null} when an existing array is given
   * @param {ArrayOrType=} arrayOrType defaults to Uint32Array
   * @return {!Array<!number>}
   */
  inverse: function inverse(source, n, arrayOrType) {
    var result = _Arrays2.default.maybeCreate(arrayOrType || Uint32Array, n);

    for (var i = 0, e = source.length; i !== e; ++i) {
      result[source[i]] = i;
    }return result;
  },

  /**
   * Transform one mapping with another, in-place unless an explicit
   * destination is given.
   *
   * @param {!Array<!number>} map indices to transform
   * @param {!Array<!number>} transform mapping to apply
   * @param {Array<!number>=} optionalDestination
   * @return {!Array<!number>} same as {@code map}
   */
  apply: function apply(map, transform, optionalDestination) {
    var dst = optionalDestination || map;

    for (var i = 0, n = map.length; i !== n; ++i) {
      dst[i] = transform[map[i]];
    }return map;
  },

  /**
   * Count the equal elements.
   *
   * When an existing array is used for the destination, it must be
   * filled with zeroes.
   *
   * @param {!Array<!number>} source integer indices
   * @param {!number} n maximum entry in source map + 1
   * @param {ArrayOrType=} arrayOrType defaults to Uint32Array
   * @return {!Array<!number>}
   */
  histogram: function histogram(source, n, arrayOrType) {
    var result = _Arrays2.default.maybeCreate(arrayOrType || Uint32Array, n);

    for (var i = 0, e = source.length; i !== e; ++i) {
      ++result[source[i]];
    }return result;
  }
};
exports.default = IndexMappings;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Lathe;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _cleanPolyMesh = __webpack_require__(102);

var _cleanPolyMesh2 = _interopRequireDefault(_cleanPolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Lathe(srcPositions, srcNormals, segments, phiStart, phiLength) {
  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;

  //assumes one normal per point
  var newPositions = new _ObjectArrayView2.default(_three.Vector3, (segments + 1) * srcPositions.length);
  var newNormals = new _ObjectArrayView2.default(_three.Vector3, (segments + 1) * srcNormals.length);
  var uvValues = new _ObjectArrayView2.default(_three.Vector2, (segments + 1) * srcPositions.length);
  var faceValueIndices = new Uint32Array(segments * (srcPositions.length - 1) * 4); //number of faces*4
  var faceRangeOffsets = new Uint32Array(segments * (srcPositions.length - 1) + 1); //number of faces

  var inversePointLength = 1.0 / (srcPositions.length - 1);
  var inverseSegments = 1.0 / segments;

  faceRangeOffsets[0] = 0;
  var faceCounter = 1;

  var tempUV = new _three.Vector2();
  var vertex = new _three.Vector3();
  var normal = new _three.Vector3();

  var rotationMatrix4 = new _three.Matrix4();
  var normalMatrix3 = new _three.Matrix3();

  var valuesCounter = 0;
  for (var i = 0, il = segments; i <= il; i++) {
    var phi = phiStart + i * inverseSegments * phiLength;
    rotationMatrix4.makeRotationY(phi);
    normalMatrix3.getNormalMatrix(rotationMatrix4);

    var u = i * inverseSegments;

    for (var j = 0, jl = srcPositions.length; j < jl; j++) {
      srcPositions.getAt(j, vertex);
      srcNormals.getAt(j, normal);

      vertex.applyMatrix4(rotationMatrix4);
      normal.applyMatrix3(normalMatrix3);

      newPositions.setAt(valuesCounter, vertex);
      newNormals.setAt(valuesCounter, normal);

      var v = j * inversePointLength;

      tempUV.set(u, v);
      uvValues.setAt(valuesCounter++, tempUV);
    }
  }

  var positionsLen = srcPositions.length;
  var indCounter = 0;
  for (var _i = 0, _il = segments; _i < _il; _i++) {
    for (var _j = 0, _jl = srcPositions.length - 1; _j < _jl; _j++) {
      var base = _j + positionsLen * _i;
      var a = base;
      var b = base + positionsLen;
      var c = base + 1 + positionsLen;
      var d = base + 1;

      faceValueIndices[indCounter++] = a;
      faceValueIndices[indCounter++] = b;
      faceValueIndices[indCounter++] = c;
      faceValueIndices[indCounter++] = d;
      faceRangeOffsets[faceCounter++] = indCounter;
    }
  }

  var positionsMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: newPositions
  });

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: newNormals
  });

  var uvMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: uvValues
  });

  var uvMapsByName = new _ObjectsByName2.default();
  var name = 'default';
  uvMapsByName.set(name, uvMap);

  var polyMesh = new _PolyMesh2.default();
  polyMesh.faceRangeOffsets = positionsMap.faceRangeOffsets;
  polyMesh.positions = positionsMap;
  polyMesh.normalMap = normalMap;
  polyMesh.uvMaps = uvMapsByName;

  return (0, _cleanPolyMesh2.default)(new _PolyMesh2.default(polyMesh));
  //return new PolyMesh( new PolyMesh( polyMesh ) );
}

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resizeCamera = resizeCamera;
exports.updateLookatTarget = updateLookatTarget;
exports.initCamera = initCamera;
exports.initCameraRadiusConstraint = initCameraRadiusConstraint;
exports.frameSphere = frameSphere;

var _three = __webpack_require__(0);

var _scene = __webpack_require__(7);

var _getTargetWorldMatrix = __webpack_require__(59);

var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

var _updateCameraLookAtTarget = __webpack_require__(71);

var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

var _player = __webpack_require__(8);

var _sceneGraph = __webpack_require__(10);

var _clamp = __webpack_require__(164);

var _clamp2 = _interopRequireDefault(_clamp);

var _decompose = __webpack_require__(51);

var _decompose2 = _interopRequireDefault(_decompose);

var _setMatrixOnNode = __webpack_require__(127);

var _setMatrixOnNode2 = _interopRequireDefault(_setMatrixOnNode);

var _getOrbitAttrs = __webpack_require__(104);

var _orbit = __webpack_require__(248);

var _zoom = __webpack_require__(251);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var degToRad = _three.Math.degToRad,
    radToDeg = _three.Math.radToDeg;
var tan = Math.tan,
    cos = Math.cos,
    atan = Math.atan,
    acos = Math.acos,
    min = Math.min,
    max = Math.max,
    pow = Math.pow,
    PI = Math.PI,
    sqrt = Math.sqrt;

// Temporary variables for intermediate calculations

var t_cameraPosition = new _three.Vector3();
var t_oldTargetPosition = new _three.Vector3();
var t_targetPosition = new _three.Vector3();
var t_sphericalCamera = new _three.Spherical();
var t_sphericalTarget = new _three.Spherical();
var t_invTargetWorldMatrix = new _three.Matrix4();
var t_invPivotMatrix = new _three.Matrix4();
var t_changeQuaternion = new _three.Quaternion();

function resizeCamera(store, cameraId, rect) {
  var aspectRatio = rect.x / rect.y;
  store.dispatch((0, _player.setRect)(rect));
  var name = (0, _sceneGraph.get)(store, [cameraId, 'name']);
  if (name) store.dispatch((0, _scene.set)({ id: cameraId, plug: 'Camera', property: 'aspectRatio' }, aspectRatio));
}

function updateLookatTarget(store, cameraId, transformData, cameraData) {
  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
  var pivotMatrix = (0, _scene.getWorldTransform)(store, _sceneGraph.virtualPivotId);

  if ((0, _getOrbitAttrs.getOrbitMode)(store, cameraId) === 'trackball') {
    t_cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
    t_oldTargetPosition.set(0, 0, -1).transformDirection(cameraWorldMatrix);
    t_targetPosition.setFromMatrixPosition(targetWorldMatrix).sub(t_cameraPosition).normalize();

    t_changeQuaternion.setFromUnitVectors(t_targetPosition, t_oldTargetPosition);
    cameraData.upPosition.applyQuaternion(t_changeQuaternion);
  }

  t_targetPosition.setFromMatrixPosition(targetWorldMatrix);

  pivotMatrix.setPosition(t_targetPosition.sub(cameraData.offset));
  (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualPivotId, pivotMatrix);

  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
  return cameraWorldMatrix;
}

function initCamera(store, dispatch, fromCameraId, toCameraId, fromRect) {
  var toId = toCameraId || _sceneGraph.virtualCameraId;
  var fromId = fromCameraId || _sceneGraph.virtualCameraId;
  var boundingBox = (0, _player.getBoundingBox)(store);
  var rect = fromRect || (0, _player.getRect)(store);
  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, fromId);
  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, fromId);
  var pivotMatrix = (0, _scene.getWorldTransform)(store, _sceneGraph.virtualPivotId);
  var cameraPosition = new _three.Vector3().setFromMatrixPosition(cameraWorldMatrix);
  var targetPosition = new _three.Vector3().setFromMatrixPosition(targetWorldMatrix);

  resizeCamera(store, toId, rect);

  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });

  var fromCameraData = (0, _scene.get)(store, { id: fromId, evalPlug: 'Camera' });
  var fromCameraTransform = (0, _scene.get)(store, { id: fromId, evalPlug: 'Transform' });
  var fromCameraProperties = (0, _scene.get)(store, {
    id: fromId,
    evalPlug: 'Properties'
  });

  var toCameraData = fromId === toId ? fromCameraData : (0, _scene.get)(store, { id: toId, evalPlug: 'Camera' });

  var orbitMode = (0, _getOrbitAttrs.getOrbitMode)(store, fromId);
  var constraintCameraY = (0, _getOrbitAttrs.getConstrainCameraY)(store, fromId);

  //realign camera to inital direction
  var hasNoTarget = !fromCameraTransform.target;
  var isNotVirtualCamera = fromId !== _sceneGraph.virtualCameraId;
  var camAttrs = (0, _player.getCameraAttrs)(store).toJS();
  var hasNoPolar = camAttrs.azimuthAngle == null && camAttrs.polarAngle == null;

  if (hasNoTarget && isNotVirtualCamera && hasNoPolar) {
    var ray = new _three.Ray(new _three.Vector3(0, 0, 0), new _three.Vector3(0, 0, -1)).applyMatrix4(cameraWorldMatrix);
    targetPosition = ray.closestPointToPoint(targetPosition);
    if (targetPosition.equals(cameraPosition)) targetPosition.addScaledVector(ray.direction, 0.01);
    targetWorldMatrix.setPosition(targetPosition);
    (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualTargetId, targetWorldMatrix);
  } else if (!hasNoTarget) {
    (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualPivotId, targetWorldMatrix);
  }

  //const pivotMatrix = targetWorldMatrix.clone();
  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);

  var upPosition = new _three.Vector3(0, 1, 0);
  if (orbitMode === 'trackball') {
    upPosition.transformDirection(cameraWorldMatrix);

    var normal = new _three.Vector3().subVectors(cameraPosition, targetWorldMatrix).normalize();
    var cameraViewPlane = new _three.Plane(normal, 0);

    upPosition.copy(cameraViewPlane.projectPoint(upPosition).normalize());
  }

  var pivotPosition = new _three.Vector3().setFromMatrixPosition(pivotMatrix);
  cameraPosition.sub(targetPosition);

  var pivY = targetWorldMatrix.elements[13];
  if (pivY + cameraPosition.length() < 0 && constraintCameraY) {
    cameraPosition.normalize().multiplyScalar(pivY);
  }

  cameraWorldMatrix.setPosition(cameraPosition.add(targetPosition));

  toCameraData.upPosition = upPosition;
  //toCameraData.pivotMatrix = pivotMatrix;
  toCameraData.offset = new _three.Vector3(0, 0, 0);

  adjustAngleAndRadius(store, fromId, cameraWorldMatrix, targetWorldMatrix, fromCameraData, boundingBox);

  if (constraintCameraY) (0, _orbit.updateSphericalRotation)(store, toId, cameraWorldMatrix, targetWorldMatrix, new _three.Vector2(0, 0));

  var embedMaxZoom = (0, _player.getCameraAttrs)(store).get('maxZoom');
  var hasZoomConstraint = fromCameraProperties.constrainCameraSphere || embedMaxZoom;
  if (hasZoomConstraint) {
    var maxZoom = fromCameraProperties.constrainCameraSphere ? fromCameraProperties.maxZoom : embedMaxZoom;
    initCameraRadiusConstraint(store, toId, toCameraData, maxZoom, cameraWorldMatrix, targetWorldMatrix);
  } else {
    toCameraData.radiusConstraint = null;
  }
  var newNear = void 0,
      newFar = void 0;
  //set the near far plane for default camera.
  if (!isNotVirtualCamera) {
    var minBoundingSphere = new _three.Sphere();
    boundingBox.getBoundingSphere(minBoundingSphere);
    newNear = Math.min((t_sphericalCamera.radius - minBoundingSphere.radius) * 0.25, 0.1);
    newFar = Math.max((t_sphericalCamera.radius - minBoundingSphere.radius) * 10, 50000);
  }
  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, upPosition);
  if (dispatch) (0, _setMatrixOnNode2.default)(store, toId, cameraWorldMatrix);
  return {
    camera: cameraWorldMatrix,
    target: targetWorldMatrix,
    upPosition: upPosition,
    newNear: newNear,
    newFar: newFar
  };
}

function initCameraRadiusConstraint(store, cameraId, cameraData, outerRadius, initCameraWorldMatrix, initTargetWorldMatrix) {
  var boundingBox = (0, _player.getBoundingBox)(store);
  var minBoundingSphere = new _three.Sphere();
  var cameraWorldMatrix = initCameraWorldMatrix || (0, _scene.getWorldTransform)(store, cameraId);
  var targetWorldMatrix = initTargetWorldMatrix || (0, _getTargetWorldMatrix2.default)(store, cameraId);
  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });

  boundingBox.getBoundingSphere(minBoundingSphere);
  if (outerRadius <= 1) {
    return;
  }

  var maxBoundingSphere = new _three.Sphere(minBoundingSphere.center, minBoundingSphere.radius * outerRadius);

  t_targetPosition.setFromMatrixPosition(targetWorldMatrix);
  t_cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
  var targetToCamera = new _three.Vector3().subVectors(t_cameraPosition, t_targetPosition);

  var thirdVector = new _three.Vector3().crossVectors(targetToCamera, cameraData.upPosition).normalize();
  var newTargetPosition = minBoundingSphere.clampPoint(t_targetPosition);
  var newCameraPosition = maxBoundingSphere.clampPoint(t_cameraPosition);
  cameraWorldMatrix.setPosition(newCameraPosition);
  targetWorldMatrix.setPosition(newTargetPosition);

  if ((0, _getOrbitAttrs.getOrbitMode)(store, cameraId) === 'trackball') {
    var newTargetToCamera = new _three.Vector3().subVectors(newCameraPosition, newTargetPosition);
    cameraData.upPosition.crossVectors(thirdVector, newTargetToCamera).normalize();
  }

  cameraData.radiusConstraint = {
    outerRadius: outerRadius,
    maxBoundingSphere: maxBoundingSphere,
    minBoundingSphere: minBoundingSphere
  };
  cameraData.newRadiusConstraint = null;
  (0, _zoom.updateZoom)(store, 0, cameraId, cameraWorldMatrix);

  if (!initCameraWorldMatrix) (0, _setMatrixOnNode2.default)(store, cameraId, cameraWorldMatrix);
}

/*
 * Set the camera angle and radius.
 */
function adjustAngleAndRadius(store, cameraId, cameraWorldMatrix, targetWorldMatrix, cameraData, boundingBox) {
  var _getCameraAttrs$toJS = (0, _player.getCameraAttrs)(store).toJS(),
      azimuthAngle = _getCameraAttrs$toJS.azimuthAngle,
      polarAngle = _getCameraAttrs$toJS.polarAngle,
      boundingRadius = _getCameraAttrs$toJS.boundingRadius;

  var initialMinPolarAngle = 0;
  var initialMaxPolarAngle = PI;
  var minPolarAngle = 0;
  var maxPolarAngle = PI;

  if (cameraId === _sceneGraph.virtualCameraId) {
    // Use defaults for the virtual camera only
    if (azimuthAngle == null) azimuthAngle = 45;
    if (polarAngle == null) polarAngle = 20;
    if (boundingRadius == null) boundingRadius = 1;
  }

  if (azimuthAngle == null && polarAngle == null) {
    return;
  }

  t_invTargetWorldMatrix.getInverse(targetWorldMatrix, true);
  // world to relative
  t_cameraPosition.setFromMatrixPosition(cameraWorldMatrix).applyMatrix4(t_invTargetWorldMatrix);

  t_sphericalCamera.setFromVector3(t_cameraPosition);
  t_sphericalCamera.theta = degToRad(azimuthAngle);
  t_sphericalCamera.phi = degToRad(90 - polarAngle);

  minPolarAngle = max(minPolarAngle || 0, initialMinPolarAngle); // radians
  maxPolarAngle = min(maxPolarAngle || PI, initialMaxPolarAngle); // radians

  t_sphericalCamera.phi = (0, _clamp2.default)(t_sphericalCamera.phi, minPolarAngle, maxPolarAngle);

  if (boundingRadius != null) {
    var fixRadius = boundingRadius * boundingBox.getBoundingSphere().radius;
    t_sphericalCamera.radius = (fixRadius <= 0 ? 1 : fixRadius) / tan(degToRad(cameraData.fieldOfView * 0.5));
    t_sphericalCamera.radius = (fixRadius <= 0 || fixRadius === Infinity ? 1 : fixRadius) / tan(degToRad(cameraData.fieldOfView * 0.5));
  }

  t_sphericalCamera.makeSafe();

  t_cameraPosition.setFromSpherical(t_sphericalCamera);
  t_sphericalCamera.setFromVector3(t_cameraPosition);

  // relative to world
  t_cameraPosition.applyMatrix4(targetWorldMatrix);
  cameraWorldMatrix.setPosition(t_cameraPosition);
}

function frameSphere(store, sphere) {
  var cameraId = (0, _player.getCamera)(store);
  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
  var playerData = (0, _scene.get)(store, { evalPlug: 'Player' });
  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
  var cameraPosition = new _three.Vector3();
  var cameraRotation = new _three.Quaternion();
  var targetPosition = new _three.Vector3();
  var scale = new _three.Vector3();

  cameraWorldMatrix.decompose(cameraPosition, cameraRotation, scale);
  targetPosition.setFromMatrixPosition(targetWorldMatrix);
  cameraData.offset.add(sphere.center).sub(targetPosition);
  targetWorldMatrix.setPosition(sphere.center);

  if (cameraData.projection === 'Perspective') {
    var angle = cameraData.aspectRatio >= 1 ? Math.PI * cameraData.fieldOfView / 360 : Math.atan(cameraData.aspectRatio * Math.tan(Math.PI * cameraData.fieldOfView / 360));
    var distance = sphere.radius / Math.sin(angle);
    cameraPosition.sub(sphere.center);
    cameraPosition.normalize().multiplyScalar(distance).add(sphere.center);
  } else {
    var halfHeight = cameraData.orthoHeight / 2;
    var smallestHalfSide = halfHeight * Math.min(cameraData.aspectRatio, 1);
    var zoom = sphere.radius / smallestHalfSide;
    store.dispatch((0, _scene.set)({ id: cameraId, plug: 'Camera', property: 'orthoZoom' }, zoom));
  }

  if ((0, _getOrbitAttrs.getOrbitMode)(store, cameraId) === 'trackball') {
    var fromVector = new _three.Vector3(0, 0, -1).applyQuaternion(cameraRotation).normalize();
    var toVector = new _three.Vector3().subVectors(sphere.center, cameraPosition).normalize();
    var changeQuaternion = new _three.Quaternion().setFromUnitVectors(fromVector, toVector);
    cameraData.upPosition.applyQuaternion(changeQuaternion);
  }

  cameraWorldMatrix.compose(cameraPosition, cameraRotation, scale);
  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);

  store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
  store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
}

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setMatrixOnNode;

var _sceneGraph = __webpack_require__(10);

var _decompose = __webpack_require__(51);

var _decompose2 = _interopRequireDefault(_decompose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function setMatrixOnNode(store, nodeId, matrix4) {
  store.dispatch((0, _sceneGraph.merge)([nodeId, 'Transform', 0], (0, _decompose2.default)(matrix4)));
}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ActionTypes = undefined;

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _setImmediate2 = __webpack_require__(502);

var _setImmediate3 = _interopRequireDefault(_setImmediate2);

exports.default = createStore;

var _isPlainObject = __webpack_require__(256);

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _transitImmutable = __webpack_require__(495);

var _rsvp = __webpack_require__(204);

var _rsvp2 = _interopRequireDefault(_rsvp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var raf = void 0,
    rafContext = void 0;

function setRequestAnimationFrame(newRequestAnimationFrame, context) {
  if (newRequestAnimationFrame) {
    raf = newRequestAnimationFrame;
    rafContext = context;
  } else {
    raf =  true ? requestAnimationFrame : _setImmediate3.default;
    rafContext =  true ? window : this;
  }
}

setRequestAnimationFrame();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = exports.ActionTypes = {
  INIT: '@@redux/INIT'
};

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [initialState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, initialState) {
  var _store;

  var currentReducer = reducer;
  var currentState = initialState;
  var listeners = [];
  var events = [];
  var isDispatching = false;
  var records = [];
  var rollbar = false;
  var currentTranslator = null;
  var currentNavigator = null;
  var apiFunction = null;
  var socket = null;

  function createEvent(type) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    events.push({ type: type, args: args });
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  function getIn(path) {
    return currentState.getIn(path);
  }

  function get(key) {
    return currentState.get(key);
  }

  function getTranslator() {
    return currentTranslator;
  }

  function getEvaluatedTranslator() {
    if (currentTranslator) currentTranslator.update();
    return currentTranslator;
  }

  function setTranslator(translator, store) {
    currentTranslator = typeof translator === 'function' ? translator(store) : translator;
  }

  function setApi(api) {
    apiFunction = api;
  }

  function hasApi() {
    return !!apiFunction;
  }

  function callApi() {
    if (!apiFunction) throw new Error('No api function defined');

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return apiFunction.apply(undefined, [this].concat(args));
  }

  function setSocketApi(sock) {
    socket = sock;
  }

  function getSocketApi() {
    return socket;
  }

  function logPageView(path, loadTime) {
    if (false) return;

    if (window && window['ga']) {
      ga('playerv2.send', 'pageview', '' + encodeURI(path));
    }
  }

  function trackEvent(action, label, value) {
    if (false) return;

    if (window && window['ga']) {
      ga('playerv2.send', 'event', 'v2player', action, label, value);
    }
  }

  function read(transitString) {
    return (0, _transitImmutable.fromJSON)(transitString);
  }

  function write(data) {
    return (0, _transitImmutable.toJSON)(data); //sceneGraph: Map(), files: Map()});
  }

  function useRollbar(rb) {
    rollbar = rb;
  }

  function error(err, label) {
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (label) console.error(label);
    if (rollbar) {
      rollbar.error(err, data);
      if (err.message) {
        console.error(err.message);
        if (err.stack) console.log(err.stack);
      } else {
        console.error(err);
      }
    } else {
      console.error(err);
    }
  }

  _rsvp2.default.on('error', error);

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    listeners.push(listener);
    var isSubscribed = true;

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;
      var index = listeners.indexOf(listener);
      listeners.splice(index, 1);
    };
  }

  // Custom debounce function, lodash.debounce is bigger and slower.
  function batchNotify() {
    var notifying = false;
    var requestNotify = false;

    function notify() {
      if (notifying) {
        requestNotify = true;
      } else {
        notifying = true;
        requestNotify = false;

        raf.call(rafContext, function () {
          // Actual notify code
          try {
            var evs = events.splice(0, events.length);
            listeners.slice().forEach(function (listener) {
              return listener(evs, requestNotify);
            });
          } catch (e) {
            error(e);
          }

          notifying = false;
          if (requestNotify) {
            notify();
          }
        });
      }
    }

    return notify;
  }

  var notifyListenersBatched = batchNotify();

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0, _isPlainObject2.default)(action)) {
      console.log('Invalid action', action);
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      console.error('Invalid action: ', action);
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action, createEvent, trackEvent);
    } catch (e) {
      error(e);
    } finally {
      isDispatching = false;
    }

    notifyListenersBatched();
    // listeners.slice().forEach(listener => listener())

    return _rsvp2.default.Promise.resolve(action.resolve ? action.resolve : action.payload);
  }

  var createCanvas = function createCanvas(width, height) {
    var domCanvas = document.createElement('Canvas');
    domCanvas.width = width;
    domCanvas.height = height;
    return domCanvas;
  };

  function setCreateCanvas(fn) {
    this.createCanvas = fn;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  var store = (_store = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    getIn: getIn,
    get: get,
    replaceReducer: replaceReducer,
    setTranslator: setTranslator,
    getTranslator: getTranslator,
    getEvaluatedTranslator: getEvaluatedTranslator,
    read: read,
    write: write,
    useRollbar: useRollbar,
    error: error,
    setApi: setApi,
    hasApi: hasApi,
    callApi: callApi,
    createEvent: createEvent,
    setRequestAnimationFrame: setRequestAnimationFrame,
    logPageView: logPageView,
    setSocketApi: setSocketApi,
    getSocketApi: getSocketApi,
    createCanvas: createCanvas,
    setCreateCanvas: setCreateCanvas
  }, (0, _defineProperty3.default)(_store, 'createEvent', createEvent), (0, _defineProperty3.default)(_store, 'trackEvent', trackEvent), _store);

  return store;
}

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(522), __esModule: true };

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(527), __esModule: true };

/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(108);
var TAG = __webpack_require__(25)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(44);
var dPs = __webpack_require__(271);
var enumBugKeys = __webpack_require__(170);
var IE_PROTO = __webpack_require__(176)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(169)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(263).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(62);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(179);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 137 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(27);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 139 */
/***/ (function(module, exports) {



/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(13);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(64);
var redefineAll = __webpack_require__(92);
var meta = __webpack_require__(114);
var forOf = __webpack_require__(142);
var anInstance = __webpack_require__(87);
var isObject = __webpack_require__(14);
var fails = __webpack_require__(21);
var $iterDetect = __webpack_require__(143);
var setToStringTag = __webpack_require__(93);
var inheritIfRequired = __webpack_require__(590);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(42);
var redefine = __webpack_require__(64);
var fails = __webpack_require__(21);
var defined = __webpack_require__(74);
var wks = __webpack_require__(16);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(52);
var call = __webpack_require__(290);
var isArrayIter = __webpack_require__(192);
var anObject = __webpack_require__(12);
var toLength = __webpack_require__(30);
var getIterFn = __webpack_require__(202);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(16)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 144 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(13);
var dP = __webpack_require__(26);
var DESCRIPTORS = __webpack_require__(35);
var SPECIES = __webpack_require__(16)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 146 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(129);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(497);

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _defineProperty = __webpack_require__(129);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _glyph = __webpack_require__(209);

var _glyph2 = _interopRequireDefault(_glyph);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Define a property on the glyph that depends on the path being loaded.
function defineDependentProperty(glyph, externalName, internalName) {
    (0, _defineProperty2.default)(glyph, externalName, {
        get: function get() {
            // Request the path property to make sure the path is loaded.
            glyph.path; // jshint ignore:line
            return glyph[internalName];
        },
        set: function set(newValue) {
            glyph[internalName] = newValue;
        },
        enumerable: true,
        configurable: true
    });
}

/**
 * A GlyphSet represents all glyphs available in the font, but modelled using
 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
 * necessary, to keep the memory footprint down.
 * @exports opentype.GlyphSet
 * @class
 * @param {opentype.Font}
 * @param {Array}
 */
// The GlyphSet object

function GlyphSet(font, glyphs) {
    this.font = font;
    this.glyphs = {};
    if (Array.isArray(glyphs)) {
        for (var i = 0; i < glyphs.length; i++) {
            this.glyphs[i] = glyphs[i];
        }
    }

    this.length = glyphs && glyphs.length || 0;
}

/**
 * @param  {number} index
 * @return {opentype.Glyph}
 */
GlyphSet.prototype.get = function (index) {
    if (typeof this.glyphs[index] === 'function') {
        this.glyphs[index] = this.glyphs[index]();
    }

    return this.glyphs[index];
};

/**
 * @param  {number} index
 * @param  {Object}
 */
GlyphSet.prototype.push = function (index, loader) {
    this.glyphs[index] = loader;
    this.length++;
};

/**
 * @alias opentype.glyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @return {opentype.Glyph}
 */
function glyphLoader(font, index) {
    return new _glyph2.default({ index: index, font: font });
}

/**
 * Generate a stub glyph that can be filled with all metadata *except*
 * the "points" and "path" properties, which must be loaded only once
 * the glyph's path is actually requested for text shaping.
 * @alias opentype.ttfGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseGlyph
 * @param  {Object} data
 * @param  {number} position
 * @param  {Function} buildPath
 * @return {opentype.Glyph}
 */
function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
    return function () {
        var glyph = new _glyph2.default({ index: index, font: font });

        glyph.path = function () {
            parseGlyph(glyph, data, position);
            var path = buildPath(font.glyphs, glyph);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };

        defineDependentProperty(glyph, 'xMin', '_xMin');
        defineDependentProperty(glyph, 'xMax', '_xMax');
        defineDependentProperty(glyph, 'yMin', '_yMin');
        defineDependentProperty(glyph, 'yMax', '_yMax');

        return glyph;
    };
}
/**
 * @alias opentype.cffGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseCFFCharstring
 * @param  {string} charstring
 * @return {opentype.Glyph}
 */
function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
    return function () {
        var glyph = new _glyph2.default({ index: index, font: font });

        glyph.path = function () {
            var path = parseCFFCharstring(font, glyph, charstring);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };

        return glyph;
    };
}

exports.default = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sizeOf = exports.encode = exports.decode = undefined;

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _weakMap = __webpack_require__(505);

var _weakMap2 = _interopRequireDefault(_weakMap);

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)

var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

/**
 * @exports opentype.decode
 * @class
 */
var decode = {};
/**
 * @exports opentype.encode
 * @class
 */
var encode = {};
/**
 * @exports opentype.sizeOf
 * @class
 */
var sizeOf = {};

// Return a function that always returns the same value.
function constant(v) {
    return function () {
        return v;
    };
}

// OpenType data types //////////////////////////////////////////////////////

/**
 * Convert an 8-bit unsigned integer to a list of 1 byte.
 * @param {number}
 * @returns {Array}
 */
encode.BYTE = function (v) {
    _check2.default.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};
/**
 * @constant
 * @type {number}
 */
sizeOf.BYTE = constant(1);

/**
 * Convert a 8-bit signed integer to a list of 1 byte.
 * @param {string}
 * @returns {Array}
 */
encode.CHAR = function (v) {
    return [v.charCodeAt(0)];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.CHAR = constant(1);

/**
 * Convert an ASCII string to a list of bytes.
 * @param {string}
 * @returns {Array}
 */
encode.CHARARRAY = function (v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b[i] = v.charCodeAt(i);
    }

    return b;
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.CHARARRAY = function (v) {
    return v.length;
};

/**
 * Convert a 16-bit unsigned integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.USHORT = function (v) {
    return [v >> 8 & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.USHORT = constant(2);

/**
 * Convert a 16-bit signed integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.SHORT = function (v) {
    // Two's complement
    if (v >= LIMIT16) {
        v = -(2 * LIMIT16 - v);
    }

    return [v >> 8 & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.SHORT = constant(2);

/**
 * Convert a 24-bit unsigned integer to a list of 3 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.UINT24 = function (v) {
    return [v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.UINT24 = constant(3);

/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.ULONG = function (v) {
    return [v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.ULONG = constant(4);

/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.LONG = function (v) {
    // Two's complement
    if (v >= LIMIT32) {
        v = -(2 * LIMIT32 - v);
    }

    return [v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.LONG = constant(4);

encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;

encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;

encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;

/**
 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
 * @param {number}
 * @returns {Array}
 */
encode.LONGDATETIME = function (v) {
    return [0, 0, 0, 0, v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.LONGDATETIME = constant(8);

/**
 * Convert a 4-char tag to a list of 4 bytes.
 * @param {string}
 * @returns {Array}
 */
encode.TAG = function (v) {
    _check2.default.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0), v.charCodeAt(1), v.charCodeAt(2), v.charCodeAt(3)];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.TAG = constant(4);

// CFF data types ///////////////////////////////////////////////////////////

encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;

encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;

encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;

encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;

// Convert a numeric operand or charstring number to a variable-size list of bytes.
/**
 * Convert a numeric operand or charstring number to a variable-size list of bytes.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER = function (v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
    } else {
        return encode.NUMBER32(v);
    }
};

/**
 * @param {number}
 * @returns {number}
 */
sizeOf.NUMBER = function (v) {
    return encode.NUMBER(v).length;
};

/**
 * Convert a signed number between -32768 and +32767 to a three-byte value.
 * This ensures we always use three bytes, but is not the most compact format.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER16 = function (v) {
    return [28, v >> 8 & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.NUMBER16 = constant(3);

/**
 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
 * This is useful if you want to be sure you always use four bytes,
 * at the expense of wasting a few bytes for smaller numbers.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER32 = function (v) {
    return [29, v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.NUMBER32 = constant(5);

/**
 * @param {number}
 * @returns {Array}
 */
encode.REAL = function (v) {
    var value = v.toString();

    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
    // This code converts it back to a number without the epsilon.
    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
    if (m) {
        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(v * epsilon) / epsilon).toString();
    }

    var nibbles = '';
    for (var i = 0, ii = value.length; i < ii; i += 1) {
        var c = value[i];
        if (c === 'e') {
            nibbles += value[++i] === '-' ? 'c' : 'b';
        } else if (c === '.') {
            nibbles += 'a';
        } else if (c === '-') {
            nibbles += 'e';
        } else {
            nibbles += c;
        }
    }

    nibbles += nibbles.length & 1 ? 'f' : 'ff';
    var out = [30];
    for (var _i = 0, _ii = nibbles.length; _i < _ii; _i += 2) {
        out.push(parseInt(nibbles.substr(_i, 2), 16));
    }

    return out;
};

/**
 * @param {number}
 * @returns {number}
 */
sizeOf.REAL = function (v) {
    return encode.REAL(v).length;
};

encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;

encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;

/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */
decode.UTF8 = function (data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes;
    for (var j = 0; j < numChars; j++, offset += 1) {
        codePoints[j] = data.getUint8(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
};

/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */
decode.UTF16 = function (data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes / 2;
    for (var j = 0; j < numChars; j++, offset += 2) {
        codePoints[j] = data.getUint16(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
};

/**
 * Convert a JavaScript string to UTF16-BE.
 * @param {string}
 * @returns {Array}
 */
encode.UTF16 = function (v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        var codepoint = v.charCodeAt(i);
        b[b.length] = codepoint >> 8 & 0xFF;
        b[b.length] = codepoint & 0xFF;
    }

    return b;
};

/**
 * @param {string}
 * @returns {number}
 */
sizeOf.UTF16 = function (v) {
    return v.length * 2;
};

// Data for converting old eight-bit Macintosh encodings to Unicode.
// This representation is optimized for decoding; encoding is slower
// and needs more memory. The assumption is that all opentype.js users
// want to open fonts, but saving a font will be comparatively rare
// so it can be more expensive. Keyed by IANA character set name.
//
// Python script for generating these strings:
//
//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
//     print(s.encode('utf-8'))
/**
 * @private
 */
var eightBitMacEncodings = {
    'x-mac-croatian': // Python: 'mac_croatian'
    '' + '',
    'x-mac-cyrillic': // Python: 'mac_cyrillic'
    '' + '',
    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
    '' + '',
    'x-mac-greek': // Python: 'mac_greek'
    '' + '\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD',
    'x-mac-icelandic': // Python: 'mac_iceland'
    '' + '',
    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
    '' + '',
    'x-mac-ce': // Python: 'mac_latin2'
    '' + '',
    macintosh: // Python: 'mac_roman'
    '' + '',
    'x-mac-romanian': // Python: 'mac_romanian'
    '' + '',
    'x-mac-turkish': // Python: 'mac_turkish'
    '' + ''
};

/**
 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
 * string, or 'undefined' if the encoding is unsupported. For example, we do
 * not support Chinese, Japanese or Korean because these would need large
 * mapping tables.
 * @param {DataView} dataView
 * @param {number} offset
 * @param {number} dataLength
 * @param {string} encoding
 * @returns {string}
 */
decode.MACSTRING = function (dataView, offset, dataLength, encoding) {
    var table = eightBitMacEncodings[encoding];
    if (table === undefined) {
        return undefined;
    }

    var result = '';
    for (var i = 0; i < dataLength; i++) {
        var c = dataView.getUint8(offset + i);
        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c <= 0x7F) {
            result += String.fromCharCode(c);
        } else {
            result += table[c & 0x7F];
        }
    }

    return result;
};

// Helper function for encode.MACSTRING. Returns a dictionary for mapping
// Unicode character codes to their 8-bit MacOS equivalent. This table
// is not exactly a super cheap data structure, but we do not care because
// encoding Macintosh strings is only rarely needed in typical applications.
var macEncodingTableCache = typeof _weakMap2.default === 'function' && new _weakMap2.default();
var macEncodingCacheKeys = void 0;
var getMacEncodingTable = function getMacEncodingTable(encoding) {
    // Since we use encoding as a cache key for WeakMap, it has to be
    // a String object and not a literal. And at least on NodeJS 2.10.1,
    // WeakMap requires that the same String instance is passed for cache hits.
    if (!macEncodingCacheKeys) {
        macEncodingCacheKeys = {};
        for (var e in eightBitMacEncodings) {
            /*jshint -W053 */ // Suppress "Do not use String as a constructor."
            macEncodingCacheKeys[e] = new String(e);
        }
    }

    var cacheKey = macEncodingCacheKeys[encoding];
    if (cacheKey === undefined) {
        return undefined;
    }

    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
    // since garbage collection may run at any time, it could also kick in
    // between the calls to cache.has() and cache.get(). In that case,
    // we would return 'undefined' even though we do support the encoding.
    if (macEncodingTableCache) {
        var cachedTable = macEncodingTableCache.get(cacheKey);
        if (cachedTable !== undefined) {
            return cachedTable;
        }
    }

    var decodingTable = eightBitMacEncodings[encoding];
    if (decodingTable === undefined) {
        return undefined;
    }

    var encodingTable = {};
    for (var i = 0; i < decodingTable.length; i++) {
        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
    }

    if (macEncodingTableCache) {
        macEncodingTableCache.set(cacheKey, encodingTable);
    }

    return encodingTable;
};

/**
 * Encodes an old-style Macintosh string. Returns a byte array upon success.
 * If the requested encoding is unsupported, or if the input string contains
 * a character that cannot be expressed in the encoding, the function returns
 * 'undefined'.
 * @param {string} str
 * @param {string} encoding
 * @returns {Array}
 */
encode.MACSTRING = function (str, encoding) {
    var table = getMacEncodingTable(encoding);
    if (table === undefined) {
        return undefined;
    }

    var result = [];
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);

        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c >= 0x80) {
            c = table[c];
            if (c === undefined) {
                // str contains a Unicode character that cannot be encoded
                // in the requested encoding.
                return undefined;
            }
        }
        result[i] = c;
        // result.push(c);
    }

    return result;
};

/**
 * @param {string} str
 * @param {string} encoding
 * @returns {number}
 */
sizeOf.MACSTRING = function (str, encoding) {
    var b = encode.MACSTRING(str, encoding);
    if (b !== undefined) {
        return b.length;
    } else {
        return 0;
    }
};

// Helper for encode.VARDELTAS
function isByteEncodable(value) {
    return value >= -128 && value <= 127;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
        ++pos;
        ++runLength;
    }
    result.push(0x80 | runLength - 1);
    return pos;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsBytes(deltas, offset, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    var pos = offset;
    while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];
        if (!isByteEncodable(value)) {
            break;
        }

        // Within a byte-encoded run of deltas, a single zero is best
        // stored literally as 0x00 value. However, if we have two or
        // more zeroes in a sequence, it is better to start a new run.
        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
        // when starting a new run.
        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
            break;
        }

        ++pos;
        ++runLength;
    }
    result.push(runLength - 1);
    for (var i = offset; i < pos; ++i) {
        result.push(deltas[i] + 256 & 0xff);
    }
    return pos;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsWords(deltas, offset, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    var pos = offset;
    while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];

        // Within a word-encoded run of deltas, it is easiest to start
        // a new run (with a different encoding) whenever we encounter
        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
        // needs 7 bytes when storing the zero inside the current run
        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
        // new run (40 66 66 80 40 77 77).
        if (value === 0) {
            break;
        }

        // Within a word-encoded run of deltas, a single value in the
        // range (-128..127) should be encoded within the current run
        // because it is more compact. For example, the sequence
        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
        // a new run (40 66 66 00 02 40 77 77).
        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
            break;
        }

        ++pos;
        ++runLength;
    }
    result.push(0x40 | runLength - 1);
    for (var i = offset; i < pos; ++i) {
        var val = deltas[i];
        result.push(val + 0x10000 >> 8 & 0xff, val + 0x100 & 0xff);
    }
    return pos;
}

/**
 * Encode a list of variation adjustment deltas.
 *
 * Variation adjustment deltas are used in gvar and cvar tables.
 * They indicate how points (in gvar) or values (in cvar) get adjusted
 * when generating instances of variation fonts.
 *
 * @see https://www.microsoft.com/typography/otspec/gvar.htm
 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
 * @param {Array}
 * @return {Array}
 */
encode.VARDELTAS = function (deltas) {
    var pos = 0;
    var result = [];
    while (pos < deltas.length) {
        var value = deltas[pos];
        if (value === 0) {
            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
        } else if (value >= -128 && value <= 127) {
            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
        } else {
            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
        }
    }
    return result;
};

// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
/**
 * @param {Array} l
 * @returns {Array}
 */
encode.INDEX = function (l) {
    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
    //    i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offsets, then again to encode the offsets using the fitting data type.
    var offset = 1; // First offset is always 1.
    var offsets = [offset];
    var data = [];
    for (var i = 0; i < l.length; i += 1) {
        var v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        offset += v.length;
        offsets.push(offset);
    }

    if (data.length === 0) {
        return [0, 0];
    }

    var encodedOffsets = [];
    var offSize = 1 + Math.floor(Math.log(offset) / Math.log(2)) / 8 | 0;
    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
    for (var _i2 = 0; _i2 < offsets.length; _i2 += 1) {
        var encodedOffset = offsetEncoder(offsets[_i2]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }

    return Array.prototype.concat(encode.Card16(l.length), encode.OffSize(offSize), encodedOffsets, data);
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.INDEX = function (v) {
    return encode.INDEX(v).length;
};

/**
 * Convert an object to a CFF DICT structure.
 * The keys should be numeric.
 * The values should be objects containing name / type / value.
 * @param {Object} m
 * @returns {Array}
 */
encode.DICT = function (m) {
    var d = [];
    var keys = (0, _keys2.default)(m);
    var length = keys.length;

    for (var i = 0; i < length; i += 1) {
        // Object.keys() return string keys, but our keys are always numeric.
        var k = parseInt(keys[i], 0);
        var v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }

    return d;
};

/**
 * @param {Object}
 * @returns {number}
 */
sizeOf.DICT = function (m) {
    return encode.DICT(m).length;
};

/**
 * @param {number}
 * @returns {Array}
 */
encode.OPERATOR = function (v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};

/**
 * @param {Array} v
 * @param {string}
 * @returns {Array}
 */
encode.OPERAND = function (v, type) {
    var d = [];
    if (Array.isArray(type)) {
        for (var i = 0; i < type.length; i += 1) {
            _check2.default.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'offset') {
            // We make it easy for ourselves and always encode offsets as
            // 4 bytes. This makes offset calculation for the top dict easier.
            d = d.concat(encode.NUMBER32(v));
        } else if (type === 'number') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'real') {
            d = d.concat(encode.REAL(v));
        } else {
            throw new Error('Unknown operand type ' + type);
            // FIXME Add support for booleans
        }
    }

    return d;
};

encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;

// memoize charstring encoding using WeakMap if available
var wmm = typeof _weakMap2.default === 'function' && new _weakMap2.default();

/**
 * Convert a list of CharString operations to bytes.
 * @param {Array}
 * @returns {Array}
 */
encode.CHARSTRING = function (ops) {
    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
    if (wmm) {
        var cachedValue = wmm.get(ops);
        if (cachedValue !== undefined) {
            return cachedValue;
        }
    }

    var d = [];
    var length = ops.length;

    for (var i = 0; i < length; i += 1) {
        var op = ops[i];
        d = d.concat(encode[op.type](op.value));
    }

    if (wmm) {
        wmm.set(ops, d);
    }

    return d;
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.CHARSTRING = function (ops) {
    return encode.CHARSTRING(ops).length;
};

// Utility functions ////////////////////////////////////////////////////////

/**
 * Convert an object containing name / type / value to bytes.
 * @param {Object}
 * @returns {Array}
 */
encode.OBJECT = function (v) {
    var encodingFunction = encode[v.type];
    _check2.default.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};

/**
 * @param {Object}
 * @returns {number}
 */
sizeOf.OBJECT = function (v) {
    var sizeOfFunction = sizeOf[v.type];
    _check2.default.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
    return sizeOfFunction(v.value);
};

/**
 * Convert a table object to bytes.
 * A table contains a list of fields containing the metadata (name, type and default value).
 * The table itself has the field values set as attributes.
 * @param {opentype.Table}
 * @returns {Array}
 */
encode.TABLE = function (table) {
    var d = [];
    var length = table.fields.length;
    var subtables = [];
    var subtableOffsets = [];

    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode[field.type];
        _check2.default.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        var bytes = encodingFunction(value);

        if (field.type === 'TABLE') {
            subtableOffsets.push(d.length);
            d = d.concat([0, 0]);
            subtables.push(bytes);
        } else {
            d = d.concat(bytes);
        }
    }

    for (var _i3 = 0; _i3 < subtables.length; _i3 += 1) {
        var o = subtableOffsets[_i3];
        var offset = d.length;
        _check2.default.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
        d[o] = offset >> 8;
        d[o + 1] = offset & 0xff;
        d = d.concat(subtables[_i3]);
    }

    return d;
};

/**
 * @param {opentype.Table}
 * @returns {number}
 */
sizeOf.TABLE = function (table) {
    var numBytes = 0;
    var length = table.fields.length;

    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var sizeOfFunction = sizeOf[field.type];
        _check2.default.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        numBytes += sizeOfFunction(value);

        // Subtables take 2 more bytes for offsets.
        if (field.type === 'TABLE') {
            numBytes += 2;
        }
    }

    return numBytes;
};

encode.RECORD = encode.TABLE;
sizeOf.RECORD = sizeOf.TABLE;

// Merge in a list of bytes.
encode.LITERAL = function (v) {
    return v;
};

sizeOf.LITERAL = function (v) {
    return v.length;
};

exports.decode = decode;
exports.encode = encode;
exports.sizeOf = sizeOf;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(97);

var _extends3 = _interopRequireDefault(_extends2);

exports.glowFilter = glowFilter;
exports.help = help;
exports.snapshot = snapshot;
exports.home = home;
exports.configurator = configurator;
exports.orbit = orbit;
exports.pan = pan;
exports.vrHeadSet = vrHeadSet;
exports.zoom = zoom;
exports.fullscreen = fullscreen;
exports.vrSettings = vrSettings;
exports.lenticularMode = lenticularMode;
exports.deviceTracking = deviceTracking;
exports.nodeRotate = nodeRotate;
exports.nodeMove = nodeMove;
exports.nodeScale = nodeScale;
exports.pause = pause;
exports.play = play;
exports.select = select;
exports.exit = exit;
exports.box = box;
exports.sphere = sphere;
exports.cone = cone;

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var filter = 'url(#glowfilter)';
var activeColor = '#ffc85f';
var blurColor = '#000';
var color = '#fff';
var padding = '0';
var boxSizing = 'border-box';
var viewBox = '-300 -300 1624 1624';
var panViewBox = '-150 -150 812 812';

function glowFilter() {
  return (0, _h2.default)('svg', { attrs: { width: 0, height: 0 } }, [(0, _h2.default)('filter', { attrs: { id: 'glowfilter' } }, [(0, _h2.default)('feGaussianBlur', {
    attrs: { in: 'SourceAlpha', stdDeviation: 50, result: 'blur' }
  }), (0, _h2.default)('feOffset', {
    attrs: { in: 'blur', dx: 0, dy: 0, result: 'offsetBlur' }
  }), (0, _h2.default)('feFlood', {
    attrs: {
      'flood-color': blurColor,
      'flood-opacity': 1,
      result: 'offsetColor'
    }
  }), (0, _h2.default)('feComposite', {
    attrs: {
      in: 'offsetColor',
      in2: 'offsetBlur',
      operator: 'in',
      result: 'offsetBlurComposed'
    }
  }), (0, _h2.default)('feMerge', [(0, _h2.default)('feMergeNode', { attrs: { in: 'offsetBlurComposed' } }), (0, _h2.default)('feMergeNode', { attrs: { in: 'SourceGraphic' } })])])]);
}

// icomoon free svg icons
function help(attrs, options) {
  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', {
    attrs: {
      fill: color,
      filter: filter,
      d: 'M744.25 70.953c-64.735-46.677-146.050-70.016-243.947-70.016-74.445 0-137.306 16.411-188.355 49.29-81.031 51.447-124.075 138.839-129.298 262.062h187.787c0-35.945 10.505-70.413 31.402-103.803 20.954-33.276 56.501-49.914 106.642-49.914 50.993 0 86.142 13.515 105.279 40.488 19.25 27.086 28.847 57.012 28.847 89.833 0 28.62-14.309 54.797-31.629 78.534-9.483 13.856-21.975 26.632-37.535 38.273 0 0-101.816 65.302-146.505 117.772-25.894 30.38-28.222 75.978-30.551 141.281-0.113 4.656 1.647 14.309 17.887 14.309 16.297 0 131.513 0 145.993 0 14.537 0 17.547-10.733 17.716-15.559 1.023-23.736 3.634-35.945 8.006-49.687 8.177-25.95 30.551-48.551 55.592-68.085l51.674-35.604c46.677-36.399 83.871-66.211 100.338-89.607 28.052-38.386 47.812-85.745 47.812-141.962-0.057-91.707-32.424-160.814-97.158-207.605zM497.293 791.608c-64.678-1.987-118.056 42.816-120.1 113.002-1.987 70.073 48.722 116.465 113.456 118.34 67.517 1.987 119.475-41.282 121.576-111.469 1.931-70.186-47.359-117.885-114.933-119.872z'
    }
  })]);
}

function snapshot(attrs, options) {
  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', {
    attrs: {
      fill: color,
      filter: filter,
      d: 'M896 256h-190.016c0 0-1.984-3.808-1.984-48s-35.808-80-80-80h-256c-44.192 0-80 35.808-80 80s1.984 48 1.984 48h-193.984c-35.328 0-64 28.672-64 64v512c0 35.328 28.672 64 64 64h800c35.328 0 64-28.672 64-64v-512c0-35.328-28.672-64-64-64zM497.44 767.136c-106.048 0-192-85.952-192-192 0-106.016 85.952-192 192-192 106.016 0 192 85.952 192 192s-85.984 192-192 192z'
    }
  })]);
}

function home(attrs, options) {
  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [
  //blurFilter('homefilter'),
  (0, _h2.default)('path', {
    attrs: {
      fill: color,
      filter: filter,
      d: 'M1024 608l-192-192v-288h-128v160l-192-192-512 512v32h128v320h320v-192h128v192h320v-320h128z'
    }
  })]);
}

function configurator(attrs, options) {
  var fill = options.active ? options.activeColor : color;
  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M286.547 465.016c16.843 16.812 81.716 85.279 81.716 85.279l35.968-37.093-56.373-58.248 108.214-114.934c0 0-48.842-47.623-27.468-28.655 20.438-75.903 1.812-160.589-55.842-220.243-57.154-59.186-138.37-78.592-211.337-58.218l123.653 127.715-32.53 125.309-121.060 33.438-123.59-127.748c-19.718 75.436-0.969 159.339 56.311 218.556 60.093 62.123 146.621 80.373 222.338 54.842zM698.815 589.231l-149.121 147.308 245.932 254.805c20.062 20.812 46.498 31.188 72.872 31.188 26.25 0 52.624-10.375 72.811-31.188 40.249-41.624 40.249-108.997 0-150.62l-242.494-251.493zM1023.681 161.838l-156.621-161.839-461.673 477.298 56.373 58.248-276.335 285.616-63.154 33.749-89.217 145.559 22.719 23.562 140.839-92.247 32.655-65.312 276.336-285.554 56.404 58.248 461.674-477.328z'
    }
  })]);
}

function orbit(attrs, options) {
  var fill = options.active ? options.activeColor : color;
  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M1024 384h-384l143.53-143.53c-72.53-72.526-168.96-112.47-271.53-112.47s-199 39.944-271.53 112.47c-72.526 72.53-112.47 168.96-112.47 271.53s39.944 199 112.47 271.53c72.53 72.526 168.96 112.47 271.53 112.47s199-39.944 271.528-112.472c6.056-6.054 11.86-12.292 17.456-18.668l96.32 84.282c-93.846 107.166-231.664 174.858-385.304 174.858-282.77 0-512-229.23-512-512s229.23-512 512-512c141.386 0 269.368 57.326 362.016 149.984l149.984-149.984v384z'
    }
  })]);
}

function pan(attrs, options) {
  var fill = options.active ? options.activeColor : color;
  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: panViewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('g', {
    attrs: {
      transform: 'matrix(0.49680763,0.49680763,-0.49680763,0.49680763,255.01217,2.6223229)'
    }
  }, [(0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M -0.49680099,-1.4900844 -0.49680795,206.9137 79.659562,126.75733 207.90699,255.00476 79.657586,383.25416 -0.49680795,303.09977 l 4.41e-6,208.40379 208.40379354,0 -80.15637,-80.15637 128.2494,-128.2494 c 43.4197,43.41971 90.25956,90.25956 128.2494,128.2494 l -80.15637,80.15637 208.4038,0 0,-208.40379 -80.1544,80.15439 -128.2494,-128.2494 c 42.74914,-42.74914 85.49828,-85.49828 128.24743,-128.24743 l 80.15637,80.15637 -10e-6,-208.4037813 -208.40379,-1e-5 80.1544,80.1543943 C 341.4983,121.41344 298.74916,164.16259 256.00002,206.91173 L 127.75259,78.664303 207.90699,-1.4900913 Z'
    }
  })])]);
}

// paths for diagonal arrows
//h('path', { attrs: { fill, filter, d: "M1024 0h-416l160 160-192 192 96 96 192-192 160 160z"} }),
//h('path', { attrs: { fill, filter, d: "M1024 1024v-416l-160 160-192-192-96 96 192 192-160 160z" } }),
//h('path', { attrs: { fill, filter, d: "M0 1024h416l-160-160 192-192-96-96-192 192-160-160z" } }),
//h('path', { attrs: { fill, filter, d: "M0 0v416l160-160 192 192 96-96-192-192 160-160z" } }),

function vrHeadSet(attrs, style) {
  return (0, _h2.default)('svg', {
    style: style,
    attrs: (0, _extends3.default)({
      viewBox: '0 0 800.000000 800.000000',
      preserveAspectRatio: 'xMidYMid meet'
    }, attrs)
  }, [(0, _h2.default)('g', {
    attrs: {
      transform: 'translate(0.000000,800.000000) scale(0.100000,-0.100000)',
      fill: '#000000',
      stroke: 'none'
    }
  }, [(0, _h2.default)('path', {
    attrs: {
      d: 'M4450 7334 c-651 -47 -1223 -245 -1740 -602 -177 -122 -473 -355 -655 -516 -113 -100 -433 -415 -487 -479 l-40 -47 337 2 336 3 33 100 c81 249 197 406 443 602 460 366 982 588 1578 669 184 25 610 26 785 1 180 -25 352 -62 482 -103 232 -74 538 -233 746 -388 147 -110 332 -297 410 -416 171 -259 278 -575 313 -924 21 -209 1 -665 -37 -848 l-6 -28 -504 0 -503 0 -42 83 c-158 316 -444 517 -794 557 -49 5 -96 10 -102 10 -10 0 -13 25 -13 93 0 213 -90 375 -249 451 l-66 31 -1640 0 -1640 0 -57 -27 c-106 -49 -192 -151 -229 -269 -34 -109 -65 -99 304 -99 287 0 326 -2 356 -18 100 -50 106 -186 12 -249 -34 -23 -37 -23 -368 -23 l-334 0 3 -387 c4 -362 5 -392 25 -450 42 -126 135 -232 241 -275 l57 -23 1310 -3 1310 -2 30 -86 c112 -331 400 -579 760 -655 77 -17 293 -17 370 0 328 69 600 284 729 574 l25 57 411 0 411 0 -7 -22 c-16 -54 -80 -167 -174 -307 -166 -248 -223 -394 -250 -640 -37 -331 42 -762 226 -1240 25 -63 43 -115 42 -116 -9 -7 -453 -121 -618 -159 -600 -137 -1072 -188 -1317 -141 -164 31 -240 99 -349 310 -110 213 -183 304 -279 346 -40 18 -74 24 -173 27 -149 5 -240 -5 -587 -70 -395 -74 -471 -72 -702 24 -65 27 -73 33 -78 61 -3 18 -16 169 -30 337 -62 758 -105 990 -198 1088 -37 39 -96 71 -221 119 -50 19 -106 44 -125 55 -32 20 -33 23 -27 69 4 27 20 93 36 148 17 55 30 105 30 111 0 6 -36 10 -94 10 l-93 0 -29 -102 c-39 -141 -40 -258 -4 -311 33 -49 108 -100 195 -132 39 -15 100 -40 137 -57 64 -29 69 -34 87 -82 45 -122 76 -352 126 -946 19 -234 39 -435 44 -446 10 -24 196 -107 317 -143 190 -55 273 -53 638 14 322 59 432 75 536 75 163 0 200 -27 301 -225 149 -289 255 -395 446 -447 98 -26 409 -36 589 -19 289 28 646 94 1039 191 237 58 616 164 640 178 10 5 -2 42 -47 146 -208 487 -315 980 -279 1296 25 217 78 358 208 547 102 150 169 266 209 369 28 69 42 94 58 98 46 11 74 57 104 171 65 241 113 484 144 735 20 163 17 645 -5 795 -38 254 -103 475 -203 683 -255 534 -713 915 -1369 1139 -184 62 -389 106 -625 133 -101 11 -487 21 -580 14z'
    }
  })])]);
}

function zoom(attrs, options) {
  var fill = options.active ? options.activeColor : color;
  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M992.262 871.396l-242.552-206.294c-25.074-22.566-51.89-32.926-73.552-31.926 57.256-67.068 91.842-154.078 91.842-249.176 0-212.078-171.922-384-384-384-212.076 0-384 171.922-384 384s171.922 384 384 384c95.098 0 182.108-34.586 249.176-91.844-1 21.662 9.36 48.478 31.926 73.552l206.294 242.552c35.322 39.246 93.022 42.554 128.22 7.356s31.892-92.898-7.354-128.22zM384 640c-141.384 0-256-114.616-256-256s114.616-256 256-256 256 114.616 256 256-114.614 256-256 256z'
    }
  })]);
}

function fullscreen(attrs, options) {
  var fill = options.active ? options.activeColor : color;

  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [options.active ? (0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M448 576v416l-160-160-192 192-96-96 192-192-160-160zM1024 96l-192 192 160 160h-416v-416l160 160 192-192z'
    }
  }) : (0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M1024 0v416l-160-160-192 192-96-96 192-192-160-160zM448 672l-192 192 160 160h-416v-416l160 160 192-192z'
    }
  })]);
}

function vrSettings(attrs, options) {
  var fill = options.active ? options.activeColor : color;

  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [(0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M884.907 256h-748.373c-27.733 0-51.2 24.32-51.2 54.187v446.293c0 29.867 23.467 54.187 52.48 54.187h203.52c23.040 0 42.667-13.653 49.493-33.707l59.307-148.053c10.24-24.747 34.133-42.24 61.867-42.24s51.627 17.493 61.867 42.24l59.307 148.053c8.107 20.053 26.453 33.707 47.36 33.707h204.373c30.293 0 53.76-24.32 53.76-54.187v-446.293c0-29.867-23.467-54.187-53.76-54.187zM308.053 622.080c-52.053 0-94.72-43.947-94.72-97.707 0-55.040 42.667-97.707 94.72-97.707s94.293 42.667 94.293 97.707c0 53.76-42.24 97.707-94.293 97.707zM715.947 622.080c-52.053 0-94.293-43.947-94.293-97.707s42.24-97.707 94.293-97.707c52.053 0 94.72 43.947 94.72 97.707s-42.667 97.707-94.72 97.707z'
    }
  })]);
}

function lenticularMode(attrs, options) {
  var fill = options.active ? options.activeColor : color;

  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [options.active ? (0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M317.143 762.857l44.571-80.571q-49.714-36-77.714-90.857t-28-116q0-69.143 34.857-128.571-130.857 66.857-217.714 201.714 95.429 147.429 244 214.286zM539.429 329.143q0-11.429-8-19.429t-19.429-8q-71.429 0-122.571 51.143t-51.143 122.571q0 11.429 8 19.429t19.429 8 19.429-8 8-19.429q0-49.143 34.857-84t84-34.857q11.429 0 19.429-8t8-19.429zM746.857 220q0 4-0.571 5.143-60 107.429-180 323.429t-180.571 324l-28 50.857q-5.714 9.143-16 9.143-6.857 0-76.571-40-9.143-5.714-9.143-16 0-6.857 25.143-49.714-81.714-37.143-150.571-98.857t-119.143-140q-11.429-17.714-11.429-39.429t11.429-39.429q87.429-134.286 217.143-212t283.429-77.714q50.857 0 102.857 9.714l30.857-55.429q5.714-9.143 16-9.143 2.857 0 10.286 3.429t17.714 8.857 18.857 10.571 18 10.571 11.143 6.571q9.143 5.714 9.143 15.429zM768 475.429q0 79.429-45.143 144.857t-119.429 94l160-286.857q4.571 25.714 4.571 48zM1024 548.571q0 20-11.429 39.429-22.286 36.571-62.286 82.857-85.714 98.286-198.571 152.571t-239.714 54.286l42.286-75.429q121.143-10.286 224.286-78.286t172.286-175.429q-65.714-102.286-161.143-168l36-64q54.286 36.571 104.286 87.429t82.571 105.143q11.429 19.429 11.429 39.429z'
    }
  }) : (0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M950.857 548.571q-86.857-134.857-217.714-201.714 34.857 59.429 34.857 128.571 0 105.714-75.143 180.857t-180.857 75.143-180.857-75.143-75.143-180.857q0-69.143 34.857-128.571-130.857 66.857-217.714 201.714 76 117.143 190.571 186.571t248.286 69.429 248.286-69.429 190.571-186.571zM539.429 329.143q0-11.429-8-19.429t-19.429-8q-71.429 0-122.571 51.143t-51.143 122.571q0 11.429 8 19.429t19.429 8 19.429-8 8-19.429q0-49.143 34.857-84t84-34.857q11.429 0 19.429-8t8-19.429zM1024 548.571q0 19.429-11.429 39.429-80 131.429-215.143 210.571t-285.429 79.143-285.429-79.429-215.143-210.286q-11.429-20-11.429-39.429t11.429-39.429q80-130.857 215.143-210.286t285.429-79.429 285.429 79.429 215.143 210.286q11.429 20 11.429 39.429z'
    }
  })]);
}

//export function enableParallaxmode(attrs, options) {
//  const fill = options.active ? options.activeColor : color;

//  return h('svg', { attrs: { viewBox, ...attrs }, style: { padding: boxSizing }}, [
//    h('path', { attrs: { fill, filter, d: "M494.464 96.192l-427.584 184.224 428 182.784 432.416-183.2-432.832-183.808zM512 486.208v441.6l415.84-197.408v-420.832l-415.84 176.64zM64.16 730.4l417.248 197.408v-441.6l-417.248-176.64v420.832z" } }),
//  ]);
//}

//export function disableParallaxmode(attrs, options) {
//  const fill = '#000';

//  return h('svg', { attrs: { viewBox, ...attrs }, style: { padding: boxSizing }}, [
//    h('path', { attrs: { fill, filter, d: "M494.464 96.192l-427.584 184.224 428 182.784 432.416-183.2-432.832-183.808zM512 486.208v441.6l415.84-197.408v-420.832l-415.84 176.64zM64.16 730.4l417.248 197.408v-441.6l-417.248-176.64v420.832z" } }),
//  ]);
//}
//
function deviceTracking(attrs, options) {
  var fill = options.active ? options.activeColor : color;

  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [(0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M395 37.2c-24.2 1.4-50.2 3.6-57.8 4.8-28.2 4.4-60.2 22.8-77.4 44.4-7.8 9.8-23.4 39-21.6 40.4 1.2 1 26.4 9.2 26.6 8.6 0.2-0.2 3.2-6.4 7-13.8 11.6-23.6 38.8-44 65.4-49.6 9.2-1.8 59.8-6 74.4-6h6.4v85.6l-16.4 1.2c-9.2 0.6-38.2 2-64.6 3.2-52.8 2.4-92.6 6.4-108 11-13 3.8-24.6 11.4-31.4 20.8-5 7-15.6 38.6-21.6 64l-2.6 10.6-8.2-1.2c-4.4-0.8-11.4-1.8-15.2-2.4l-7-1.2-17.6 88.4c-12.8 63.6-17 89-15.4 90 1.2 0.8 8.4 2.4 15.8 3.8l13.4 2.4-1.8 13.4c-1 7.4-1.8 31-2 52.4-0.2 34.6 0.2 40.4 4 51.4 15.2 45.6 59.8 72 133 78.6 24 2.2 25.2 2.2 42.6-3 62.8-18.2 121.4-24.2 219-22.4 79 1.6 130.2 8 175.6 22.4 15 4.8 17 5 38.6 3.2 73.4-6.2 118.6-32.2 134.8-77.2 4.6-13.2 6.4-64.6 3.2-95.2-1.4-12.2-2-22.6-1.6-23s6.8-2 14.2-3.6c7.4-1.4 13.8-3.2 14.4-3.6 0.4-0.6-7-40.4-16.8-88.8l-17.6-87.8-5.8 0.2c-3.4 0-10.2 0.8-15.2 1.6l-9.2 1.6-6.2-25c-9-35.4-13.2-45.8-22.2-54-8.8-8-30-18.4-43.6-21.6-15.4-3.4-63.8-7.4-120-10.2l-52.6-2.4v-85.6l5.6 1.2c3 0.6 18 1.6 33.4 2.2 15.4 0.8 34 2.6 41.6 4 28.2 5.8 54.4 26 67 51.6 3.8 7.6 7.8 13.2 9 12.8 1.4-0.4 7.2-2.4 13-4.2 5.6-2 10.4-4.6 10.4-6 0-1.6-3.4-9.4-7.4-17.4-10.6-21.4-32.6-43-54.4-53.6-9.2-4.4-23-9.4-31-11-38.2-8.2-203.8-11.6-296.2-6zM592 186c68.4 3.2 106 9 132.2 20.2 12 5.2 16.8 11.8 34.2 46.8 37.6 75 76.8 210.6 72.6 250.6-0.8 7.4-2.6 15.6-4 18.6-3.6 6.8-18.4 20.2-32.4 29.2-12.4 7.8-61.8 32-76.6 37.4-8.6 3-8.8 3-4-0.4 49.6-35 63.4-45.6 76.6-58.4 17.8-17.6 17.4-16 12.4-56-4.8-39-20-94.8-40.4-149-11-29.4-36.4-82.4-42.4-88.4-7.4-7.8-43.2-16.4-86.2-20.6-34.4-3.4-158.2-4.8-206.8-2.2-60.4 3.2-89.4 7.4-112.2 16.4-12 4.6-16.8 11.6-33.6 49.8-38 86.6-61.4 172.2-61.4 224.4v15.4l13.2 13.2c12.8 12.6 43.4 35.6 67.4 50.4 6.2 4 11.2 7.6 10.6 8-1.2 1.4-40.4-15-62.8-26.2-24.8-12.4-45-26.6-49-34.6-1.6-3-4-15.6-5.4-27.6-2.2-20-2-24.2 1.8-46.4 8-46.4 22.4-94.6 45.6-153.6 13.4-34 32-73 40.2-84.2 7.8-10.6 21.2-17 46.4-22.4 19.2-4.2 70.6-10 98-11 38.6-1.6 127.2-1.2 166 0.6zM194 656.8c0 6.4 6 33 10 45.2 21.6 63.6 98.4 169.8 171 236.8 28 25.8 44 37.4 60.8 44.2 25.2 10.4 69 15 103.6 11.2 52.2-6 69.8-16 125.6-71 90-89.2 156-193 163.8-257.8l1.4-11.4h-30.2v7.6c0 19.8-18 63.4-41.8 101.4-38 60.2-102 134.8-150 174.8-25.4 21-49.8 28.2-96.2 28.2-41.2 0-63.6-5.4-85.6-20.4-15.8-10.8-56-49.2-79-75.6-73.4-83.8-117.8-157.2-124.4-205.6l-1.4-10.4h-13.8c-10.6 0-13.8 0.6-13.8 2.8zM407.2 770.6c-1.8 7.4-3.2 13.6-3.2 14.2 0 1.6 28 7.4 55 11.4 43.2 6.4 79.6 4.6 136-6.2 12.2-2.4 22.2-4.6 22.6-5 0.4-0.2-1-6.6-2.8-14l-3.4-13.4-7.2 1c-4 0.6-17.6 3.2-30.2 5.6-33.6 6.6-93.2 6.6-126 0.2-12.6-2.6-26.2-5.2-30.2-5.8l-7.2-1-3.4 13z'
    }
  })]);
}

function nodeRotate(attrs, options) {
  var fill = options.active ? options.activeColor : color;

  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: boxSizing } }, [(0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M1024 384h-384l143.53-143.53c-72.53-72.526-168.96-112.47-271.53-112.47s-199 39.944-271.53 112.47c-72.526 72.53-112.47 168.96-112.47 271.53s39.944 199 112.47 271.53c72.53 72.526 168.96 112.47 271.53 112.47s199-39.944 271.528-112.472c6.056-6.054 11.86-12.292 17.456-18.668l96.32 84.282c-93.846 107.166-231.664 174.858-385.304 174.858-282.77 0-512-229.23-512-512s229.23-512 512-512c141.386 0 269.368 57.326 362.016 149.984l149.984-149.984v384z'
    }
  }), (0, _h2.default)('path', {
    attrs: { fill: fill, filter: filter, d: 'M512 250l262 262-262 262-262-262z' }
  })]);
}

function nodeMove(attrs, options) {
  var fill = options.active ? options.activeColor : color;
  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: panViewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('g', {
    attrs: {
      transform: 'matrix(0.49680763,0.49680763,-0.49680763,0.49680763,255.01217,2.6223229)'
    }
  }, [(0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M -0.49680099,-1.4900844 -0.49680795,206.9137 79.659562,126.75733 207.90699,255.00476 79.657586,383.25416 -0.49680795,303.09977 l 4.41e-6,208.40379 208.40379354,0 -80.15637,-80.15637 128.2494,-128.2494 c 43.4197,43.41971 90.25956,90.25956 128.2494,128.2494 l -80.15637,80.15637 208.4038,0 0,-208.40379 -80.1544,80.15439 -128.2494,-128.2494 c 42.74914,-42.74914 85.49828,-85.49828 128.24743,-128.24743 l 80.15637,80.15637 -10e-6,-208.4037813 -208.40379,-1e-5 80.1544,80.1543943 C 341.4983,121.41344 298.74916,164.16259 256.00002,206.91173 L 127.75259,78.664303 207.90699,-1.4900913 Z'
    }
  }), (0, _h2.default)('path', {
    attrs: { fill: fill, filter: filter, d: 'M256 0l256 256-256 256-256-256z' }
  })])]);
}

function nodeScale(attrs, options) {
  var fill = options.active ? options.activeColor : color;

  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M992.262 871.396l-242.552-206.294c-25.074-22.566-51.89-32.926-73.552-31.926 57.256-67.068 91.842-154.078 91.842-249.176 0-212.078-171.922-384-384-384-212.076 0-384 171.922-384 384s171.922 384 384 384c95.098 0 182.108-34.586 249.176-91.844-1 21.662 9.36 48.478 31.926 73.552l206.294 242.552c35.322 39.246 93.022 42.554 128.22 7.356s31.892-92.898-7.354-128.22zM384 640c-141.384 0-256-114.616-256-256s114.616-256 256-256 256 114.616 256 256-114.614 256-256 256z'
    }
  }), (0, _h2.default)('path', {
    attrs: { fill: fill, filter: filter, d: 'M375 181l200 200-200 200-200-200z' }
  })]);
}

function pause(attrs, options) {
  var fill = options.active ? options.activeColor : color;

  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M64 0h384v1024h-384z' } }), (0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M576 0h384v1024h-384z' } })]);
}

function play(attrs, options) {
  var fill = options.active ? options.activeColor : color;

  return (0, _h2.default)('svg', { attrs: (0, _extends3.default)({ viewBox: viewBox }, attrs), style: { padding: padding, boxSizing: boxSizing } }, [(0, _h2.default)('path', { attrs: { fill: fill, filter: filter, d: 'M138 0L1024 512L138 1024z' } })]);
}

function select(attrs, options) {
  var fill = options.active ? options.activeColor : '#000'; // FIXME white default not displayed?
  return (0, _h2.default)('svg', {
    attrs: (0, _extends3.default)({ viewBox: '0 0 32 32' }, attrs),
    style: { padding: padding, boxSizing: boxSizing }
  }, [(0, _h2.default)('path', {
    attrs: {
      fill: fill,
      filter: filter,
      d: 'M16 0c-8.837 0-16 7.163-16 16s7.163 16 16 16 16-7.163 16-16-7.163-16-16-16zM16 28c-6.627 0-12-5.373-12-12s5.373-12 12-12c6.627 0 12 5.373 12 12s-5.373 12-12 12zM10 16c0-3.314 2.686-6 6-6s6 2.686 6 6c0 3.314-2.686 6-6 6s-6-2.686-6-6z'
    }
  })]);
}

function exit(attrs, options) {
  var fill = options.active ? options.activeColor : '#000';
  return (0, _h2.default)('svg', { attrs: {} }, [(0, _h2.default)('g', [(0, _h2.default)('line', {
    attrs: { x1: 2, y1: 2, x2: 30, y2: 30 },
    style: { stroke: 'black', strokeWidth: 3 }
  }), (0, _h2.default)('line', {
    attrs: { x1: 30, y1: 2, x2: 2, y2: 30 },
    style: { stroke: 'black', strokeWidth: 3 }
  })]), (0, _h2.default)('g', [(0, _h2.default)('line', {
    attrs: { x1: 2.4, y1: 2.4, x2: 29.6, y2: 29.6 },
    style: { stroke: 'white', strokeWidth: 2 }
  }), (0, _h2.default)('line', {
    attrs: { x1: 29.6, y1: 2.4, x2: 2.4, y2: 29.6 },
    style: { stroke: 'white', strokeWidth: 2 }
  })])]);
}

function box(attrs, options) {
  var fill = options.active ? options.activeColor : '#000'; // FIXME white default not displayed?
  return (0, _h2.default)('svg', {
    attrs: (0, _extends3.default)({ viewBox: '0 0 32 32' }, attrs),
    style: { padding: padding, boxSizing: boxSizing }
  }, [(0, _h2.default)('rect', { attrs: { fill: fill, filter: filter, x: 2, y: 2, width: 28, height: 28 } })]);
}

function sphere(attrs, options) {
  var fill = options.active ? options.activeColor : '#000'; // FIXME white default not displayed?
  return (0, _h2.default)('svg', {
    attrs: (0, _extends3.default)({ viewBox: '0 0 32 32' }, attrs),
    style: { padding: padding, boxSizing: boxSizing }
  }, [(0, _h2.default)('circle', { attrs: { fill: fill, filter: filter, r: 14, cx: 16, cy: 16 } })]);
}

function cone(attrs, options) {
  var fill = options.active ? options.activeColor : '#000'; // FIXME white default not displayed?
  return (0, _h2.default)('svg', {
    attrs: (0, _extends3.default)({ viewBox: '0 0 32 32' }, attrs),
    style: { padding: padding, boxSizing: boxSizing }
  }, [(0, _h2.default)('polygon', { attrs: { fill: fill, filter: filter, points: '16,2 28,28 2,28' } })]);
}

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var headerFont = '-apple-system,".SFNSDisplay-Bold","Helvetica Neue","Roboto","Segoe UI",sans-serif';
var bodyFont = "'Lucida Grande', 'Lucida Sans Unicode', 'Lucida Sans', Verdana, Tahoma, sans-serif";
var colors = {
  gray: '#999',
  black: '#333',
  lightBg: '#eee',
  border: '#ccc',
  white: '#fff'
};

exports.default = {
  root: {
    height: '100%',
    fontSize: '14px',
    fontFamily: bodyFont,
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  },
  absoluteMaxCentered: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  },
  header: {
    display: 'flex',
    flex: '0 0 auto',
    justifyContent: 'center',
    margin: '0',
    backgroundColor: colors.lightBg,
    fontFamily: headerFont
  },
  mainRow: {
    display: 'flex',
    flex: '1 1 100px',
    justifyContent: 'center'
  },
  statsRow: {
    flex: '0 0 auto',
    backgroundColor: colors.gray,
    color: colors.lightBg,
    padding: '5px'
  },
  player: {
    position: 'relative',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    height: '100%',
    width: '100%'
  },
  maxRow: {
    flex: '1 1 auto'
  },
  leftCol: {
    flex: '1 1 200px',
    maxWidth: '300px',
    overflow: 'scroll'
  },
  centerCol: {
    flex: '2 2 500px',
    border: '1px solid ' + colors.border
  },
  rightCol: {
    flex: '1 1 200px',
    maxWidth: '300px',
    overflow: 'scroll'
  },
  footer: {
    flex: '0 0 auto',
    padding: '5px',
    backgroundColor: colors.lightBg,
    margin: '0'
  },
  explorerSelected: {
    backgroundColor: colors.gray
  },
  explorerNotSelected: {
    backgroundColor: colors.white,
    cursor: 'pointer'
  }
};

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getObject;
function getObject(objects) {
  return function (hash) {
    var s = objects[hash];
    if (!s) {
      throw new Error('Unknown content hash: ' + hash);
    }

    try {
      return JSON.parse(s);
    } catch (e) {
      console.log('Error parsing hash: ' + hash);
      throw new Error(e);
    }
  };
}

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BitSet;
function BitSet(length) {
  this.data = new Uint32Array(length + 31 >>> 5);
  this.length = length;

  this.byteView = null;
}

BitSet.prototype = {
  constructor: BitSet,

  clear: function clear() {
    this.data.fill(0);
    return this;
  },

  fill: function fill(optionalOffset, optionalLength) {
    var data = this.data;

    var begin = optionalOffset !== undefined ? optionalOffset : 0;
    var until = optionalLength !== undefined ? begin + optionalLength : this.length;

    var wordIndexBegin = begin >>> 5;
    var wordIndexUntil = until >>> 5;

    // Smear the highbit with a signed shift for a pattern of MSBs:
    var maskBegin = -0x80000000 >> ~begin;

    // Power of two minus one yields a pattern of LSBs:
    var maskUntil = (1 << until) - 1;

    if (wordIndexBegin === wordIndexUntil) data[wordIndexBegin] |= maskBegin & maskUntil;else {
      data[wordIndexBegin] |= maskBegin;

      if (++wordIndexBegin !== wordIndexUntil) data.fill(~0, wordIndexBegin, wordIndexUntil);

      data[wordIndexUntil] |= maskUntil;
    }

    return this;
  },

  include: function include(i) {
    this.data[i >>> 5] |= 1 << i;
  },

  exclude: function exclude(i) {
    this.data[i >>> 5] &= ~(1 << i);
  },

  contains: function contains(i) {
    return (this.data[i >>> 5] & 1 << i) !== 0;
  },

  swap: function swap(i, j) {
    var data = this.data;

    var wordIndexI = i >>> 5,
        maskI = 1 << i;
    var wordIndexJ = j >>> 5,
        maskJ = 1 << j;

    var stateI = (data[wordIndexI] & maskI) !== 0;
    var stateJ = (data[wordIndexJ] & maskJ) !== 0;

    if (stateI !== stateJ) {
      if (stateI) {
        data[wordIndexI] &= ~maskI;
        data[wordIndexJ] |= maskJ;
      } else {
        data[wordIndexI] |= maskI;
        data[wordIndexJ] &= ~maskJ;
      }
    }
  },

  testAndInclude: function testAndInclude(i) {
    var data = this.data;

    var wordIndex = i >>> 5,
        mask = 1 << i;

    var unchangedWord = data[wordIndex];

    data[wordIndex] = unchangedWord | mask;
    return (unchangedWord & mask) !== 0;
  },

  includeFromArray: function includeFromArray(array, optionalOffset, optionalUntil) {
    var data = this.data;

    for (var j = optionalOffset || 0, e = optionalUntil || array.length; j < e; ++j) {
      var i = array[j];

      data[i >>> 5] |= 1 << i;
    }

    return this;
  },

  containsAnyIn: function containsAnyIn(array, optionalOffset, optionalUntil) {
    var result = false;
    var data = this.data;

    for (var j = optionalOffset || 0, e = optionalUntil || array.length; j < e && !result; ++j) {
      var i = array[j];

      result = (data[i >>> 5] & 1 << i) !== 0;
    }

    return result;
  },

  countSetBits: function countSetBits(optionalOffset, optionalUntil) {
    var result = 0;

    var begin = optionalOffset !== undefined ? optionalOffset : 0;
    var until = optionalUntil !== undefined ? optionalUntil : this.length;

    if ((until - begin & -0x4000) === 0)
      // that is, 'begin' is less than 'until' and fewer than 2048 bytes

      result = this.countSetBitsInShortRange(begin, until);else if (begin < until) {
      // use a LUT - it's several times faster at scale

      var data = this.byteView;
      var lut = BitSet._ByteBitCount;

      if (data === null) {
        data = new Uint8Array(this.data.buffer);
        this.byteView = data;
      }

      var wordIndexBegin = begin >>> 3;
      var wordIndexUntil = until >>> 3;

      // Smear the highbit with a signed shift for a pattern of MSBs:
      var maskBegin = -0x80000000 >> 31 - (begin & 7);
      // Power of two minus one yields a pattern of LSBs:
      var maskUntil = (1 << (until & 7)) - 1;

      result = lut[data[wordIndexBegin] & maskBegin];

      for (var j = wordIndexBegin + 1; j !== wordIndexUntil; ++j) {
        result += lut[data[j]];
      }result += lut[data[wordIndexUntil] & maskUntil];
    }

    return result;
  },

  countSetBitsInShortRange: function countSetBitsInShortRange(begin, until) {
    // Note: For some odd reason the data word must be signed to keep
    // V8 from deoptimizing - all unsigned access won't do.

    var result = 0;

    var data = this.data;

    var here = begin;
    var index = here >>> 5;

    var word = data[index] >> here;

    result = word & 1;

    while (++here !== until) {
      if ((here & 31) !== 0) word >>= 1;else word = data[++index] | 0; // cast to signed (important)

      result += word & 1;
    }

    return result;
  },

  toIndexArray: function toIndexArray(optionalKnownLength) {
    var result = new Uint32Array(optionalKnownLength === undefined ? this.countSetBits() : optionalKnownLength);
    var baseIndex = 0;
    var writeOffset = 0;
    var data = this.data;

    for (var j = 0, n = data.length; j !== n; ++j) {
      for (var mask = data[j], i = baseIndex; mask !== 0; mask >>>= 1, ++i) {
        if ((mask & 1) !== 0) result[writeOffset++] = i;
      }baseIndex += 32;
    }

    return result;
  }
};

BitSet._ByteBitCount = function () {
  var lut = new Uint8Array(256);

  for (var i = 0; i !== 256; ++i) {
    var value = 0;
    for (var m = i; m !== 0; m >>>= 1) {
      if ((m & 1) !== 0) ++value;
    }lut[i] = value;
  }

  return lut;
}();

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _create = __webpack_require__(48);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = ScalarArrayView;

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

var _FlatArrayView = __webpack_require__(227);

var _FlatArrayView2 = _interopRequireDefault(_FlatArrayView);

var _ScalarBuffer = __webpack_require__(228);

var _ScalarBuffer2 = _interopRequireDefault(_ScalarBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ScalarArrayView(length, optionalArrayOrType, optionalOffset, optionalStride) {
  var offset = optionalOffset === undefined ? 0 : optionalOffset;
  var stride = optionalStride === undefined ? 1 : optionalStride;

  var offsetLength = (offset + stride - 1) / stride | 0;
  var minArrayLength = length !== null ? (offsetLength + length) * stride : null;

  var array = _Arrays2.default.maybeCreate(optionalArrayOrType || Uint32Array, minArrayLength);

  _FlatArrayView2.default.call(this, array, length !== null ? length : // figure out length from user-provided array
  (array.length - offset + stride - 1) / stride | 0);

  this.offset = offset;
  this.stride = stride;
}

ScalarArrayView.prototype = (0, _assign2.default)((0, _create2.default)(_FlatArrayView2.default.prototype), {
  constructor: ScalarArrayView,

  getAt: function getAt(index) {
    return this.array[this.offset + index * this.stride];
  },

  setAt: function setAt(index, value) {
    this.array[this.offset + index * this.stride] = value;
  },

  newCompatibleView: function newCompatibleView(arrayOrType, optionalLength) {
    return new ScalarArrayView(optionalLength || null, arrayOrType, 0);
  },

  newCompatibleBuffer: function newCompatibleBuffer() {
    return new _ScalarBuffer2.default(this.data.constructor);
  }
});

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyFunctionToPolyMap;

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function applyFunctionToPolyMap(polyMesh, applyToPolyMapFunction, additionalArguments) {
  var args = additionalArguments || {};

  var resultMesh = new _PolyMesh2.default(polyMesh);
  resultMesh.positions = applyToPolyMapFunction(resultMesh.positions, 'positions', args);
  if (resultMesh.normalMap) resultMesh.normalMap = applyToPolyMapFunction(resultMesh.normalMap, 'normalMap', args);

  var uvMaps = new _ObjectsByName2.default();
  for (var i = 0; i < polyMesh.uvMaps.length; i++) {
    var name = polyMesh.uvMaps.namesByIndex[i];
    var uvMap = applyToPolyMapFunction(polyMesh.uvMaps.byName[name], name, args);
    uvMaps.set(name, uvMap);
  }

  resultMesh.uvMaps = uvMaps;
  resultMesh.faceRangeOffsets = resultMesh.positions.faceRangeOffsets;

  var finalMesh = new _PolyMesh2.default(resultMesh);

  return finalMesh;
}

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bendVertices = bendVertices;
exports.default = bendPolyMesh;

var _three = __webpack_require__(0);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _Normals = __webpack_require__(50);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Apply bend on vertices
 *
 * @param vertices - vertices
 * @param defaultAxis - axis to use
 * @param bendAngleDeg - bend angle
 * @param rotationDeg - rotation of the source
 * @param translation - translation of the data
 * @param fixedEndsEnabled - use fixed ends
 * @return true if the operation is complete and normals can be recomputed
 */
function bendVertices(vertices, defaultAxis, bendAngleDeg, rotationDeg, translation, fixedEndsEnabled) {
  var DEGTORAD = Math.PI / 180;

  var translationMat4 = new _three.Matrix4().makeTranslation(translation.x, translation.y, translation.z);
  //transformations
  rotationDeg.multiplyScalar(DEGTORAD);
  var rotMat4 = new _three.Matrix4().makeRotationFromEuler(new _three.Euler().setFromVector3(rotationDeg)).multiply(getDefaultAxisRotation(defaultAxis));
  //translation first
  var transform = new _three.Matrix4().multiplyMatrices(rotMat4, translationMat4);
  var invTransform = new _three.Matrix4().getInverse(transform);

  var v = new _three.Vector3();
  //put mesh positions into bend transform space before calculating maxLenY
  for (var i = 0; i < vertices.length; ++i) {
    vertices.getAt(i, v);
    v.applyMatrix4(transform);
    vertices.setAt(i, v);
  }

  var bendAngleRad = -(bendAngleDeg * DEGTORAD); //convert to rads and make clockwise the positive direction
  var maxLenY = findLengthY(vertices.data);
  if (maxLenY < 0.000001) {
    return false;
  }
  //Note: when fixedEndsEnabled == false:
  //   the length of the bent object remains same - the ends move to accommodate
  //Note: when fixedEndsEnabled == true,
  //   the length of the bent object changes, so that the ends can remain in the same place
  var radius = maxLenY / bendAngleRad; // radius of circle the object is bending around (arc length formula)
  var displacement = 0;
  if (fixedEndsEnabled) {
    radius = 0.5 * maxLenY / Math.sin(bendAngleRad / 2);
    displacement = Math.tan(bendAngleRad / 4) * maxLenY * 0.5;
  }

  var theta = void 0,
      sint = void 0,
      cost = void 0;
  for (var _i = 0; _i < vertices.length; ++_i) {
    vertices.getAt(_i, v);

    //theta is proportional to v.y, so v.y == maxLen/2 gives bendAngleRad/2
    theta = v.y * bendAngleRad / maxLenY;
    sint = Math.sin(theta);
    cost = Math.cos(theta);

    v.y = v.x * sint + sint * radius;
    v.x = v.x * cost + cost * radius - radius;
    v.x += displacement;

    v.applyMatrix4(invTransform);

    vertices.setAt(_i, v);
  }
  return true;
}

function bendPolyMesh(mesh, defaultAxis, bendAngleDeg, rotationDeg, translation, fixedEndsEnabled) {
  //bend angle 0 results in infinite radius for circle the object bends around (i.e. straight line instead of circle)
  if (bendAngleDeg === 0) {
    return mesh;
  }

  var DEGTORAD = Math.PI / 180;

  //clone positions
  mesh = new _PolyMesh2.default(mesh);
  var mapId = _PolyMaps2.default.IdPositions;
  var newPolyMap = new _PolyMap2.default(_PolyMaps2.default.resolveMap(mesh, mapId));
  var newMapValues = newPolyMap.values.clone();
  newPolyMap.values = newMapValues;
  _PolyMaps2.default.assignMap(mesh, mapId, newPolyMap);
  //clone normals
  mapId = _PolyMaps2.default.IdNormals;
  newPolyMap = new _PolyMap2.default(_PolyMaps2.default.resolveMap(mesh, mapId));
  newMapValues = newPolyMap.values.clone();
  newPolyMap.values = newMapValues;
  _PolyMaps2.default.assignMap(mesh, mapId, newPolyMap);

  if (bendVertices(mesh.positions.values, defaultAxis, bendAngleDeg, rotationDeg, translation, fixedEndsEnabled)) {
    mesh = (0, _Normals.recalculateNormalsFromConnectivity)(mesh);
  }
  return mesh;
}

bendPolyMesh.AxisTypes = {
  X: 1,
  Y: 2,
  Z: 3
};

function findLengthY(vertices) {
  //every third element (from the second) is the y element
  var min = vertices[1];
  var max = vertices[1];
  for (var i = 4; i < vertices.length; i += 3) {
    if (vertices[i] < min) {
      min = vertices[i];
    }
    if (vertices[i] > max) {
      max = vertices[i];
    }
  }
  return max - min;
}

function getDefaultAxisRotation(axis) {
  //default axis is Z, don't do anything, otherwise rotate
  var axisRotation = new _three.Matrix4();
  switch (axis) {
    case bendPolyMesh.AxisTypes.X:
      axisRotation.makeRotationY(-Math.PI / 2);
      break;
    case bendPolyMesh.AxisTypes.Y:
      axisRotation.makeRotationX(Math.PI / 2);
      break;
  }
  return axisRotation;
}

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeDuplicateNormals;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectBuffer = __webpack_require__(68);

var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removeDuplicateNormals(polyMesh, removeUnusedValues, withLogging) {
  if (!polyMesh.normalMap) return polyMesh;

  var ru = removeUnusedValues || true;
  var l = withLogging || false;

  var faceValueIndices = polyMesh.positions.faceValueIndices;
  var values = polyMesh.positions.values;

  var normalFaceValueIndices = new Uint32Array(polyMesh.normalMap.faceValueIndices);
  var normalValues = polyMesh.normalMap.values;

  var duplicatesFound = 0;

  var n1 = void 0,
      n2 = void 0;

  //TODO bad nested array
  var valuesToIndices = [];
  for (var i = 0; i < values.length; i++) {
    valuesToIndices[i] = [];
  }

  for (var _i = 0; _i < faceValueIndices.length; _i++) {
    valuesToIndices[faceValueIndices[_i]].push(_i);
  }

  //compares every normal on specific vertices to each other
  //then remaps indices of normals that are the same
  for (var _i2 = 0; _i2 < valuesToIndices.length; _i2++) {
    for (var j = 0; j < valuesToIndices[_i2].length; j++) {
      n1 = normalFaceValueIndices[valuesToIndices[_i2][j]];
      for (var k = 0; k < valuesToIndices[_i2].length; k++) {
        n2 = normalFaceValueIndices[valuesToIndices[_i2][j + k]];
        if (n1 !== n2 && normalValues.getAt(n1).dot(normalValues.getAt(n2)) > 0.99) {
          normalFaceValueIndices[valuesToIndices[_i2][j + k]] = n1;
          duplicatesFound++;
        }
      }
    }
  }

  if (l) console.log('Normal Duplicates Found: ' + duplicatesFound);

  var normals = normalValues;
  if (ru && duplicatesFound) {
    var newNormalValuesBuffer = new _ObjectBuffer2.default(_three.Vector3);
    var isUsed = new Int32Array(normalValues.length);
    isUsed.fill(-1);

    var newNormalsCount = 0;
    for (var _i3 = 0; _i3 < normalFaceValueIndices.length; _i3++) {
      if (isUsed[normalFaceValueIndices[_i3]] === -1) {
        newNormalValuesBuffer.push(normalValues.getAt(normalFaceValueIndices[_i3]));
        isUsed[normalFaceValueIndices[_i3]] = newNormalsCount++;
      }

      normalFaceValueIndices[_i3] = isUsed[normalFaceValueIndices[_i3]];
    }

    var newNormalValues = new _ObjectArrayView2.default(_three.Vector3, newNormalsCount);
    newNormalValues.fromArray(newNormalValuesBuffer.toArray());

    normals = newNormalValues;
    if (l) console.log('' + normalValues.length + ' normal values reduced to ' + newNormalValues.length + ', duplicates removed: ' + (normalValues.length - newNormalValues.length));
  }

  var newNormals = new _PolyMap2.default({
    faceRangeOffsets: polyMesh.faceRangeOffsets,
    faceValueIndices: normalFaceValueIndices,
    values: normals
  });

  var resultMesh = new _PolyMesh2.default(polyMesh);
  resultMesh.normalMap = newNormals;
  return resultMesh;
}

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _trunc = __webpack_require__(258);

var _trunc2 = _interopRequireDefault(_trunc);

var _map = __webpack_require__(257);

var _map2 = _interopRequireDefault(_map);

exports.default = removeDuplicateValues;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectBuffer = __webpack_require__(68);

var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removeDuplicateValues(polyMesh, withLogging) {
  //removes indentical values in the values array and remaps the indices
  //also has the side effect of removing values not used by a face

  var l = withLogging || false;

  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
  var values = polyMesh.positions.values;

  var newValues = new _ObjectBuffer2.default(_three.Vector3);

  var valueMappings = new _map2.default();
  var newValuesLength = 0;

  var key = 0;
  var newIndex = 0;
  var value = new _three.Vector3();
  var keyValue = new _three.Vector3();
  var boundingBox = new _three.Box3();
  boundingBox.setFromArray(new Float32Array(values.data));
  var scaledInverseBoundingDiagonal = Math.pow(2, 16) / boundingBox.getSize().length();

  for (var ix = 0; ix < faceValueIndices.length; ix++) {
    values.getAt(faceValueIndices[ix], value);
    //hash function scales values to the diagonal of the bounding box and stores 16 bits of precision for each x, y, z
    keyValue.subVectors(value, boundingBox.min).multiplyScalar(scaledInverseBoundingDiagonal);
    keyValue.x = (0, _trunc2.default)(keyValue.x) * Math.pow(2, 32);
    keyValue.y = (0, _trunc2.default)(keyValue.y) * Math.pow(2, 16);
    keyValue.z = (0, _trunc2.default)(keyValue.z);
    key = keyValue.x + keyValue.y + keyValue.z;
    if (!valueMappings.has(key)) {
      valueMappings.set(key, newValuesLength); //save location of value in map
      newIndex = newValuesLength;
      newValues.push(value); //push value to the newValues array
      newValuesLength++;
    } else {
      newIndex = valueMappings.get(key);
    }

    faceValueIndices[ix] = newIndex; //update indices array with new value
  }

  if (l) console.log('' + values.length + ' values reduced to ' + newValuesLength + ', duplicates removed: ' + (values.length - newValuesLength));

  if (values.length === newValuesLength) return polyMesh;

  var newValuesArray = new _ObjectArrayView2.default(_three.Vector3, newValuesLength);
  newValuesArray.fromArray(newValues.toArray());

  var newPositions = new _PolyMap2.default({
    faceRangeOffsets: polyMesh.faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: newValuesArray
  });

  var newMesh = (0, _assign2.default)({}, polyMesh, { positions: newPositions });
  var resultMesh = new _PolyMesh2.default(newMesh);

  resultMesh.topologyChanged(true);
  return resultMesh;
}

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Selection = exports.PolyMesh = exports.PolyMaps = exports.PolyMap = exports.Importer = undefined;

__webpack_require__(417);

var _Importer = __webpack_require__(459);

var _Importer2 = _interopRequireDefault(_Importer);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _Selection = __webpack_require__(70);

var _Selection2 = _interopRequireDefault(_Selection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Importer = _Importer2.default;
exports.PolyMap = _PolyMap2.default;
exports.PolyMaps = _PolyMaps2.default;
exports.PolyMesh = _PolyMesh2.default;
exports.Selection = _Selection2.default;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__(47);

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = __webpack_require__(38);

var _typeof3 = _interopRequireDefault(_typeof2);

exports.validatePolymeshData = validatePolymeshData;
exports.checkGeometryCache = checkGeometryCache;
exports.clearGeometryCache = clearGeometryCache;
exports.cacheGeometry = cacheGeometry;
exports.convertToPolyMesh = convertToPolyMesh;
exports.convertToBingeom = convertToBingeom;
exports.convertToCNSPolyMesh = convertToCNSPolyMesh;

var _polyMesh = __webpack_require__(161);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validateAndRetype(data) {
  if (data instanceof Uint32Array) return data;else if (data instanceof ArrayBuffer) return new Uint32Array(data);else if (typeof Buffer !== 'undefined' && data instanceof Buffer) {
    return new Uint32Array(new Uint8Array(data).buffer);
  }

  throw new Error('Invalid bingeom type: ' + (typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)));
}

function extractFooter(data) {
  var jsonLength = data[data.length - 2];
  if (!jsonLength) throw new Error('No footer in bingeom');
  var charData = new Uint8Array(data.buffer);
  var len = charData.byteLength - 8;
  charData = charData.subarray(len - jsonLength, len);
  return JSON.parse(String.fromCharCode.apply(null, charData));
}

function validateDataInfo(dataInfo) {
  return dataInfo !== undefined && typeof dataInfo.o === 'number' && typeof dataInfo.l === 'number';
}

function validatePolymeshData(jsonData) {
  return jsonData && validateDataInfo(jsonData.faceCount) && validateDataInfo(jsonData.faces) && validateDataInfo(jsonData.positions);
}

function assert(truthy, message) {
  if (!truthy) throw new Error(message);
}

var RawUintByteSize = { 1: 'RawUint8', 2: 'RawUint16', 4: 'RawUint32' };

var types = {
  RawUint8: { shift: 0, arr: Uint8Array },
  RawUint16: { shift: 1, arr: Uint16Array },
  RawUint32: { shift: 2, arr: Uint32Array },
  RawFloat32: { shift: 2, arr: Float32Array }
};

function readArray(buffer, jsonData) {
  var dataType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!jsonData) return dataType ? new types[dataType].arr(0) : [];
  var typeinfo = types[dataType || RawUintByteSize[jsonData.b || 4]];
  return new typeinfo.arr(buffer, jsonData.o, jsonData.l >> typeinfo.shift);
}

function noTriangulation(faces, faceSize) {
  return faces;
}

function staticTriangulation(faces, faceSize) {
  if (faces.length % faceSize !== 0) throw new Error('Invalid face index array');
  var trianglePerFace = faceSize - 2;
  var nbFaces = 3 * (faces.length * trianglePerFace) / faceSize; // number of triangulated faces

  var newFaces = new faces.constructor(nbFaces);
  for (var inn = 0, out = 0, il = faces.length; out < il;) {
    var first = faces[out++];
    var second = faces[out++];
    for (var j = trianglePerFace; j > 0; --j) {
      newFaces[inn++] = first;
      newFaces[inn++] = second;
      second = faces[out++];
      newFaces[inn++] = second;
    }
  }

  return newFaces;
}

function dynamicTriangulation(faces, faceCount) {
  var fl = faceCount.length;
  var nbFaces = -(fl << 1); // starts at -2*fl because the number of triangle in on face 'x' is faceCount[x]-2
  for (var i = fl - 1; i >= 0; --i) {
    nbFaces += faceCount[i];
  }var newFaces = new faces.constructor(nbFaces * 3); // can reuse the same constructor as faces because the max index is the same
  for (var inn = 0, out = 0, f = 0, _fl = faceCount.length; f < _fl; ++f) {
    var first = faces[out++];
    var second = faces[out++];
    for (var j = faceCount[f] - 2; j > 0; --j) {
      newFaces[inn++] = first;
      newFaces[inn++] = second;
      second = faces[out++];
      newFaces[inn++] = second;
    }
  }

  return newFaces;
}

var geometryCache = {};
var polyMeshCaches = {};

function checkGeometryCache(hash) {
  return geometryCache[hash];
}

function clearGeometryCache() {
  geometryCache = {};
  polyMeshCaches = {};
}

/*
 * cache geometry by file hash. This might break when we start adding
 * on operators, so verify that.
 */
function cacheGeometry(hash, geometry) {
  geometryCache[hash] = geometry;
  return geometry;
}

function convertToPolyMesh(data) {
  var binaryData = validateAndRetype(data);
  var jsonData = extractFooter(binaryData);
  //console.log('extracted footer: ', jsonData);
  var buffer = binaryData.buffer;
  assert(validatePolymeshData(jsonData), 'Invalid Polymesh Data?');

  var positions = readArray(buffer, jsonData.positions, 'RawFloat32');
  var fc = readArray(buffer, jsonData.faceCount);
  var faceCount = fc;
  if (fc.length === 1) faceCount = fc[0];
  var triangulationFunction = fc.length === 1 ? fc[0] !== 3 ? staticTriangulation : noTriangulation : dynamicTriangulation;
  var faces = triangulationFunction(readArray(buffer, jsonData.faces), faceCount);

  // normalMap
  var normalMap = jsonData.normalMap && {
    faces: triangulationFunction(readArray(buffer, jsonData.normalMap.faces), faceCount),
    values: readArray(buffer, jsonData.normalMap.values, 'RawFloat32')
  };

  var uvs = null;

  // uvMaps
  if (jsonData.uvMaps && (0, _keys2.default)(jsonData.uvMaps).length) {
    uvs = {};
    for (var attr in jsonData.uvMaps) {
      if (jsonData.uvMaps.hasOwnProperty(attr)) {
        var map = jsonData.uvMaps[attr];
        // TODO for vray?: if (options.uvsToVec3Array) throw new Error('vec3ForUvs');

        uvs[attr] = {
          faces: triangulationFunction(readArray(buffer, map.faces), faceCount),
          values: readArray(buffer, map.values, 'RawFloat32')
        };
      }
    }
  }

  // // extra data
  // if (tmp = jsonData.materialIds) {//this.materialIds = reader.readArray(tmp, "RawUint32");
  //   let rawMtl = reader.readArray(tmp, "RawUint32");
  //   if (triangulationFunction !== noTriangulation) {  // noTriangulation, material id already correct!
  //     let nbTriangulatedFaces = this.faces.length / 3;    // already know the right size of the material ids array
  //
  //     let materialTriangulationFunction = (triangulationFunction === staticTriangulation) ? staticMaterialTriangulation : dynamicMaterialTriangulation;
  //     rawMtl = materialTriangulationFunction(rawMtl, faceCount, nbTriangulatedFaces);
  //   }
  //   this.materialIds = rawMtl;
  // }
  // return this;
  return { positions: positions, faces: faces, normalMap: normalMap, uvs: uvs };
}

var BIN_VERSION = 1000;
//Things to change when we eventually upgrade the format
// - remove all references to poseBoneToWorldTransform
// - materialIds should be a Uint8Array or at least a Uint16Array
// - materialIds could also be deprecated in favor of material ranges

/*
 * Convert PolyMesh to bingeom
 *
 */
function convertToBingeom(polyMesh) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  //{ positions, faces, normalMap, uvs }) {
  var jsonFooter = { blendShapes: {}, colorMaps: {} }; //, uvMaps: { 'default': {}} };
  var byteLength = 0;
  var buffers = [];
  var bufferFooters = [];

  function extract(key, typedArray, footer, readInto) {
    var sourceBuf = readInto ? new readInto(typedArray) : typedArray;
    var buf = new Uint8Array(sourceBuf.buffer, sourceBuf.byteOffset, typedArray.byteLength);

    // pad buffer if necessary to maintain 4-byte alignment
    var overBytes = buf.byteLength % 4;
    var padBytes = 0;
    if (overBytes) {
      padBytes = 4 - overBytes;
      var paddedBuf = new Uint8Array(buf.byteLength + padBytes);
      paddedBuf.set(buf);
      buf = paddedBuf;
    }

    var reuseFooter = null;
    for (var i = 0; i < buffers.length; i++) {
      if (equalsArrayBuffers(buf, buffers[i])) {
        reuseFooter = bufferFooters[i];
        break;
      }
    }

    if (reuseFooter !== null) {
      footer[key] = reuseFooter;
    } else {
      var bytesPerElement = readInto ? readInto.BYTES_PER_ELEMENT : typedArray.BYTES_PER_ELEMENT;
      footer[key] = {
        b: bytesPerElement,
        l: buf.byteLength - padBytes,
        o: byteLength
      };
      byteLength += buf.byteLength;
      buffers.push(buf);
      bufferFooters.push(footer[key]);
    }
    //console.log( "extract: key", key, "result", footer[key], (reuseFooter !== null ) ? 'deduped' : '');
  }

  function equalsArrayBuffers(a, b) {
    // a and b must be Uint8Arrays.

    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  }

  function offsetsSum(offsets) {
    var arr = new Uint32Array(offsets.length - 1);
    for (var i = 0; i < offsets.length - 1; i++) {
      arr[i] = offsets[i + 1] - offsets[i];
    }

    return arr;
  }

  extract('faces', polyMesh.positions.faceValueIndices, jsonFooter);
  extract('faceCount', offsetsSum(polyMesh.faceRangeOffsets), jsonFooter);
  extract('positions', polyMesh.positions.values.data, jsonFooter, Float32Array);

  if (polyMesh.normalMap) {
    jsonFooter.normalMap = {};
    extract('faces', polyMesh.normalMap.faceValueIndices, jsonFooter.normalMap);
    extract('values', polyMesh.normalMap.values.data, jsonFooter.normalMap, Float32Array);
  }

  if (polyMesh.tangentMap && polyMesh.tangentMap.length) {
    jsonFooter.tangentMap = {};
    extract('faces', polyMesh.tangentMap.faceValueIndices, jsonFooter.tangentMap);
    extract('values', polyMesh.tangentMap.values.data, jsonFooter.tangentMap, Float32Array);
  }

  if (polyMesh.uvMaps && polyMesh.uvMaps.length) {
    jsonFooter.uvMaps = {};
    polyMesh.uvMaps.namesByIndex.forEach(function (uvName) {
      var uvMap = polyMesh.uvMaps.byName[uvName];
      jsonFooter.uvMaps[uvName] = {};
      extract('faces', uvMap.faceValueIndices, jsonFooter.uvMaps[uvName]);
      extract('values', uvMap.values.data, jsonFooter.uvMaps[uvName], Float32Array);
    });
  }

  if (polyMesh.edgeCreaseWeights && polyMesh.edgeCreaseWeights.length) {
    extract('edgeCreaseWeights', polyMesh.edgeCreaseWeights, jsonFooter, Float32Array); // don't need to convert, already Float32Array...?
  }

  if (polyMesh.skinning) {
    jsonFooter.skinning = {};
    extract('positionSkinRange', polyMesh.skinning.positionSkinRange, jsonFooter.skinning);
    extract('skinWeights', polyMesh.skinning.skinWeights, jsonFooter.skinning);
    extract('poseSkinToPoseBoneTransform', polyMesh.skinning.poseSkinToPoseBoneTransform.data, jsonFooter.skinning, Float32Array);
    extract('skinBoneIndices', polyMesh.skinning.skinBoneIndices, jsonFooter.skinning);
  }

  if (polyMesh.materialIds) {
    extract('materialIds', polyMesh.materialIds, jsonFooter, Uint32Array);
  }

  if (polyMesh.blendShapes) {
    for (var name in polyMesh.blendShapes) {
      jsonFooter.blendShapes[name] = {};
      extract('positions', polyMesh.blendShapes[name].positions.data, jsonFooter.blendShapes[name], Float32Array);
      if (polyMesh.blendShapes[name].normals) {
        extract('normals', polyMesh.blendShapes[name].normals.data, jsonFooter.blendShapes[name], Float32Array);
      }
      if (polyMesh.blendShapes[name].weights) {
        extract('weights', polyMesh.blendShapes[name].weights.data, jsonFooter.blendShapes[name], Float32Array);
      }
    }
  }

  var jsonFooterString = (0, _stringify2.default)(jsonFooter);
  jsonFooterString += { 0: '', 1: '   ', 2: '  ', 3: ' ' }[jsonFooterString.length % 4];

  var currentByte = 0;
  var result = new Uint8Array(byteLength + jsonFooterString.length + 8);
  for (var i = 0; i < buffers.length; i++) {
    result.set(buffers[i], currentByte);
    currentByte += buffers[i].byteLength;
  }

  for (var _i = 0; _i < jsonFooterString.length; _i++) {
    result[currentByte++] = jsonFooterString.charCodeAt(_i);
  }

  var currentDWord = currentByte >> 2;
  var newBytes32 = new Uint32Array(result.buffer);
  newBytes32[currentDWord] = jsonFooterString.length;
  newBytes32[currentDWord + 1] = BIN_VERSION;
  if (options.fbx) return new Uint8Array(result.buffer);
  return new Uint32Array(result.buffer);
}

function convertToCNSPolyMesh(data, refId) {
  if (refId && polyMeshCaches[refId]) return polyMeshCaches[refId];

  var binaryData = validateAndRetype(data);
  var jsonData = extractFooter(binaryData);
  var buffer = binaryData.buffer;

  var has = Object.prototype.hasOwnProperty;

  if (jsonData && !jsonData.faceCount && !jsonData.faces && !jsonData.positions) {
    console.warn('Warning: PolyMesh is empty.');
    return new _polyMesh.PolyMesh();
  }

  assert(validatePolymeshData(jsonData), 'Invalid Polymesh Data?');

  var fc = readArray(buffer, jsonData.faceCount);
  //console.log( 'CNS', CNS );
  var importer = new _polyMesh.Importer();
  //console.log( 'importer', importer );
  if (fc.length === 1) {
    importer.defaultFaceArity = fc[0];
  } else {
    importer.setFaceArities(fc);
  }

  importer.collapsePositions = false;
  importer.collapseMapValues = false;

  var positionFaceIndices = readArray(buffer, jsonData.faces);
  var positionValues = readArray(buffer, jsonData.positions, 'RawFloat32');

  var positionsId = _polyMesh.PolyMaps.id(_polyMesh.PolyMaps.TypePosition);

  importer.setMapIndices(positionsId, positionFaceIndices);
  importer.setMapValues(positionsId, positionValues);

  // normalMap
  // if normals are not present in final polyMesh (see further down), we default to a flat normal map
  if (jsonData.normalMap) {
    var normalFaceIndices = readArray(buffer, jsonData.normalMap.faces);
    var normalValues = readArray(buffer, jsonData.normalMap.values, 'RawFloat32');

    var normalsId = _polyMesh.PolyMaps.id(_polyMesh.PolyMaps.TypeNormal);

    importer.setMapIndices(normalsId, normalFaceIndices);
    importer.setMapValues(normalsId, normalValues);
  }

  // uvMaps
  if (jsonData.uvMaps && (0, _keys2.default)(jsonData.uvMaps).length) {
    for (var attr in jsonData.uvMaps) {
      if (has.call(jsonData.uvMaps, attr)) {
        var map = jsonData.uvMaps[attr];

        var uvFaceIndices = readArray(buffer, map.faces);
        var uvValues = readArray(buffer, map.values, 'RawFloat32');

        var uvsId = _polyMesh.PolyMaps.id(_polyMesh.PolyMaps.TypeUV, attr);

        importer.setMapIndices(uvsId, uvFaceIndices);
        importer.setMapValues(uvsId, uvValues);
      }
    }
  }

  // tangentMap
  if (jsonData.tangentMap) {
    var tangentFaceIndices = readArray(buffer, jsonData.tangentMap.faces);
    var tangentValues = readArray(buffer, jsonData.tangentMap.values, 'RawFloat32');

    var tangentsId = _polyMesh.PolyMaps.id(_polyMesh.PolyMaps.TypeTangent);

    importer.setMapIndices(tangentsId, tangentFaceIndices);
    importer.setMapValues(tangentsId, tangentValues);
  }

  // blendShapes
  if (jsonData.blendShapes) {
    importer.initializeBlendShape();

    for (var name in jsonData.blendShapes) {
      if (has.call(jsonData.blendShapes, name)) {
        var jsonBlendShape = jsonData.blendShapes[name];

        var positions = readArray(buffer, jsonBlendShape.positions, 'RawFloat32');
        var normals = !!jsonBlendShape.normals ? readArray(buffer, jsonBlendShape.normals, 'RawFloat32') : null;
        var weights = !!jsonBlendShape.weights ? readArray(buffer, jsonBlendShape.weights, 'RawFloat32') : null;

        importer.setBlendShapes(name, positions, normals, weights);
      }
    }
  }

  // skinning
  if (jsonData.skinning) {
    importer.setSkinning(readArray(buffer, jsonData.skinning.positionSkinRange, 'RawUint32'), readArray(buffer, jsonData.skinning.skinWeights, 'RawFloat32'), readArray(buffer, jsonData.skinning.skinBoneIndices, 'RawUint16'), readArray(buffer, jsonData.skinning.poseSkinToPoseBoneTransform, 'RawFloat32'));
  }

  // edge creases
  // Can come in 2 forms:
  //  1) 'creases': Imported from fbx. Contains an edge crease weights array and an array of
  //                vertex index pairs for the corresponding creased edges
  //  2) 'edgeCreaseWeights': A single array of weights, where the edge is implied by the index, which
  //                corresponds to the V2 polyMesh edge index. This form is preferred.
  if (jsonData.edgeCreaseWeights) importer.setCreases(readArray(buffer, jsonData.edgeCreaseWeights, 'RawFloat32'));else if (jsonData.creases) {
    var _weights = readArray(buffer, jsonData.creases.weights, 'RawFloat32');
    var edges = readArray(buffer, jsonData.creases.edgeVertexIndices, 'RawUint32');
    importer.setCreases(_weights, edges);
  }

  if (jsonData.materialIds) {
    importer.setMaterialIds(readArray(buffer, jsonData.materialIds, 'RawUint32'));
  }

  // TODO: add support for UVs.
  // TODO: add support for Colors.

  var polyMesh = importer.toMeshAndClear();
  //console.log('bingeom jsonDate ', jsonData);
  //console.log('bingeom.js convertToCNSPolyMesh ', polyMesh );

  if (refId) polyMeshCaches[refId] = polyMesh;
  return polyMesh;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(99).Buffer))

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getViewScale = getViewScale;
exports.drawMoveGizmo = drawMoveGizmo;
exports.drawRotateGizmo = drawRotateGizmo;
exports.drawScaleGizmo = drawScaleGizmo;
exports.highlightAxis = highlightAxis;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _player = __webpack_require__(8);

var _selection = __webpack_require__(45);

var _scene = __webpack_require__(7);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var axisColors = { x: 0xff0000, y: 0x00ff00, z: 0x0000ff };

var materials = {
  x: new THREE.MeshStandardMaterial({ color: axisColors.x, depthTest: false }),
  y: new THREE.MeshStandardMaterial({ color: axisColors.y, depthTest: false }),
  z: new THREE.MeshStandardMaterial({ color: axisColors.z, depthTest: false })
};

var lineRadius = 0.02;

function cancelAxis(axis) {
  materials[axis].color = new THREE.Color(axisColors[axis]);
  materials[axis].needsUpdate = true;
}

function resetMaterials() {
  ['x', 'y', 'z'].forEach(cancelAxis);
}

function getViewScale(store) {
  var viewRect = (0, _player.getRect)(store);
  var posObj = new THREE.Vector3().copy(viewRect.height < viewRect.width ? { x: 0, y: 0.4, z: 0 } : { x: 0.4, y: 0, z: 0 });

  var node = (0, _selection.getSelectedNodes)(store)[0];
  if (!node) return 0;
  var nodePosition = new THREE.Vector3().setFromMatrixPosition((0, _scene.getWorldTransform)(store, node));

  var camera = (0, _player.getThreeCamera)(store);
  var cameraPosition = new THREE.Vector3().setFromMatrixPosition(camera.matrix);

  var inverseProjectionMatrix = new THREE.Matrix4().getInverse(camera.projectionMatrix, true);
  var referencePoint = new THREE.Vector3().copy(nodePosition).applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  referencePoint.add(posObj).applyMatrix4(inverseProjectionMatrix).applyMatrix4(camera.matrix);

  var scale = referencePoint.sub(nodePosition).length();
  return scale;
}

function drawMoveGizmo() {
  resetMaterials();
  var coneRadius = 0.08;
  var cone = new THREE.ConeGeometry(coneRadius, 0.25, 25);
  var yArrow = new THREE.CylinderGeometry(lineRadius, lineRadius, 2, 32);
  var cone2 = cone.clone();
  cone.translate(0, 1, 0);
  cone2.rotateX(Math.PI);
  cone2.translate(0, -1, 0);
  yArrow.merge(cone);
  yArrow.merge(cone2);

  var zArrow = yArrow.clone();
  var xArrow = yArrow.clone();

  var yMesh = new THREE.Mesh(yArrow, materials.y);
  yMesh.axis = 'y';

  zArrow.rotateX(Math.PI / 2);
  var zMesh = new THREE.Mesh(zArrow, materials.z);
  zMesh.axis = 'z';

  xArrow.rotateZ(Math.PI / 2);
  var xMesh = new THREE.Mesh(xArrow, materials.x);
  xMesh.axis = 'x';

  var moveGizmo = new THREE.Object3D();
  moveGizmo.add(xMesh);
  moveGizmo.add(yMesh);
  moveGizmo.add(zMesh);

  return moveGizmo;
}

function drawRotateGizmo() {
  resetMaterials();
  var xRotation = new THREE.TorusGeometry(1, lineRadius, 16, 100);
  var yRotation = xRotation.clone();
  var zRotation = xRotation.clone();

  xRotation.rotateY(Math.PI / 2);
  yRotation.rotateX(Math.PI / 2);

  var rotateGizmo = new THREE.Object3D();
  var xMesh = new THREE.Mesh(xRotation, materials.x);
  xMesh.axis = 'x';
  var yMesh = new THREE.Mesh(yRotation, materials.y);
  yMesh.axis = 'y';
  var zMesh = new THREE.Mesh(zRotation, materials.z);
  zMesh.axis = 'z';
  rotateGizmo.add(xMesh);
  rotateGizmo.add(yMesh);
  rotateGizmo.add(zMesh);

  return rotateGizmo;
}

function drawScaleGizmo() {
  resetMaterials();
  var boxWidth = 0.2;
  var box = new THREE.BoxGeometry(boxWidth, boxWidth, boxWidth);
  var yArrow = new THREE.CylinderGeometry(lineRadius, lineRadius, 1, 32);
  yArrow.translate(0, 0.5, 0);
  //const box2 = box.clone();
  box.translate(0, 1, 0);
  //box2.rotateX(Math.PI);
  //box2.translate(0, -1, 0);
  yArrow.merge(box);
  //yArrow.merge(box2);

  var zArrow = yArrow.clone();
  var xArrow = yArrow.clone();

  var yMesh = new THREE.Mesh(yArrow, materials.y);
  yMesh.axis = 'y';

  zArrow.rotateX(Math.PI / 2);
  var zMesh = new THREE.Mesh(zArrow, materials.z);
  zMesh.axis = 'z';

  xArrow.rotateZ(-Math.PI / 2);
  var xMesh = new THREE.Mesh(xArrow, materials.x);
  xMesh.axis = 'x';

  var scaleGizmo = new THREE.Object3D();
  scaleGizmo.add(xMesh);
  scaleGizmo.add(yMesh);
  scaleGizmo.add(zMesh);

  return scaleGizmo;
}

function highlightAxis(translator, ev, activeAxis) {
  var axis = null;
  var x = ev.clientX / (ev.rect.width / 2) - 1;
  var y = -(ev.clientY / (ev.rect.height / 2) - 1);
  var hits = translator.raycastSelect({ x: x, y: y }, 'Widgets');

  if (hits && hits[0] && hits[0].node && hits[0].node.axis) {
    if (activeAxis) cancelAxis(activeAxis);
    axis = hits[0].node.axis;
    materials[axis].color = new THREE.Color(1, 1, 0);
    materials[axis].needsUpdate = true;
    translator.postTranslate('normal', true);
  } else if (activeAxis) {
    cancelAxis(activeAxis);
    translator.postTranslate('normal', true);
  }

  return axis;
}

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clamp;
function clamp(value, min, max) {
  return Math.max(Math.min(value, max), min);
}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(514), __esModule: true };

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(523), __esModule: true };

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(57);
var IObject = __webpack_require__(171);
var toObject = __webpack_require__(83);
var toLength = __webpack_require__(136);
var asc = __webpack_require__(537);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 168 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(27);
var document = __webpack_require__(29).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 170 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(108);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(133);
var $export = __webpack_require__(11);
var redefine = __webpack_require__(175);
var hide = __webpack_require__(62);
var has = __webpack_require__(61);
var Iterators = __webpack_require__(81);
var $iterCreate = __webpack_require__(545);
var setToStringTag = __webpack_require__(111);
var getPrototypeOf = __webpack_require__(273);
var ITERATOR = __webpack_require__(25)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(107);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 174 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(62);


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(177)('keys');
var uid = __webpack_require__(137);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(29);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(57);
var invoke = __webpack_require__(543);
var html = __webpack_require__(263);
var cel = __webpack_require__(169);
var global = __webpack_require__(29);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(108)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 179 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(27);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(29);
var core = __webpack_require__(9);
var LIBRARY = __webpack_require__(133);
var wksExt = __webpack_require__(182);
var defineProperty = __webpack_require__(41).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(25);


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(132);
var ITERATOR = __webpack_require__(25)('iterator');
var Iterators = __webpack_require__(81);
module.exports = __webpack_require__(9).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(77);
var toAbsoluteIndex = __webpack_require__(94);
var toLength = __webpack_require__(30);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(53);
var toLength = __webpack_require__(30);
var toAbsoluteIndex = __webpack_require__(94);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(88);
var TAG = __webpack_require__(16)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(26);
var createDesc = __webpack_require__(75);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(14);
var document = __webpack_require__(13).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 189 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(16)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(88);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(89);
var ITERATOR = __webpack_require__(16)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 193 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),
/* 194 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(14);
var anObject = __webpack_require__(12);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(52)(Function.call, __webpack_require__(63).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(197)('keys');
var uid = __webpack_require__(78);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(13);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(12);
var aFunction = __webpack_require__(73);
var SPECIES = __webpack_require__(16)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(289);
var defined = __webpack_require__(74);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(52);
var invoke = __webpack_require__(286);
var html = __webpack_require__(284);
var cel = __webpack_require__(188);
var global = __webpack_require__(13);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(88)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(13);
var hide = __webpack_require__(42);
var uid = __webpack_require__(78);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(186);
var ITERATOR = __webpack_require__(16)('iterator');
var Iterators = __webpack_require__(89);
module.exports = __webpack_require__(113).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(86);
var step = __webpack_require__(292);
var Iterators = __webpack_require__(89);
var toIObject = __webpack_require__(53);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(291)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asap", function() { return asap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return cast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Promise", function() { return Promise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventTarget", function() { return EventTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return all$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allSettled", function() { return allSettled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "race", function() { return race$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hash", function() { return hash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hashSettled", function() { return hashSettled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rethrow", function() { return rethrow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defer", function() { return defer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "denodeify", function() { return denodeify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configure", function() { return configure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "off", function() { return off; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolve", function() { return resolve$2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reject", function() { return reject$2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "async", function() { return async; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });
var require;/*!
 * @overview RSVP - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2016 Yehuda Katz, Tom Dale, Stefan Penner and contributors
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
 * @version   3.6.2
 */

function indexOf(callbacks, callback) {
  for (var i = 0, l = callbacks.length; i < l; i++) {
    if (callbacks[i] === callback) {
      return i;
    }
  }

  return -1;
}

function callbacksFor(object) {
  var callbacks = object._promiseCallbacks;

  if (!callbacks) {
    callbacks = object._promiseCallbacks = {};
  }

  return callbacks;
}

/**
  @class RSVP.EventTarget
*/
var EventTarget = {

  /**
    `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For
    Example:
     ```javascript
    let object = {};
     RSVP.EventTarget.mixin(object);
     object.on('finished', function(event) {
      // handle event
    });
     object.trigger('finished', { detail: value });
    ```
     `EventTarget.mixin` also works with prototypes:
     ```javascript
    let Person = function() {};
    RSVP.EventTarget.mixin(Person.prototype);
     let yehuda = new Person();
    let tom = new Person();
     yehuda.on('poke', function(event) {
      console.log('Yehuda says OW');
    });
     tom.on('poke', function(event) {
      console.log('Tom says OW');
    });
     yehuda.trigger('poke');
    tom.trigger('poke');
    ```
     @method mixin
    @for RSVP.EventTarget
    @private
    @param {Object} object object to extend with EventTarget methods
  */
  mixin: function (object) {
    object['on'] = this['on'];
    object['off'] = this['off'];
    object['trigger'] = this['trigger'];
    object._promiseCallbacks = undefined;
    return object;
  },


  /**
    Registers a callback to be executed when `eventName` is triggered
     ```javascript
    object.on('event', function(eventInfo){
      // handle the event
    });
     object.trigger('event');
    ```
     @method on
    @for RSVP.EventTarget
    @private
    @param {String} eventName name of the event to listen for
    @param {Function} callback function to be called when the event is triggered.
  */
  on: function (eventName, callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('Callback must be a function');
    }

    var allCallbacks = callbacksFor(this),
        callbacks = void 0;

    callbacks = allCallbacks[eventName];

    if (!callbacks) {
      callbacks = allCallbacks[eventName] = [];
    }

    if (indexOf(callbacks, callback) === -1) {
      callbacks.push(callback);
    }
  },


  /**
    You can use `off` to stop firing a particular callback for an event:
     ```javascript
    function doStuff() { // do stuff! }
    object.on('stuff', doStuff);
     object.trigger('stuff'); // doStuff will be called
     // Unregister ONLY the doStuff callback
    object.off('stuff', doStuff);
    object.trigger('stuff'); // doStuff will NOT be called
    ```
     If you don't pass a `callback` argument to `off`, ALL callbacks for the
    event will not be executed when the event fires. For example:
     ```javascript
    let callback1 = function(){};
    let callback2 = function(){};
     object.on('stuff', callback1);
    object.on('stuff', callback2);
     object.trigger('stuff'); // callback1 and callback2 will be executed.
     object.off('stuff');
    object.trigger('stuff'); // callback1 and callback2 will not be executed!
    ```
     @method off
    @for RSVP.EventTarget
    @private
    @param {String} eventName event to stop listening to
    @param {Function} callback optional argument. If given, only the function
    given will be removed from the event's callback queue. If no `callback`
    argument is given, all callbacks will be removed from the event's callback
    queue.
  */
  off: function (eventName, callback) {
    var allCallbacks = callbacksFor(this),
        callbacks = void 0,
        index = void 0;

    if (!callback) {
      allCallbacks[eventName] = [];
      return;
    }

    callbacks = allCallbacks[eventName];

    index = indexOf(callbacks, callback);

    if (index !== -1) {
      callbacks.splice(index, 1);
    }
  },


  /**
    Use `trigger` to fire custom events. For example:
     ```javascript
    object.on('foo', function(){
      console.log('foo event happened!');
    });
    object.trigger('foo');
    // 'foo event happened!' logged to the console
    ```
     You can also pass a value as a second argument to `trigger` that will be
    passed as an argument to all event listeners for the event:
     ```javascript
    object.on('foo', function(value){
      console.log(value.name);
    });
     object.trigger('foo', { name: 'bar' });
    // 'bar' logged to the console
    ```
     @method trigger
    @for RSVP.EventTarget
    @private
    @param {String} eventName name of the event to be triggered
    @param {*} options optional value to be passed to any event handlers for
    the given `eventName`
  */
  trigger: function (eventName, options, label) {
    var allCallbacks = callbacksFor(this),
        callbacks = void 0,
        callback = void 0;

    if (callbacks = allCallbacks[eventName]) {
      // Don't cache the callbacks.length since it may grow
      for (var i = 0; i < callbacks.length; i++) {
        callback = callbacks[i];

        callback(options, label);
      }
    }
  }
};

var config = {
  instrument: false
};

EventTarget['mixin'](config);

function configure(name, value) {
  if (arguments.length === 2) {
    config[name] = value;
  } else {
    return config[name];
  }
}

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}

function isObject(x) {
  return x !== null && typeof x === 'object';
}

function isMaybeThenable(x) {
  return x !== null && typeof x === 'object';
}

var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

// Date.now is not available in browsers < IE9
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
var now = Date.now || function () {
  return new Date().getTime();
};

var queue = [];

function scheduleFlush() {
  setTimeout(function () {
    for (var i = 0; i < queue.length; i++) {
      var entry = queue[i];

      var payload = entry.payload;

      payload.guid = payload.key + payload.id;
      payload.childGuid = payload.key + payload.childId;
      if (payload.error) {
        payload.stack = payload.error.stack;
      }

      config['trigger'](entry.name, entry.payload);
    }
    queue.length = 0;
  }, 50);
}

function instrument(eventName, promise, child) {
  if (1 === queue.push({
    name: eventName,
    payload: {
      key: promise._guidKey,
      id: promise._id,
      eventName: eventName,
      detail: promise._result,
      childId: child && child._id,
      label: promise._label,
      timeStamp: now(),
      error: config["instrument-with-stack"] ? new Error(promise._label) : null
    } })) {
    scheduleFlush();
  }
}

/**
  `RSVP.Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new RSVP.Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = RSVP.Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {*} object value that the returned promise will be resolved with
  @param {String} label optional string for identifying the returned promise.
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object, label) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop, label);
  resolve(promise, object);
  return promise;
}

function withOwnPromise() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  config.async(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value, undefined);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    thenable._onError = null;
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      if (thenable !== value) {
        resolve(promise, value, undefined);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  var isOwnThenable = maybeThenable.constructor === promise.constructor && then$$1 === then && promise.constructor.resolve === resolve$1;

  if (isOwnThenable) {
    handleOwnThenable(promise, maybeThenable);
  } else if (then$$1 === GET_THEN_ERROR) {
    reject(promise, GET_THEN_ERROR.error);
    GET_THEN_ERROR.error = null;
  } else if (isFunction(then$$1)) {
    handleForeignThenable(promise, maybeThenable, then$$1);
  } else {
    fulfill(promise, maybeThenable);
  }
}

function resolve(promise, value) {
  if (promise === value) {
    fulfill(promise, value);
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onError) {
    promise._onError(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length === 0) {
    if (config.instrument) {
      instrument('fulfilled', promise);
    }
  } else {
    config.async(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;
  config.async(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var subscribers = parent._subscribers;
  var length = subscribers.length;

  parent._onError = null;

  subscribers[length] = child;
  subscribers[length + FULFILLED] = onFulfillment;
  subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    config.async(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (config.instrument) {
    instrument(settled === FULFILLED ? 'fulfilled' : 'rejected', promise);
  }

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      result = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, result);
    } else {
      callback(result);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, result) {
  try {
    return callback(result);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(state, promise, callback, result) {
  var hasCallback = isFunction(callback);
  var value = void 0,
      error = void 0;

  if (hasCallback) {
    value = tryCatch(callback, result);

    if (value === TRY_CATCH_ERROR) {
      error = value.error;
      value.error = null; // release
    } else if (value === promise) {
      reject(promise, withOwnPromise());
      return;
    }
  } else {
    value = result;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && error === undefined) {
    resolve(promise, value);
  } else if (error !== undefined) {
    reject(promise, error);
  } else if (state === FULFILLED) {
    fulfill(promise, value);
  } else if (state === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  var resolved = false;
  try {
    resolver(function (value) {
      if (resolved) {
        return;
      }
      resolved = true;
      resolve(promise, value);
    }, function (reason) {
      if (resolved) {
        return;
      }
      resolved = true;
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

function then(onFulfillment, onRejection, label) {
  var parent = this;
  var state = parent._state;

  if (state === FULFILLED && !onFulfillment || state === REJECTED && !onRejection) {
    config.instrument && instrument('chained', parent, parent);
    return parent;
  }

  parent._onError = null;

  var child = new parent.constructor(noop, label);
  var result = parent._result;

  config.instrument && instrument('chained', parent, child);

  if (state === PENDING) {
    subscribe(parent, child, onFulfillment, onRejection);
  } else {
    var callback = state === FULFILLED ? onFulfillment : onRejection;
    config.async(function () {
      return invokeCallback(state, child, callback, result);
    });
  }

  return child;
}

var Enumerator = function () {
  function Enumerator(Constructor, input, abortOnReject, label) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop, label);
    this._abortOnReject = abortOnReject;

    this._init.apply(this, arguments);
  }

  Enumerator.prototype._init = function _init(Constructor, input) {
    var len = input.length || 0;
    this.length = len;
    this._remaining = len;
    this._result = new Array(len);

    this._enumerate(input);
    if (this._remaining === 0) {
      fulfill(this.promise, this._result);
    }
  };

  Enumerator.prototype._enumerate = function _enumerate(input) {
    var length = this.length;
    var promise = this.promise;

    for (var i = 0; promise._state === PENDING && i < length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._settleMaybeThenable = function _settleMaybeThenable(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;

    if (resolve$$1 === resolve$1) {
      var then$$1 = getThen(entry);

      if (then$$1 === then && entry._state !== PENDING) {
        entry._onError = null;
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof then$$1 !== 'function') {
        this._remaining--;
        this._result[i] = this._makeResult(FULFILLED, i, entry);
      } else if (c === Promise) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, then$$1);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    if (isMaybeThenable(entry)) {
      this._settleMaybeThenable(entry, i);
    } else {
      this._remaining--;
      this._result[i] = this._makeResult(FULFILLED, i, entry);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;

    if (promise._state === PENDING) {
      if (this._abortOnReject && state === REJECTED) {
        reject(promise, value);
      } else {
        this._remaining--;
        this._result[i] = this._makeResult(state, i, value);
        if (this._remaining === 0) {
          fulfill(promise, this._result);
        }
      }
    }
  };

  Enumerator.prototype._makeResult = function _makeResult(state, i, value) {
    return value;
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

function makeSettledResult(state, position, value) {
  if (state === FULFILLED) {
    return {
      state: 'fulfilled',
      value: value
    };
  } else {
    return {
      state: 'rejected',
      reason: value
    };
  }
}

/**
  `RSVP.Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.resolve(2);
  let promise3 = RSVP.resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  RSVP.Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `RSVP.all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.reject(new Error("2"));
  let promise3 = RSVP.reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  RSVP.Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries, label) {
  if (!isArray(entries)) {
    return this.reject(new TypeError("Promise.all must be called with an array"), label);
  }
  return new Enumerator(this, entries, true /* abort on reject */, label).promise;
}

/**
  `RSVP.Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  RSVP.Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `RSVP.Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  RSVP.Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  RSVP.Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} entries array of promises to observe
  @param {String} label optional string for describing the promise returned.
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries, label) {
  /*jshint validthis:true */
  var Constructor = this;

  var promise = new Constructor(noop, label);

  if (!isArray(entries)) {
    reject(promise, new TypeError('Promise.race must be called with an array'));
    return promise;
  }

  for (var i = 0; promise._state === PENDING && i < entries.length; i++) {
    subscribe(Constructor.resolve(entries[i]), undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }

  return promise;
}

/**
  `RSVP.Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new RSVP.Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = RSVP.Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {*} reason value that the returned promise will be rejected with.
  @param {String} label optional string for identifying the returned promise.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason, label) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop, label);
  reject(promise, reason);
  return promise;
}

var guidKey = 'rsvp_' + now() + '-';
var counter = 0;

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promises eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class RSVP.Promise
  @param {function} resolver
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @constructor
*/

var Promise = function () {
  function Promise(resolver, label) {
    this._id = counter++;
    this._label = label;
    this._state = undefined;
    this._result = undefined;
    this._subscribers = [];

    config.instrument && instrument('created', this);

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  Promise.prototype._onError = function _onError(reason) {
    var _this = this;

    config.after(function () {
      if (_this._onError) {
        config.trigger('error', reason, _this._label);
      }
    });
  };

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn\'t find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection, label) {
    return this.then(undefined, onRejection, label);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuthor();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuthor();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback, label) {
    var promise = this;
    var constructor = promise.constructor;

    return promise.then(function (value) {
      return constructor.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      return constructor.resolve(callback()).then(function () {
        throw reason;
      });
    }, label);
  };

  return Promise;
}();



Promise.cast = resolve$1; // deprecated
Promise.all = all;
Promise.race = race;
Promise.resolve = resolve$1;
Promise.reject = reject$1;

Promise.prototype._guidKey = guidKey;

/**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.

  ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```

  Chaining
  --------

  The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.

  ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });

  findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we\'re unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we\'re unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

  ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```

  Assimilation
  ------------

  Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.

  ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```

  If the assimliated promise rejects, then the downstream promise will also reject.

  ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```

  Simple Example
  --------------

  Synchronous Example

  ```javascript
  let result;

  try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```

  Errback Example

  ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```

  Promise Example;

  ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```

  Advanced Example
  --------------

  Synchronous Example

  ```javascript
  let author, books;

  try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```

  Errback Example

  ```js

  function foundBooks(books) {

  }

  function failure(reason) {

  }

  findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```

  Promise Example;

  ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```

  @method then
  @param {Function} onFulfillment
  @param {Function} onRejection
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise}
*/
Promise.prototype.then = then;

function Result() {
  this.value = undefined;
}

var ERROR = new Result();
var GET_THEN_ERROR$1 = new Result();

function getThen$1(obj) {
  try {
    return obj.then;
  } catch (error) {
    ERROR.value = error;
    return ERROR;
  }
}

function tryApply(f, s, a) {
  try {
    f.apply(s, a);
  } catch (error) {
    ERROR.value = error;
    return ERROR;
  }
}

function makeObject(_, argumentNames) {
  var obj = {};
  var length = _.length;
  var args = new Array(length);

  for (var x = 0; x < length; x++) {
    args[x] = _[x];
  }

  for (var i = 0; i < argumentNames.length; i++) {
    var name = argumentNames[i];
    obj[name] = args[i + 1];
  }

  return obj;
}

function arrayResult(_) {
  var length = _.length;
  var args = new Array(length - 1);

  for (var i = 1; i < length; i++) {
    args[i - 1] = _[i];
  }

  return args;
}

function wrapThenable(then, promise) {
  return {
    then: function (onFulFillment, onRejection) {
      return then.call(promise, onFulFillment, onRejection);
    }
  };
}

/**
  `RSVP.denodeify` takes a 'node-style' function and returns a function that
  will return an `RSVP.Promise`. You can use `denodeify` in Node.js or the
  browser when you'd prefer to use promises over using callbacks. For example,
  `denodeify` transforms the following:

  ```javascript
  let fs = require('fs');

  fs.readFile('myfile.txt', function(err, data){
    if (err) return handleError(err);
    handleData(data);
  });
  ```

  into:

  ```javascript
  let fs = require('fs');
  let readFile = RSVP.denodeify(fs.readFile);

  readFile('myfile.txt').then(handleData, handleError);
  ```

  If the node function has multiple success parameters, then `denodeify`
  just returns the first one:

  ```javascript
  let request = RSVP.denodeify(require('request'));

  request('http://example.com').then(function(res) {
    // ...
  });
  ```

  However, if you need all success parameters, setting `denodeify`'s
  second parameter to `true` causes it to return all success parameters
  as an array:

  ```javascript
  let request = RSVP.denodeify(require('request'), true);

  request('http://example.com').then(function(result) {
    // result[0] -> res
    // result[1] -> body
  });
  ```

  Or if you pass it an array with names it returns the parameters as a hash:

  ```javascript
  let request = RSVP.denodeify(require('request'), ['res', 'body']);

  request('http://example.com').then(function(result) {
    // result.res
    // result.body
  });
  ```

  Sometimes you need to retain the `this`:

  ```javascript
  let app = require('express')();
  let render = RSVP.denodeify(app.render.bind(app));
  ```

  The denodified function inherits from the original function. It works in all
  environments, except IE 10 and below. Consequently all properties of the original
  function are available to you. However, any properties you change on the
  denodeified function won't be changed on the original function. Example:

  ```javascript
  let request = RSVP.denodeify(require('request')),
      cookieJar = request.jar(); // <- Inheritance is used here

  request('http://example.com', {jar: cookieJar}).then(function(res) {
    // cookieJar.cookies holds now the cookies returned by example.com
  });
  ```

  Using `denodeify` makes it easier to compose asynchronous operations instead
  of using callbacks. For example, instead of:

  ```javascript
  let fs = require('fs');

  fs.readFile('myfile.txt', function(err, data){
    if (err) { ... } // Handle error
    fs.writeFile('myfile2.txt', data, function(err){
      if (err) { ... } // Handle error
      console.log('done')
    });
  });
  ```

  you can chain the operations together using `then` from the returned promise:

  ```javascript
  let fs = require('fs');
  let readFile = RSVP.denodeify(fs.readFile);
  let writeFile = RSVP.denodeify(fs.writeFile);

  readFile('myfile.txt').then(function(data){
    return writeFile('myfile2.txt', data);
  }).then(function(){
    console.log('done')
  }).catch(function(error){
    // Handle error
  });
  ```

  @method denodeify
  @static
  @for RSVP
  @param {Function} nodeFunc a 'node-style' function that takes a callback as
  its last argument. The callback expects an error to be passed as its first
  argument (if an error occurred, otherwise null), and the value from the
  operation as its second argument ('function(err, value){ }').
  @param {Boolean|Array} [options] An optional paramter that if set
  to `true` causes the promise to fulfill with the callback's success arguments
  as an array. This is useful if the node function has multiple success
  paramters. If you set this paramter to an array with names, the promise will
  fulfill with a hash with these names as keys and the success parameters as
  values.
  @return {Function} a function that wraps `nodeFunc` to return an
  `RSVP.Promise`
  @static
*/
function denodeify(nodeFunc, options) {
  var fn = function () {
    var self = this;
    var l = arguments.length;
    var args = new Array(l + 1);
    var promiseInput = false;

    for (var i = 0; i < l; ++i) {
      var arg = arguments[i];

      if (!promiseInput) {
        // TODO: clean this up
        promiseInput = needsPromiseInput(arg);
        if (promiseInput === GET_THEN_ERROR$1) {
          var p = new Promise(noop);
          reject(p, GET_THEN_ERROR$1.value);
          return p;
        } else if (promiseInput && promiseInput !== true) {
          arg = wrapThenable(promiseInput, arg);
        }
      }
      args[i] = arg;
    }

    var promise = new Promise(noop);

    args[l] = function (err, val) {
      if (err) reject(promise, err);else if (options === undefined) resolve(promise, val);else if (options === true) resolve(promise, arrayResult(arguments));else if (isArray(options)) resolve(promise, makeObject(arguments, options));else resolve(promise, val);
    };

    if (promiseInput) {
      return handlePromiseInput(promise, args, nodeFunc, self);
    } else {
      return handleValueInput(promise, args, nodeFunc, self);
    }
  };

  fn.__proto__ = nodeFunc;

  return fn;
}

function handleValueInput(promise, args, nodeFunc, self) {
  var result = tryApply(nodeFunc, self, args);
  if (result === ERROR) {
    reject(promise, result.value);
  }
  return promise;
}

function handlePromiseInput(promise, args, nodeFunc, self) {
  return Promise.all(args).then(function (args) {
    var result = tryApply(nodeFunc, self, args);
    if (result === ERROR) {
      reject(promise, result.value);
    }
    return promise;
  });
}

function needsPromiseInput(arg) {
  if (arg && typeof arg === 'object') {
    if (arg.constructor === Promise) {
      return true;
    } else {
      return getThen$1(arg);
    }
  } else {
    return false;
  }
}

/**
  This is a convenient alias for `RSVP.Promise.all`.

  @method all
  @static
  @for RSVP
  @param {Array} array Array of promises.
  @param {String} label An optional label. This is useful
  for tooling.
*/
function all$1(array, label) {
  return Promise.all(array, label);
}

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AllSettled = function (_Enumerator) {
  _inherits(AllSettled, _Enumerator);

  function AllSettled(Constructor, entries, label) {
    return _possibleConstructorReturn(this, _Enumerator.call(this, Constructor, entries, false /* don't abort on reject */, label));
  }

  return AllSettled;
}(Enumerator);

AllSettled.prototype._makeResult = makeSettledResult;

/**
`RSVP.allSettled` is similar to `RSVP.all`, but instead of implementing
a fail-fast method, it waits until all the promises have returned and
shows you all the results. This is useful if you want to handle multiple
promises' failure states together as a set.
 Returns a promise that is fulfilled when all the given promises have been
settled. The return promise is fulfilled with an array of the states of
the promises passed into the `promises` array argument.
 Each state object will either indicate fulfillment or rejection, and
provide the corresponding value or reason. The states will take one of
the following formats:
 ```javascript
{ state: 'fulfilled', value: value }
  or
{ state: 'rejected', reason: reason }
```
 Example:
 ```javascript
let promise1 = RSVP.Promise.resolve(1);
let promise2 = RSVP.Promise.reject(new Error('2'));
let promise3 = RSVP.Promise.reject(new Error('3'));
let promises = [ promise1, promise2, promise3 ];
 RSVP.allSettled(promises).then(function(array){
  // array == [
  //   { state: 'fulfilled', value: 1 },
  //   { state: 'rejected', reason: Error },
  //   { state: 'rejected', reason: Error }
  // ]
  // Note that for the second item, reason.message will be '2', and for the
  // third item, reason.message will be '3'.
}, function(error) {
  // Not run. (This block would only be called if allSettled had failed,
  // for instance if passed an incorrect argument type.)
});
```
 @method allSettled
@static
@for RSVP
@param {Array} entries
@param {String} label - optional string that describes the promise.
Useful for tooling.
@return {Promise} promise that is fulfilled with an array of the settled
states of the constituent promises.
*/

function allSettled(entries, label) {
  if (!isArray(entries)) {
    return Promise.reject(new TypeError("Promise.allSettled must be called with an array"), label);
  }

  return new AllSettled(Promise, entries, label).promise;
}

/**
  This is a convenient alias for `RSVP.Promise.race`.

  @method race
  @static
  @for RSVP
  @param {Array} array Array of promises.
  @param {String} label An optional label. This is useful
  for tooling.
 */
function race$1(array, label) {
  return Promise.race(array, label);
}

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var hasOwnProperty = Object.prototype.hasOwnProperty;

var PromiseHash = function (_Enumerator) {
  _inherits$1(PromiseHash, _Enumerator);

  function PromiseHash(Constructor, object) {
    var abortOnReject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var label = arguments[3];
    return _possibleConstructorReturn$1(this, _Enumerator.call(this, Constructor, object, abortOnReject, label));
  }

  PromiseHash.prototype._init = function _init(Constructor, object) {
    this._result = {};

    this._enumerate(object);
    if (this._remaining === 0) {
      fulfill(this.promise, this._result);
    }
  };

  PromiseHash.prototype._enumerate = function _enumerate(input) {
    var promise = this.promise;
    var results = [];

    for (var key in input) {
      if (hasOwnProperty.call(input, key)) {
        results.push({
          position: key,
          entry: input[key]
        });
      }
    }

    var length = results.length;
    this._remaining = length;
    var result = void 0;

    for (var i = 0; promise._state === PENDING && i < length; i++) {
      result = results[i];
      this._eachEntry(result.entry, result.position);
    }
  };

  return PromiseHash;
}(Enumerator);

/**
  `RSVP.hash` is similar to `RSVP.all`, but takes an object instead of an array
  for its `promises` argument.

  Returns a promise that is fulfilled when all the given promises have been
  fulfilled, or rejected if any of them become rejected. The returned promise
  is fulfilled with a hash that has the same key names as the `promises` object
  argument. If any of the values in the object are not promises, they will
  simply be copied over to the fulfilled object.

  Example:

  ```javascript
  let promises = {
    myPromise: RSVP.resolve(1),
    yourPromise: RSVP.resolve(2),
    theirPromise: RSVP.resolve(3),
    notAPromise: 4
  };

  RSVP.hash(promises).then(function(hash){
    // hash here is an object that looks like:
    // {
    //   myPromise: 1,
    //   yourPromise: 2,
    //   theirPromise: 3,
    //   notAPromise: 4
    // }
  });
  ````

  If any of the `promises` given to `RSVP.hash` are rejected, the first promise
  that is rejected will be given as the reason to the rejection handler.

  Example:

  ```javascript
  let promises = {
    myPromise: RSVP.resolve(1),
    rejectedPromise: RSVP.reject(new Error('rejectedPromise')),
    anotherRejectedPromise: RSVP.reject(new Error('anotherRejectedPromise')),
  };

  RSVP.hash(promises).then(function(hash){
    // Code here never runs because there are rejected promises!
  }, function(reason) {
    // reason.message === 'rejectedPromise'
  });
  ```

  An important note: `RSVP.hash` is intended for plain JavaScript objects that
  are just a set of keys and values. `RSVP.hash` will NOT preserve prototype
  chains.

  Example:

  ```javascript
  function MyConstructor(){
    this.example = RSVP.resolve('Example');
  }

  MyConstructor.prototype = {
    protoProperty: RSVP.resolve('Proto Property')
  };

  let myObject = new MyConstructor();

  RSVP.hash(myObject).then(function(hash){
    // protoProperty will not be present, instead you will just have an
    // object that looks like:
    // {
    //   example: 'Example'
    // }
    //
    // hash.hasOwnProperty('protoProperty'); // false
    // 'undefined' === typeof hash.protoProperty
  });
  ```

  @method hash
  @static
  @for RSVP
  @param {Object} object
  @param {String} label optional string that describes the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all properties of `promises`
  have been fulfilled, or rejected if any of them become rejected.
*/
function hash(object, label) {
  if (!isObject(object)) {
    return Promise.reject(new TypeError("Promise.hash must be called with an object"), label);
  }

  return new PromiseHash(Promise, object, label).promise;
}

function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HashSettled = function (_PromiseHash) {
  _inherits$2(HashSettled, _PromiseHash);

  function HashSettled(Constructor, object, label) {
    return _possibleConstructorReturn$2(this, _PromiseHash.call(this, Constructor, object, false, label));
  }

  return HashSettled;
}(PromiseHash);

HashSettled.prototype._makeResult = makeSettledResult;

/**
  `RSVP.hashSettled` is similar to `RSVP.allSettled`, but takes an object
  instead of an array for its `promises` argument.

  Unlike `RSVP.all` or `RSVP.hash`, which implement a fail-fast method,
  but like `RSVP.allSettled`, `hashSettled` waits until all the
  constituent promises have returned and then shows you all the results
  with their states and values/reasons. This is useful if you want to
  handle multiple promises' failure states together as a set.

  Returns a promise that is fulfilled when all the given promises have been
  settled, or rejected if the passed parameters are invalid.

  The returned promise is fulfilled with a hash that has the same key names as
  the `promises` object argument. If any of the values in the object are not
  promises, they will be copied over to the fulfilled object and marked with state
  'fulfilled'.

  Example:

  ```javascript
  let promises = {
    myPromise: RSVP.Promise.resolve(1),
    yourPromise: RSVP.Promise.resolve(2),
    theirPromise: RSVP.Promise.resolve(3),
    notAPromise: 4
  };

  RSVP.hashSettled(promises).then(function(hash){
    // hash here is an object that looks like:
    // {
    //   myPromise: { state: 'fulfilled', value: 1 },
    //   yourPromise: { state: 'fulfilled', value: 2 },
    //   theirPromise: { state: 'fulfilled', value: 3 },
    //   notAPromise: { state: 'fulfilled', value: 4 }
    // }
  });
  ```

  If any of the `promises` given to `RSVP.hash` are rejected, the state will
  be set to 'rejected' and the reason for rejection provided.

  Example:

  ```javascript
  let promises = {
    myPromise: RSVP.Promise.resolve(1),
    rejectedPromise: RSVP.Promise.reject(new Error('rejection')),
    anotherRejectedPromise: RSVP.Promise.reject(new Error('more rejection')),
  };

  RSVP.hashSettled(promises).then(function(hash){
    // hash here is an object that looks like:
    // {
    //   myPromise:              { state: 'fulfilled', value: 1 },
    //   rejectedPromise:        { state: 'rejected', reason: Error },
    //   anotherRejectedPromise: { state: 'rejected', reason: Error },
    // }
    // Note that for rejectedPromise, reason.message == 'rejection',
    // and for anotherRejectedPromise, reason.message == 'more rejection'.
  });
  ```

  An important note: `RSVP.hashSettled` is intended for plain JavaScript objects that
  are just a set of keys and values. `RSVP.hashSettled` will NOT preserve prototype
  chains.

  Example:

  ```javascript
  function MyConstructor(){
    this.example = RSVP.Promise.resolve('Example');
  }

  MyConstructor.prototype = {
    protoProperty: RSVP.Promise.resolve('Proto Property')
  };

  let myObject = new MyConstructor();

  RSVP.hashSettled(myObject).then(function(hash){
    // protoProperty will not be present, instead you will just have an
    // object that looks like:
    // {
    //   example: { state: 'fulfilled', value: 'Example' }
    // }
    //
    // hash.hasOwnProperty('protoProperty'); // false
    // 'undefined' === typeof hash.protoProperty
  });
  ```

  @method hashSettled
  @for RSVP
  @param {Object} object
  @param {String} label optional string that describes the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when when all properties of `promises`
  have been settled.
  @static
*/

function hashSettled(object, label) {
  if (!isObject(object)) {
    return Promise.reject(new TypeError("RSVP.hashSettled must be called with an object"), label);
  }

  return new HashSettled(Promise, object, false, label).promise;
}

/**
  `RSVP.rethrow` will rethrow an error on the next turn of the JavaScript event
  loop in order to aid debugging.

  Promises A+ specifies that any exceptions that occur with a promise must be
  caught by the promises implementation and bubbled to the last handler. For
  this reason, it is recommended that you always specify a second rejection
  handler function to `then`. However, `RSVP.rethrow` will throw the exception
  outside of the promise, so it bubbles up to your console if in the browser,
  or domain/cause uncaught exception in Node. `rethrow` will also throw the
  error again so the error can be handled by the promise per the spec.

  ```javascript
  function throws(){
    throw new Error('Whoops!');
  }

  let promise = new RSVP.Promise(function(resolve, reject){
    throws();
  });

  promise.catch(RSVP.rethrow).then(function(){
    // Code here doesn't run because the promise became rejected due to an
    // error!
  }, function (err){
    // handle the error here
  });
  ```

  The 'Whoops' error will be thrown on the next turn of the event loop
  and you can watch for it in your console. You can also handle it using a
  rejection handler given to `.then` or `.catch` on the returned promise.

  @method rethrow
  @static
  @for RSVP
  @param {Error} reason reason the promise became rejected.
  @throws Error
  @static
*/
function rethrow(reason) {
  setTimeout(function () {
    throw reason;
  });
  throw reason;
}

/**
  `RSVP.defer` returns an object similar to jQuery's `$.Deferred`.
  `RSVP.defer` should be used when porting over code reliant on `$.Deferred`'s
  interface. New code should use the `RSVP.Promise` constructor instead.

  The object returned from `RSVP.defer` is a plain object with three properties:

  * promise - an `RSVP.Promise`.
  * reject - a function that causes the `promise` property on this object to
    become rejected
  * resolve - a function that causes the `promise` property on this object to
    become fulfilled.

  Example:

   ```javascript
   let deferred = RSVP.defer();

   deferred.resolve("Success!");

   deferred.promise.then(function(value){
     // value here is "Success!"
   });
   ```

  @method defer
  @static
  @for RSVP
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Object}
 */

function defer(label) {
  var deferred = { resolve: undefined, reject: undefined };

  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  }, label);

  return deferred;
}

/**
 `RSVP.map` is similar to JavaScript's native `map` method, except that it
  waits for all promises to become fulfilled before running the `mapFn` on
  each item in given to `promises`. `RSVP.map` returns a promise that will
  become fulfilled with the result of running `mapFn` on the values the promises
  become fulfilled with.

  For example:

  ```javascript

  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.resolve(2);
  let promise3 = RSVP.resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  let mapFn = function(item){
    return item + 1;
  };

  RSVP.map(promises, mapFn).then(function(result){
    // result is [ 2, 3, 4 ]
  });
  ```

  If any of the `promises` given to `RSVP.map` are rejected, the first promise
  that is rejected will be given as an argument to the returned promise's
  rejection handler. For example:

  ```javascript
  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.reject(new Error('2'));
  let promise3 = RSVP.reject(new Error('3'));
  let promises = [ promise1, promise2, promise3 ];

  let mapFn = function(item){
    return item + 1;
  };

  RSVP.map(promises, mapFn).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(reason) {
    // reason.message === '2'
  });
  ```

  `RSVP.map` will also wait if a promise is returned from `mapFn`. For example,
  say you want to get all comments from a set of blog posts, but you need
  the blog posts first because they contain a url to those comments.

  ```javscript

  let mapFn = function(blogPost){
    // getComments does some ajax and returns an RSVP.Promise that is fulfilled
    // with some comments data
    return getComments(blogPost.comments_url);
  };

  // getBlogPosts does some ajax and returns an RSVP.Promise that is fulfilled
  // with some blog post data
  RSVP.map(getBlogPosts(), mapFn).then(function(comments){
    // comments is the result of asking the server for the comments
    // of all blog posts returned from getBlogPosts()
  });
  ```

  @method map
  @static
  @for RSVP
  @param {Array} promises
  @param {Function} mapFn function to be called on each fulfilled promise.
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled with the result of calling
  `mapFn` on each fulfilled promise or value when they become fulfilled.
   The promise will be rejected if any of the given `promises` become rejected.
  @static
*/
function map(promises, mapFn, label) {
  if (!isArray(promises)) {
    return Promise.reject(new TypeError("RSVP.map must be called with an array"), label);
  }

  if (!isFunction(mapFn)) {
    return Promise.reject(new TypeError("RSVP.map expects a function as a second argument"), label);
  }

  return Promise.all(promises, label).then(function (values) {
    var length = values.length;
    var results = new Array(length);

    for (var i = 0; i < length; i++) {
      results[i] = mapFn(values[i]);
    }

    return Promise.all(results, label);
  });
}

/**
  This is a convenient alias for `RSVP.Promise.resolve`.

  @method resolve
  @static
  @for RSVP
  @param {*} value value that the returned promise will be resolved with
  @param {String} label optional string for identifying the returned promise.
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$2(value, label) {
  return Promise.resolve(value, label);
}

/**
  This is a convenient alias for `RSVP.Promise.reject`.

  @method reject
  @static
  @for RSVP
  @param {*} reason value that the returned promise will be rejected with.
  @param {String} label optional string for identifying the returned promise.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$2(reason, label) {
  return Promise.reject(reason, label);
}

/**
 `RSVP.filter` is similar to JavaScript's native `filter` method, except that it
  waits for all promises to become fulfilled before running the `filterFn` on
  each item in given to `promises`. `RSVP.filter` returns a promise that will
  become fulfilled with the result of running `filterFn` on the values the
  promises become fulfilled with.

  For example:

  ```javascript

  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.resolve(2);
  let promise3 = RSVP.resolve(3);

  let promises = [promise1, promise2, promise3];

  let filterFn = function(item){
    return item > 1;
  };

  RSVP.filter(promises, filterFn).then(function(result){
    // result is [ 2, 3 ]
  });
  ```

  If any of the `promises` given to `RSVP.filter` are rejected, the first promise
  that is rejected will be given as an argument to the returned promise's
  rejection handler. For example:

  ```javascript
  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.reject(new Error('2'));
  let promise3 = RSVP.reject(new Error('3'));
  let promises = [ promise1, promise2, promise3 ];

  let filterFn = function(item){
    return item > 1;
  };

  RSVP.filter(promises, filterFn).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(reason) {
    // reason.message === '2'
  });
  ```

  `RSVP.filter` will also wait for any promises returned from `filterFn`.
  For instance, you may want to fetch a list of users then return a subset
  of those users based on some asynchronous operation:

  ```javascript

  let alice = { name: 'alice' };
  let bob   = { name: 'bob' };
  let users = [ alice, bob ];

  let promises = users.map(function(user){
    return RSVP.resolve(user);
  });

  let filterFn = function(user){
    // Here, Alice has permissions to create a blog post, but Bob does not.
    return getPrivilegesForUser(user).then(function(privs){
      return privs.can_create_blog_post === true;
    });
  };
  RSVP.filter(promises, filterFn).then(function(users){
    // true, because the server told us only Alice can create a blog post.
    users.length === 1;
    // false, because Alice is the only user present in `users`
    users[0] === bob;
  });
  ```

  @method filter
  @static
  @for RSVP
  @param {Array} promises
  @param {Function} filterFn - function to be called on each resolved value to
  filter the final results.
  @param {String} label optional string describing the promise. Useful for
  tooling.
  @return {Promise}
*/

function resolveAll(promises, label) {
  return Promise.all(promises, label);
}

function resolveSingle(promise, label) {
  return Promise.resolve(promise, label).then(function (promises) {
    return resolveAll(promises, label);
  });
}

function filter(promises, filterFn, label) {
  if (!isArray(promises) && !(isObject(promises) && promises.then !== undefined)) {
    return Promise.reject(new TypeError("RSVP.filter must be called with an array or promise"), label);
  }

  if (!isFunction(filterFn)) {
    return Promise.reject(new TypeError("RSVP.filter expects function as a second argument"), label);
  }

  var promise = isArray(promises) ? resolveAll(promises, label) : resolveSingle(promises, label);
  return promise.then(function (values) {
    var length = values.length;
    var filtered = new Array(length);

    for (var i = 0; i < length; i++) {
      filtered[i] = filterFn(values[i]);
    }

    return resolveAll(filtered, label).then(function (filtered) {
      var results = new Array(length);
      var newLength = 0;

      for (var _i = 0; _i < length; _i++) {
        if (filtered[_i]) {
          results[newLength] = values[_i];
          newLength++;
        }
      }

      results.length = newLength;

      return results;
    });
  });
}

var len = 0;
var vertxNext = void 0;
function asap(callback, arg) {
  queue$1[len] = callback;
  queue$1[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 1, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    scheduleFlush$1();
  }
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  var nextTick = process.nextTick;
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // setImmediate should be used instead instead
  var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
  if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
    nextTick = setImmediate;
  }
  return function () {
    return nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }
  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    return node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  return function () {
    return setTimeout(flush, 1);
  };
}

var queue$1 = new Array(1000);

function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue$1[i];
    var arg = queue$1[i + 1];

    callback(arg);

    queue$1[i] = undefined;
    queue$1[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertex() {
  try {
    var r = require;
    var vertx = __webpack_require__(719);
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush$1 = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush$1 = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush$1 = useMutationObserver();
} else if (isWorker) {
  scheduleFlush$1 = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush$1 = attemptVertex();
} else {
  scheduleFlush$1 = useSetTimeout();
}

var platform = void 0;

/* global self */
if (typeof self === 'object') {
  platform = self;

  /* global global */
} else if (typeof global === 'object') {
  platform = global;
} else {
  throw new Error('no global: `self` or `global` found');
}

var _asap$cast$Promise$Ev;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// defaults
config.async = asap;
config.after = function (cb) {
  return setTimeout(cb, 0);
};
var cast = resolve$2;

var async = function (callback, arg) {
  return config.async(callback, arg);
};

function on() {
  config['on'].apply(config, arguments);
}

function off() {
  config['off'].apply(config, arguments);
}

// Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`
if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
  var callbacks = window['__PROMISE_INSTRUMENTATION__'];
  configure('instrument', true);
  for (var eventName in callbacks) {
    if (callbacks.hasOwnProperty(eventName)) {
      on(eventName, callbacks[eventName]);
    }
  }
}

// the default export here is for backwards compat:
//   https://github.com/tildeio/rsvp.js/issues/434
var rsvp = (_asap$cast$Promise$Ev = {
  asap: asap,
  cast: cast,
  Promise: Promise,
  EventTarget: EventTarget,
  all: all$1,
  allSettled: allSettled,
  race: race$1,
  hash: hash,
  hashSettled: hashSettled,
  rethrow: rethrow,
  defer: defer,
  denodeify: denodeify,
  configure: configure,
  on: on,
  off: off,
  resolve: resolve$2,
  reject: reject$2,
  map: map
}, _defineProperty(_asap$cast$Promise$Ev, 'async', async), _defineProperty(_asap$cast$Promise$Ev, 'filter', filter), _asap$cast$Promise$Ev);

/* harmony default export */ __webpack_exports__["default"] = (rsvp);

//# sourceMappingURL=rsvp.es.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(146), __webpack_require__(696).setImmediate, __webpack_require__(66)))

/***/ }),
/* 205 */
/***/ (function(module, exports) {

module.exports = {
  array: Array.isArray,
  primitive: function(s) { return typeof s === 'string' || typeof s === 'number'; },
};


/***/ }),
/* 206 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__(47);

var _stringify2 = _interopRequireDefault(_stringify);

var _isInteger = __webpack_require__(260);

var _isInteger2 = _interopRequireDefault(_isInteger);

var _three = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function initVector3(from) {
  if (!from) return new _three.Vector3();
  if (from.isVector3) return from;
  if (from.hasOwnProperty('x')) return new _three.Vector3(from.x, from.y, from.z);
  if (Array.isArray(from)) return new _three.Vector3(from[0], from[1], from[2]);
  return new _three.Vector3();
}

function initVector2(from) {
  if (!from) return new _three.Vector2();
  if (from.isVector2) return from;
  if (from.hasOwnProperty('x')) return new _three.Vector2(from.x, from.y);
  if (Array.isArray(from)) return new _three.Vector2(from[0], from[1]);
  return new _three.Vector2();
}

function initColor(from) {
  if ((0, _isInteger2.default)(from)) return new _three.Color(from); //hex value
  if (!from) return new _three.Color();
  if (typeof from === 'string') {
    var color = new _three.Color();
    color.setHex(parseInt('0x' + from.replace('#', '')));
    return color;
  }
  if (Array.isArray(from)) return new _three.Color(from[0], from[1], from[2]);
  if (from.hasOwnProperty('r')) return new _three.Color(from.r, from.g, from.b);
  return new _three.Color();
}

var schemaTypes = {
  Boolean: function Boolean(schema) {
    var defaultValue = schema.defaultValue || false;

    return {
      defaultValue: defaultValue,

      set: function set(val) {
        return val == null ? defaultValue : !!val;
      }
    };
  },

  Label: function Label(schema) {
    return {
      set: function set(val) {
        return typeof val === 'string' ? val : '';
      }
    };
  },

  Number: function (_Number) {
    function Number(_x) {
      return _Number.apply(this, arguments);
    }

    Number.toString = function () {
      return _Number.toString();
    };

    return Number;
  }(function (schema) {
    var min = schema.minValue;
    var max = schema.maxValue;
    var defaultValue = schema.defaultValue || 0;

    var clamp = void 0;

    if (min !== undefined && max !== undefined) clamp = function clamp(v) {
      return Math.min(Math.max(min, v), max);
    };else if (min !== undefined) clamp = function clamp(v) {
      return Math.max(v, min);
    };else if (max !== undefined) clamp = function clamp(v) {
      return Math.min(v, max);
    };else clamp = function clamp(v) {
      return v;
    };

    return {
      defaultValue: defaultValue,

      set: function set(val) {
        var num = Number(val);
        if (isNaN(num)) return defaultValue;
        return Math.round(clamp(num) * 10000) / 10000;
      }
    };
  }),

  Integer: function Integer(schema) {
    var min = schema.minValue;
    var max = schema.maxValue;
    var defaultValue = schema.defaultValue || 0;

    var clamp = void 0;

    if (min !== undefined && max !== undefined) clamp = function clamp(v) {
      return Math.min(Math.max(min, v), max);
    };else if (min !== undefined) clamp = function clamp(v) {
      return Math.max(v, min);
    };else if (max !== undefined) clamp = function clamp(v) {
      return Math.min(v, max);
    };else clamp = function clamp(v) {
      return v;
    };

    return {
      defaultValue: defaultValue,

      set: function set(val) {
        var num = Number(val);
        if (isNaN(num)) return defaultValue;
        return Math.round(clamp(num));
      }
    };
  },

  Plug: function Plug(schema) {
    if (!schema.plug) throw new Error('plug property expects a `plug` property');

    return {
      isPlugReference: schema.plug,

      set: function set(id) {
        if (id && id.id) return id.id;
        return id;
      }
    };
  },

  Options: function Options(schema) {
    var defaultValue = schema.defaultValue;
    return {
      defaultValue: defaultValue,

      set: function set(val) {
        return val == null ? defaultValue : val;
      }
    };
  },

  Image: function Image(schema) {
    return {
      isFileReference: true,

      set: function set(id) {
        if (id && id.id) return id.id;
        return id; // ? FileReference({id}) : null;
      }
    };
  },

  Binary: function Binary(schema) {
    return {
      isFileReference: true,

      set: function set(id) {
        if (id && id.id) return id.id;
        return id; // ? FileReference({id}) : null;
      }
    };
  },

  File: function File(schema) {
    return {
      isFileReference: true,

      set: function set(id) {
        if (id && id.id) return id.id;
        return id; // ? FileReference({id}) : null;
      }
    };
  },

  Object: function Object(schema) {
    var defaultValue = schema.defaultValue || {};
    return {
      set: function set(obj) {
        return obj || defaultValue;
      },

      equals: function equals(val1, val2) {
        return (0, _stringify2.default)(val1) === (0, _stringify2.default)(val2);
      }
    };
  },

  String: function String(schema) {
    var defaultValue = schema.defaultValue || '';

    return {
      defaultValue: defaultValue,

      set: function set(str) {
        return typeof str === 'string' ? str : defaultValue;
      }
    };
  },

  TextArea: function TextArea(schema) {
    //same as String for now
    var defaultValue = schema.defaultValue || '';

    return {
      defaultValue: defaultValue,

      set: function set(str) {
        return typeof str === 'string' ? str : defaultValue;
      }
    };
  },

  Node: function Node(schema) {
    return {
      isNodeReference: true,

      set: function set(id) {
        if (id && id.id) return id.id;
        return id;
      }
    };
  },

  NodeList: function NodeList(schema) {
    return {
      isReferenceList: true,

      set: function set(ids) {
        if (Array.isArray(ids)) {
          return ids.map(function (id) {
            return id && id.id ? id.id : id;
          });
        }

        return [];
      },

      equals: function equals(val1, val2) {
        return (0, _stringify2.default)(val1) === (0, _stringify2.default)(val2);
      }
    };
  },

  Vec2: function Vec2(schema) {
    var defaultValue = initVector2(schema.defaultValue);

    return {
      defaultValue: defaultValue,

      set: function set(val) {
        return initVector2(val || defaultValue);
      },

      get: function get(val) {
        return val.clone();
      },

      equals: function equals(val1, val2) {
        return val1 && val2 && val1.equals(val2);
      }
    };
  },

  Color: function Color(schema) {
    var defaultValue = initColor(schema.defaultValue);

    return {
      defaultValue: defaultValue,

      set: function set(val) {
        return initColor(val !== undefined ? val : defaultValue);
      },

      get: function get(val) {
        return val.clone();
      },

      equals: function equals(val1, val2) {
        return val1 && val2 && val1.equals(val2);
      }
    };
  },

  Vec3: function Vec3(schema) {
    var defaultValue = initVector3(schema.defaultValue);

    return {
      defaultValue: defaultValue,

      set: function set(val) {
        return initVector3(val || defaultValue);
      },

      get: function get(val) {
        return val.clone();
      },

      equals: function equals(val1, val2) {
        return val1 && val2 && val1.equals(val2);
      }
    };
  }
};

exports.default = schemaTypes;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
// The Bounding Box object

function derive(v0, v1, v2, v3, t) {
    return Math.pow(1 - t, 3) * v0 + 3 * Math.pow(1 - t, 2) * t * v1 + 3 * (1 - t) * Math.pow(t, 2) * v2 + Math.pow(t, 3) * v3;
}
/**
 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
 * It is used to calculate the bounding box of a glyph or text path.
 *
 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
 *
 * @exports opentype.BoundingBox
 * @class
 * @constructor
 */
function BoundingBox() {
    this.x1 = Number.NaN;
    this.y1 = Number.NaN;
    this.x2 = Number.NaN;
    this.y2 = Number.NaN;
}

/**
 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
 */
BoundingBox.prototype.isEmpty = function () {
    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};

/**
 * Add the point to the bounding box.
 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
 * @param {number} x - The X coordinate of the point.
 * @param {number} y - The Y coordinate of the point.
 */
BoundingBox.prototype.addPoint = function (x, y) {
    if (typeof x === 'number') {
        if (isNaN(this.x1) || isNaN(this.x2)) {
            this.x1 = x;
            this.x2 = x;
        }
        if (x < this.x1) {
            this.x1 = x;
        }
        if (x > this.x2) {
            this.x2 = x;
        }
    }
    if (typeof y === 'number') {
        if (isNaN(this.y1) || isNaN(this.y2)) {
            this.y1 = y;
            this.y2 = y;
        }
        if (y < this.y1) {
            this.y1 = y;
        }
        if (y > this.y2) {
            this.y2 = y;
        }
    }
};

/**
 * Add a X coordinate to the bounding box.
 * This extends the bounding box to include the X coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} x - The X coordinate of the point.
 */
BoundingBox.prototype.addX = function (x) {
    this.addPoint(x, null);
};

/**
 * Add a Y coordinate to the bounding box.
 * This extends the bounding box to include the Y coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} y - The Y coordinate of the point.
 */
BoundingBox.prototype.addY = function (y) {
    this.addPoint(null, y);
};

/**
 * Add a Bzier curve to the bounding box.
 * This extends the bounding box to include the entire Bzier.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the first control point.
 * @param {number} y1 - The Y coordinate of the first control point.
 * @param {number} x2 - The X coordinate of the second control point.
 * @param {number} y2 - The Y coordinate of the second control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */
BoundingBox.prototype.addBezier = function (x0, y0, x1, y1, x2, y2, x, y) {
    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
    // and https://github.com/icons8/svg-path-bounding-box

    var p0 = [x0, y0];
    var p1 = [x1, y1];
    var p2 = [x2, y2];
    var p3 = [x, y];

    this.addPoint(x0, y0);
    this.addPoint(x, y);

    for (var i = 0; i <= 1; i++) {
        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        var c = 3 * p1[i] - 3 * p0[i];

        if (a === 0) {
            if (b === 0) continue;
            var t = -c / b;
            if (0 < t && t < 1) {
                if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t));
                if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t));
            }
            continue;
        }

        var b2ac = Math.pow(b, 2) - 4 * c * a;
        if (b2ac < 0) continue;
        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
        if (0 < t1 && t1 < 1) {
            if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1));
            if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1));
        }
        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
        if (0 < t2 && t2 < 1) {
            if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2));
            if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2));
        }
    }
};

/**
 * Add a quadratic curve to the bounding box.
 * This extends the bounding box to include the entire quadratic curve.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the control point.
 * @param {number} y1 - The Y coordinate of the control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */
BoundingBox.prototype.addQuad = function (x0, y0, x1, y1, x, y) {
    var cp1x = x0 + 2 / 3 * (x1 - x0);
    var cp1y = y0 + 2 / 3 * (y1 - y0);
    var cp2x = cp1x + 1 / 3 * (x - x0);
    var cp2y = cp1y + 1 / 3 * (y - y0);
    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};

exports.default = BoundingBox;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _draw = __webpack_require__(320);

var _draw2 = _interopRequireDefault(_draw);

var _path2 = __webpack_require__(100);

var _path3 = _interopRequireDefault(_path2);

var _glyf = __webpack_require__(213);

var _glyf2 = _interopRequireDefault(_glyf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The Glyph object

function getPathDefinition(glyph, path) {
    var _path = path || { commands: [] };
    return {
        configurable: true,

        get: function get() {
            if (typeof _path === 'function') {
                _path = _path();
            }

            return _path;
        },

        set: function set(p) {
            _path = p;
        }
    };
}
/**
 * @typedef GlyphOptions
 * @type Object
 * @property {string} [name] - The glyph name
 * @property {number} [unicode]
 * @property {Array} [unicodes]
 * @property {number} [xMin]
 * @property {number} [yMin]
 * @property {number} [xMax]
 * @property {number} [yMax]
 * @property {number} [advanceWidth]
 */

// A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
/**
 * @exports opentype.Glyph
 * @class
 * @param {GlyphOptions}
 * @constructor
 */
function Glyph(options) {
    // By putting all the code on a prototype function (which is only declared once)
    // we reduce the memory requirements for larger fonts by some 2%
    this.bindConstructorValues(options);
}

/**
 * @param  {GlyphOptions}
 */
Glyph.prototype.bindConstructorValues = function (options) {
    this.index = options.index || 0;

    // These three values cannot be deferred for memory optimization:
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

    // But by binding these values only when necessary, we reduce can
    // the memory requirements by almost 3% for larger fonts.
    if (options.xMin) {
        this.xMin = options.xMin;
    }

    if (options.yMin) {
        this.yMin = options.yMin;
    }

    if (options.xMax) {
        this.xMax = options.xMax;
    }

    if (options.yMax) {
        this.yMax = options.yMax;
    }

    if (options.advanceWidth) {
        this.advanceWidth = options.advanceWidth;
    }

    // The path for a glyph is the most memory intensive, and is bound as a value
    // with a getter/setter to ensure we actually do path parsing only once the
    // path is actually needed by anything.
    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
};

/**
 * @param {number}
 */
Glyph.prototype.addUnicode = function (unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }

    this.unicodes.push(unicode);
};

/**
 * Calculate the minimum bounding box for this glyph.
 * @return {opentype.BoundingBox}
 */
Glyph.prototype.getBoundingBox = function () {
    return this.path.getBoundingBox();
};

/**
 * Convert the glyph to a Path we can draw on a drawing context.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to stretch the glyph.
 * @param  {opentype.Font} if hinting is to be used, the font
 * @return {opentype.Path}
 */
Glyph.prototype.getPath = function (x, y, fontSize, options, font) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    var commands = void 0;
    var hPoints = void 0;
    if (!options) options = {};
    var xScale = options.xScale;
    var yScale = options.yScale;

    if (options.hinting && font && font.hinting) {
        // in case of hinting, the hinting engine takes care
        // of scaling the points (not the path) before hinting.
        hPoints = this.path && font.hinting.exec(this, fontSize);
        // in case the hinting engine failed hPoints is undefined
        // and thus reverts to plain rending
    }

    if (hPoints) {
        commands = _glyf2.default.getPath(hPoints).commands;
        x = Math.round(x);
        y = Math.round(y);
        // TODO in case of hinting xyScaling is not yet supported
        xScale = yScale = 1;
    } else {
        commands = this.path.commands;
        var scale = 1 / this.path.unitsPerEm * fontSize;
        if (xScale === undefined) xScale = scale;
        if (yScale === undefined) yScale = scale;
    }

    var p = new _path3.default();
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);
        } else if (cmd.type === 'L') {
            p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale);
        } else if (cmd.type === 'C') {
            p.curveTo(x + cmd.x1 * xScale, y + -cmd.y1 * yScale, x + cmd.x2 * xScale, y + -cmd.y2 * yScale, x + cmd.x * xScale, y + -cmd.y * yScale);
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }

    return p;
};

/**
 * Split the glyph into contours.
 * This function is here for backwards compatibility, and to
 * provide raw access to the TrueType glyph outlines.
 * @return {Array}
 */
Glyph.prototype.getContours = function () {
    if (this.points === undefined) {
        return [];
    }

    var contours = [];
    var currentContour = [];
    for (var i = 0; i < this.points.length; i += 1) {
        var pt = this.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    _check2.default.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};

/**
 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
 * @return {Object}
 */
Glyph.prototype.getMetrics = function () {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }

        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }

        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }

    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: this.leftSideBearing
    };

    if (!isFinite(metrics.xMin)) {
        metrics.xMin = 0;
    }

    if (!isFinite(metrics.xMax)) {
        metrics.xMax = this.advanceWidth;
    }

    if (!isFinite(metrics.yMin)) {
        metrics.yMin = 0;
    }

    if (!isFinite(metrics.yMax)) {
        metrics.yMax = 0;
    }

    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};

/**
 * Draw the glyph on the given context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to stretch the glyph.
 */
Glyph.prototype.draw = function (ctx, x, y, fontSize, options) {
    this.getPath(x, y, fontSize, options).draw(ctx);
};

/**
 * Draw the points of the glyph.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */
Glyph.prototype.drawPoints = function (ctx, x, y, fontSize) {
    function drawCircles(l, x, y, scale) {
        var PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (var j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + l[j].x * scale, y + l[j].y * scale);
            ctx.arc(x + l[j].x * scale, y + l[j].y * scale, 2, 0, PI_SQ, false);
        }

        ctx.closePath();
        ctx.fill();
    }

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    var scale = 1 / this.path.unitsPerEm * fontSize;

    var blueCircles = [];
    var redCircles = [];
    var path = this.path;
    for (var i = 0; i < path.commands.length; i += 1) {
        var cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({ x: cmd.x, y: -cmd.y });
        }

        if (cmd.x1 !== undefined) {
            redCircles.push({ x: cmd.x1, y: -cmd.y1 });
        }

        if (cmd.x2 !== undefined) {
            redCircles.push({ x: cmd.x2, y: -cmd.y2 });
        }
    }

    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};

/**
 * Draw lines indicating important font measurements.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */
Glyph.prototype.drawMetrics = function (ctx, x, y, fontSize) {
    var scale = void 0;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.path.unitsPerEm * fontSize;
    ctx.lineWidth = 1;

    // Draw the origin
    ctx.strokeStyle = 'black';
    _draw2.default.line(ctx, x, -10000, x, 10000);
    _draw2.default.line(ctx, -10000, y, 10000, y);

    // This code is here due to memory optimization: by not using
    // defaults in the constructor, we save a notable amount of memory.
    var xMin = this.xMin || 0;
    var yMin = this.yMin || 0;
    var xMax = this.xMax || 0;
    var yMax = this.yMax || 0;
    var advanceWidth = this.advanceWidth || 0;

    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    _draw2.default.line(ctx, x + xMin * scale, -10000, x + xMin * scale, 10000);
    _draw2.default.line(ctx, x + xMax * scale, -10000, x + xMax * scale, 10000);
    _draw2.default.line(ctx, -10000, y + -yMin * scale, 10000, y + -yMin * scale);
    _draw2.default.line(ctx, -10000, y + -yMax * scale, 10000, y + -yMax * scale);

    // Draw the advance width
    ctx.strokeStyle = 'green';
    _draw2.default.line(ctx, x + advanceWidth * scale, -10000, x + advanceWidth * scale, 10000);
};

exports.default = Glyph;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadSync = exports.load = exports.parse = exports._parse = exports.BoundingBox = exports.Path = exports.Glyph = exports.Font = undefined;

var _tinyInflate = __webpack_require__(697);

var _tinyInflate2 = _interopRequireDefault(_tinyInflate);

var _font = __webpack_require__(321);

var _font2 = _interopRequireDefault(_font);

var _glyph = __webpack_require__(209);

var _glyph2 = _interopRequireDefault(_glyph);

var _encoding = __webpack_require__(121);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _bbox = __webpack_require__(208);

var _bbox2 = _interopRequireDefault(_bbox);

var _path = __webpack_require__(100);

var _path2 = _interopRequireDefault(_path);

var _util = __webpack_require__(224);

var _cmap = __webpack_require__(212);

var _cmap2 = _interopRequireDefault(_cmap);

var _cff = __webpack_require__(211);

var _cff2 = _interopRequireDefault(_cff);

var _fvar = __webpack_require__(325);

var _fvar2 = _interopRequireDefault(_fvar);

var _glyf = __webpack_require__(213);

var _glyf2 = _interopRequireDefault(_glyf);

var _gpos = __webpack_require__(326);

var _gpos2 = _interopRequireDefault(_gpos);

var _gsub = __webpack_require__(214);

var _gsub2 = _interopRequireDefault(_gsub);

var _head = __webpack_require__(215);

var _head2 = _interopRequireDefault(_head);

var _hhea = __webpack_require__(216);

var _hhea2 = _interopRequireDefault(_hhea);

var _hmtx = __webpack_require__(217);

var _hmtx2 = _interopRequireDefault(_hmtx);

var _kern = __webpack_require__(327);

var _kern2 = _interopRequireDefault(_kern);

var _ltag = __webpack_require__(218);

var _ltag2 = _interopRequireDefault(_ltag);

var _loca = __webpack_require__(328);

var _loca2 = _interopRequireDefault(_loca);

var _maxp = __webpack_require__(219);

var _maxp2 = _interopRequireDefault(_maxp);

var _name2 = __webpack_require__(221);

var _name3 = _interopRequireDefault(_name2);

var _os = __webpack_require__(222);

var _os2 = _interopRequireDefault(_os);

var _post = __webpack_require__(223);

var _post2 = _interopRequireDefault(_post);

var _meta = __webpack_require__(220);

var _meta2 = _interopRequireDefault(_meta);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The opentype library.
 * @namespace opentype
 */

// File loaders /////////////////////////////////////////////////////////
/**
 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
 * and the font as an ArrayBuffer in the second parameter if it succeeds.
 * @param  {string} path - The path of the file
 * @param  {Function} callback - The function to call when the font load completes
 */
function loadFromFile(path, callback) {
    var fs = __webpack_require__(206);
    fs.readFile(path, function (err, buffer) {
        if (err) {
            return callback(err.message);
        }

        callback(null, (0, _util.nodeBufferToArrayBuffer)(buffer));
    });
}
/**
 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
 * and the font as an ArrayBuffer in the second parameter if it succeeds.
 * @param  {string} url - The URL of the font file.
 * @param  {Function} callback - The function to call when the font load completes
 */
// opentype.js
// https://github.com/nodebox/opentype.js
// (c) 2015 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.

/* global DataView, Uint8Array, XMLHttpRequest  */

function loadFromUrl(url, callback) {
    var request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function () {
        if (request.status !== 200) {
            return callback('Font could not be loaded: ' + request.statusText);
        }

        return callback(null, request.response);
    };

    request.onerror = function () {
        callback('Font could not be loaded');
    };

    request.send();
}

// Table Directory Entries //////////////////////////////////////////////
/**
 * Parses OpenType table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */
function parseOpenTypeTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 12;
    for (var i = 0; i < numTables; i += 1) {
        var tag = _parse2.default.getTag(data, p);
        var checksum = _parse2.default.getULong(data, p + 4);
        var offset = _parse2.default.getULong(data, p + 8);
        var length = _parse2.default.getULong(data, p + 12);
        tableEntries.push({ tag: tag, checksum: checksum, offset: offset, length: length, compression: false });
        p += 16;
    }

    return tableEntries;
}

/**
 * Parses WOFF table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */
function parseWOFFTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 44; // offset to the first table directory entry.
    for (var i = 0; i < numTables; i += 1) {
        var tag = _parse2.default.getTag(data, p);
        var offset = _parse2.default.getULong(data, p + 4);
        var compLength = _parse2.default.getULong(data, p + 8);
        var origLength = _parse2.default.getULong(data, p + 12);
        var compression = void 0;
        if (compLength < origLength) {
            compression = 'WOFF';
        } else {
            compression = false;
        }

        tableEntries.push({ tag: tag, offset: offset, compression: compression,
            compressedLength: compLength, length: origLength });
        p += 20;
    }

    return tableEntries;
}

/**
 * @typedef TableData
 * @type Object
 * @property {DataView} data - The DataView
 * @property {number} offset - The data offset.
 */

/**
 * @param  {DataView}
 * @param  {Object}
 * @return {TableData}
 */
function uncompressTable(data, tableEntry) {
    if (tableEntry.compression === 'WOFF') {
        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
        var outBuffer = new Uint8Array(tableEntry.length);
        (0, _tinyInflate2.default)(inBuffer, outBuffer);
        if (outBuffer.byteLength !== tableEntry.length) {
            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
        }

        var view = new DataView(outBuffer.buffer, 0);
        return { data: view, offset: 0 };
    } else {
        return { data: data, offset: tableEntry.offset };
    }
}

// Public API ///////////////////////////////////////////////////////////

/**
 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
 * Throws an error if the font could not be parsed.
 * @param  {ArrayBuffer}
 * @return {opentype.Font}
 */
function parseBuffer(buffer) {
    var indexToLocFormat = void 0;
    var ltagTable = void 0;

    // Since the constructor can also be called to create new fonts from scratch, we indicate this
    // should be an empty font that we'll fill with our own data.
    var font = new _font2.default({ empty: true });

    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.
    var data = new DataView(buffer, 0);
    var numTables = void 0;
    var tableEntries = [];
    var signature = _parse2.default.getTag(data, 0);
    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
        font.outlinesFormat = 'truetype';
        numTables = _parse2.default.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'OTTO') {
        font.outlinesFormat = 'cff';
        numTables = _parse2.default.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'wOFF') {
        var flavor = _parse2.default.getTag(data, 4);
        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
            font.outlinesFormat = 'truetype';
        } else if (flavor === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType flavor ' + signature);
        }

        numTables = _parse2.default.getUShort(data, 12);
        tableEntries = parseWOFFTableEntries(data, numTables);
    } else {
        throw new Error('Unsupported OpenType signature ' + signature);
    }

    var cffTableEntry = void 0;
    var fvarTableEntry = void 0;
    var glyfTableEntry = void 0;
    var gposTableEntry = void 0;
    var gsubTableEntry = void 0;
    var hmtxTableEntry = void 0;
    var kernTableEntry = void 0;
    var locaTableEntry = void 0;
    var nameTableEntry = void 0;
    var metaTableEntry = void 0;
    var p = void 0;

    for (var i = 0; i < numTables; i += 1) {
        var tableEntry = tableEntries[i];
        var table = void 0;
        switch (tableEntry.tag) {
            case 'cmap':
                table = uncompressTable(data, tableEntry);
                font.tables.cmap = _cmap2.default.parse(table.data, table.offset);
                font.encoding = new _encoding.CmapEncoding(font.tables.cmap);
                break;
            case 'cvt ':
                table = uncompressTable(data, tableEntry);
                p = new _parse2.default.Parser(table.data, table.offset);
                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
                break;
            case 'fvar':
                fvarTableEntry = tableEntry;
                break;
            case 'fpgm':
                table = uncompressTable(data, tableEntry);
                p = new _parse2.default.Parser(table.data, table.offset);
                font.tables.fpgm = p.parseByteList(tableEntry.length);
                break;
            case 'head':
                table = uncompressTable(data, tableEntry);
                font.tables.head = _head2.default.parse(table.data, table.offset);
                font.unitsPerEm = font.tables.head.unitsPerEm;
                indexToLocFormat = font.tables.head.indexToLocFormat;
                break;
            case 'hhea':
                table = uncompressTable(data, tableEntry);
                font.tables.hhea = _hhea2.default.parse(table.data, table.offset);
                font.ascender = font.tables.hhea.ascender;
                font.descender = font.tables.hhea.descender;
                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
                break;
            case 'hmtx':
                hmtxTableEntry = tableEntry;
                break;
            case 'ltag':
                table = uncompressTable(data, tableEntry);
                ltagTable = _ltag2.default.parse(table.data, table.offset);
                break;
            case 'maxp':
                table = uncompressTable(data, tableEntry);
                font.tables.maxp = _maxp2.default.parse(table.data, table.offset);
                font.numGlyphs = font.tables.maxp.numGlyphs;
                break;
            case 'name':
                nameTableEntry = tableEntry;
                break;
            case 'OS/2':
                table = uncompressTable(data, tableEntry);
                font.tables.os2 = _os2.default.parse(table.data, table.offset);
                break;
            case 'post':
                table = uncompressTable(data, tableEntry);
                font.tables.post = _post2.default.parse(table.data, table.offset);
                font.glyphNames = new _encoding.GlyphNames(font.tables.post);
                break;
            case 'prep':
                table = uncompressTable(data, tableEntry);
                p = new _parse2.default.Parser(table.data, table.offset);
                font.tables.prep = p.parseByteList(tableEntry.length);
                break;
            case 'glyf':
                glyfTableEntry = tableEntry;
                break;
            case 'loca':
                locaTableEntry = tableEntry;
                break;
            case 'CFF ':
                cffTableEntry = tableEntry;
                break;
            case 'kern':
                kernTableEntry = tableEntry;
                break;
            case 'GPOS':
                gposTableEntry = tableEntry;
                break;
            case 'GSUB':
                gsubTableEntry = tableEntry;
                break;
            case 'meta':
                metaTableEntry = tableEntry;
                break;
        }
    }

    var nameTable = uncompressTable(data, nameTableEntry);
    font.tables.name = _name3.default.parse(nameTable.data, nameTable.offset, ltagTable);
    font.names = font.tables.name;

    if (glyfTableEntry && locaTableEntry) {
        var shortVersion = indexToLocFormat === 0;
        var locaTable = uncompressTable(data, locaTableEntry);
        var locaOffsets = _loca2.default.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
        var glyfTable = uncompressTable(data, glyfTableEntry);
        font.glyphs = _glyf2.default.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
    } else if (cffTableEntry) {
        var cffTable = uncompressTable(data, cffTableEntry);
        _cff2.default.parse(cffTable.data, cffTable.offset, font);
    } else {
        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
    }

    var hmtxTable = uncompressTable(data, hmtxTableEntry);
    _hmtx2.default.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
    (0, _encoding.addGlyphNames)(font);

    if (kernTableEntry) {
        var kernTable = uncompressTable(data, kernTableEntry);
        font.kerningPairs = _kern2.default.parse(kernTable.data, kernTable.offset);
    } else {
        font.kerningPairs = {};
    }

    if (gposTableEntry) {
        var gposTable = uncompressTable(data, gposTableEntry);
        _gpos2.default.parse(gposTable.data, gposTable.offset, font);
    }

    if (gsubTableEntry) {
        var gsubTable = uncompressTable(data, gsubTableEntry);
        font.tables.gsub = _gsub2.default.parse(gsubTable.data, gsubTable.offset);
    }

    if (fvarTableEntry) {
        var fvarTable = uncompressTable(data, fvarTableEntry);
        font.tables.fvar = _fvar2.default.parse(fvarTable.data, fvarTable.offset, font.names);
    }

    if (metaTableEntry) {
        var metaTable = uncompressTable(data, metaTableEntry);
        font.tables.meta = _meta2.default.parse(metaTable.data, metaTable.offset);
        font.metas = font.tables.meta;
    }

    return font;
}

/**
 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
 * with two arguments `(err, font)`. The `err` will be null on success,
 * the `font` is a Font object.
 * We use the node.js callback convention so that
 * opentype.js can integrate with frameworks like async.js.
 * @alias opentype.load
 * @param  {string} url - The URL of the font to load.
 * @param  {Function} callback - The callback.
 */
function load(url, callback) {
    var isNode = typeof window === 'undefined';
    var loadFn = isNode ? loadFromFile : loadFromUrl;
    loadFn(url, function (err, arrayBuffer) {
        if (err) {
            return callback(err);
        }
        var font = void 0;
        try {
            font = parseBuffer(arrayBuffer);
        } catch (e) {
            return callback(e, null);
        }
        return callback(null, font);
    });
}

/**
 * Synchronously load the font from a URL or file.
 * When done, returns the font object or throws an error.
 * @alias opentype.loadSync
 * @param  {string} url - The URL of the font to load.
 * @return {opentype.Font}
 */
function loadSync(url) {
    var fs = __webpack_require__(206);
    var buffer = fs.readFileSync(url);
    return parseBuffer((0, _util.nodeBufferToArrayBuffer)(buffer));
}

exports.Font = _font2.default;
exports.Glyph = _glyph2.default;
exports.Path = _path2.default;
exports.BoundingBox = _bbox2.default;
exports._parse = _parse2.default;
exports.parse = parseBuffer;
exports.load = load;
exports.loadSync = loadSync;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _encoding = __webpack_require__(121);

var _glyphset = __webpack_require__(150);

var _glyphset2 = _interopRequireDefault(_glyphset);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _path = __webpack_require__(100);

var _path2 = _interopRequireDefault(_path);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Custom equals function that can also check lists.
function equals(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }

        for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
                return false;
            }
        }

        return true;
    } else {
        return false;
    }
}

// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf

function calcCFFSubroutineBias(subrs) {
    var bias = void 0;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }

    return bias;
}

// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    var offsets = [];
    var objects = [];
    var count = _parse2.default.getCard16(data, start);
    var objectOffset = void 0;
    var endOffset = void 0;
    if (count !== 0) {
        var offsetSize = _parse2.default.getByte(data, start + 2);
        objectOffset = start + (count + 1) * offsetSize + 2;
        var pos = start + 3;
        for (var i = 0; i < count + 1; i += 1) {
            offsets.push(_parse2.default.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }

        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }

    for (var _i = 0; _i < offsets.length - 1; _i += 1) {
        var value = _parse2.default.getBytes(data, objectOffset + offsets[_i], objectOffset + offsets[_i + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }

        objects.push(value);
    }

    return { objects: objects, startOffset: start, endOffset: endOffset };
}

// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    var s = '';
    var eof = 15;
    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        var b = parser.parseByte();
        var n1 = b >> 4;
        var n2 = b & 15;

        if (n1 === eof) {
            break;
        }

        s += lookup[n1];

        if (n2 === eof) {
            break;
        }

        s += lookup[n2];
    }

    return parseFloat(s);
}

// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    var b1 = void 0;
    var b2 = void 0;
    var b3 = void 0;
    var b4 = void 0;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }

    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }

    if (b0 === 30) {
        return parseFloatOperand(parser);
    }

    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }

    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }

    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }

    throw new Error('Invalid b0 ' + b0);
}

// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    var o = {};
    for (var i = 0; i < entries.length; i += 1) {
        var key = entries[i][0];
        var values = entries[i][1];
        var value = void 0;
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }

        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }

        o[key] = value;
    }

    return o;
}

// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    start = start !== undefined ? start : 0;
    var parser = new _parse2.default.Parser(data, start);
    var entries = [];
    var operands = [];
    size = size !== undefined ? size : data.length;

    while (parser.relativeOffset < size) {
        var op = parser.parseByte();

        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }

            entries.push([op, operands]);
            operands = [];
        } else {
            // Since the operands (values) come before the operators (keys), we store all operands in a list
            // until we encounter an operator.
            operands.push(parseOperand(parser, op));
        }
    }

    return entriesToObject(entries);
}

// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) {
        index = _encoding.cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }

    return index;
}

// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    var newDict = {};
    var value = void 0;

    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for (var i = 0; i < meta.length; i += 1) {
        var m = meta[i];

        if (Array.isArray(m.type)) {
            var values = [];
            values.length = m.type.length;
            for (var j = 0; j < m.type.length; j++) {
                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
                if (value === undefined) {
                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
                }
                if (m.type[j] === 'SID') {
                    value = getCFFString(strings, value);
                }
                values[j] = value;
            }
            newDict[m.name] = values;
        } else {
            value = dict[m.op];
            if (value === undefined) {
                value = m.value !== undefined ? m.value : null;
            }

            if (m.type === 'SID') {
                value = getCFFString(strings, value);
            }
            newDict[m.name] = value;
        }
    }

    return newDict;
}

// Parse the CFF header.
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = _parse2.default.getCard8(data, start);
    header.formatMinor = _parse2.default.getCard8(data, start + 1);
    header.size = _parse2.default.getCard8(data, start + 2);
    header.offsetSize = _parse2.default.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}

var TOP_DICT_META = [{ name: 'version', op: 0, type: 'SID' }, { name: 'notice', op: 1, type: 'SID' }, { name: 'copyright', op: 1200, type: 'SID' }, { name: 'fullName', op: 2, type: 'SID' }, { name: 'familyName', op: 3, type: 'SID' }, { name: 'weight', op: 4, type: 'SID' }, { name: 'isFixedPitch', op: 1201, type: 'number', value: 0 }, { name: 'italicAngle', op: 1202, type: 'number', value: 0 }, { name: 'underlinePosition', op: 1203, type: 'number', value: -100 }, { name: 'underlineThickness', op: 1204, type: 'number', value: 50 }, { name: 'paintType', op: 1205, type: 'number', value: 0 }, { name: 'charstringType', op: 1206, type: 'number', value: 2 }, {
    name: 'fontMatrix',
    op: 1207,
    type: ['real', 'real', 'real', 'real', 'real', 'real'],
    value: [0.001, 0, 0, 0.001, 0, 0]
}, { name: 'uniqueId', op: 13, type: 'number' }, { name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0] }, { name: 'strokeWidth', op: 1208, type: 'number', value: 0 }, { name: 'xuid', op: 14, type: [], value: null }, { name: 'charset', op: 15, type: 'offset', value: 0 }, { name: 'encoding', op: 16, type: 'offset', value: 0 }, { name: 'charStrings', op: 17, type: 'offset', value: 0 }, { name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0] }, { name: 'ros', op: 1230, type: ['SID', 'SID', 'number'] }, { name: 'cidFontVersion', op: 1231, type: 'number', value: 0 }, { name: 'cidFontRevision', op: 1232, type: 'number', value: 0 }, { name: 'cidFontType', op: 1233, type: 'number', value: 0 }, { name: 'cidCount', op: 1234, type: 'number', value: 8720 }, { name: 'uidBase', op: 1235, type: 'number' }, { name: 'fdArray', op: 1236, type: 'offset' }, { name: 'fdSelect', op: 1237, type: 'offset' }, { name: 'fontName', op: 1238, type: 'SID' }];

var PRIVATE_DICT_META = [{ name: 'subrs', op: 19, type: 'offset', value: 0 }, { name: 'defaultWidthX', op: 20, type: 'number', value: 0 }, { name: 'nominalWidthX', op: 21, type: 'number', value: 0 }];

// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    var dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}

// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    var dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}

// Returns a list of "Top DICT"s found using an INDEX list.
// Used to read both the usual high-level Top DICTs and also the FDArray
// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
// a Private DICT that is read and saved into the Top DICT.
//
// In addition to the expected/optional values as outlined in TOP_DICT_META
// the following values might be saved into the Top DICT.
//
//    _subrs []        array of local CFF subroutines from Private DICT
//    _subrsBias       bias value computed from number of subroutines
//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
//    _defaultWidthX   default widths for CFF characters
//    _nominalWidthX   bias added to width embedded within glyph description
//
//    _privateDict     saved copy of parsed Private DICT from Top DICT
function gatherCFFTopDicts(data, start, cffIndex, strings) {
    var topDictArray = [];
    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
        var topDict = parseCFFTopDict(topDictData, strings);
        topDict._subrs = [];
        topDict._subrsBias = 0;
        var privateSize = topDict.private[0];
        var privateOffset = topDict.private[1];
        if (privateSize !== 0 && privateOffset !== 0) {
            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
            topDict._defaultWidthX = privateDict.defaultWidthX;
            topDict._nominalWidthX = privateDict.nominalWidthX;
            if (privateDict.subrs !== 0) {
                var subrOffset = privateOffset + privateDict.subrs;
                var subrIndex = parseCFFIndex(data, subrOffset + start);
                topDict._subrs = subrIndex.objects;
                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
            }
            topDict._privateDict = privateDict;
        }
        topDictArray.push(topDict);
    }
    return topDictArray;
}

// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    var sid = void 0;
    var count = void 0;
    var parser = new _parse2.default.Parser(data, start);

    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    var charset = ['.notdef'];

    var format = parser.parseCard8();
    if (format === 0) {
        for (var i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (var _i2 = 0; _i2 <= count; _i2 += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (var _i3 = 0; _i3 <= count; _i3 += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }

    return charset;
}

// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    var code = void 0;
    var enc = {};
    var parser = new _parse2.default.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        var nCodes = parser.parseCard8();
        for (var i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        var nRanges = parser.parseCard8();
        code = 1;
        for (var _i4 = 0; _i4 < nRanges; _i4 += 1) {
            var first = parser.parseCard8();
            var nLeft = parser.parseCard8();
            for (var j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }

    return new _encoding.CffEncoding(enc, charset);
}

// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(font, glyph, code) {
    var c1x = void 0;
    var c1y = void 0;
    var c2x = void 0;
    var c2y = void 0;
    var p = new _path2.default();
    var stack = [];
    var nStems = 0;
    var haveWidth = false;
    var open = false;
    var x = 0;
    var y = 0;
    var subrs = void 0;
    var subrsBias = void 0;
    var defaultWidthX = void 0;
    var nominalWidthX = void 0;
    if (font.isCIDFont) {
        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
        subrs = fdDict._subrs;
        subrsBias = fdDict._subrsBias;
        defaultWidthX = fdDict._defaultWidthX;
        nominalWidthX = fdDict._nominalWidthX;
    } else {
        subrs = font.tables.cff.topDict._subrs;
        subrsBias = font.tables.cff.topDict._subrsBias;
        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
    }
    var width = defaultWidthX;

    function newContour(x, y) {
        if (open) {
            p.closePath();
        }

        p.moveTo(x, y);
        open = true;
    }

    function parseStems() {
        var hasWidthArg = void 0;

        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + nominalWidthX;
        }

        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }

    function parse(code) {
        var b1 = void 0;
        var b2 = void 0;
        var b3 = void 0;
        var b4 = void 0;
        var codeIndex = void 0;
        var subrCode = void 0;
        var jpx = void 0;
        var jpy = void 0;
        var c3x = void 0;
        var c3y = void 0;
        var c4x = void 0;
        var c4y = void 0;

        var i = 0;
        while (i < code.length) {
            var v = code[i];
            i += 1;
            switch (v) {
                case 1:
                    // hstem
                    parseStems();
                    break;
                case 3:
                    // vstem
                    parseStems();
                    break;
                case 4:
                    // vmoveto
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    y += stack.pop();
                    newContour(x, y);
                    break;
                case 5:
                    // rlineto
                    while (stack.length > 0) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 6:
                    // hlineto
                    while (stack.length > 0) {
                        x += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 7:
                    // vlineto
                    while (stack.length > 0) {
                        y += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        x += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 8:
                    // rrcurveto
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 10:
                    // callsubr
                    codeIndex = stack.pop() + subrsBias;
                    subrCode = subrs[codeIndex];
                    if (subrCode) {
                        parse(subrCode);
                    }

                    break;
                case 11:
                    // return
                    return;
                case 12:
                    // flex operators
                    v = code[i];
                    i += 1;
                    switch (v) {
                        case 35:
                            // flex
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                            c1x = x + stack.shift(); // dx1
                            c1y = y + stack.shift(); // dy1
                            c2x = c1x + stack.shift(); // dx2
                            c2y = c1y + stack.shift(); // dy2
                            jpx = c2x + stack.shift(); // dx3
                            jpy = c2y + stack.shift(); // dy3
                            c3x = jpx + stack.shift(); // dx4
                            c3y = jpy + stack.shift(); // dy4
                            c4x = c3x + stack.shift(); // dx5
                            c4y = c3y + stack.shift(); // dy5
                            x = c4x + stack.shift(); // dx6
                            y = c4y + stack.shift(); // dy6
                            stack.shift(); // flex depth
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 34:
                            // hflex
                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                            c1x = x + stack.shift(); // dx1
                            c1y = y; // dy1
                            c2x = c1x + stack.shift(); // dx2
                            c2y = c1y + stack.shift(); // dy2
                            jpx = c2x + stack.shift(); // dx3
                            jpy = c2y; // dy3
                            c3x = jpx + stack.shift(); // dx4
                            c3y = c2y; // dy4
                            c4x = c3x + stack.shift(); // dx5
                            c4y = y; // dy5
                            x = c4x + stack.shift(); // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 36:
                            // hflex1
                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                            c1x = x + stack.shift(); // dx1
                            c1y = y + stack.shift(); // dy1
                            c2x = c1x + stack.shift(); // dx2
                            c2y = c1y + stack.shift(); // dy2
                            jpx = c2x + stack.shift(); // dx3
                            jpy = c2y; // dy3
                            c3x = jpx + stack.shift(); // dx4
                            c3y = c2y; // dy4
                            c4x = c3x + stack.shift(); // dx5
                            c4y = c3y + stack.shift(); // dy5
                            x = c4x + stack.shift(); // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 37:
                            // flex1
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                            c1x = x + stack.shift(); // dx1
                            c1y = y + stack.shift(); // dy1
                            c2x = c1x + stack.shift(); // dx2
                            c2y = c1y + stack.shift(); // dy2
                            jpx = c2x + stack.shift(); // dx3
                            jpy = c2y + stack.shift(); // dy3
                            c3x = jpx + stack.shift(); // dx4
                            c3y = jpy + stack.shift(); // dy4
                            c4x = c3x + stack.shift(); // dx5
                            c4y = c3y + stack.shift(); // dy5
                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                                x = c4x + stack.shift();
                            } else {
                                y = c4y + stack.shift();
                            }

                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        default:
                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
                            stack.length = 0;
                    }
                    break;
                case 14:
                    // endchar
                    if (stack.length > 0 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    if (open) {
                        p.closePath();
                        open = false;
                    }

                    break;
                case 18:
                    // hstemhm
                    parseStems();
                    break;
                case 19: // hintmask
                case 20:
                    // cntrmask
                    parseStems();
                    i += nStems + 7 >> 3;
                    break;
                case 21:
                    // rmoveto
                    if (stack.length > 2 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    y += stack.pop();
                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 22:
                    // hmoveto
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 23:
                    // vstemhm
                    parseStems();
                    break;
                case 24:
                    // rcurveline
                    while (stack.length > 2) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                    break;
                case 25:
                    // rlinecurve
                    while (stack.length > 6) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    break;
                case 26:
                    // vvcurveto
                    if (stack.length % 2) {
                        x += stack.shift();
                    }

                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x;
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 27:
                    // hhcurveto
                    if (stack.length % 2) {
                        y += stack.shift();
                    }

                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y;
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 28:
                    // shortint
                    b1 = code[i];
                    b2 = code[i + 1];
                    stack.push((b1 << 24 | b2 << 16) >> 16);
                    i += 2;
                    break;
                case 29:
                    // callgsubr
                    codeIndex = stack.pop() + font.gsubrsBias;
                    subrCode = font.gsubrs[codeIndex];
                    if (subrCode) {
                        parse(subrCode);
                    }

                    break;
                case 30:
                    // vhcurveto
                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 31:
                    // hvcurveto
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                default:
                    if (v < 32) {
                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
                    } else if (v < 247) {
                        stack.push(v - 139);
                    } else if (v < 251) {
                        b1 = code[i];
                        i += 1;
                        stack.push((v - 247) * 256 + b1 + 108);
                    } else if (v < 255) {
                        b1 = code[i];
                        i += 1;
                        stack.push(-(v - 251) * 256 - b1 - 108);
                    } else {
                        b1 = code[i];
                        b2 = code[i + 1];
                        b3 = code[i + 2];
                        b4 = code[i + 3];
                        i += 4;
                        stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);
                    }
            }
        }
    }

    parse(code);

    glyph.advanceWidth = width;
    return p;
}

function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
    var fdSelect = [];
    var fdIndex = void 0;
    var parser = new _parse2.default.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        // Simple list of nGlyphs elements
        for (var iGid = 0; iGid < nGlyphs; iGid++) {
            fdIndex = parser.parseCard8();
            if (fdIndex >= fdArrayCount) {
                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            }
            fdSelect.push(fdIndex);
        }
    } else if (format === 3) {
        // Ranges
        var nRanges = parser.parseCard16();
        var first = parser.parseCard16();
        if (first !== 0) {
            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
        }
        var next = void 0;
        for (var iRange = 0; iRange < nRanges; iRange++) {
            fdIndex = parser.parseCard8();
            next = parser.parseCard16();
            if (fdIndex >= fdArrayCount) {
                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            }
            if (next > nGlyphs) {
                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
            }
            for (; first < next; first++) {
                fdSelect.push(fdIndex);
            }
            first = next;
        }
        if (next !== nGlyphs) {
            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
        }
    } else {
        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
    }
    return fdSelect;
}

// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    font.tables.cff = {};
    var header = parseCFFHeader(data, start);
    var nameIndex = parseCFFIndex(data, header.endOffset, _parse2.default.bytesToString);
    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, _parse2.default.bytesToString);
    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
    if (topDictArray.length !== 1) {
        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
    }

    var topDict = topDictArray[0];
    font.tables.cff.topDict = topDict;

    if (topDict._privateDict) {
        font.defaultWidthX = topDict._privateDict.defaultWidthX;
        font.nominalWidthX = topDict._privateDict.nominalWidthX;
    }

    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
        font.isCIDFont = true;
    }

    if (font.isCIDFont) {
        var fdArrayOffset = topDict.fdArray;
        var fdSelectOffset = topDict.fdSelect;
        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
        }
        fdArrayOffset += start;
        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
        topDict._fdArray = fdArray;
        fdSelectOffset += start;
        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
    }

    var privateDictOffset = start + topDict.private[1];
    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;

    if (privateDict.subrs !== 0) {
        var subrOffset = privateDictOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }

    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;

    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) {
        // Standard encoding
        font.cffEncoding = new _encoding.CffEncoding(_encoding.cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) {
        // Expert encoding
        font.cffEncoding = new _encoding.CffEncoding(_encoding.cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }

    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;

    font.glyphs = new _glyphset2.default.GlyphSet(font);
    for (var i = 0; i < font.nGlyphs; i += 1) {
        var charString = charStringsIndex.objects[i];
        font.glyphs.push(i, _glyphset2.default.cffGlyphLoader(font, i, parseCFFCharstring, charString));
    }
}

// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    var sid = void 0;

    // Is the string in the CFF standard strings?
    var i = _encoding.cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }

    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + _encoding.cffStandardStrings.length;
    } else {
        sid = _encoding.cffStandardStrings.length + strings.length;
        strings.push(s);
    }

    return sid;
}

function makeHeader() {
    return new _table2.default.Record('Header', [{ name: 'major', type: 'Card8', value: 1 }, { name: 'minor', type: 'Card8', value: 0 }, { name: 'hdrSize', type: 'Card8', value: 4 }, { name: 'major', type: 'Card8', value: 1 }]);
}

function makeNameIndex(fontNames) {
    var t = new _table2.default.Record('Name INDEX', [{ name: 'names', type: 'INDEX', value: [] }]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({ name: 'name_' + i, type: 'NAME', value: fontNames[i] });
    }

    return t;
}

// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    var m = {};
    for (var i = 0; i < meta.length; i += 1) {
        var entry = meta[i];
        var value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }

            m[entry.op] = { name: entry.name, type: entry.type, value: value };
        }
    }

    return m;
}

// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    var t = new _table2.default.Record('Top DICT', [{ name: 'dict', type: 'DICT', value: {} }]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}

function makeTopDictIndex(topDict) {
    var t = new _table2.default.Record('Top DICT INDEX', [{ name: 'topDicts', type: 'INDEX', value: [] }]);
    t.topDicts = [{ name: 'topDict_0', type: 'TABLE', value: topDict }];
    return t;
}

function makeStringIndex(strings) {
    var t = new _table2.default.Record('String INDEX', [{ name: 'strings', type: 'INDEX', value: [] }]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({ name: 'string_' + i, type: 'STRING', value: strings[i] });
    }

    return t;
}

function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new _table2.default.Record('Global Subr INDEX', [{ name: 'subrs', type: 'INDEX', value: [] }]);
}

function makeCharsets(glyphNames, strings) {
    var t = new _table2.default.Record('Charsets', [{ name: 'format', type: 'Card8', value: 0 }]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({ name: 'glyph_' + i, type: 'SID', value: glyphSID });
    }

    return t;
}

function glyphToOps(glyph) {
    var ops = [];
    var path = glyph.path;
    ops.push({ name: 'width', type: 'NUMBER', value: glyph.advanceWidth });
    var x = 0;
    var y = 0;
    for (var i = 0; i < path.commands.length; i += 1) {
        var dx = void 0;
        var dy = void 0;
        var cmd = path.commands[i];
        if (cmd.type === 'Q') {
            // CFF only supports bzier curves, so convert the quad to a bzier.
            var _13 = 1 / 3;
            var _23 = 2 / 3;

            // We're going to create a new command so we don't change the original path.
            cmd = {
                type: 'C',
                x: cmd.x,
                y: cmd.y,
                x1: _13 * x + _23 * cmd.x1,
                y1: _13 * y + _23 * cmd.y1,
                x2: _13 * cmd.x + _23 * cmd.x1,
                y2: _13 * cmd.y + _23 * cmd.y1
            };
        }

        if (cmd.type === 'M') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({ name: 'dx', type: 'NUMBER', value: dx });
            ops.push({ name: 'dy', type: 'NUMBER', value: dy });
            ops.push({ name: 'rmoveto', type: 'OP', value: 21 });
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'L') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({ name: 'dx', type: 'NUMBER', value: dx });
            ops.push({ name: 'dy', type: 'NUMBER', value: dy });
            ops.push({ name: 'rlineto', type: 'OP', value: 5 });
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'C') {
            var dx1 = Math.round(cmd.x1 - x);
            var dy1 = Math.round(cmd.y1 - y);
            var dx2 = Math.round(cmd.x2 - cmd.x1);
            var dy2 = Math.round(cmd.y2 - cmd.y1);
            dx = Math.round(cmd.x - cmd.x2);
            dy = Math.round(cmd.y - cmd.y2);
            ops.push({ name: 'dx1', type: 'NUMBER', value: dx1 });
            ops.push({ name: 'dy1', type: 'NUMBER', value: dy1 });
            ops.push({ name: 'dx2', type: 'NUMBER', value: dx2 });
            ops.push({ name: 'dy2', type: 'NUMBER', value: dy2 });
            ops.push({ name: 'dx', type: 'NUMBER', value: dx });
            ops.push({ name: 'dy', type: 'NUMBER', value: dy });
            ops.push({ name: 'rrcurveto', type: 'OP', value: 8 });
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        }

        // Contours are closed automatically.
    }

    ops.push({ name: 'endchar', type: 'OP', value: 14 });
    return ops;
}

function makeCharStringsIndex(glyphs) {
    var t = new _table2.default.Record('CharStrings INDEX', [{ name: 'charStrings', type: 'INDEX', value: [] }]);

    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var ops = glyphToOps(glyph);
        t.charStrings.push({ name: glyph.name, type: 'CHARSTRING', value: ops });
    }

    return t;
}

function makePrivateDict(attrs, strings) {
    var t = new _table2.default.Record('Private DICT', [{ name: 'dict', type: 'DICT', value: {} }]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}

function makeCFFTable(glyphs, options) {
    var t = new _table2.default.Table('CFF ', [{ name: 'header', type: 'RECORD' }, { name: 'nameIndex', type: 'RECORD' }, { name: 'topDictIndex', type: 'RECORD' }, { name: 'stringIndex', type: 'RECORD' }, { name: 'globalSubrIndex', type: 'RECORD' }, { name: 'charsets', type: 'RECORD' }, { name: 'charStringsIndex', type: 'RECORD' }, { name: 'privateDict', type: 'RECORD' }]);

    var fontScale = 1 / options.unitsPerEm;
    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        fontBBox: options.fontBBox || [0, 0, 0, 0],
        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };

    var privateAttrs = {};

    var glyphNames = [];
    var glyph = void 0;

    // Skip first glyph (.notdef)
    for (var i = 1; i < glyphs.length; i += 1) {
        glyph = glyphs.get(i);
        glyphNames.push(glyph.name);
    }

    var strings = [];

    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    t.privateDict = makePrivateDict(privateAttrs, strings);

    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);

    var startOffset = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;

    // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.encoding = 0;
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);

    return t;
}

exports.default = { parse: parseCFFTable, make: makeCFFTable };

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parseCmapTableFormat12(cmap, p) {
    //Skip reserved.
    p.parseUShort();

    // Length in bytes of the sub-tables.
    cmap.length = p.parseULong();
    cmap.language = p.parseULong();

    var groupCount = void 0;
    cmap.groupCount = groupCount = p.parseULong();
    cmap.glyphIndexMap = {};

    for (var i = 0; i < groupCount; i += 1) {
        var startCharCode = p.parseULong();
        var endCharCode = p.parseULong();
        var startGlyphId = p.parseULong();

        for (var c = startCharCode; c <= endCharCode; c += 1) {
            cmap.glyphIndexMap[c] = startGlyphId;
            startGlyphId++;
        }
    }
} // The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm

function parseCmapTableFormat4(cmap, p, data, start, offset) {
    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();

    // segCount is stored x 2.
    var segCount = void 0;
    cmap.segCount = segCount = p.parseUShort() >> 1;

    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);

    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};
    var endCountParser = new _parse2.default.Parser(data, start + offset + 14);
    var startCountParser = new _parse2.default.Parser(data, start + offset + 16 + segCount * 2);
    var idDeltaParser = new _parse2.default.Parser(data, start + offset + 16 + segCount * 4);
    var idRangeOffsetParser = new _parse2.default.Parser(data, start + offset + 16 + segCount * 6);
    var glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (var i = 0; i < segCount - 1; i += 1) {
        var glyphIndex = void 0;
        var endCount = endCountParser.parseUShort();
        var startCount = startCountParser.parseUShort();
        var idDelta = idDeltaParser.parseShort();
        var idRangeOffset = idRangeOffsetParser.parseUShort();
        for (var c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;

                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;

                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = _parse2.default.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = glyphIndex + idDelta & 0xFFFF;
                }
            } else {
                glyphIndex = c + idDelta & 0xFFFF;
            }

            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
}

// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4 and 12.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    var cmap = {};
    cmap.version = _parse2.default.getUShort(data, start);
    _check2.default.argument(cmap.version === 0, 'cmap table version should be 0.');

    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 3" table. This is a Windows format.
    cmap.numTables = _parse2.default.getUShort(data, start + 2);
    var offset = -1;
    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
        var platformId = _parse2.default.getUShort(data, start + 4 + i * 8);
        var encodingId = _parse2.default.getUShort(data, start + 4 + i * 8 + 2);
        if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) {
            offset = _parse2.default.getULong(data, start + 4 + i * 8 + 4);
            break;
        }
    }

    if (offset === -1) {
        // There is no cmap table in the font that we support.
        throw new Error('No valid cmap sub-tables found.');
    }

    var p = new _parse2.default.Parser(data, start + offset);
    cmap.format = p.parseUShort();

    if (cmap.format === 12) {
        parseCmapTableFormat12(cmap, p);
    } else if (cmap.format === 4) {
        parseCmapTableFormat4(cmap, p, data, start, offset);
    } else {
        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
    }

    return cmap;
}

function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0
    });
}

function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}

function makeCmapTable(glyphs) {
    var t = new _table2.default.Table('cmap', [{ name: 'version', type: 'USHORT', value: 0 }, { name: 'numTables', type: 'USHORT', value: 1 }, { name: 'platformID', type: 'USHORT', value: 3 }, { name: 'encodingID', type: 'USHORT', value: 1 }, { name: 'offset', type: 'ULONG', value: 12 }, { name: 'format', type: 'USHORT', value: 4 }, { name: 'length', type: 'USHORT', value: 0 }, { name: 'language', type: 'USHORT', value: 0 }, { name: 'segCountX2', type: 'USHORT', value: 0 }, { name: 'searchRange', type: 'USHORT', value: 0 }, { name: 'entrySelector', type: 'USHORT', value: 0 }, { name: 'rangeShift', type: 'USHORT', value: 0 }]);

    t.segments = [];
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        for (var j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }

        t.segments = t.segments.sort(function (a, b) {
            return a.start - b.start;
        });
    }

    addTerminatorSegment(t);

    var segCount = void 0;
    segCount = t.segments.length;
    t.segCountX2 = segCount * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;

    // Set up parallel segment arrays.
    var endCounts = [];
    var startCounts = [];
    var idDeltas = [];
    var idRangeOffsets = [];
    var glyphIds = [];

    for (var _i = 0; _i < segCount; _i += 1) {
        var segment = t.segments[_i];
        endCounts = endCounts.concat({ name: 'end_' + _i, type: 'USHORT', value: segment.end });
        startCounts = startCounts.concat({ name: 'start_' + _i, type: 'USHORT', value: segment.start });
        idDeltas = idDeltas.concat({ name: 'idDelta_' + _i, type: 'SHORT', value: segment.delta });
        idRangeOffsets = idRangeOffsets.concat({ name: 'idRangeOffset_' + _i, type: 'USHORT', value: segment.offset });
        if (segment.glyphId !== undefined) {
            glyphIds = glyphIds.concat({ name: 'glyph_' + _i, type: 'USHORT', value: segment.glyphId });
        }
    }

    t.fields = t.fields.concat(endCounts);
    t.fields.push({ name: 'reservedPad', type: 'USHORT', value: 0 });
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);

    t.length = 14 + // Subtable header
    endCounts.length * 2 + 2 + // reservedPad
    startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;

    return t;
}

exports.default = { parse: parseCmapTable, make: makeCmapTable };

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _glyphset = __webpack_require__(150);

var _glyphset2 = _interopRequireDefault(_glyphset);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _path = __webpack_require__(100);

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parse the coordinate data for a glyph.
// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm

function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v = void 0;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }

        v = previousValue + v;
    } else {
        //  The coordinate is 2 bytes long.
        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            // Parse the coordinate as a signed 16-bit delta value.
            v = previousValue + p.parseShort();
        }
    }

    return v;
}

// Parse a TrueType glyph.
function parseGlyph(glyph, data, start) {
    var p = new _parse2.default.Parser(data, start);
    glyph.numberOfContours = p.parseShort();
    glyph._xMin = p.parseShort();
    glyph._yMin = p.parseShort();
    glyph._xMax = p.parseShort();
    glyph._yMax = p.parseShort();
    var flags = void 0;
    var flag = void 0;

    if (glyph.numberOfContours > 0) {
        // This glyph is not a composite.
        var endPointIndices = glyph.endPointIndices = [];
        for (var i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }

        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (var _i = 0; _i < glyph.instructionLength; _i += 1) {
            glyph.instructions.push(p.parseByte());
        }

        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (var _i2 = 0; _i2 < numberOfCoordinates; _i2 += 1) {
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                var repeatCount = p.parseByte();
                for (var j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    _i2 += 1;
                }
            }
        }

        _check2.default.argument(flags.length === numberOfCoordinates, 'Bad flags.');

        if (endPointIndices.length > 0) {
            var points = [];
            var point = void 0;
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for (var _i3 = 0; _i3 < numberOfCoordinates; _i3 += 1) {
                    flag = flags[_i3];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(_i3) >= 0;
                    points.push(point);
                }

                var px = 0;
                for (var _i4 = 0; _i4 < numberOfCoordinates; _i4 += 1) {
                    flag = flags[_i4];
                    point = points[_i4];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }

                var py = 0;
                for (var _i5 = 0; _i5 < numberOfCoordinates; _i5 += 1) {
                    flag = flags[_i5];
                    point = points[_i5];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }

            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        var moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            var component = {
                glyphIndex: p.parseUShort(),
                xScale: 1,
                scale01: 0,
                scale10: 0,
                yScale: 1,
                dx: 0,
                dy: 0
            };
            if ((flags & 1) > 0) {
                // The arguments are words
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseShort();
                    component.dy = p.parseShort();
                } else {
                    // values are matched points
                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
                }
            } else {
                // The arguments are bytes
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseChar();
                    component.dy = p.parseChar();
                } else {
                    // values are matched points
                    component.matchedPoints = [p.parseByte(), p.parseByte()];
                }
            }

            if ((flags & 8) > 0) {
                // We have a scale
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }

            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
        if (flags & 0x100) {
            // We have instructions
            glyph.instructionLength = p.parseUShort();
            glyph.instructions = [];
            for (var _i6 = 0; _i6 < glyph.instructionLength; _i6 += 1) {
                glyph.instructions.push(p.parseByte());
            }
        }
    }
}

// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    var newPoints = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        var newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }

    return newPoints;
}

function getContours(points) {
    var contours = [];
    var currentContour = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    _check2.default.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}

// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    var p = new _path2.default();
    if (!points) {
        return p;
    }

    var contours = getContours(points);

    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
        var contour = contours[contourIndex];

        var prev = null;
        var curr = contour[contour.length - 1];
        var next = contour[0];

        if (curr.onCurve) {
            p.moveTo(curr.x, curr.y);
        } else {
            if (next.onCurve) {
                p.moveTo(next.x, next.y);
            } else {
                // If both first and last points are off-curve, start at their middle.
                var start = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
                p.moveTo(start.x, start.y);
            }
        }

        for (var i = 0; i < contour.length; ++i) {
            prev = curr;
            curr = next;
            next = contour[(i + 1) % contour.length];

            if (curr.onCurve) {
                // This is a straight line.
                p.lineTo(curr.x, curr.y);
            } else {
                var prev2 = prev;
                var next2 = next;

                if (!prev.onCurve) {
                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
                    p.lineTo(prev2.x, prev2.y);
                }

                if (!next.onCurve) {
                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
                }

                p.lineTo(prev2.x, prev2.y);
                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
            }
        }

        p.closePath();
    }
    return p;
}

function buildPath(glyphs, glyph) {
    if (glyph.isComposite) {
        for (var j = 0; j < glyph.components.length; j += 1) {
            var component = glyph.components[j];
            var componentGlyph = glyphs.get(component.glyphIndex);
            // Force the ttfGlyphLoader to parse the glyph.
            componentGlyph.getPath();
            if (componentGlyph.points) {
                var transformedPoints = void 0;
                if (component.matchedPoints === undefined) {
                    // component positioned by offset
                    transformedPoints = transformPoints(componentGlyph.points, component);
                } else {
                    // component positioned by matched points
                    if (component.matchedPoints[0] > glyph.points.length - 1 || component.matchedPoints[1] > componentGlyph.points.length - 1) {
                        throw Error('Matched points out of range in ' + glyph.name);
                    }
                    var firstPt = glyph.points[component.matchedPoints[0]];
                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
                    var transform = {
                        xScale: component.xScale, scale01: component.scale01,
                        scale10: component.scale10, yScale: component.yScale,
                        dx: 0, dy: 0
                    };
                    secondPt = transformPoints([secondPt], transform)[0];
                    transform.dx = firstPt.x - secondPt.x;
                    transform.dy = firstPt.y - secondPt.y;
                    transformedPoints = transformPoints(componentGlyph.points, transform);
                }
                glyph.points = glyph.points.concat(transformedPoints);
            }
        }
    }

    return getPath(glyph.points);
}

// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    var glyphs = new _glyphset2.default.GlyphSet(font);

    // The last element of the loca table is invalid.
    for (var i = 0; i < loca.length - 1; i += 1) {
        var offset = loca[i];
        var nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(i, _glyphset2.default.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
        } else {
            glyphs.push(i, _glyphset2.default.glyphLoader(font, i));
        }
    }

    return glyphs;
}

exports.default = { getPath: getPath, parse: parseGlyfTable };

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _parse = __webpack_require__(17);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var subtableParsers = new Array(9); // subtableParsers[0] is unused

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
// The `GSUB` table contains ligatures, among other things.
// https://www.microsoft.com/typography/OTSPEC/gsub.htm

subtableParsers[1] = function parseLookup1() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(_parse.Parser.coverage),
            deltaGlyphId: this.parseUShort()
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(_parse.Parser.coverage),
            substitute: this.parseOffset16List()
        };
    }
    _check2.default.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
subtableParsers[2] = function parseLookup2() {
    var substFormat = this.parseUShort();
    _check2.default.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(_parse.Parser.coverage),
        sequences: this.parseListOfLists()
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
subtableParsers[3] = function parseLookup3() {
    var substFormat = this.parseUShort();
    _check2.default.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(_parse.Parser.coverage),
        alternateSets: this.parseListOfLists()
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
subtableParsers[4] = function parseLookup4() {
    var substFormat = this.parseUShort();
    _check2.default.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(_parse.Parser.coverage),
        ligatureSets: this.parseListOfLists(function () {
            return {
                ligGlyph: this.parseUShort(),
                components: this.parseUShortList(this.parseUShort() - 1)
            };
        })
    };
};

var lookupRecordDesc = {
    sequenceIndex: _parse.Parser.uShort,
    lookupListIndex: _parse.Parser.uShort
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
subtableParsers[5] = function parseLookup5() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();

    if (substFormat === 1) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(_parse.Parser.coverage),
            ruleSets: this.parseListOfLists(function () {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    input: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(_parse.Parser.coverage),
            classDef: this.parsePointer(_parse.Parser.classDef),
            classSets: this.parseListOfLists(function () {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    classes: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        var glyphCount = this.parseUShort();
        var substCount = this.parseUShort();
        return {
            substFormat: substFormat,
            coverages: this.parseList(glyphCount, _parse.Parser.pointer(_parse.Parser.coverage)),
            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
        };
    }
    _check2.default.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
subtableParsers[6] = function parseLookup6() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(_parse.Parser.coverage),
            chainRuleSets: this.parseListOfLists(function () {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(_parse.Parser.coverage),
            backtrackClassDef: this.parsePointer(_parse.Parser.classDef),
            inputClassDef: this.parsePointer(_parse.Parser.classDef),
            lookaheadClassDef: this.parsePointer(_parse.Parser.classDef),
            chainClassSet: this.parseListOfLists(function () {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        return {
            substFormat: 3,
            backtrackCoverage: this.parseList(_parse.Parser.pointer(_parse.Parser.coverage)),
            inputCoverage: this.parseList(_parse.Parser.pointer(_parse.Parser.coverage)),
            lookaheadCoverage: this.parseList(_parse.Parser.pointer(_parse.Parser.coverage)),
            lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
    }
    _check2.default.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
subtableParsers[7] = function parseLookup7() {
    // Extension Substitution subtable
    var substFormat = this.parseUShort();
    _check2.default.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
    var extensionLookupType = this.parseUShort();
    var extensionParser = new _parse.Parser(this.data, this.offset + this.parseULong());
    return {
        substFormat: 1,
        lookupType: extensionLookupType,
        extension: subtableParsers[extensionLookupType].call(extensionParser)
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
subtableParsers[8] = function parseLookup8() {
    var substFormat = this.parseUShort();
    _check2.default.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(_parse.Parser.coverage),
        backtrackCoverage: this.parseList(_parse.Parser.pointer(_parse.Parser.coverage)),
        lookaheadCoverage: this.parseList(_parse.Parser.pointer(_parse.Parser.coverage)),
        substitutes: this.parseUShortList()
    };
};

// https://www.microsoft.com/typography/OTSPEC/gsub.htm
function parseGsubTable(data, start) {
    start = start || 0;
    var p = new _parse.Parser(data, start);
    var tableVersion = p.parseVersion();
    _check2.default.argument(tableVersion === 1, 'Unsupported GSUB table version.');
    return {
        version: tableVersion,
        scripts: p.parseScriptList(),
        features: p.parseFeatureList(),
        lookups: p.parseLookupList(subtableParsers)
    };
}

// GSUB Writing //////////////////////////////////////////////
var subtableMakers = new Array(9);

subtableMakers[1] = function makeLookup1(subtable) {
    if (subtable.substFormat === 1) {
        return new _table2.default.Table('substitutionTable', [{ name: 'substFormat', type: 'USHORT', value: 1 }, { name: 'coverage', type: 'TABLE', value: new _table2.default.Coverage(subtable.coverage) }, { name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId }]);
    } else {
        return new _table2.default.Table('substitutionTable', [{ name: 'substFormat', type: 'USHORT', value: 2 }, { name: 'coverage', type: 'TABLE', value: new _table2.default.Coverage(subtable.coverage) }].concat(_table2.default.ushortList('substitute', subtable.substitute)));
    }
    _check2.default.fail('Lookup type 1 substFormat must be 1 or 2.');
};

subtableMakers[3] = function makeLookup3(subtable) {
    _check2.default.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
    return new _table2.default.Table('substitutionTable', [{ name: 'substFormat', type: 'USHORT', value: 1 }, { name: 'coverage', type: 'TABLE', value: new _table2.default.Coverage(subtable.coverage) }].concat(_table2.default.tableList('altSet', subtable.alternateSets, function (alternateSet) {
        return new _table2.default.Table('alternateSetTable', _table2.default.ushortList('alternate', alternateSet));
    })));
};

subtableMakers[4] = function makeLookup4(subtable) {
    _check2.default.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
    return new _table2.default.Table('substitutionTable', [{ name: 'substFormat', type: 'USHORT', value: 1 }, { name: 'coverage', type: 'TABLE', value: new _table2.default.Coverage(subtable.coverage) }].concat(_table2.default.tableList('ligSet', subtable.ligatureSets, function (ligatureSet) {
        return new _table2.default.Table('ligatureSetTable', _table2.default.tableList('ligature', ligatureSet, function (ligature) {
            return new _table2.default.Table('ligatureTable', [{ name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph }].concat(_table2.default.ushortList('component', ligature.components, ligature.components.length + 1)));
        }));
    })));
};

function makeGsubTable(gsub) {
    return new _table2.default.Table('GSUB', [{ name: 'version', type: 'ULONG', value: 0x10000 }, { name: 'scripts', type: 'TABLE', value: new _table2.default.ScriptList(gsub.scripts) }, { name: 'features', type: 'TABLE', value: new _table2.default.FeatureList(gsub.features) }, { name: 'lookups', type: 'TABLE', value: new _table2.default.LookupList(gsub.lookups, subtableMakers) }]);
}

exports.default = { parse: parseGsubTable, make: makeGsubTable };

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parse the header `head` table
function parseHeadTable(data, start) {
    var head = {};
    var p = new _parse2.default.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    _check2.default.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();
    head.glyphDataFormat = p.parseShort();
    return head;
} // The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm

function makeHeadTable(options) {
    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
    var createdTimestamp = timestamp;

    if (options.createdTimestamp) {
        createdTimestamp = options.createdTimestamp + 2082844800;
    }

    return new _table2.default.Table('head', [{ name: 'version', type: 'FIXED', value: 0x00010000 }, { name: 'fontRevision', type: 'FIXED', value: 0x00010000 }, { name: 'checkSumAdjustment', type: 'ULONG', value: 0 }, { name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5 }, { name: 'flags', type: 'USHORT', value: 0 }, { name: 'unitsPerEm', type: 'USHORT', value: 1000 }, { name: 'created', type: 'LONGDATETIME', value: createdTimestamp }, { name: 'modified', type: 'LONGDATETIME', value: timestamp }, { name: 'xMin', type: 'SHORT', value: 0 }, { name: 'yMin', type: 'SHORT', value: 0 }, { name: 'xMax', type: 'SHORT', value: 0 }, { name: 'yMax', type: 'SHORT', value: 0 }, { name: 'macStyle', type: 'USHORT', value: 0 }, { name: 'lowestRecPPEM', type: 'USHORT', value: 0 }, { name: 'fontDirectionHint', type: 'SHORT', value: 2 }, { name: 'indexToLocFormat', type: 'SHORT', value: 0 }, { name: 'glyphDataFormat', type: 'SHORT', value: 0 }], options);
}

exports.default = { parse: parseHeadTable, make: makeHeadTable };

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parse the horizontal header `hhea` table
// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm

function parseHheaTable(data, start) {
    var hhea = {};
    var p = new _parse2.default.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}

function makeHheaTable(options) {
    return new _table2.default.Table('hhea', [{ name: 'version', type: 'FIXED', value: 0x00010000 }, { name: 'ascender', type: 'FWORD', value: 0 }, { name: 'descender', type: 'FWORD', value: 0 }, { name: 'lineGap', type: 'FWORD', value: 0 }, { name: 'advanceWidthMax', type: 'UFWORD', value: 0 }, { name: 'minLeftSideBearing', type: 'FWORD', value: 0 }, { name: 'minRightSideBearing', type: 'FWORD', value: 0 }, { name: 'xMaxExtent', type: 'FWORD', value: 0 }, { name: 'caretSlopeRise', type: 'SHORT', value: 1 }, { name: 'caretSlopeRun', type: 'SHORT', value: 0 }, { name: 'caretOffset', type: 'SHORT', value: 0 }, { name: 'reserved1', type: 'SHORT', value: 0 }, { name: 'reserved2', type: 'SHORT', value: 0 }, { name: 'reserved3', type: 'SHORT', value: 0 }, { name: 'reserved4', type: 'SHORT', value: 0 }, { name: 'metricDataFormat', type: 'SHORT', value: 0 }, { name: 'numberOfHMetrics', type: 'USHORT', value: 0 }], options);
}

exports.default = { parse: parseHheaTable, make: makeHheaTable };

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm

function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    var advanceWidth = void 0;
    var leftSideBearing = void 0;
    var p = new _parse2.default.Parser(data, start);
    for (var i = 0; i < numGlyphs; i += 1) {
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }

        var glyph = glyphs.get(i);
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}

function makeHmtxTable(glyphs) {
    var t = new _table2.default.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({ name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth });
        t.fields.push({ name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing });
    }

    return t;
}

exports.default = { parse: parseHmtxTable, make: makeHmtxTable };

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function makeLtagTable(tags) {
    var result = new _table2.default.Table('ltag', [{ name: 'version', type: 'ULONG', value: 1 }, { name: 'flags', type: 'ULONG', value: 0 }, { name: 'numTags', type: 'ULONG', value: tags.length }]);

    var stringPool = '';
    var stringPoolOffset = 12 + tags.length * 4;
    for (var i = 0; i < tags.length; ++i) {
        var pos = stringPool.indexOf(tags[i]);
        if (pos < 0) {
            pos = stringPool.length;
            stringPool += tags[i];
        }

        result.fields.push({ name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos });
        result.fields.push({ name: 'length ' + i, type: 'USHORT', value: tags[i].length });
    }

    result.fields.push({ name: 'stringPool', type: 'CHARARRAY', value: stringPool });
    return result;
} // The `ltag` table stores IETF BCP-47 language tags. It allows supporting
// languages for which TrueType does not assign a numeric code.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6ltag.html
// http://www.w3.org/International/articles/language-tags/
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry

function parseLtagTable(data, start) {
    var p = new _parse2.default.Parser(data, start);
    var tableVersion = p.parseULong();
    _check2.default.argument(tableVersion === 1, 'Unsupported ltag table version.');
    // The 'ltag' specification does not define any flags; skip the field.
    p.skip('uLong', 1);
    var numTags = p.parseULong();

    var tags = [];
    for (var i = 0; i < numTags; i++) {
        var tag = '';
        var offset = start + p.parseUShort();
        var length = p.parseUShort();
        for (var j = offset; j < offset + length; ++j) {
            tag += String.fromCharCode(data.getInt8(j));
        }

        tags.push(tag);
    }

    return tags;
}

exports.default = { make: makeLtagTable, parse: parseLtagTable };

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parse the maximum profile `maxp` table.
// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm

function parseMaxpTable(data, start) {
    var maxp = {};
    var p = new _parse2.default.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }

    return maxp;
}

function makeMaxpTable(numGlyphs) {
    return new _table2.default.Table('maxp', [{ name: 'version', type: 'FIXED', value: 0x00005000 }, { name: 'numGlyphs', type: 'USHORT', value: numGlyphs }]);
}

exports.default = { parse: parseMaxpTable, make: makeMaxpTable };

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _types = __webpack_require__(151);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parse the metadata `meta` table.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

function parseMetaTable(data, start) {
    var p = new _parse2.default.Parser(data, start);
    var tableVersion = p.parseULong();
    _check2.default.argument(tableVersion === 1, 'Unsupported META table version.');
    p.parseULong(); // flags - currently unused and set to 0
    p.parseULong(); // tableOffset
    var numDataMaps = p.parseULong();

    var tags = {};
    for (var i = 0; i < numDataMaps; i++) {
        var tag = p.parseTag();
        var dataOffset = p.parseULong();
        var dataLength = p.parseULong();
        var text = _types.decode.UTF8(data, start + dataOffset, dataLength);

        tags[tag] = text;
    }
    return tags;
}

function makeMetaTable(tags) {
    var numTags = (0, _keys2.default)(tags).length;
    var stringPool = '';
    var stringPoolOffset = 16 + numTags * 12;

    var result = new _table2.default.Table('meta', [{ name: 'version', type: 'ULONG', value: 1 }, { name: 'flags', type: 'ULONG', value: 0 }, { name: 'offset', type: 'ULONG', value: stringPoolOffset }, { name: 'numTags', type: 'ULONG', value: numTags }]);

    for (var tag in tags) {
        var pos = stringPool.length;
        stringPool += tags[tag];

        result.fields.push({ name: 'tag ' + tag, type: 'TAG', value: tag });
        result.fields.push({ name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos });
        result.fields.push({ name: 'length ' + tag, type: 'ULONG', value: tags[tag].length });
    }

    result.fields.push({ name: 'stringPool', type: 'CHARARRAY', value: stringPool });

    return result;
}

exports.default = { parse: parseMetaTable, make: makeMetaTable };

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _types = __webpack_require__(151);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NameIDs for the name table.
var nameTableNames = ['copyright', // 0
'fontFamily', // 1
'fontSubfamily', // 2
'uniqueID', // 3
'fullName', // 4
'version', // 5
'postScriptName', // 6
'trademark', // 7
'manufacturer', // 8
'designer', // 9
'description', // 10
'manufacturerURL', // 11
'designerURL', // 12
'license', // 13
'licenseURL', // 14
'reserved', // 15
'preferredFamily', // 16
'preferredSubfamily', // 17
'compatibleFullName', // 18
'sampleText', // 19
'postScriptFindFontName', // 20
'wwsFamily', // 21
'wwsSubfamily' // 22
]; // The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm

var macLanguages = {
    0: 'en',
    1: 'fr',
    2: 'de',
    3: 'it',
    4: 'nl',
    5: 'sv',
    6: 'es',
    7: 'da',
    8: 'pt',
    9: 'no',
    10: 'he',
    11: 'ja',
    12: 'ar',
    13: 'fi',
    14: 'el',
    15: 'is',
    16: 'mt',
    17: 'tr',
    18: 'hr',
    19: 'zh-Hant',
    20: 'ur',
    21: 'hi',
    22: 'th',
    23: 'ko',
    24: 'lt',
    25: 'pl',
    26: 'hu',
    27: 'es',
    28: 'lv',
    29: 'se',
    30: 'fo',
    31: 'fa',
    32: 'ru',
    33: 'zh',
    34: 'nl-BE',
    35: 'ga',
    36: 'sq',
    37: 'ro',
    38: 'cz',
    39: 'sk',
    40: 'si',
    41: 'yi',
    42: 'sr',
    43: 'mk',
    44: 'bg',
    45: 'uk',
    46: 'be',
    47: 'uz',
    48: 'kk',
    49: 'az-Cyrl',
    50: 'az-Arab',
    51: 'hy',
    52: 'ka',
    53: 'mo',
    54: 'ky',
    55: 'tg',
    56: 'tk',
    57: 'mn-CN',
    58: 'mn',
    59: 'ps',
    60: 'ks',
    61: 'ku',
    62: 'sd',
    63: 'bo',
    64: 'ne',
    65: 'sa',
    66: 'mr',
    67: 'bn',
    68: 'as',
    69: 'gu',
    70: 'pa',
    71: 'or',
    72: 'ml',
    73: 'kn',
    74: 'ta',
    75: 'te',
    76: 'si',
    77: 'my',
    78: 'km',
    79: 'lo',
    80: 'vi',
    81: 'id',
    82: 'tl',
    83: 'ms',
    84: 'ms-Arab',
    85: 'am',
    86: 'ti',
    87: 'om',
    88: 'so',
    89: 'sw',
    90: 'rw',
    91: 'rn',
    92: 'ny',
    93: 'mg',
    94: 'eo',
    128: 'cy',
    129: 'eu',
    130: 'ca',
    131: 'la',
    132: 'qu',
    133: 'gn',
    134: 'ay',
    135: 'tt',
    136: 'ug',
    137: 'dz',
    138: 'jv',
    139: 'su',
    140: 'gl',
    141: 'af',
    142: 'br',
    143: 'iu',
    144: 'gd',
    145: 'gv',
    146: 'ga',
    147: 'to',
    148: 'el-polyton',
    149: 'kl',
    150: 'az',
    151: 'nn'
};

// MacOS language ID  MacOS script ID
//
// Note that the script ID is not sufficient to determine what encoding
// to use in TrueType files. For some languages, MacOS used a modification
// of a mainstream script. For example, an Icelandic name would be stored
// with smRoman in the TrueType naming table, but the actual encoding
// is a special Icelandic version of the normal Macintosh Roman encoding.
// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
// Syllables but MacOS had run out of available script codes, so this was
// done as a (pretty radical) "modification" of Ethiopic.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
var macLanguageToScript = {
    0: 0, // langEnglish  smRoman
    1: 0, // langFrench  smRoman
    2: 0, // langGerman  smRoman
    3: 0, // langItalian  smRoman
    4: 0, // langDutch  smRoman
    5: 0, // langSwedish  smRoman
    6: 0, // langSpanish  smRoman
    7: 0, // langDanish  smRoman
    8: 0, // langPortuguese  smRoman
    9: 0, // langNorwegian  smRoman
    10: 5, // langHebrew  smHebrew
    11: 1, // langJapanese  smJapanese
    12: 4, // langArabic  smArabic
    13: 0, // langFinnish  smRoman
    14: 6, // langGreek  smGreek
    15: 0, // langIcelandic  smRoman (modified)
    16: 0, // langMaltese  smRoman
    17: 0, // langTurkish  smRoman (modified)
    18: 0, // langCroatian  smRoman (modified)
    19: 2, // langTradChinese  smTradChinese
    20: 4, // langUrdu  smArabic
    21: 9, // langHindi  smDevanagari
    22: 21, // langThai  smThai
    23: 3, // langKorean  smKorean
    24: 29, // langLithuanian  smCentralEuroRoman
    25: 29, // langPolish  smCentralEuroRoman
    26: 29, // langHungarian  smCentralEuroRoman
    27: 29, // langEstonian  smCentralEuroRoman
    28: 29, // langLatvian  smCentralEuroRoman
    29: 0, // langSami  smRoman
    30: 0, // langFaroese  smRoman (modified)
    31: 4, // langFarsi  smArabic (modified)
    32: 7, // langRussian  smCyrillic
    33: 25, // langSimpChinese  smSimpChinese
    34: 0, // langFlemish  smRoman
    35: 0, // langIrishGaelic  smRoman (modified)
    36: 0, // langAlbanian  smRoman
    37: 0, // langRomanian  smRoman (modified)
    38: 29, // langCzech  smCentralEuroRoman
    39: 29, // langSlovak  smCentralEuroRoman
    40: 0, // langSlovenian  smRoman (modified)
    41: 5, // langYiddish  smHebrew
    42: 7, // langSerbian  smCyrillic
    43: 7, // langMacedonian  smCyrillic
    44: 7, // langBulgarian  smCyrillic
    45: 7, // langUkrainian  smCyrillic (modified)
    46: 7, // langByelorussian  smCyrillic
    47: 7, // langUzbek  smCyrillic
    48: 7, // langKazakh  smCyrillic
    49: 7, // langAzerbaijani  smCyrillic
    50: 4, // langAzerbaijanAr  smArabic
    51: 24, // langArmenian  smArmenian
    52: 23, // langGeorgian  smGeorgian
    53: 7, // langMoldavian  smCyrillic
    54: 7, // langKirghiz  smCyrillic
    55: 7, // langTajiki  smCyrillic
    56: 7, // langTurkmen  smCyrillic
    57: 27, // langMongolian  smMongolian
    58: 7, // langMongolianCyr  smCyrillic
    59: 4, // langPashto  smArabic
    60: 4, // langKurdish  smArabic
    61: 4, // langKashmiri  smArabic
    62: 4, // langSindhi  smArabic
    63: 26, // langTibetan  smTibetan
    64: 9, // langNepali  smDevanagari
    65: 9, // langSanskrit  smDevanagari
    66: 9, // langMarathi  smDevanagari
    67: 13, // langBengali  smBengali
    68: 13, // langAssamese  smBengali
    69: 11, // langGujarati  smGujarati
    70: 10, // langPunjabi  smGurmukhi
    71: 12, // langOriya  smOriya
    72: 17, // langMalayalam  smMalayalam
    73: 16, // langKannada  smKannada
    74: 14, // langTamil  smTamil
    75: 15, // langTelugu  smTelugu
    76: 18, // langSinhalese  smSinhalese
    77: 19, // langBurmese  smBurmese
    78: 20, // langKhmer  smKhmer
    79: 22, // langLao  smLao
    80: 30, // langVietnamese  smVietnamese
    81: 0, // langIndonesian  smRoman
    82: 0, // langTagalog  smRoman
    83: 0, // langMalayRoman  smRoman
    84: 4, // langMalayArabic  smArabic
    85: 28, // langAmharic  smEthiopic
    86: 28, // langTigrinya  smEthiopic
    87: 28, // langOromo  smEthiopic
    88: 0, // langSomali  smRoman
    89: 0, // langSwahili  smRoman
    90: 0, // langKinyarwanda  smRoman
    91: 0, // langRundi  smRoman
    92: 0, // langNyanja  smRoman
    93: 0, // langMalagasy  smRoman
    94: 0, // langEsperanto  smRoman
    128: 0, // langWelsh  smRoman (modified)
    129: 0, // langBasque  smRoman
    130: 0, // langCatalan  smRoman
    131: 0, // langLatin  smRoman
    132: 0, // langQuechua  smRoman
    133: 0, // langGuarani  smRoman
    134: 0, // langAymara  smRoman
    135: 7, // langTatar  smCyrillic
    136: 4, // langUighur  smArabic
    137: 26, // langDzongkha  smTibetan
    138: 0, // langJavaneseRom  smRoman
    139: 0, // langSundaneseRom  smRoman
    140: 0, // langGalician  smRoman
    141: 0, // langAfrikaans  smRoman
    142: 0, // langBreton  smRoman (modified)
    143: 28, // langInuktitut  smEthiopic (modified)
    144: 0, // langScottishGaelic  smRoman (modified)
    145: 0, // langManxGaelic  smRoman (modified)
    146: 0, // langIrishGaelicScript  smRoman (modified)
    147: 0, // langTongan  smRoman
    148: 6, // langGreekAncient  smRoman
    149: 0, // langGreenlandic  smRoman
    150: 0, // langAzerbaijanRoman  smRoman
    151: 0 // langNynorsk  smRoman
};

// While Microsoft indicates a region/country for all its language
// IDs, we omit the region code if it's equal to the "most likely
// region subtag" according to Unicode CLDR. For scripts, we omit
// the subtag if it is equal to the Suppress-Script entry in the
// IANA language subtag registry for IETF BCP 47.
//
// For example, Microsoft states that its language code 0x041A is
// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
// and not 'hr-HR' because Croatia is the default country for Croatian,
// according to Unicode CLDR. As another example, Microsoft states
// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
// for the Croatian language, according to IANA.
//
// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
var windowsLanguages = {
    0x0436: 'af',
    0x041C: 'sq',
    0x0484: 'gsw',
    0x045E: 'am',
    0x1401: 'ar-DZ',
    0x3C01: 'ar-BH',
    0x0C01: 'ar',
    0x0801: 'ar-IQ',
    0x2C01: 'ar-JO',
    0x3401: 'ar-KW',
    0x3001: 'ar-LB',
    0x1001: 'ar-LY',
    0x1801: 'ary',
    0x2001: 'ar-OM',
    0x4001: 'ar-QA',
    0x0401: 'ar-SA',
    0x2801: 'ar-SY',
    0x1C01: 'aeb',
    0x3801: 'ar-AE',
    0x2401: 'ar-YE',
    0x042B: 'hy',
    0x044D: 'as',
    0x082C: 'az-Cyrl',
    0x042C: 'az',
    0x046D: 'ba',
    0x042D: 'eu',
    0x0423: 'be',
    0x0845: 'bn',
    0x0445: 'bn-IN',
    0x201A: 'bs-Cyrl',
    0x141A: 'bs',
    0x047E: 'br',
    0x0402: 'bg',
    0x0403: 'ca',
    0x0C04: 'zh-HK',
    0x1404: 'zh-MO',
    0x0804: 'zh',
    0x1004: 'zh-SG',
    0x0404: 'zh-TW',
    0x0483: 'co',
    0x041A: 'hr',
    0x101A: 'hr-BA',
    0x0405: 'cs',
    0x0406: 'da',
    0x048C: 'prs',
    0x0465: 'dv',
    0x0813: 'nl-BE',
    0x0413: 'nl',
    0x0C09: 'en-AU',
    0x2809: 'en-BZ',
    0x1009: 'en-CA',
    0x2409: 'en-029',
    0x4009: 'en-IN',
    0x1809: 'en-IE',
    0x2009: 'en-JM',
    0x4409: 'en-MY',
    0x1409: 'en-NZ',
    0x3409: 'en-PH',
    0x4809: 'en-SG',
    0x1C09: 'en-ZA',
    0x2C09: 'en-TT',
    0x0809: 'en-GB',
    0x0409: 'en',
    0x3009: 'en-ZW',
    0x0425: 'et',
    0x0438: 'fo',
    0x0464: 'fil',
    0x040B: 'fi',
    0x080C: 'fr-BE',
    0x0C0C: 'fr-CA',
    0x040C: 'fr',
    0x140C: 'fr-LU',
    0x180C: 'fr-MC',
    0x100C: 'fr-CH',
    0x0462: 'fy',
    0x0456: 'gl',
    0x0437: 'ka',
    0x0C07: 'de-AT',
    0x0407: 'de',
    0x1407: 'de-LI',
    0x1007: 'de-LU',
    0x0807: 'de-CH',
    0x0408: 'el',
    0x046F: 'kl',
    0x0447: 'gu',
    0x0468: 'ha',
    0x040D: 'he',
    0x0439: 'hi',
    0x040E: 'hu',
    0x040F: 'is',
    0x0470: 'ig',
    0x0421: 'id',
    0x045D: 'iu',
    0x085D: 'iu-Latn',
    0x083C: 'ga',
    0x0434: 'xh',
    0x0435: 'zu',
    0x0410: 'it',
    0x0810: 'it-CH',
    0x0411: 'ja',
    0x044B: 'kn',
    0x043F: 'kk',
    0x0453: 'km',
    0x0486: 'quc',
    0x0487: 'rw',
    0x0441: 'sw',
    0x0457: 'kok',
    0x0412: 'ko',
    0x0440: 'ky',
    0x0454: 'lo',
    0x0426: 'lv',
    0x0427: 'lt',
    0x082E: 'dsb',
    0x046E: 'lb',
    0x042F: 'mk',
    0x083E: 'ms-BN',
    0x043E: 'ms',
    0x044C: 'ml',
    0x043A: 'mt',
    0x0481: 'mi',
    0x047A: 'arn',
    0x044E: 'mr',
    0x047C: 'moh',
    0x0450: 'mn',
    0x0850: 'mn-CN',
    0x0461: 'ne',
    0x0414: 'nb',
    0x0814: 'nn',
    0x0482: 'oc',
    0x0448: 'or',
    0x0463: 'ps',
    0x0415: 'pl',
    0x0416: 'pt',
    0x0816: 'pt-PT',
    0x0446: 'pa',
    0x046B: 'qu-BO',
    0x086B: 'qu-EC',
    0x0C6B: 'qu',
    0x0418: 'ro',
    0x0417: 'rm',
    0x0419: 'ru',
    0x243B: 'smn',
    0x103B: 'smj-NO',
    0x143B: 'smj',
    0x0C3B: 'se-FI',
    0x043B: 'se',
    0x083B: 'se-SE',
    0x203B: 'sms',
    0x183B: 'sma-NO',
    0x1C3B: 'sms',
    0x044F: 'sa',
    0x1C1A: 'sr-Cyrl-BA',
    0x0C1A: 'sr',
    0x181A: 'sr-Latn-BA',
    0x081A: 'sr-Latn',
    0x046C: 'nso',
    0x0432: 'tn',
    0x045B: 'si',
    0x041B: 'sk',
    0x0424: 'sl',
    0x2C0A: 'es-AR',
    0x400A: 'es-BO',
    0x340A: 'es-CL',
    0x240A: 'es-CO',
    0x140A: 'es-CR',
    0x1C0A: 'es-DO',
    0x300A: 'es-EC',
    0x440A: 'es-SV',
    0x100A: 'es-GT',
    0x480A: 'es-HN',
    0x080A: 'es-MX',
    0x4C0A: 'es-NI',
    0x180A: 'es-PA',
    0x3C0A: 'es-PY',
    0x280A: 'es-PE',
    0x500A: 'es-PR',

    // Microsoft has defined two different language codes for
    // Spanish with modern sorting and Spanish with traditional
    // sorting. This makes sense for collation APIs, and it would be
    // possible to express this in BCP 47 language tags via Unicode
    // extensions (eg., es-u-co-trad is Spanish with traditional
    // sorting). However, for storing names in fonts, the distinction
    // does not make sense, so we give es in both cases.
    0x0C0A: 'es',
    0x040A: 'es',

    0x540A: 'es-US',
    0x380A: 'es-UY',
    0x200A: 'es-VE',
    0x081D: 'sv-FI',
    0x041D: 'sv',
    0x045A: 'syr',
    0x0428: 'tg',
    0x085F: 'tzm',
    0x0449: 'ta',
    0x0444: 'tt',
    0x044A: 'te',
    0x041E: 'th',
    0x0451: 'bo',
    0x041F: 'tr',
    0x0442: 'tk',
    0x0480: 'ug',
    0x0422: 'uk',
    0x042E: 'hsb',
    0x0420: 'ur',
    0x0843: 'uz-Cyrl',
    0x0443: 'uz',
    0x042A: 'vi',
    0x0452: 'cy',
    0x0488: 'wo',
    0x0485: 'sah',
    0x0478: 'ii',
    0x046A: 'yo'
};

// Returns a IETF BCP 47 language code, for example 'zh-Hant'
// for 'Chinese in the traditional script'.
function getLanguageCode(platformID, languageID, ltag) {
    switch (platformID) {
        case 0:
            // Unicode
            if (languageID === 0xFFFF) {
                return 'und';
            } else if (ltag) {
                return ltag[languageID];
            }

            break;

        case 1:
            // Macintosh
            return macLanguages[languageID];

        case 3:
            // Windows
            return windowsLanguages[languageID];
    }

    return undefined;
}

var utf16 = 'utf-16';

// MacOS script ID  encoding. This table stores the default case,
// which can be overridden by macLanguageEncodings.
var macScriptEncodings = {
    0: 'macintosh', // smRoman
    1: 'x-mac-japanese', // smJapanese
    2: 'x-mac-chinesetrad', // smTradChinese
    3: 'x-mac-korean', // smKorean
    6: 'x-mac-greek', // smGreek
    7: 'x-mac-cyrillic', // smCyrillic
    9: 'x-mac-devanagai', // smDevanagari
    10: 'x-mac-gurmukhi', // smGurmukhi
    11: 'x-mac-gujarati', // smGujarati
    12: 'x-mac-oriya', // smOriya
    13: 'x-mac-bengali', // smBengali
    14: 'x-mac-tamil', // smTamil
    15: 'x-mac-telugu', // smTelugu
    16: 'x-mac-kannada', // smKannada
    17: 'x-mac-malayalam', // smMalayalam
    18: 'x-mac-sinhalese', // smSinhalese
    19: 'x-mac-burmese', // smBurmese
    20: 'x-mac-khmer', // smKhmer
    21: 'x-mac-thai', // smThai
    22: 'x-mac-lao', // smLao
    23: 'x-mac-georgian', // smGeorgian
    24: 'x-mac-armenian', // smArmenian
    25: 'x-mac-chinesesimp', // smSimpChinese
    26: 'x-mac-tibetan', // smTibetan
    27: 'x-mac-mongolian', // smMongolian
    28: 'x-mac-ethiopic', // smEthiopic
    29: 'x-mac-ce', // smCentralEuroRoman
    30: 'x-mac-vietnamese', // smVietnamese
    31: 'x-mac-extarabic' // smExtArabic
};

// MacOS language ID  encoding. This table stores the exceptional
// cases, which override macScriptEncodings. For writing MacOS naming
// tables, we need to emit a MacOS script ID. Therefore, we cannot
// merge macScriptEncodings into macLanguageEncodings.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
var macLanguageEncodings = {
    15: 'x-mac-icelandic', // langIcelandic
    17: 'x-mac-turkish', // langTurkish
    18: 'x-mac-croatian', // langCroatian
    24: 'x-mac-ce', // langLithuanian
    25: 'x-mac-ce', // langPolish
    26: 'x-mac-ce', // langHungarian
    27: 'x-mac-ce', // langEstonian
    28: 'x-mac-ce', // langLatvian
    30: 'x-mac-icelandic', // langFaroese
    37: 'x-mac-romanian', // langRomanian
    38: 'x-mac-ce', // langCzech
    39: 'x-mac-ce', // langSlovak
    40: 'x-mac-ce', // langSlovenian
    143: 'x-mac-inuit', // langInuktitut
    146: 'x-mac-gaelic' // langIrishGaelicScript
};

function getEncoding(platformID, encodingID, languageID) {
    switch (platformID) {
        case 0:
            // Unicode
            return utf16;

        case 1:
            // Apple Macintosh
            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

        case 3:
            // Microsoft Windows
            if (encodingID === 1 || encodingID === 10) {
                return utf16;
            }

            break;
    }

    return undefined;
}

// Parse the naming `name` table.
// FIXME: Format 1 additional fields are not supported yet.
// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
function parseNameTable(data, start, ltag) {
    var name = {};
    var p = new _parse2.default.Parser(data, start);
    var format = p.parseUShort();
    var count = p.parseUShort();
    var stringOffset = p.offset + p.parseUShort();
    for (var i = 0; i < count; i++) {
        var platformID = p.parseUShort();
        var encodingID = p.parseUShort();
        var languageID = p.parseUShort();
        var nameID = p.parseUShort();
        var property = nameTableNames[nameID] || nameID;
        var byteLength = p.parseUShort();
        var offset = p.parseUShort();
        var language = getLanguageCode(platformID, languageID, ltag);
        var encoding = getEncoding(platformID, encodingID, languageID);
        if (encoding !== undefined && language !== undefined) {
            var text = void 0;
            if (encoding === utf16) {
                text = _types.decode.UTF16(data, stringOffset + offset, byteLength);
            } else {
                text = _types.decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
            }

            if (text) {
                var translations = name[property];
                if (translations === undefined) {
                    translations = name[property] = {};
                }

                translations[language] = text;
            }
        }
    }

    var langTagCount = 0;
    if (format === 1) {
        // FIXME: Also handle Microsoft's 'name' table 1.
        langTagCount = p.parseUShort();
    }

    return name;
}

// {23: 'foo'}  {'foo': 23}
// ['bar', 'baz']  {'bar': 0, 'baz': 1}
function reverseDict(dict) {
    var result = {};
    for (var key in dict) {
        result[dict[key]] = parseInt(key);
    }

    return result;
}

function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new _table2.default.Record('NameRecord', [{ name: 'platformID', type: 'USHORT', value: platformID }, { name: 'encodingID', type: 'USHORT', value: encodingID }, { name: 'languageID', type: 'USHORT', value: languageID }, { name: 'nameID', type: 'USHORT', value: nameID }, { name: 'length', type: 'USHORT', value: length }, { name: 'offset', type: 'USHORT', value: offset }]);
}

// Finds the position of needle in haystack, or -1 if not there.
// Like String.indexOf(), but for arrays.
function findSubArray(needle, haystack) {
    var needleLength = needle.length;
    var limit = haystack.length - needleLength + 1;

    loop: for (var pos = 0; pos < limit; pos++) {
        for (; pos < limit; pos++) {
            for (var k = 0; k < needleLength; k++) {
                if (haystack[pos + k] !== needle[k]) {
                    continue loop;
                }
            }

            return pos;
        }
    }

    return -1;
}

function addStringToPool(s, pool) {
    var offset = findSubArray(s, pool);
    if (offset < 0) {
        offset = pool.length;
        var i = 0;
        var len = s.length;
        for (; i < len; ++i) {
            pool.push(s[i]);
        }
    }

    return offset;
}

function makeNameTable(names, ltag) {
    var nameID = void 0;
    var nameIDs = [];

    var namesWithNumericKeys = {};
    var nameTableIds = reverseDict(nameTableNames);
    for (var key in names) {
        var id = nameTableIds[key];
        if (id === undefined) {
            id = key;
        }

        nameID = parseInt(id);

        if (isNaN(nameID)) {
            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
        }

        namesWithNumericKeys[nameID] = names[key];
        nameIDs.push(nameID);
    }

    var macLanguageIds = reverseDict(macLanguages);
    var windowsLanguageIds = reverseDict(windowsLanguages);

    var nameRecords = [];
    var stringPool = [];

    for (var i = 0; i < nameIDs.length; i++) {
        nameID = nameIDs[i];
        var translations = namesWithNumericKeys[nameID];
        for (var lang in translations) {
            var text = translations[lang];

            // For MacOS, we try to emit the name in the form that was introduced
            // in the initial version of the TrueType spec (in the late 1980s).
            // However, this can fail for various reasons: the requested BCP 47
            // language code might not have an old-style Mac equivalent;
            // we might not have a codec for the needed character encoding;
            // or the name might contain characters that cannot be expressed
            // in the old-style Macintosh encoding. In case of failure, we emit
            // the name in a more modern fashion (Unicode encoding with BCP 47
            // language tags) that is recognized by MacOS 10.5, released in 2009.
            // If fonts were only read by operating systems, we could simply
            // emit all names in the modern form; this would be much easier.
            // However, there are many applications and libraries that read
            // 'name' tables directly, and these will usually only recognize
            // the ancient form (silently skipping the unrecognized names).
            var macPlatform = 1; // Macintosh
            var macLanguage = macLanguageIds[lang];
            var macScript = macLanguageToScript[macLanguage];
            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
            var macName = _types.encode.MACSTRING(text, macEncoding);
            if (macName === undefined) {
                macPlatform = 0; // Unicode
                macLanguage = ltag.indexOf(lang);
                if (macLanguage < 0) {
                    macLanguage = ltag.length;
                    ltag.push(lang);
                }

                macScript = 4; // Unicode 2.0 and later
                macName = _types.encode.UTF16(text);
            }

            var macNameOffset = addStringToPool(macName, stringPool);
            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage, nameID, macName.length, macNameOffset));

            var winLanguage = windowsLanguageIds[lang];
            if (winLanguage !== undefined) {
                var winName = _types.encode.UTF16(text);
                var winNameOffset = addStringToPool(winName, stringPool);
                nameRecords.push(makeNameRecord(3, 1, winLanguage, nameID, winName.length, winNameOffset));
            }
        }
    }

    nameRecords.sort(function (a, b) {
        return a.platformID - b.platformID || a.encodingID - b.encodingID || a.languageID - b.languageID || a.nameID - b.nameID;
    });

    var t = new _table2.default.Table('name', [{ name: 'format', type: 'USHORT', value: 0 }, { name: 'count', type: 'USHORT', value: nameRecords.length }, { name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12 }]);

    for (var r = 0; r < nameRecords.length; r++) {
        t.fields.push({ name: 'record_' + r, type: 'RECORD', value: nameRecords[r] });
    }

    t.fields.push({ name: 'strings', type: 'LITERAL', value: stringPool });
    return t;
}

exports.default = { parse: parseNameTable, make: makeNameTable };

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm

var unicodeRanges = [{ begin: 0x0000, end: 0x007F }, // Basic Latin
{ begin: 0x0080, end: 0x00FF }, // Latin-1 Supplement
{ begin: 0x0100, end: 0x017F }, // Latin Extended-A
{ begin: 0x0180, end: 0x024F }, // Latin Extended-B
{ begin: 0x0250, end: 0x02AF }, // IPA Extensions
{ begin: 0x02B0, end: 0x02FF }, // Spacing Modifier Letters
{ begin: 0x0300, end: 0x036F }, // Combining Diacritical Marks
{ begin: 0x0370, end: 0x03FF }, // Greek and Coptic
{ begin: 0x2C80, end: 0x2CFF }, // Coptic
{ begin: 0x0400, end: 0x04FF }, // Cyrillic
{ begin: 0x0530, end: 0x058F }, // Armenian
{ begin: 0x0590, end: 0x05FF }, // Hebrew
{ begin: 0xA500, end: 0xA63F }, // Vai
{ begin: 0x0600, end: 0x06FF }, // Arabic
{ begin: 0x07C0, end: 0x07FF }, // NKo
{ begin: 0x0900, end: 0x097F }, // Devanagari
{ begin: 0x0980, end: 0x09FF }, // Bengali
{ begin: 0x0A00, end: 0x0A7F }, // Gurmukhi
{ begin: 0x0A80, end: 0x0AFF }, // Gujarati
{ begin: 0x0B00, end: 0x0B7F }, // Oriya
{ begin: 0x0B80, end: 0x0BFF }, // Tamil
{ begin: 0x0C00, end: 0x0C7F }, // Telugu
{ begin: 0x0C80, end: 0x0CFF }, // Kannada
{ begin: 0x0D00, end: 0x0D7F }, // Malayalam
{ begin: 0x0E00, end: 0x0E7F }, // Thai
{ begin: 0x0E80, end: 0x0EFF }, // Lao
{ begin: 0x10A0, end: 0x10FF }, // Georgian
{ begin: 0x1B00, end: 0x1B7F }, // Balinese
{ begin: 0x1100, end: 0x11FF }, // Hangul Jamo
{ begin: 0x1E00, end: 0x1EFF }, // Latin Extended Additional
{ begin: 0x1F00, end: 0x1FFF }, // Greek Extended
{ begin: 0x2000, end: 0x206F }, // General Punctuation
{ begin: 0x2070, end: 0x209F }, // Superscripts And Subscripts
{ begin: 0x20A0, end: 0x20CF }, // Currency Symbol
{ begin: 0x20D0, end: 0x20FF }, // Combining Diacritical Marks For Symbols
{ begin: 0x2100, end: 0x214F }, // Letterlike Symbols
{ begin: 0x2150, end: 0x218F }, // Number Forms
{ begin: 0x2190, end: 0x21FF }, // Arrows
{ begin: 0x2200, end: 0x22FF }, // Mathematical Operators
{ begin: 0x2300, end: 0x23FF }, // Miscellaneous Technical
{ begin: 0x2400, end: 0x243F }, // Control Pictures
{ begin: 0x2440, end: 0x245F }, // Optical Character Recognition
{ begin: 0x2460, end: 0x24FF }, // Enclosed Alphanumerics
{ begin: 0x2500, end: 0x257F }, // Box Drawing
{ begin: 0x2580, end: 0x259F }, // Block Elements
{ begin: 0x25A0, end: 0x25FF }, // Geometric Shapes
{ begin: 0x2600, end: 0x26FF }, // Miscellaneous Symbols
{ begin: 0x2700, end: 0x27BF }, // Dingbats
{ begin: 0x3000, end: 0x303F }, // CJK Symbols And Punctuation
{ begin: 0x3040, end: 0x309F }, // Hiragana
{ begin: 0x30A0, end: 0x30FF }, // Katakana
{ begin: 0x3100, end: 0x312F }, // Bopomofo
{ begin: 0x3130, end: 0x318F }, // Hangul Compatibility Jamo
{ begin: 0xA840, end: 0xA87F }, // Phags-pa
{ begin: 0x3200, end: 0x32FF }, // Enclosed CJK Letters And Months
{ begin: 0x3300, end: 0x33FF }, // CJK Compatibility
{ begin: 0xAC00, end: 0xD7AF }, // Hangul Syllables
{ begin: 0xD800, end: 0xDFFF }, // Non-Plane 0 *
{ begin: 0x10900, end: 0x1091F }, // Phoenicia
{ begin: 0x4E00, end: 0x9FFF }, // CJK Unified Ideographs
{ begin: 0xE000, end: 0xF8FF }, // Private Use Area (plane 0)
{ begin: 0x31C0, end: 0x31EF }, // CJK Strokes
{ begin: 0xFB00, end: 0xFB4F }, // Alphabetic Presentation Forms
{ begin: 0xFB50, end: 0xFDFF }, // Arabic Presentation Forms-A
{ begin: 0xFE20, end: 0xFE2F }, // Combining Half Marks
{ begin: 0xFE10, end: 0xFE1F }, // Vertical Forms
{ begin: 0xFE50, end: 0xFE6F }, // Small Form Variants
{ begin: 0xFE70, end: 0xFEFF }, // Arabic Presentation Forms-B
{ begin: 0xFF00, end: 0xFFEF }, // Halfwidth And Fullwidth Forms
{ begin: 0xFFF0, end: 0xFFFF }, // Specials
{ begin: 0x0F00, end: 0x0FFF }, // Tibetan
{ begin: 0x0700, end: 0x074F }, // Syriac
{ begin: 0x0780, end: 0x07BF }, // Thaana
{ begin: 0x0D80, end: 0x0DFF }, // Sinhala
{ begin: 0x1000, end: 0x109F }, // Myanmar
{ begin: 0x1200, end: 0x137F }, // Ethiopic
{ begin: 0x13A0, end: 0x13FF }, // Cherokee
{ begin: 0x1400, end: 0x167F }, // Unified Canadian Aboriginal Syllabics
{ begin: 0x1680, end: 0x169F }, // Ogham
{ begin: 0x16A0, end: 0x16FF }, // Runic
{ begin: 0x1780, end: 0x17FF }, // Khmer
{ begin: 0x1800, end: 0x18AF }, // Mongolian
{ begin: 0x2800, end: 0x28FF }, // Braille Patterns
{ begin: 0xA000, end: 0xA48F }, // Yi Syllables
{ begin: 0x1700, end: 0x171F }, // Tagalog
{ begin: 0x10300, end: 0x1032F }, // Old Italic
{ begin: 0x10330, end: 0x1034F }, // Gothic
{ begin: 0x10400, end: 0x1044F }, // Deseret
{ begin: 0x1D000, end: 0x1D0FF }, // Byzantine Musical Symbols
{ begin: 0x1D400, end: 0x1D7FF }, // Mathematical Alphanumeric Symbols
{ begin: 0xFF000, end: 0xFFFFD }, // Private Use (plane 15)
{ begin: 0xFE00, end: 0xFE0F }, // Variation Selectors
{ begin: 0xE0000, end: 0xE007F }, // Tags
{ begin: 0x1900, end: 0x194F }, // Limbu
{ begin: 0x1950, end: 0x197F }, // Tai Le
{ begin: 0x1980, end: 0x19DF }, // New Tai Lue
{ begin: 0x1A00, end: 0x1A1F }, // Buginese
{ begin: 0x2C00, end: 0x2C5F }, // Glagolitic
{ begin: 0x2D30, end: 0x2D7F }, // Tifinagh
{ begin: 0x4DC0, end: 0x4DFF }, // Yijing Hexagram Symbols
{ begin: 0xA800, end: 0xA82F }, // Syloti Nagri
{ begin: 0x10000, end: 0x1007F }, // Linear B Syllabary
{ begin: 0x10140, end: 0x1018F }, // Ancient Greek Numbers
{ begin: 0x10380, end: 0x1039F }, // Ugaritic
{ begin: 0x103A0, end: 0x103DF }, // Old Persian
{ begin: 0x10450, end: 0x1047F }, // Shavian
{ begin: 0x10480, end: 0x104AF }, // Osmanya
{ begin: 0x10800, end: 0x1083F }, // Cypriot Syllabary
{ begin: 0x10A00, end: 0x10A5F }, // Kharoshthi
{ begin: 0x1D300, end: 0x1D35F }, // Tai Xuan Jing Symbols
{ begin: 0x12000, end: 0x123FF }, // Cuneiform
{ begin: 0x1D360, end: 0x1D37F }, // Counting Rod Numerals
{ begin: 0x1B80, end: 0x1BBF }, // Sundanese
{ begin: 0x1C00, end: 0x1C4F }, // Lepcha
{ begin: 0x1C50, end: 0x1C7F }, // Ol Chiki
{ begin: 0xA880, end: 0xA8DF }, // Saurashtra
{ begin: 0xA900, end: 0xA92F }, // Kayah Li
{ begin: 0xA930, end: 0xA95F }, // Rejang
{ begin: 0xAA00, end: 0xAA5F }, // Cham
{ begin: 0x10190, end: 0x101CF }, // Ancient Symbols
{ begin: 0x101D0, end: 0x101FF }, // Phaistos Disc
{ begin: 0x102A0, end: 0x102DF }, // Carian
{ begin: 0x1F030, end: 0x1F09F // Domino Tiles
}];

function getUnicodeRange(unicode) {
    for (var i = 0; i < unicodeRanges.length; i += 1) {
        var range = unicodeRanges[i];
        if (unicode >= range.begin && unicode < range.end) {
            return i;
        }
    }

    return -1;
}

// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    var os2 = {};
    var p = new _parse2.default.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }

    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }

    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }

    return os2;
}

function makeOS2Table(options) {
    return new _table2.default.Table('OS/2', [{ name: 'version', type: 'USHORT', value: 0x0003 }, { name: 'xAvgCharWidth', type: 'SHORT', value: 0 }, { name: 'usWeightClass', type: 'USHORT', value: 0 }, { name: 'usWidthClass', type: 'USHORT', value: 0 }, { name: 'fsType', type: 'USHORT', value: 0 }, { name: 'ySubscriptXSize', type: 'SHORT', value: 650 }, { name: 'ySubscriptYSize', type: 'SHORT', value: 699 }, { name: 'ySubscriptXOffset', type: 'SHORT', value: 0 }, { name: 'ySubscriptYOffset', type: 'SHORT', value: 140 }, { name: 'ySuperscriptXSize', type: 'SHORT', value: 650 }, { name: 'ySuperscriptYSize', type: 'SHORT', value: 699 }, { name: 'ySuperscriptXOffset', type: 'SHORT', value: 0 }, { name: 'ySuperscriptYOffset', type: 'SHORT', value: 479 }, { name: 'yStrikeoutSize', type: 'SHORT', value: 49 }, { name: 'yStrikeoutPosition', type: 'SHORT', value: 258 }, { name: 'sFamilyClass', type: 'SHORT', value: 0 }, { name: 'bFamilyType', type: 'BYTE', value: 0 }, { name: 'bSerifStyle', type: 'BYTE', value: 0 }, { name: 'bWeight', type: 'BYTE', value: 0 }, { name: 'bProportion', type: 'BYTE', value: 0 }, { name: 'bContrast', type: 'BYTE', value: 0 }, { name: 'bStrokeVariation', type: 'BYTE', value: 0 }, { name: 'bArmStyle', type: 'BYTE', value: 0 }, { name: 'bLetterform', type: 'BYTE', value: 0 }, { name: 'bMidline', type: 'BYTE', value: 0 }, { name: 'bXHeight', type: 'BYTE', value: 0 }, { name: 'ulUnicodeRange1', type: 'ULONG', value: 0 }, { name: 'ulUnicodeRange2', type: 'ULONG', value: 0 }, { name: 'ulUnicodeRange3', type: 'ULONG', value: 0 }, { name: 'ulUnicodeRange4', type: 'ULONG', value: 0 }, { name: 'achVendID', type: 'CHARARRAY', value: 'XXXX' }, { name: 'fsSelection', type: 'USHORT', value: 0 }, { name: 'usFirstCharIndex', type: 'USHORT', value: 0 }, { name: 'usLastCharIndex', type: 'USHORT', value: 0 }, { name: 'sTypoAscender', type: 'SHORT', value: 0 }, { name: 'sTypoDescender', type: 'SHORT', value: 0 }, { name: 'sTypoLineGap', type: 'SHORT', value: 0 }, { name: 'usWinAscent', type: 'USHORT', value: 0 }, { name: 'usWinDescent', type: 'USHORT', value: 0 }, { name: 'ulCodePageRange1', type: 'ULONG', value: 0 }, { name: 'ulCodePageRange2', type: 'ULONG', value: 0 }, { name: 'sxHeight', type: 'SHORT', value: 0 }, { name: 'sCapHeight', type: 'SHORT', value: 0 }, { name: 'usDefaultChar', type: 'USHORT', value: 0 }, { name: 'usBreakChar', type: 'USHORT', value: 0 }, { name: 'usMaxContext', type: 'USHORT', value: 0 }], options);
}

exports.default = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _encoding = __webpack_require__(121);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parse the PostScript `post` table
function parsePostTable(data, start) {
    var post = {};
    var p = new _parse2.default.Parser(data, start);
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
        case 1:
            post.names = _encoding.standardNames.slice();
            break;
        case 2:
            post.numberOfGlyphs = p.parseUShort();
            post.glyphNameIndex = new Array(post.numberOfGlyphs);
            for (var i = 0; i < post.numberOfGlyphs; i++) {
                post.glyphNameIndex[i] = p.parseUShort();
            }

            post.names = [];
            for (var _i = 0; _i < post.numberOfGlyphs; _i++) {
                if (post.glyphNameIndex[_i] >= _encoding.standardNames.length) {
                    var nameLength = p.parseChar();
                    post.names.push(p.parseString(nameLength));
                }
            }

            break;
        case 2.5:
            post.numberOfGlyphs = p.parseUShort();
            post.offset = new Array(post.numberOfGlyphs);
            for (var _i2 = 0; _i2 < post.numberOfGlyphs; _i2++) {
                post.offset[_i2] = p.parseChar();
            }

            break;
    }
    return post;
} // The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm

function makePostTable() {
    return new _table2.default.Table('post', [{ name: 'version', type: 'FIXED', value: 0x00030000 }, { name: 'italicAngle', type: 'FIXED', value: 0 }, { name: 'underlinePosition', type: 'FWORD', value: 0 }, { name: 'underlineThickness', type: 'FWORD', value: 0 }, { name: 'isFixedPitch', type: 'ULONG', value: 0 }, { name: 'minMemType42', type: 'ULONG', value: 0 }, { name: 'maxMemType42', type: 'ULONG', value: 0 }, { name: 'minMemType1', type: 'ULONG', value: 0 }, { name: 'maxMemType1', type: 'ULONG', value: 0 }]);
}

exports.default = { parse: parsePostTable, make: makePostTable };

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
function isBrowser() {
    return typeof window !== 'undefined';
}

function isNode() {
    return typeof window === 'undefined';
}

function nodeBufferToArrayBuffer(buffer) {
    var ab = new ArrayBuffer(buffer.length);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        view[i] = buffer[i];
    }

    return ab;
}

function arrayBufferToNodeBuffer(ab) {
    var buffer = new Buffer(ab.byteLength);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
    }

    return buffer;
}

function checkArgument(expression, message) {
    if (!expression) {
        throw message;
    }
}

exports.isBrowser = isBrowser;
exports.isNode = isNode;
exports.nodeBufferToArrayBuffer = nodeBufferToArrayBuffer;
exports.arrayBufferToNodeBuffer = arrayBufferToNodeBuffer;
exports.checkArgument = checkArgument;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(99).Buffer))

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TessellateConstants = exports.TessellationTypes = undefined;

var _stringIndicesToArray = __webpack_require__(69);

var _stringIndicesToArray2 = _interopRequireDefault(_stringIndicesToArray);

var _tessellate = __webpack_require__(446);

var _tessellate2 = _interopRequireDefault(_tessellate);

var _Selection = __webpack_require__(70);

var _Selection2 = _interopRequireDefault(_Selection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TessellationTypes = exports.TessellationTypes = {
  edge: 1,
  vertex: 2
};

var TessellateConstants = exports.TessellateConstants = {
  UNPROCESSED: 0,
  SELECTED: 1
};

var Tessellate = {
  name: 'Tessellate',

  schema: {
    iterations: {
      label: 'iterations',
      type: 'Number',
      step: 1,
      defaultValue: 1,
      animatable: true
    },
    tessellationType: {
      label: 'Tessellation Type',
      type: 'Options',
      display: 'Dropdown',
      labels: ['Edge - Quadrilaterals', 'Vertex - Triangles'],
      values: [TessellationTypes.edge, TessellationTypes.vertex],
      defaultValue: 1
    },
    indices: {
      label: 'Selection',
      type: 'TextArea',
      defaultValue: '',
      display: 'indexStyle'
    }
  },

  update: function update(operator, primitive) {
    var mesh = primitive.mesh;
    if (!mesh) return primitive;
    var iterations = operator.iterations,
        tessellationType = operator.tessellationType,
        indices = operator.indices;


    var selection = new _Selection2.default((0, _stringIndicesToArray2.default)(indices), _Selection2.default.Faces);
    var selectedFaceIndices = selection ? selection.indices : [];
    var selectedFaceList = new Uint8Array(mesh.faceRangeOffsets.length);

    if (!selection || selectedFaceIndices.length === 0) {
      selectedFaceList.fill(TessellateConstants.SELECTED);
    } else {
      for (var f = 0; f < selectedFaceIndices.length; ++f) {
        var index = selectedFaceIndices[f];
        if (index >= 0 && index < selectedFaceList.length) {
          selectedFaceList[index] = TessellateConstants.SELECTED;
        }
      }
    }

    primitive.mesh = (0, _tessellate2.default)(mesh, selectedFaceList, tessellationType, iterations);
    return primitive;
  }
};

exports.default = Tessellate;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BlockBuffer;

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BlockBuffer(arrayType, nIntraBlockIndexBits) {
  this.blocks = [];
  this.lastBlock = null;
  this.arrayType = arrayType;

  var nBits = nIntraBlockIndexBits || 12;
  this.intraBlockIndexBits = nBits;
  this.intraBlockIndexMask = (1 << nBits) - 1;

  this.length = 0;
}

BlockBuffer.prototype = {
  constructor: BlockBuffer,

  elementSize: 1, // in scalars, constant default

  toArrayAndClear: function toArrayAndClear() {
    var result = this.toArray();
    this.clear();
    return result;
  },

  newRangeArray: function newRangeArray(optionalNumberOfElements) {
    var n = optionalNumberOfElements || 1;
    return new this.arrayType(n * this.elementSize);
  },

  rangeToArray: function rangeToArray(index, n, optionalArray, optionalWriteOffset) {
    var intraBlockIndexMask = this.intraBlockIndexMask;
    var elementSize = this.elementSize;

    var blockIndex = index >> this.intraBlockIndexBits;
    var blockOffset = index & intraBlockIndexMask;

    var block = this.blocks[blockIndex];

    var array = optionalArray || new this.arrayType(n * elementSize);
    var writeOffset = optionalWriteOffset === undefined ? 0 : optionalWriteOffset;

    for (var i = 0; i < n; ++i) {
      for (var j = blockOffset * elementSize, s = j + elementSize; j !== s; ++j) {
        array[writeOffset++] = block[j];
      }if ((++blockOffset & intraBlockIndexMask) === 0) block = this.blocks[++blockIndex];
    }

    return array;
  },

  arrayToRange: function arrayToRange(array, index, n, optionalReadOffset) {
    var intraBlockIndexMask = this.intraBlockIndexMask;
    var elementSize = this.elementSize;

    var blockIndex = index >> this.intraBlockIndexBits;
    var blockOffset = index & intraBlockIndexMask;

    var block = this.blocks[blockIndex];

    var readOffset = optionalReadOffset === undefined ? 0 : optionalReadOffset;

    for (var i = 0; i < n; ++i) {
      for (var j = blockOffset * elementSize, s = j + elementSize; j !== s; ++j) {
        block[j] = array[readOffset++];
      }if ((++blockOffset & intraBlockIndexMask) === 0) block = this.blocks[++blockIndex];
    }

    return this;
  },

  pushArrayRange: function pushArrayRange(array, n, optionalReadOffset) {
    var intraBlockIndexMask = this.intraBlockIndexMask;
    var elementSize = this.elementSize;

    var blockOffset = this.length; // masked later

    var block = this.lastBlock;

    var readOffset = optionalReadOffset === undefined ? 0 : optionalReadOffset;

    for (var i = 0; i < n; ++i) {
      if ((blockOffset &= intraBlockIndexMask) === 0) {
        var blockSize = intraBlockIndexMask + 1;
        block = new this.arrayType(blockSize * elementSize);
        this.lastBlock = block;
        this.blocks.push(block);
      }

      for (var j = blockOffset++ * elementSize, s = j + elementSize; j !== s; ++j) {
        block[j] = array[readOffset++];
      }
    }

    return this.length += n;
  },

  clear: function clear() {
    this.blocks = [];
    this.length = 0;
    this.lastBlock = null;

    return this;
  },

  toArray: function toArray(optionalArrayOrType, optionalOffset) {
    var writeOffset = optionalOffset === undefined ? 0 : optionalOffset;
    var elementSize = this.elementSize;
    var minArraySize = this.length * elementSize + writeOffset;

    var array = _Arrays2.default.maybeCreate(optionalArrayOrType || this.arrayType, minArraySize);

    var blocks = this.blocks;
    var blockSize = (1 << this.intraBlockIndexBits) * elementSize;
    var nFullBlocks = Math.max(blocks.length - 1, 0);

    for (var i = 0; i !== nFullBlocks; ++i) {
      array.set(blocks[i], writeOffset);
      writeOffset += blockSize;
    }

    var lastBlockUse = minArraySize - writeOffset;

    if (lastBlockUse !== 0) array.set(blocks[nFullBlocks].subarray(0, lastBlockUse), writeOffset);

    return array;
  }
};

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = FlatArrayView;

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

var _Orders = __webpack_require__(229);

var _Orders2 = _interopRequireDefault(_Orders);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FlatArrayView(data, length) {
  this.data = data;
  this.length = length;
}

FlatArrayView.prototype = {
  constructor: FlatArrayView,

  offset: 0, // in scalars, constant default
  stride: 1, // in scalars, constant default
  elementSize: 1, // in scalars, constant default

  // Access to element ranges

  newRangeArray: function newRangeArray(optionalNumberOfElements) {
    var n = optionalNumberOfElements || 1;
    return new this.data.constructor(n * this.elementSize);
  },

  rangeToArray: function rangeToArray(index, n, optionalArray, optionalWriteOffset) {
    var data = this.data;
    var stride = this.stride;
    var elemSize = this.elementSize;

    var array = optionalArray || new this.data.constructor(n * this.elementSize);
    var writeOffset = optionalWriteOffset || 0;

    for (var offset = this.offset + index * stride, end = offset + n * stride; offset < end; offset += stride) {
      for (var i = offset, e = offset + elemSize; i !== e; ++i) {
        array[writeOffset++] = data[i];
      }
    }return array;
  },

  arrayToRange: function arrayToRange(array, index, n, optionalReadOffset) {
    var data = this.data;
    var stride = this.stride;
    var elemSize = this.elementSize;
    var readOffset = optionalReadOffset || 0;

    for (var offset = this.offset + index * stride, end = offset + n * stride; offset < end; offset += stride) {
      for (var i = offset, e = offset + elemSize; i !== e; ++i) {
        data[i] = array[readOffset++];
      }
    }return this;
  },

  // Bulk copy operations

  toArray: function toArray(optionalArrayOrType, optionalOffset) {
    var stride = this.stride;
    var length = this.length;
    var elemSize = this.elementSize;
    var writeOffset = optionalOffset === undefined ? 0 : optionalOffset;
    var minimumLength = writeOffset + length * elemSize;

    if (stride === elemSize) {
      // data is packed, can use typed array API

      var data = this.data;
      var offset = this.offset;
      var dataEnd = offset + length * elemSize;

      if (writeOffset === 0 && (optionalArrayOrType === undefined || optionalArrayOrType === this.data.constructor)) return _Arrays2.default.slice(data, offset, dataEnd);

      var array = _Arrays2.default.maybeCreate(optionalArrayOrType, minimumLength);

      array.set(data.subarray(offset, dataEnd), writeOffset);

      return array;
    } else {
      // data is strided, twiddle it apart

      var _array = _Arrays2.default.maybeCreate(optionalArrayOrType, minimumLength);

      return this.rangeToArray(0, length, _array, optionalOffset);
    }
  },

  fromArray: function fromArray(array, optionalOffset) {
    var stride = this.stride;
    var length = this.length;
    var elemSize = this.elementSize;
    var readOffset = optionalOffset === undefined ? 0 : optionalOffset;
    var minimumLength = readOffset + length * elemSize;

    if (stride === elemSize) {
      // data is packed, can use typed array API

      var readView = readOffset === 0 && array.length === minimumLength ? array : array.subarray(readOffset, minimumLength);

      this.data.set(readView, this.offset);
    } else {
      // data is strided, scatter it

      return this.arrayToRange(array, 0, length, readOffset);
    }

    return this;
  },

  // Array data management

  repack: function repack(optionalArrayType) {
    var currentArrayType = this.data.constructor;
    var requestedArrayType = optionalArrayType || currentArrayType;

    if (this.stride !== this.elementSize || requestedArrayType !== currentArrayType) this.forceRepack(optionalArrayType);

    return this;
  },

  forceRepack: function forceRepack(optionalArrayType) {
    this.data = this.toArray(optionalArrayType);
    this.offset = 0;
    this.stride = this.elementSize;

    return this;
  },

  // Factory methods for views / buffers

  clone: function clone() {
    return this.newCompatibleView(this.toArray(), this.length);
  },

  newCompatibleView: function newCompatibleView(arrayOrType, optionalLength) {
    throw Error('not implemented'); // abstract
  },

  newCompatibleBuffer: function newCompatibleBuffer() {
    throw Error('not implemented'); // abstract
  },

  // Factory methods for compare functions

  newCompareAtIndices: function newCompareAtIndices() {
    return _Orders2.default.derefedTuplesIn(this.data, this.elementSize, this.stride);
  },

  newCompareAtIndicesStable: function newCompareAtIndicesStable() {
    return _Orders2.default.derefedTuplesStableIn(this.data, this.elementSize, this.stride);
  }
};

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _create = __webpack_require__(48);

var _create2 = _interopRequireDefault(_create);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = ScalarBuffer;

var _BlockBuffer = __webpack_require__(226);

var _BlockBuffer2 = _interopRequireDefault(_BlockBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ScalarBuffer(optionalArrayType) {
  _BlockBuffer2.default.call(this, optionalArrayType || Uint32Array);
}

ScalarBuffer.prototype = (0, _assign2.default)((0, _create2.default)(_BlockBuffer2.default.prototype), {
  constructor: ScalarBuffer,

  getAt: function getAt(index) {
    var blockIndex = index >> this.intraBlockIndexBits;
    var blockOffset = index & this.intraBlockIndexMask;

    return this.blocks[blockIndex][blockOffset];
  },

  setAt: function setAt(index, value) {
    var blockIndex = index >> this.intraBlockIndexBits;
    var blockOffset = index & this.intraBlockIndexMask;

    this.blocks[blockIndex][blockOffset] = value;
    return this;
  },

  push: function push(value) {
    var index = this.length++;
    var block = this.lastBlock;
    var blockOffset = index & this.intraBlockIndexMask;

    if (blockOffset === 0) {
      var blockSize = this.intraBlockIndexMask + 1;
      block = new this.arrayType(blockSize);
      this.lastBlock = block;
      this.blocks.push(block);
    }

    block[blockOffset] = value;

    return index + 1;
  }
});

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var Orders = {
  Numeric: function Numeric(a, b) {
    return a - b;
  },

  Natural: function Natural(a, b) {
    return a < b ? -1 : b < a ? 1 : 0;
  },

  // Note: Unstable compare functions are not an optimization.
  // Some operations require to detect equality!

  derefedNumbersIn: function derefedNumbersIn(array) {
    return function compare(a, b) {
      return array[a] - array[b];
    };
  },

  derefedTuplesIn: function derefedTuplesIn(array, elementSize, optionalStride) {
    if (!elementSize) throw Error('Invalid element size!');

    var stride = optionalStride || elementSize;

    if (stride === 1 && elementSize === 1) return Orders.derefNumbersIn(array);

    return function compare(a, b) {
      var offsetA = a * stride;
      var offsetB = b * stride;

      var result = array[offsetA] - array[offsetB];

      for (var i = 1; i !== elementSize && result === 0; ++i) {
        result = array[offsetA + i] - array[offsetB + i];
      }return result;
    };
  },

  derefedNumbersStableIn: function derefedNumbersStableIn(array) {
    return function compare(a, b) {
      var result = array[a] - array[b];
      return result !== 0 ? result : a - b;
    };
  },

  derefedTuplesStableIn: function derefedTuplesStableIn(array, elementSize, optionalStride) {
    if (!elementSize) throw Error('Invalid element size!');

    var stride = optionalStride || elementSize;

    if (stride === 1 && elementSize === 1) return Orders.derefNumbersStableIn(array);

    return function compare(a, b) {
      var offsetA = a * stride;
      var offsetB = b * stride;

      var result = array[offsetA] - array[offsetB];

      for (var i = 1; i !== elementSize && result === 0; ++i) {
        result = array[offsetA + i] - array[offsetB + i];
      }return result !== 0 ? result : a - b;
    };
  }
};

exports.default = Orders;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.default = EarCutTriangulation;

var _earcut = __webpack_require__(304);

var _earcut2 = _interopRequireDefault(_earcut);

var _three = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_MATERIAL_IDS = 30;

// list of vector that will be reused for each triangulation calls
var REMEMBER_VECTORS = [];

/**
 * Try to apply a fan triangulation on a face using vertex at (faceBegin+startIndex)
 * as the source of the fan.
 *
 * Assume that the order of the face is CCW. Therefore, a negative determinent means
 * that a vertex involved is the concave one.
 *
 * @param positionValue - the vertices of the mesh
 * @param faceValueIndices - the indices of the mesh
 * @param faceBegin - index of the first index used for that face
 * @param faceUntil - index of the first index used for the next face
 * @param startIndex - offset, between 'faceBegin' and 'faceUntil' used as the
 *                     source of the fan triangulation
 * @param axisSystem - axis system for that face, defined as:
 *                     { xAxis: Vector3, yAxis: Vector3 }
 * @param checkFlip - if true, will compute the whole face to check if it needs
 *                    to be flipped
 * @return an object { result, orientation }:
 *         - result: -1 if the triangulation worked, otherwise the index of the
 *                   vertex that caused the failure if 'checkFlip' is true or simply
 *                   zero.
 *         - orientation: -1 if the face must be flipped on the x-axis to fit
 *                   the order, otherwise 1 if already in the right direction
 */
function tryFanTriangulation(positionValues, faceValueIndices, faceBegin, faceSize, startIndex, axisSystem, checkFlip) {
  var result = -1;
  var orientation = 0;

  var vStart = REMEMBER_VECTORS[0]; // vector corresponding to the start index
  var vEdge = REMEMBER_VECTORS[1]; // use to compute the edge
  var swapper = void 0;

  // read the first and second vertex and compute the first edge
  positionValues.getAt(faceValueIndices[faceBegin + startIndex], vStart);
  positionValues.getAt(faceValueIndices[faceBegin + (startIndex + 1) % faceSize], vEdge);
  vEdge.sub(vStart);
  var planar0 = {
    x: vEdge.dot(axisSystem.xAxis),
    y: vEdge.dot(axisSystem.yAxis)
  };

  // read the third vertex and compute the second edge
  positionValues.getAt(faceValueIndices[faceBegin + (startIndex + 2) % faceSize], vEdge);
  vEdge.sub(vStart);
  var planar1 = {
    x: vEdge.dot(axisSystem.xAxis),
    y: vEdge.dot(axisSystem.yAxis)
  };

  // compute the orientation of the first
  // the orientation is computed based on the axis system so if the sum
  // of the orientation is negative, it means that the axis was probably
  // made with a concave vertex
  var baseOrientation = planar0.x * planar1.y - planar0.y * planar1.x;
  var lastEdgeLength = planar1.x * planar1.x + planar1.y * planar1.y;
  var sumOrientation = baseOrientation;

  var index = startIndex + 3;
  for (var i = 3; i < faceSize; ++i, ++index) {
    // swap the planarX
    swapper = planar0;
    planar0 = planar1;
    planar1 = swapper;

    // compute the new edge
    positionValues.getAt(faceValueIndices[faceBegin + index % faceSize], vEdge);
    vEdge.sub(vStart);
    planar1.x = vEdge.dot(axisSystem.xAxis);
    planar1.y = vEdge.dot(axisSystem.yAxis);

    // current orientation
    var currentOrientation = planar0.x * planar1.y - planar0.y * planar1.x;

    if (result === -1) {
      var currentEdgeLength = planar1.x * planar1.x + planar1.y * planar1.y;
      if (currentOrientation * baseOrientation < 0.0) {
        // it means that a fan triangulation is not possible in this case
        if (currentEdgeLength < lastEdgeLength) {
          result = index % faceSize;
        } else {
          result = (index - 1) % faceSize;
        }

        if (!checkFlip) {
          break;
        }
      }
      lastEdgeLength = currentEdgeLength;
    }
    sumOrientation += currentOrientation;
  }

  orientation = sumOrientation < 0.0 ? -1 : 1;

  return { result: result, orientation: orientation };
}

/**
 * Create the fan triangulation from a 'startIndex'
 * @param startIndex - the base of the fan triangulation
 * @param numberOfVertices - number of vertices
 * @return an array with the triangle indices
 */
function createFanTriangulation(startIndex, numberOfVertices) {
  var nbTriangle = numberOfVertices - 2;
  var triangulation = new Array(nbTriangle);

  // initialize the iterator that walk the triangualtion path
  // if 'orientation' is negative, add the number of vertices to always have
  // positive values to do module arithmetic on.
  var iterator = startIndex + 1;
  var nextIndex = iterator % numberOfVertices;
  for (var ti = 0, wi = 0; ti < nbTriangle; ++ti, wi += 3) {
    ++iterator; // move to the next vertex
    var newIndex = iterator % numberOfVertices;

    triangulation[wi] = startIndex;
    triangulation[wi + 1] = nextIndex;
    triangulation[wi + 2] = newIndex;

    nextIndex = newIndex;
  }
  return triangulation;
}

/**
 * Compute the triangulation for 'self'
 *
 * Create a mapping, ex: [0,1,2,3,4] --> [2,3,1, 0,1,3, 4,0,3]
 *
 * @param self - must be instance of 'EarCutTriangulation'
 */
function createMapFaceIdToLocalTriangulation(self) {
  // one per 'faceRangeOffsets' item
  var faceOffsets = self.mesh.faceRangeOffsets;

  var faceValueIndices = self.mesh.positions.faceValueIndices;
  var positionValues = self.mesh.positions.values;

  // face id is the
  var numberOfFaces = faceOffsets.length - 1;
  var mapFaceIdToLocalTriangulation = new Array(numberOfFaces);

  // vertices vectors
  var v0 = REMEMBER_VECTORS[0];
  var v1 = REMEMBER_VECTORS[1];

  // edges vectors
  var currEdge = REMEMBER_VECTORS[2];
  var nextEdge = REMEMBER_VECTORS[3];

  // corner normal vectors
  var currNormal = REMEMBER_VECTORS[4];

  // to know the total number of triangles in the end because per face, it's
  // the number of vertices minus 2, let initialize this value with all the
  // minus 2 already added up
  var numTriangles = -2 * numberOfFaces;

  var faceBegin = faceOffsets[0];
  for (var fi = 0; fi < numberOfFaces; ++fi) {
    var faceUntil = faceOffsets[fi + 1];
    var numberOfVertices = faceUntil - faceBegin;

    if (numberOfVertices < 3) {
      numTriangles += 2; // cancel invalid face
    } else if (numberOfVertices === 3) {
      numTriangles += 3;

      // use null, because the mapping stays unchanged for triangles with [0,1,2]
      mapFaceIdToLocalTriangulation[fi] = null;
    } else {
      numTriangles += numberOfVertices;

      // find the first non-colinear three consecutive points
      var startIndex = 0;

      // read the first and last point and create edge
      positionValues.getAt(faceValueIndices[faceUntil - 1], v1);
      positionValues.getAt(faceValueIndices[faceBegin], v0);
      nextEdge.copy(v1).sub(v0).normalize();

      // do..while they are colinear
      do {
        positionValues.getAt(faceValueIndices[faceBegin + (startIndex + 1) % numberOfVertices], v1);

        // create the two edges
        currEdge.copy(v1).sub(v0).normalize();

        // if the absolute of the dot product is less than this, then these
        // points are not colinear
        if (Math.abs(currEdge.dot(nextEdge)) < 1.0) break;

        // move to the next vertex to check linearity
        ++startIndex;
        nextEdge.copy(currEdge).multiplyScalar(-1.0);
        v0.copy(v1);
      } while (startIndex < numberOfVertices);

      // create coordinate system with currEdge and nextEdge
      currNormal.copy(currEdge).cross(nextEdge).normalize();
      nextEdge.copy(currNormal).cross(currEdge).normalize();

      // create the axis system
      var axisSystem = { xAxis: currEdge, yAxis: nextEdge };

      // try the fan triangulation
      var fanTriangulation = tryFanTriangulation(positionValues, faceValueIndices, faceBegin, numberOfVertices, startIndex, axisSystem, false // stop as soon as it fails
      );

      // check if that fan triangulation failed
      if (fanTriangulation.result !== -1) {
        // try the fan triangulation a second time with the concave vertex
        startIndex = fanTriangulation.result;
        fanTriangulation = tryFanTriangulation(positionValues, faceValueIndices, faceBegin, numberOfVertices, startIndex, // concave vertex returned by last call
        axisSystem, true // compute the whole thing to know the orientation of the face (needed for earcut)
        );
      }

      if (fanTriangulation.result === -1) {
        // fan triangulation worked
        mapFaceIdToLocalTriangulation[fi] = createFanTriangulation(startIndex, numberOfVertices);
      } else {
        // two fan triangulations failed, let's go with 'earcut'

        // project the points on a plane and use 'fanTriangulation.orientation' to flip the
        // x-axis to preserve CCW order
        var flatVerticesSize = numberOfVertices * 2;
        var flatVertices = new Array(flatVerticesSize);

        // reverse the axis
        axisSystem.xAxis.multiplyScalar(fanTriangulation.orientation);

        // flatten all the vertices
        for (var vi = faceBegin, wi = 0; vi < faceUntil; ++vi, wi += 2) {
          positionValues.getAt(faceValueIndices[vi], v0);

          flatVertices[wi] = v0.dot(axisSystem.xAxis);
          flatVertices[wi + 1] = v0.dot(axisSystem.yAxis);
        }

        // compute the ear cut triangulation
        mapFaceIdToLocalTriangulation[fi] = (0, _earcut2.default)(flatVertices);
      }
    }

    // move the face limits
    faceBegin = faceUntil;
  }

  // update the triangle count and return the mapping
  self.numTriangles = numTriangles;
  self.mapFaceIdToLocalTriangulation = mapFaceIdToLocalTriangulation;
}

/**
 * Compute the triangulation for 'self'
 * @param self - must be instance of 'EarCutTriangulation'
 */
function computeMaterialIds(self) {
  var materialIds = self.mesh.materialIds;
  if (materialIds) {
    // compute the polygonOrder first
    var faceOffsets = self.mesh.faceRangeOffsets;
    var numPolygons = faceOffsets.length - 1;
    var polygonOrder = new Uint32Array(numPolygons);
    for (var i = 0; i < polygonOrder.length; i++) {
      polygonOrder[i] = i;
    }

    // sort them so can be rendered in order
    polygonOrder.sort(function (a, b) {
      return materialIds[a] - materialIds[b];
    });
    self.polygonOrder = polygonOrder;

    // temporary array used to count how much each ID is used
    var tmpGroupCounts = new Uint32Array(MAX_MATERIAL_IDS);
    var maxMaterialIdFound = 0;

    var fi = 0;
    var faceBegin = faceOffsets[0];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(materialIds), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var materialId = _step.value;

        // is the material ID higher than the allowed number?
        if (materialId >= MAX_MATERIAL_IDS) {
          // replace it with the largest value allowed
          materialId = MAX_MATERIAL_IDS - 1;
          maxMaterialIdFound = materialId;
        } else if (materialId > maxMaterialIdFound) {
          // is this the highest material ID found so far?
          maxMaterialIdFound = materialId;
        }

        var faceUntil = faceOffsets[fi + 1];
        tmpGroupCounts[materialId] += faceUntil - faceBegin - 2;
        faceBegin = faceUntil;
        ++fi;
      }

      // if not all material indices are used, just create a view instead of
      // reallocating a new buffer
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var groupCounts = maxMaterialIdFound + 1 === MAX_MATERIAL_IDS ? tmpGroupCounts : new Uint32Array(tmpGroupCounts.buffer, 0, maxMaterialIdFound + 1);

    // fill the groupStarts by accumulating the counts
    var groupStarts = new Uint32Array(maxMaterialIdFound + 1);
    var groupOffset = 0;
    for (var _i = 0; _i <= maxMaterialIdFound; ++_i) {
      groupStarts[_i] = groupOffset;
      // multiply the group count my three to include coordinates and
      // increment the offset
      groupOffset += groupCounts[_i] *= 3;
    }

    self.groups = { groupStarts: groupStarts, groupCounts: groupCounts };
  }
}

function EarCutTriangulation(mesh) {
  if (REMEMBER_VECTORS.length === 0) {
    for (var i = 0; i < 5; ++i) {
      REMEMBER_VECTORS.push(new _three.Vector3());
    }
  }

  this.mesh = mesh;

  // for material ids
  this.groups = null;
  this.polygonOrder = null;

  // total number of triangles after the triangulation
  this.numTriangles = -1;

  // compute the mapping from current face indices to triangulated
  // face indices and the number of triangles
  // this.mapFaceIdToLocalTriangulation = this.createMapFaceIdToLocalTriangulation();
  createMapFaceIdToLocalTriangulation(this);

  // compute the material ids and the polygon order
  computeMaterialIds(this);
}

EarCutTriangulation.prototype = {
  constructor: EarCutTriangulation,

  translateIndices: function translateIndices(inputArray, outputView) {
    var faceOffsets = this.mesh.faceRangeOffsets;
    var numberOfFaces = faceOffsets.length - 1;

    var outputArray = outputView.data;
    var stride = outputView.stride;
    var writeIndex = outputView.offset;

    var polygonOrder = this.polygonOrder;

    // create the new indices for this map
    for (var fi = 0; fi < numberOfFaces; ++fi) {
      var polygonIndex = polygonOrder ? polygonOrder[fi] : fi;

      var startIndex = faceOffsets[polygonIndex];

      var localTriangulation = this.mapFaceIdToLocalTriangulation[polygonIndex];
      if (localTriangulation) {
        // map the indices to the triangulation
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = (0, _getIterator3.default)(localTriangulation), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var ti = _step2.value;

            outputArray[writeIndex] = inputArray[startIndex + ti];
            writeIndex += stride;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } else {
        // there's no mapping for this face (it's already a triangle, or an
        // invalid face), just list them in order
        var stopIndex = faceOffsets[polygonIndex + 1];
        for (var si = startIndex; si < stopIndex; ++si) {
          outputArray[writeIndex] = inputArray[si];
          writeIndex += stride;
        }
      }
    }
  },

  translateMaterialIds: function translateMaterialIds(outputView) {
    // NOT USED and cannot trust version from SimpleFanTriangulation because
    // it has wrong arguments
  },

  translateToUnindexedValues: function translateToUnindexedValues(inputView, outputView, indices) {
    var faceOffsets = this.mesh.faceRangeOffsets;
    var numberOfFaces = faceOffsets.length - 1;
    var temp = inputView.newRangeArray(1);

    var polygonOrder = this.polygonOrder;

    var writeIndex = 0;

    // create the new indices for this map
    for (var fi = 0; fi < numberOfFaces; ++fi) {
      var polygonIndex = polygonOrder ? polygonOrder[fi] : fi;

      var startIndex = faceOffsets[polygonIndex];

      var localTriangulation = this.mapFaceIdToLocalTriangulation[polygonIndex];
      if (localTriangulation) {
        // map the indices to the triangulation
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = (0, _getIterator3.default)(localTriangulation), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var ti = _step3.value;

            outputView.arrayToRange(inputView.rangeToArray(indices[startIndex + ti], 1, temp), writeIndex, 1);
            ++writeIndex;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      } else {
        // there's no mapping for this face (it's already a triangle, or an
        // invalid face), just list them in order
        var stopIndex = faceOffsets[polygonIndex + 1];
        for (var si = startIndex; si < stopIndex; ++si, ++writeIndex) {
          outputView.arrayToRange(inputView.rangeToArray(indices[si], 1, temp), writeIndex, 1);
        }
      }
    }
  }
};

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BlendShapeData(positions, normals, weights, weight) {
  this.positions = positions || new _ObjectArrayView2.default(_three.Vector3, 0); // must be an object array view (cannot be null)
  this.normals = normals; // must be an object array view or null
  this.weights = weights; // Stored as a ScalarArrayView
  this.weight = weight || 1; // a single weight for the whole shape (a float value)
}

BlendShapeData.prototype = {
  constructor: BlendShapeData,

  isEmpty: function isEmpty() {
    return !this.positions.length;
  },

  setWeight: function setWeight(w) {
    this.weight = w;
  }
};

exports.default = BlendShapeData;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeFaceNormal = computeFaceNormal;
exports.default = FaceNormals;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * To compute the normal of a face
 * 
 * @param values - an ObjectArrayView of the vertices
 * @param indices - an array of the indices
 * @param faceBegin - the index where the face indices begin
 * @param faceUntil - the index where the following face begins
 * @param dontNormalize - to not normalize the result
 * @param optional??? - to provide preallocated Vector3 needed to compute
 * @return the face normal
 */
function computeFaceNormal(values, indices, faceBegin, faceUntil, dontNormalize, optionalFaceNormal, optionalFirstVertex, optionalCurrVector, optionalNextVector, optionalCrossVector) {
  var firstVertex = optionalFirstVertex || new _three.Vector3();
  var currVector = optionalCurrVector || new _three.Vector3();
  var nextVector = optionalNextVector || new _three.Vector3();
  var crossVector = optionalCrossVector || new _three.Vector3();

  // reuse the face normal, if provided, and reset it for accurate computation
  var faceNormal = optionalFaceNormal || new _three.Vector3();
  if (optionalFaceNormal) faceNormal.set(0.0, 0.0, 0.0);

  var swapper = void 0,
      index = void 0;

  // read the first vertex
  index = indices[faceBegin];
  values.getAt(index, firstVertex);

  // read the second vertex and substract the first to get the first vector
  index = indices[faceBegin + 1];
  values.getAt(index, currVector);
  currVector.sub(firstVertex);

  for (var fi = faceBegin + 2; fi < faceUntil; ++fi) {
    // read the new vertex and compute the new vector
    index = indices[fi];
    values.getAt(index, nextVector);
    nextVector.sub(firstVertex);

    // compute the cross product and add it to the accumulated face normal sum
    crossVector.crossVectors(currVector, nextVector);
    faceNormal.add(crossVector);

    // swap currVector and nextVector
    swapper = currVector;
    currVector = nextVector;
    nextVector = swapper;
  }

  if (!dontNormalize) faceNormal.normalize();
  return faceNormal;
}

function FaceNormals(polyMap) {
  this.polyMap = polyMap;

  this._compute();
}

FaceNormals.prototype = {
  constructor: FaceNormals,

  getNormalForFaceId: function getNormalForFaceId(faceIndex, optionalTarget) {
    var result = optionalTarget || new _three.Vector3();
    this.faceNormalValues.getAt(faceIndex, result);
    return result;
  },

  _compute: function _compute() {
    var polyMap = this.polyMap;

    var faceRangeOffsets = polyMap.faceRangeOffsets;
    var faceValueIndices = polyMap.faceValueIndices;
    var values = polyMap.values;

    var faceCount = faceRangeOffsets.length - 1;
    var faceNormalValues = new _ObjectArrayView2.default(_three.Vector3, faceCount);

    var firstVertex = new _three.Vector3();
    var currVector = new _three.Vector3();
    var nextVector = new _three.Vector3();
    var crossVector = new _three.Vector3();
    var faceNormal = new _three.Vector3();

    for (var f = 0; f < faceCount; ++f) {
      var faceBegin = faceRangeOffsets[f];
      var faceUntil = faceRangeOffsets[f + 1];
      computeFaceNormal(values, faceValueIndices, faceBegin, faceUntil, false, faceNormal, firstVertex, currVector, nextVector, crossVector);
      faceNormalValues.setAt(f, faceNormal);
    }

    this.faceNormalValues = faceNormalValues;
  }
};

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SmoothingGroupIds = exports.ShapeSetBevelStyles = undefined;

var _toConsumableArray2 = __webpack_require__(149);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _log = __webpack_require__(499);

var _log2 = _interopRequireDefault(_log);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.ShapeSet = ShapeSet;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _bendPolyMesh = __webpack_require__(158);

var _FaceNormals = __webpack_require__(232);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getFaceUntilWithoutHoles(from, faceBegin, faceIndex) {
  var holeOffset = from.holeOffsets[faceIndex];
  var result = -1;
  if (holeOffset.length === 0) {
    result = from.loopRangeOffsets[faceIndex + 1];
  } else {
    result = faceBegin + holeOffset[0];
  }
  return result;
}

function styleRound(segments) {
  var angle = Math.PI / segments;
  return function (segmentIndex) {
    var curAngle = segmentIndex * angle;
    return {
      offset: Math.sin(curAngle),
      height: 0.5 - Math.cos(curAngle) * 0.5
    };
  };
}

function styleExtended(segments) {
  var inv = 1.0 / segments;
  return function (segmentIndex) {
    var value = segmentIndex * inv;
    return {
      offset: Math.sqrt(value),
      height: value
    };
  };
}

/**
 * @param testVertex - vertex to test with
 * @param baseInfo - { x, y, deltaX, deltaY }
 * @param bestDistance - best distance so far
 */
function horizontalDistanceWithDeltas(testVertex, baseInfo, bestDistance) {
  if (baseInfo.deltaY !== 0.0) {
    var alpha = (testVertex.y - baseInfo.y) / baseInfo.deltaY;
    if (alpha >= 0.0 && alpha <= 1.0) {
      var candidateDistance = Math.abs(testVertex.x - baseInfo.x - alpha * baseInfo.deltaX);
      bestDistance = Math.min(bestDistance, candidateDistance);
    }
  }
  return bestDistance;
}

function computeOuterEdges(from) {
  var swapper = void 0;
  var thisVector = new _three.Vector3();
  var thisVectorPrev = new _three.Vector3();

  var nbThisFace = from.loopRangeOffsets.length - 1;
  var thisEdges = [];
  for (var tf = 0; tf < nbThisFace; ++tf) {
    var thisFaceBegin = from.loopRangeOffsets[tf];
    var thisFaceUntil = getFaceUntilWithoutHoles(from, thisFaceBegin, tf);

    from.positions.getAt(thisFaceUntil - 1, thisVectorPrev);
    for (var ti = thisFaceBegin; ti < thisFaceUntil; ++ti) {
      from.positions.getAt(ti, thisVector);

      var thisMinX = thisVector.x,
          thisMaxX = thisVectorPrev.x;
      var thisMinY = thisVector.y,
          thisMaxY = thisVectorPrev.y;
      if (thisMinY > thisMaxY) {
        swapper = thisMinX;
        thisMinX = thisMaxX;
        thisMaxX = swapper;

        swapper = thisMinY;
        thisMinY = thisMaxY;
        thisMaxY = swapper;
      }

      thisEdges.push({
        x: thisMinX,
        y: thisMinY,
        deltaX: thisMaxX - thisMinX,
        deltaY: thisMaxY - thisMinY
      });

      // swap the 'second' vertices
      swapper = thisVector;
      thisVector = thisVectorPrev;
      thisVectorPrev = swapper;
    }
  }
  return thisEdges;
}

var ShapeSetBevelStyles = exports.ShapeSetBevelStyles = {
  Round: 0,
  Extended: 1
};

var SmoothingGroupIds = exports.SmoothingGroupIds = {
  Front: 1,
  Back: 2,
  Bevel: 4
};

function ShapeSet(from) {
  if (from) {
    this.loopRangeOffsets = from.loopRangeOffsets;
    this.loopValueIndices = from.loopValueIndices;
    this.positions = from.positions;
    this.holeOffsets = from.holeOffsets;
    this.bevelSegments = from.bevelSegments;
    this.bevelSmoothingGroups = from.bevelSmoothingGroups || [];
    this.backFaceOffsets = from.backFaceOffsets;
    this.ringOffsets = from.ringOffsets;
  } else {
    this.loopRangeOffsets = new Uint32Array(1);
    this.loopValueIndices = new Uint32Array(0);
    this.positions = new _ObjectArrayView2.default(_three.Vector3, 0);
    this.holeOffsets = [];
    this.bevelSegments = [];
    this.backFaceOffsets = 0;
    this.bevelSmoothingGroups = [];
    this.ringOffsets = [];
  }
}

ShapeSet.prototype = {
  constructor: ShapeSet,

  /**
   * Test every pair of edges from both shape and find the smallest distance between the two.
   *
   * @param secondShapeSet - shape set to compute the distance from 'this'
   * @param currentHorizontalOffset - the current offset of the second shape set
   * @param compact - the padding to add to horizontal distance
   * @param lastComputation - (optional) { thisEdges } if 'thisEdges' was already computed in a
   *                          previous call to this function, then let reuse it.
   * @return the offset to use for compact shape sets
   */
  getHorizontalDistance: function getHorizontalDistance(secondShapeSet, currentHorizontalOffset, compact, lastComputation) {
    // FOR NOW, stupid brute force algorithm
    var bestDistance = currentHorizontalOffset;

    var nbSecFace = secondShapeSet.loopRangeOffsets.length - 1;

    // compute the edges of 'this' only once
    var thisEdges = lastComputation && lastComputation.thisEdges || computeOuterEdges(this);
    var secEdges = computeOuterEdges(secondShapeSet);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(secEdges), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var tmpSecEdge = _step.value;

        // a copy of 'tmpSecEdge' with horizontal offset and also describe the bottom vertex
        var secEdge = {
          x: tmpSecEdge.x + currentHorizontalOffset,
          y: tmpSecEdge.y,
          deltaX: tmpSecEdge.deltaX,
          deltaY: tmpSecEdge.deltaY
        };

        var secMinY = tmpSecEdge.y;
        var secMaxY = tmpSecEdge.y + tmpSecEdge.deltaY;

        // describe the top vertex (and doesn't need the deltas)
        var secEdgeTop = {
          x: secEdge.x,
          y: secMaxY
        };

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = (0, _getIterator3.default)(thisEdges), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var edge = _step2.value;

            // check if the two edges' vertical intervals intersect
            if (secEdgeTop.y >= edge.y && secEdge.y <= edge.y + edge.deltaY) {
              // the equivalent of 'edgeTop' will be computed in the next iteration
              bestDistance = horizontalDistanceWithDeltas(edge, secEdge, bestDistance);

              bestDistance = horizontalDistanceWithDeltas(secEdgeTop, edge, bestDistance);
              bestDistance = horizontalDistanceWithDeltas(secEdge, edge, bestDistance);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (lastComputation) {
      lastComputation.thisEdges = secEdges;
    }
    // Subtract the best distance and the compact padding to the current
    // horizontal offset to get the offset for this second shape set.
    // We multiply by a fudge factor of 1.01 since for some reason certain font letter
    // combinations still retain a small gap. Possibly some precision/rounding issue.
    return currentHorizontalOffset - (bestDistance * 1.01 + compact);
  },

  translateShape: function translateShape(direction) {
    var nbVertices = this.positions.length;
    var tmpVector = new _three.Vector3();
    for (var vi = 0; vi < nbVertices; ++vi) {
      this.positions.getAt(vi, tmpVector);
      tmpVector.add(direction);
      this.positions.setAt(vi, tmpVector);
    }
  },

  /**
   * Bevel each faces.
   *
   * It copies a face, then put its bevelled faces after it. Then goes to the
   * next face. So this changes the way the faces are represented from the input.
   *
   * @param xOffset - Offset to move outside the face
   * @param zOffset - Offset the move the up
   * @param segments - number of division to connect the bevel
   * @param {ShapeSetBevelStyles} style - how the bevel should look like
   * @param threshold - ratio over 'xOffset' of how much a bevelled vertex should
   *                    be away from its source vertex
   */
  bevelShapeSet: function bevelShapeSet(xOffset, zOffset, segments, style, threshold, smoothingAngleDeg) {
    var from = this;
    var maxMoveSquare = xOffset * xOffset * threshold * threshold;
    var smoothingAngleRad = Math.cos(smoothingAngleDeg * _three.Math.DEG2RAD);

    // need to update the holes, even if the new faces won't have any
    var copyVector = new _three.Vector3();
    var lastVertex = new _three.Vector3();
    var lastEdge = new _three.Vector3();
    var currVertex = new _three.Vector3();
    var currEdge = new _three.Vector3();
    var cornerVector = new _three.Vector3();

    // smoothing group id's are calculated per loop vertex based on angle
    // between adjacent edges, then applied to the corresponding bevel segments
    var currSmoothGroup = void 0;
    var bevelSmoothingGroups = from.bevelSmoothingGroups;
    var vertexSmoothingGroups = [];
    var smoothStartBit = (0, _log2.default)(SmoothingGroupIds.Bevel);
    var maxShift = 30 - smoothStartBit; // guard against number wrap-around

    // original number of faces
    var nbFaces = this.loopRangeOffsets.length - 1;

    // precompute segment values
    var segmentHeights = [];
    var segmentOffsets = [];
    {
      var styleFunction = null;
      if (style === ShapeSetBevelStyles.Extended) {
        styleFunction = styleExtended(segments);
      } else {
        // Otherwise, use round
        styleFunction = styleRound(segments);
      }

      for (var si = 0; si <= segments; ++si) {
        var _styleFunction = styleFunction(si),
            offset = _styleFunction.offset,
            height = _styleFunction.height;

        segmentHeights.push(-height * zOffset);
        segmentOffsets.push(offset);
      }
    }

    // new positions
    var nbVertices = this.positions.length;
    var newPositions = new _ObjectArrayView2.default(_three.Vector3, nbVertices * (segments + 1));
    // these are plane created by the segments. This is an index list based in 'newPositions'
    var bevelSegments = []; // all the bevels will be already triangulated

    // apply the xOffset
    var faceBegin = this.loopRangeOffsets[0];
    var faceUntil = faceBegin;
    var faceOffset = 0;
    var swapper = void 0;
    var dotEdges = void 0;

    function __writeSegmentVertices(writeAt) {
      // find where the other endpoint of the bevel should be (on the XY plane only)
      // this is done by finding the point where a vertex meet currEdge and lastEdge
      // when offset by their binormal (which is the edge rotated 90 degree CW to bevel outside)
      // the problem is solved by computing it for the edges instead and then the final
      // result is rotated 90 degrees (this is why yMove uses negative x coordinates
      // of the solution), which result in the same.
      dotEdges = currEdge.dot(lastEdge);
      var offset = xOffset / (1 + dotEdges);
      var xMove = -offset * (lastEdge.y + currEdge.y);
      var yMove = offset * (lastEdge.x + currEdge.x);

      var moveLengthSquare = xMove * xMove + yMove * yMove;
      if (moveLengthSquare > maxMoveSquare) {
        // shrink the move to be the maximal valid move
        var scale = Math.sqrt(maxMoveSquare / moveLengthSquare);
        xMove *= scale;
        yMove *= scale;
      }

      // for each parts of the segments, add vertices listed 'nbVertices' appart
      for (var _si = 0; _si <= segments; ++_si) {
        var xySegOffset = segmentOffsets[_si];
        cornerVector.x = lastVertex.x + xySegOffset * xMove;
        cornerVector.y = lastVertex.y + xySegOffset * yMove;
        cornerVector.z = segmentHeights[_si];

        newPositions.setAt(writeAt, cornerVector);
        writeAt += nbVertices;
      }
    }

    // a range is either a complete face, or the face until the first hole, or between holes
    function __offsetRangeVertices() {
      // read the last vertex of the loop
      from.positions.getAt(from.loopValueIndices[faceUntil - 1], copyVector);

      // read the first vertex
      var lastIndex = from.loopValueIndices[faceBegin];
      from.positions.getAt(lastIndex, lastVertex);

      // compute the last edge
      lastEdge.subVectors(lastVertex, copyVector).normalize();

      var smoothStartIndices = [];
      var smoothWrap = false; // if end of loop should be smoothed with start
      var lookForSmoothStart = true; // flag for collecting range of smooth start indices
      currSmoothGroup = SmoothingGroupIds.Bevel; // reset to default start group id
      var groupShift = 0; // bitshift of smoothing group from starting default

      for (var fi = faceBegin + 1; fi < faceUntil; ++fi) {
        // read the currrent vertex
        var currIndex = from.loopValueIndices[fi];
        from.positions.getAt(currIndex, currVertex);

        // compute the current edge
        currEdge.subVectors(currVertex, lastVertex).normalize();

        __writeSegmentVertices(lastIndex);

        // add smoothing group (increment it if not smoothed with previous edge)
        if (dotEdges < smoothingAngleRad) {
          // if at max bit, reset back to 1 bit above the starting default, to
          // avoid accidental smoothing between end and start of loop
          if (groupShift === maxShift) groupShift = 1;
          currSmoothGroup = SmoothingGroupIds.Bevel << groupShift++;
          lookForSmoothStart = false;
        } else {
          // check for smoothness between end and start, and collect starting
          // smooth indices to match with end
          if (fi === faceBegin + 1) {
            smoothWrap = true;
          }
          if (lookForSmoothStart) smoothStartIndices.push(currIndex - 1);
        }
        vertexSmoothingGroups[currIndex - 1] = currSmoothGroup;

        // swap the edges
        swapper = lastEdge;
        lastEdge = currEdge;
        currEdge = swapper;

        // swap the vertices
        swapper = lastVertex;
        lastVertex = currVertex;
        currVertex = swapper;

        // forward the index
        lastIndex = currIndex;
      }

      //*** do the final vertex, read again the first vertex and compute the edge
      from.positions.getAt(faceBegin, currVertex);
      currEdge.subVectors(currVertex, lastVertex).normalize();
      __writeSegmentVertices(lastIndex);

      // add final smooth group
      if (dotEdges < smoothingAngleRad) {
        if (groupShift === maxShift) groupShift = 1;
        currSmoothGroup = SmoothingGroupIds.Bevel << groupShift++;
      } else {
        if (lookForSmoothStart) smoothStartIndices.push(lastIndex);
      }
      vertexSmoothingGroups[lastIndex] = currSmoothGroup;

      // if end of loop should be smoothed with start, update starting id's to
      // match end
      if (smoothWrap && currSmoothGroup !== SmoothingGroupIds.Bevel) {
        for (var i = 0; i < smoothStartIndices.length; i++) {
          vertexSmoothingGroups[smoothStartIndices[i]] = currSmoothGroup;
        }
      }
    }

    // using the same range as '__offsetRangeVertices', the
    function __writeBevelSegmentIndices() {
      var currIndex = from.loopValueIndices[faceUntil - 1];
      var nextIndex = from.loopValueIndices[faceBegin];

      for (var fi = faceBegin; fi < faceUntil;) {
        var currLayer = 0;
        var nextLayer = nbVertices;
        for (var _si2 = 0; _si2 < segments; ++_si2) {
          // first triangle
          bevelSegments.push(currIndex + currLayer);
          bevelSegments.push(nextIndex + currLayer);
          bevelSegments.push(nextIndex + nextLayer);
          bevelSmoothingGroups.push(vertexSmoothingGroups[currIndex]);

          // second triangle
          bevelSegments.push(currIndex + currLayer);
          bevelSegments.push(nextIndex + nextLayer);
          bevelSegments.push(currIndex + nextLayer);
          bevelSmoothingGroups.push(vertexSmoothingGroups[currIndex]);

          // increment the layers
          currLayer = nextLayer;
          nextLayer += nbVertices;
        }

        currIndex = nextIndex;
        ++fi;
        nextIndex = from.loopValueIndices[fi];
      }
    }

    for (var fi = 0; fi < nbFaces; ++fi) {
      var holes = this.holeOffsets[fi];
      var faceStart = faceBegin;
      var faceEnd = this.loopRangeOffsets[fi + 1];
      faceOffset = faceEnd - faceBegin;

      for (var hi = 0; hi < holes.length; ++hi) {
        faceUntil = faceStart + holes[hi];
        __offsetRangeVertices();
        __writeBevelSegmentIndices();
        faceBegin = faceUntil;
      }

      // the final hole (if there was holes), or the whole face itself
      faceUntil = faceEnd;
      __offsetRangeVertices();
      __writeBevelSegmentIndices();
      faceBegin = faceUntil;
    }
    // update the from with the new values
    this.positions = newPositions;
    this.bevelSegments = bevelSegments;
    this.backFaceOffsets = segments * nbVertices;
  },

  /**
   * Bend the whole shape set.
   *
   * Should be applied before the bevel because the rings only remembers their
   * original location.
   *
   * @param angle - how much bending should happen (in degrees)
   */
  bend: function bend(angle) {
    var v0 = new _three.Vector3();
    var rotationDeg = new _three.Vector3().set(0.0, 0.0, -90.0);
    var that = this;
    // 1. find the width of the shape set to get the right translation value
    var translation = 0;
    {
      var updateMinMax = function updateMinMax(posStart, posEnd) {
        for (var pi = posStart; pi < posEnd; ++pi) {
          that.positions.getAt(pi, v0);
          if (v0.x < minX) {
            minX = v0.x;
          } else if (v0.x > maxX) {
            maxX = v0.x;
          }
        }
      };

      this.positions.getAt(0, v0);
      var minX = v0.x;
      var maxX = v0.x;

      if (!this.ringOffsets.length) {
        updateMinMax(1, this.positions.length);
      } else {
        // skip rings in translation calc, so bend pivot is centred based on text only
        // before ring 1
        updateMinMax(1, this.ringOffsets[0].start);
        // between rings
        updateMinMax(this.ringOffsets[0].until + 1, this.ringOffsets[1].start);
        // after ring 2 (usually ring 2 is at the end, but just in case)
        updateMinMax(this.ringOffsets[1].until + 1, this.positions.length);
      }
      translation = (maxX - minX) * -0.5;
    }

    // 2. apply the bend
    v0.set(translation, 0.0, 0.0); // used for translation
    (0, _bendPolyMesh.bendVertices)(this.positions, 'Z', angle, rotationDeg, v0, true);

    // 3. restore the ring according to their location
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = (0, _getIterator3.default)(this.ringOffsets), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var ringItem = _step3.value;

        // only use up to middle, because that's the outer ring
        var sumX = 0.0;
        var sumY = 0.0;
        for (var _vi = ringItem.start; _vi < ringItem.middle; ++_vi) {
          this.positions.getAt(_vi, v0);
          sumX += v0.x;
          sumY += v0.y;
        }
        var divBy = 1.0 / (ringItem.middle - ringItem.start);
        sumX *= divBy;
        sumY *= divBy;

        // reset the z axis
        v0.z = 0.0;
        var vi = ringItem.start;

        // outer ring
        {
          var incrAngle = 2.0 * Math.PI / (ringItem.middle - ringItem.start);
          for (var _angle = 0.0; vi < ringItem.middle; ++vi, _angle += incrAngle) {
            v0.x = sumX + Math.cos(_angle) * ringItem.outerRadius;
            v0.y = sumY - Math.sin(_angle) * ringItem.outerRadius;
            this.positions.setAt(vi, v0);
          }
        }

        // inner ring
        {
          var _incrAngle = 2.0 * Math.PI / (ringItem.until - ringItem.middle);
          for (var _angle2 = 0.0; vi < ringItem.until; ++vi, _angle2 += _incrAngle) {
            v0.x = sumX + Math.cos(_angle2) * ringItem.innerRadius;
            v0.y = sumY + Math.sin(_angle2) * ringItem.innerRadius;
            this.positions.setAt(vi, v0);
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }
};

function quadBezierAt(v1, v2, v3, t) {
  var oneMinusT = 1 - t;
  var first = oneMinusT * oneMinusT;
  var second = 2.0 * oneMinusT * t;
  var third = t * t;
  return {
    x: first * v1.x + second * v2.x + third * v3.x,
    y: first * v1.y + second * v2.y + third * v3.y
  };
}

function findHoles(from) {
  var nbLoops = from.loopRangeOffsets.length - 1;
  var holes = new Array(nbLoops);

  var firstVertex = new _three.Vector3();
  var currVector = new _three.Vector3();
  var nextVector = new _three.Vector3();
  var crossVector = new _three.Vector3();
  var loopOrientation = new _three.Vector3();

  var loopBegin = from.loopRangeOffsets[0];
  for (var fi = 0; fi < nbLoops; ++fi) {
    var loopUntil = from.loopRangeOffsets[fi + 1];

    // treat the loop as a face and compute its normal
    (0, _FaceNormals.computeFaceNormal)(from.positions, from.loopValueIndices, loopBegin, loopUntil, true, loopOrientation, firstVertex, currVector, nextVector, crossVector);

    // if the z component of the normal is greater than zero, it means that
    // loop is a hole (because holes list their points in CCW order)
    holes[fi] = loopOrientation.z > 0.0;

    loopBegin = loopUntil;
  }
  return holes;
}

function putHolesInLoops(from, holes, ownership, boundingBoxes) {
  var boxSize = new _three.Vector3();
  var nbLoops = holes.length;

  for (var inner = 0; inner < nbLoops; ++inner) {
    if (!holes[inner]) continue; // not a hole

    var holeBox = boundingBoxes[inner];

    var ownerIndex = -1,
        ownerArea = -1;
    for (var outer = 0; outer < nbLoops; ++outer) {
      if (holes[outer]) continue; // is a hole

      // find the smallest outer loop containing that inner loop to avoid
      // holes inside holes.
      var outBox = boundingBoxes[outer];
      if (outBox.containsBox(holeBox)) {
        outBox.getSize(boxSize);
        var outBoxArea = boxSize.x * boxSize.y;
        if (ownerIndex === -1 || outBoxArea < ownerArea) {
          ownerIndex = outer;
          ownerArea = outBoxArea;
        }
      }
    }
    ownership[inner] = ownerIndex;
  }
}

function convertLoopsToFaces(from, ownership, boundingBoxes) {
  var nbLoops = ownership.length;
  var readVector = new _three.Vector3();

  var newRangeOffsets = [0];
  var newValueIndices = [];
  var newPositions = new _ObjectArrayView2.default(_three.Vector3, from.positions.length);
  var newBoundingBox = [];

  var index = 0;
  var lowestFace = 0; // assume the first face is going to lowest one by default
  var lowestPoint = boundingBoxes[0].min.y;
  for (var li = 0; li < nbLoops; ++li) {
    if (ownership[li] === -1) {
      var holes = []; // offsets for this face
      var faceStartIndex = index;

      // start by copying the outer loop
      var loopBegin = from.loopRangeOffsets[li];
      var loopUntil = from.loopRangeOffsets[li + 1];

      for (var i = loopBegin; i < loopUntil; ++i) {
        from.positions.getAt(i, readVector);
        newPositions.setAt(index, readVector);

        newValueIndices.push(index);
        ++index;
      }

      // add the holes
      for (var lj = 0; lj < nbLoops; ++lj) {
        if (ownership[lj] === li) {
          holes.push(index - faceStartIndex);

          // add the holes indices
          var holeBegin = from.loopRangeOffsets[lj];
          var holeUntil = from.loopRangeOffsets[lj + 1];

          for (var _i = holeBegin; _i < holeUntil; ++_i) {
            from.positions.getAt(_i, readVector);
            newPositions.setAt(index, readVector);

            newValueIndices.push(index);
            ++index;
          }
        }
      }

      var bbox = boundingBoxes[li];
      newBoundingBox.push(bbox);

      var testPoint = bbox.min.y;
      if (testPoint < lowestPoint) {
        lowestPoint = testPoint;
        lowestFace = newRangeOffsets.length - 1;
      }

      newRangeOffsets.push(index);
      from.holeOffsets.push(holes);
    }
  }

  from.loopRangeOffsets = new Uint32Array(newRangeOffsets);
  from.loopValueIndices = new Uint32Array(newValueIndices);
  from.positions = newPositions;

  // copy the faces' bounding boxes into 'boundingBoxes' to have an updated version
  for (var b = 0; b < newBoundingBox.length; ++b) {
    boundingBoxes[b] = newBoundingBox[b];
  }
  return lowestFace;
}

/**
 * @param from - shape set info
 * @param anchoredIndex - index of the shape to connect to
 * @param compact - how much compact it should be (0 means barely touching)
 * @param boundingBoxes - updated bounding boxes for the faces
 * @param horizontal - (boolean) true, try to connect horizontally, otherwise, vertically
 */
function compactFaces(from, anchoredIndex, compact, boundingBoxes, horizontal) {
  // anchored face limits
  var anchorBegin = from.loopRangeOffsets[anchoredIndex];
  var anchorUntil = getFaceUntilWithoutHoles(from, anchorBegin, anchoredIndex);

  var anchorVertex = new _three.Vector3();
  var testVertex = new _three.Vector3();
  var testBox = null; // assigned by faces

  // use the right weight distance function when compacting horizontally or vertically
  var weightDistance = null;
  if (horizontal) {
    weightDistance = function weightDistance() {
      // use the distance between the two vertices as the base distance
      var squareDistance = anchorVertex.distanceToSquared(testVertex);

      // if outside the 'slab' of the bounding box, increase the distance
      var extra = 0.0;
      if (anchorVertex.y < testBox.min.y) {
        extra = testBox.min.y - anchorVertex.y;
      } else if (anchorVertex.y > testBox.max.y) {
        extra = anchorVertex.y - testBox.max.y;
      }
      return squareDistance + extra * extra;
    };
  } else {
    weightDistance = function weightDistance() {
      // use the distance between the two vertices as the base distance
      var squareDistance = anchorVertex.distanceToSquared(testVertex);

      // if outside the 'slab' of the bounding box, increase the distance
      var extra = 0.0;
      if (anchorVertex.x < testBox.min.x) {
        extra = testBox.min.x - anchorVertex.x;
      } else if (anchorVertex.x > testBox.max.x) {
        extra = anchorVertex.x - testBox.max.x;
      }
      return squareDistance + extra * extra;
    };
  }

  var nbFaces = from.loopRangeOffsets.length - 1;
  for (var fi = 0; fi < nbFaces; ++fi) {
    if (fi !== anchoredIndex) {
      // face limits
      var faceBegin = from.loopRangeOffsets[fi];
      var faceUntil = getFaceUntilWithoutHoles(from, faceBegin, fi);

      // set the bounding box for the test
      testBox = boundingBoxes[fi];

      var bestDistance = 1000000000.0;
      var bestPair = { anchorIndex: -1, testIndex: -1 };

      // FOR NOW, brute force algorithm in O(n*m)
      // for each anchor vertex
      for (var ai = anchorBegin; ai < anchorUntil; ++ai) {
        from.positions.getAt(ai, anchorVertex);

        // for each test vertex
        for (var ti = faceBegin; ti < faceUntil; ++ti) {
          from.positions.getAt(ti, testVertex);

          var testDistance = weightDistance();
          if (testDistance < bestDistance) {
            bestPair.anchorIndex = ai;
            bestPair.testIndex = ti;
            bestDistance = testDistance;
          }
        }
      }

      // found the best pair of points, now need to move the points closer
      from.positions.getAt(bestPair.anchorIndex, anchorVertex);
      from.positions.getAt(bestPair.testIndex, testVertex);
      var moveLength = anchorVertex.sub(testVertex).length();
      anchorVertex.multiplyScalar((moveLength + compact) / moveLength);

      // for each vertex in that face, translate by anchorVertex
      faceUntil = from.loopRangeOffsets[fi + 1];
      for (var _ti = faceBegin; _ti < faceUntil; ++_ti) {
        from.positions.getAt(_ti, testVertex);
        testVertex.add(anchorVertex);
        from.positions.setAt(_ti, testVertex);
      }
    }
  }
}

ShapeSet.fromPath = function (path, segments, bottom, compact, ringInfo) {
  var loopRangeOffsets = [0];
  var loopValueIndices = [];
  var vectorPositions = [];
  var boundingBoxes = [];

  // use half of the segment of lines to help with better compact
  var lineSegments = Math.max(Math.floor(segments * 0.25), 2);

  var looplength = 0;
  var valueIndices = 0;
  var bbox = new _three.Box3();
  var lastVector = null;
  for (var idx = 0; idx < path.commands.length; ++idx) {
    var cmd = path.commands[idx];
    if (cmd.type === 'Q') {
      // quadratics
      looplength += segments;
      var p1 = path.commands[idx - 1];
      var p2 = { x: cmd.x1, y: cmd.y1 };
      var p3 = cmd;
      for (var i = 1; i <= segments; ++i) {
        var pos = quadBezierAt(p1, p2, p3, i / segments);
        var vec = new _three.Vector3(pos.x, bottom - pos.y, 0).multiplyScalar(1 / 72.0);

        if (!(lastVector && lastVector.x === vec.x && lastVector.y === vec.y)) {
          lastVector = vec;

          loopValueIndices.push(valueIndices);
          bbox.expandByPoint(vec);
          vectorPositions.push(vec);
          ++valueIndices;
        } else {
          --looplength;
        }
      }
    } else if (cmd.type === 'L') {
      // line
      looplength += lineSegments;
      var _p = path.commands[idx - 1];
      var _p2 = { x: (cmd.x + _p.x) * 0.5, y: (cmd.y + _p.y) * 0.5 };
      var _p3 = cmd;
      for (var _i2 = 1; _i2 <= lineSegments; ++_i2) {
        var _pos = quadBezierAt(_p, _p2, _p3, _i2 / lineSegments);
        var _vec = new _three.Vector3(_pos.x, bottom - _pos.y, 0).multiplyScalar(1 / 72.0);

        if (!(lastVector && lastVector.x === _vec.x && lastVector.y === _vec.y)) {
          lastVector = _vec;

          loopValueIndices.push(valueIndices);
          bbox.expandByPoint(_vec);
          vectorPositions.push(_vec);
          ++valueIndices;
        } else {
          --looplength;
        }
      }
    } else if (cmd.type !== 'Z') {
      // anything else than an end of loop
      var _vec2 = new _three.Vector3(cmd.x, bottom - cmd.y, 0).multiplyScalar(1 / 72.0);

      if (!(lastVector && lastVector.x === _vec2.x && lastVector.y === _vec2.y)) {
        ++looplength;
        lastVector = _vec2;

        loopValueIndices.push(valueIndices);
        bbox.expandByPoint(_vec2);
        vectorPositions.push(_vec2);
        ++valueIndices;
      }
    } else {
      // end of loop, remove the last point because it's the same as the first one
      --looplength;
      --valueIndices;
      vectorPositions.pop();
      loopValueIndices.pop();

      loopRangeOffsets.push(looplength);

      // add the bounding box and create a new one
      boundingBoxes.push(bbox);
      bbox = new _three.Box3();
    }
  }

  // handle ring
  var ringOffsets = [];
  if (ringInfo) {
    ringInfo.innerRadius /= 72.0;
    ringInfo.outerRadius /= 72.0;
    if (ringInfo.innerRadius >= ringInfo.outerRadius) {
      ringInfo.innerRadius = ringInfo.outerRadius;
    }

    // find total bounding box
    var totalBbox = new _three.Box3().copy(boundingBoxes[0]);
    for (var bi = 1; bi < boundingBoxes.length; ++bi) {
      totalBbox.union(boundingBoxes[bi]);
    }

    // box size
    var totalSize = totalBbox.getSize();
    var dist = Math.min(totalSize.x, totalSize.y);

    var xCenter = ringInfo.xPosition < 0 ? totalBbox.min.x - dist : totalBbox.max.x + dist;
    var yCenter = 0.5 * ((totalBbox.min.y - dist) * (1.0 - ringInfo.yPosition) + (totalBbox.max.y + dist) * (1.0 + ringInfo.yPosition));

    // segment ratio for outer loop
    var outerSegment = Math.round(segments * (ringInfo.outerRadius / ringInfo.innerRadius));

    var ringOffset = {};
    ringOffsets.push(ringOffset);

    // outer loop
    {
      var loopSize = 4 * outerSegment;
      ringOffset.start = looplength;
      ringOffset.middle = looplength + loopSize;
      ringOffset.outerRadius = ringInfo.outerRadius;
      looplength += loopSize;
      var incrAngle = Math.PI / (2.0 * outerSegment);
      var angle = 0.0;
      for (var oi = 0; oi < loopSize; ++oi) {
        vectorPositions.push(new _three.Vector3(xCenter + Math.cos(angle) * ringInfo.outerRadius, yCenter - Math.sin(angle) * ringInfo.outerRadius, // minus to create a CW outer loop
        0.0));
        loopValueIndices.push(valueIndices);
        ++valueIndices;
        angle += incrAngle;
      }
      loopRangeOffsets.push(looplength);

      // bouding box
      boundingBoxes.push(new _three.Box3(new _three.Vector3(xCenter - ringInfo.outerRadius, yCenter - ringInfo.outerRadius, 0.0), new _three.Vector3(xCenter + ringInfo.outerRadius, yCenter + ringInfo.outerRadius, 0.0)));
    }

    // inner loop
    {
      var _loopSize = 4 * segments;
      ringOffset.until = looplength + _loopSize;
      ringOffset.innerRadius = ringInfo.innerRadius;
      looplength += _loopSize;
      var _incrAngle2 = Math.PI / (2.0 * segments);
      var _angle3 = 0.0;
      for (var _oi = 0; _oi < _loopSize; ++_oi) {
        vectorPositions.push(new _three.Vector3(xCenter + Math.cos(_angle3) * ringInfo.innerRadius, yCenter + Math.sin(_angle3) * ringInfo.innerRadius, 0.0));
        loopValueIndices.push(valueIndices);
        ++valueIndices;
        _angle3 += _incrAngle2;
      }
      loopRangeOffsets.push(looplength);

      // bouding box
      boundingBoxes.push(new _three.Box3(new _three.Vector3(xCenter - ringInfo.innerRadius, yCenter - ringInfo.innerRadius, 0.0), new _three.Vector3(xCenter + ringInfo.innerRadius, yCenter + ringInfo.innerRadius, 0.0)));
    }
  }

  var from = {
    loopRangeOffsets: new Uint32Array(loopRangeOffsets),
    loopValueIndices: new Uint32Array(loopValueIndices),
    positions: new _ObjectArrayView2.default(_three.Vector3, vectorPositions.length),
    // hole offsets contains array and each of them is the offset for the holes
    // listed at end of a face (it's needed for 'earcut')
    holeOffsets: [],
    bevelSegments: [],
    backFaceOffsets: 0, // index where the vertices for the back faces starts
    bevelSmoothingGroups: [],
    ringOffsets: ringOffsets
  };

  // fill the position
  for (var _i3 = 0; _i3 < vectorPositions.length; ++_i3) {
    from.positions.setAt(_i3, vectorPositions[_i3]);
  }

  // if it's a hole, this is the index of the non-hole loop owning it
  var ownership = new Array(loopRangeOffsets.length - 1).fill(-1);

  // find which holes are loops!
  var holes = findHoles(from);

  // find hole ownerships (inside which outer loop that hole is)
  putHolesInLoops(from, holes, ownership, boundingBoxes);

  // split each outer loop into a face (and returns the main face to use as
  // anchor if 'compact' is true)
  var mainFace = convertLoopsToFaces(from, ownership, boundingBoxes);

  // only compact the shape set if it has more than one face
  if (compact !== undefined && from.loopRangeOffsets.length > 2) {
    compactFaces(from, mainFace, compact, boundingBoxes, false);
  }

  return new ShapeSet(from);
};

/**
 * NOTE: can only merge shape set that are not bevelled
 *
 * @param shapeSets - array of shape sets to merge
 * @param offsets - array of vectors to offset each shape set by
 * @return merged shape sets
 */
ShapeSet.mergeShapeSets = function (shapeSets, offsets) {
  // compute the size of each buffers
  var finalLoopRangeOffsetsLength = 1;
  var finalLoopValueIndicesLength = 0; // which is also the length of positions

  var ringOffsets = [];

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = (0, _getIterator3.default)(shapeSets), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _shapeSet = _step4.value;

      finalLoopRangeOffsetsLength += _shapeSet.loopRangeOffsets.length - 1;
      finalLoopValueIndicesLength += _shapeSet.loopValueIndices.length;
    }

    // init the final 'from' that holds all the buffers
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  var finalFrom = {
    loopRangeOffsets: new Uint32Array(finalLoopRangeOffsetsLength),
    loopValueIndices: new Uint32Array(finalLoopValueIndicesLength),
    positions: new _ObjectArrayView2.default(_three.Vector3, finalLoopValueIndicesLength),
    holeOffsets: [],
    bevelSegments: [],
    backFaceOffsets: 0,
    bevelSmoothingGroups: [],
    ringOffsets: ringOffsets
  };

  // offsets in which to add the values of each shape set
  var loopRangeOffsetsOffset = 0;
  var loopValueIndicesOffset = 0;

  // indices to write in buffers
  var loopRangeOffsetsIdx = 0;
  var loopValueIndicesIdx = 0;

  var tmpVector = new _three.Vector3();

  // for each shape sets
  for (var si = 0; si < shapeSets.length; ++si) {
    var _finalFrom$holeOffset;

    var shapeSet = shapeSets[si];
    var offsetVector = offsets[si];
    var nbValueIndices = shapeSet.loopValueIndices.length;

    // copy the range offsets
    var nbRangeOffsets = shapeSet.loopRangeOffsets.length - 1;
    for (var i = 0; i < nbRangeOffsets; ++i, ++loopRangeOffsetsIdx) {
      finalFrom.loopRangeOffsets[loopRangeOffsetsIdx] = shapeSet.loopRangeOffsets[i] + loopRangeOffsetsOffset;
    }

    // update the ring offsets
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = (0, _getIterator3.default)(shapeSet.ringOffsets), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var ringItem = _step5.value;

        ringOffsets.push({
          start: ringItem.start + loopValueIndicesOffset,
          middle: ringItem.middle + loopValueIndicesOffset,
          until: ringItem.until + loopValueIndicesOffset,
          outerRadius: ringItem.outerRadius,
          innerRadius: ringItem.innerRadius
        });
      }

      // copy the indices and positions
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return) {
          _iterator5.return();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }

    for (var _i4 = 0; _i4 < nbValueIndices; ++_i4, ++loopValueIndicesIdx) {
      finalFrom.loopValueIndices[loopValueIndicesIdx] = shapeSet.loopValueIndices[_i4] + loopValueIndicesOffset;

      shapeSet.positions.getAt(_i4, tmpVector);
      tmpVector.add(offsetVector);
      finalFrom.positions.setAt(loopValueIndicesIdx, tmpVector);
    }

    // add the holes
    (_finalFrom$holeOffset = finalFrom.holeOffsets).push.apply(_finalFrom$holeOffset, (0, _toConsumableArray3.default)(shapeSet.holeOffsets));

    // increment the offsets
    loopValueIndicesOffset += nbValueIndices;
    loopRangeOffsetsOffset += nbValueIndices;
  }
  // conclude the range offsets
  finalFrom.loopRangeOffsets[loopRangeOffsetsIdx] = finalLoopValueIndicesLength;

  return new ShapeSet(finalFrom);
};

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.falloffFunctionPresets = undefined;

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _falloffWeightFunctio;

exports.default = calculateFalloffWeights;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var falloffFunctionPresets = exports.falloffFunctionPresets = {
  sinusoidal: 0,
  linear: 1
};

// A variation of the Smoothstep function is used to approximate the cosine function
function sinusoidalFalloffWeights(distances, falloffRadius, weights) {
  var weightsLength = weights.length;
  for (var i = 0; i < weightsLength; ++i) {
    var x = distances[i];
    weights[i] = distances[i] <= falloffRadius ? 1 - x * x / (falloffRadius * falloffRadius) * (3 - 2 * x / falloffRadius) : 0;
  }
}

function linearFalloffWeights(distances, falloffRadius, weights) {
  var weightsLength = weights.length;
  for (var i = 0; i < weightsLength; ++i) {
    var x = distances[i];
    weights[i] = x <= falloffRadius ? 1 - x / falloffRadius : 0;
  }
}

var falloffWeightFunctions = (_falloffWeightFunctio = {}, (0, _defineProperty3.default)(_falloffWeightFunctio, falloffFunctionPresets.sinusoidal, sinusoidalFalloffWeights), (0, _defineProperty3.default)(_falloffWeightFunctio, falloffFunctionPresets.linear, linearFalloffWeights), _falloffWeightFunctio);

function calculateFalloffWeights(distances, falloffRadius, falloffCurve) {
  var weights = new Float32Array(distances.length);

  falloffWeightFunctions[falloffCurve](distances, falloffRadius, weights);

  return weights;
}

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createMeshArray;

var _three = __webpack_require__(0);

function createMeshArray(mesh, numRepeat, translation, rotation, scale, meshToPivotTransform) {
  var meshArray = [mesh];
  var transforms = [new _three.Matrix4()];

  if (numRepeat <= 1) {
    return { meshArray: meshArray, transforms: transforms };
  }

  for (var i = 1; i < numRepeat; ++i) {
    meshArray.push(mesh);
  }

  var rotationMatrix = new _three.Matrix4().makeRotationFromQuaternion(rotation);
  var scaleMatrix = new _three.Matrix4().makeScale(scale.x, scale.y, scale.z);
  var rotationAndScale = scaleMatrix.multiply(rotationMatrix);

  var pivotToMeshTransform = new _three.Matrix4();

  if (meshToPivotTransform && meshToPivotTransform.isMatrix4) {
    pivotToMeshTransform.getInverse(meshToPivotTransform);
  } else {
    meshToPivotTransform = new _three.Matrix4();
  }

  var currentTranslation = new _three.Vector3();
  var translationMatrix = new _three.Matrix4();
  var totalRotationAndScale = new _three.Matrix4();

  // Successive Transformations - Rotation, then Scale, then Translation
  for (var _i = 1; _i < numRepeat; ++_i) {
    currentTranslation.add(translation);
    translationMatrix.makeTranslation(currentTranslation.x, currentTranslation.y, currentTranslation.z);

    totalRotationAndScale.multiply(rotationAndScale);

    var totalTransform = new _three.Matrix4();
    totalTransform.multiply(pivotToMeshTransform);
    totalTransform.multiply(translationMatrix);
    totalTransform.multiply(totalRotationAndScale);
    totalTransform.multiply(meshToPivotTransform);

    transforms.push(totalTransform);
  }

  return { meshArray: meshArray, transforms: transforms };
}

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getPlane;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function getPlane(rotation, rotateOrder, axis, center, defaultNormal) {
  var normal = new THREE.Vector3().copy(defaultNormal);
  var newRotation = new THREE.Vector3().copy(rotation).multiplyScalar(Math.PI / 180.0);
  var eulerRotation = new THREE.Euler().setFromVector3(newRotation, rotateOrder);
  var rotationMatrix = new THREE.Matrix4().makeRotationFromEuler(eulerRotation);

  var axisMatrix = void 0;
  if (axis === 1) {
    axisMatrix = new THREE.Matrix4().makeRotationY(Math.PI / 2.0);
    rotationMatrix.multiply(axisMatrix);
  }
  if (axis === 2) {
    axisMatrix = new THREE.Matrix4().makeRotationX(Math.PI / 2.0);
    rotationMatrix.multiply(axisMatrix);
  } // For Z direction we do nothing
  normal.applyMatrix4(rotationMatrix).normalize();
  //Buffer for the values
  if (Math.abs(normal.x) < 0.0001) {
    normal.x = 0;
  }
  if (Math.abs(normal.y) < 0.0001) {
    normal.y = 0;
  }
  if (Math.abs(normal.z) < 0.0001) {
    normal.z = 0;
  }

  return new THREE.Plane().setFromNormalAndCoplanarPoint(normal, center);
}

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeUnusedValues;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removeUnusedValues(polyMesh) {
  var withLogging = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
  var totalFaceValueIndices = faceValueIndices.length;

  var values = polyMesh.positions.values;
  var originalValuesLength = values.length;
  var newValues = new _ObjectArrayView2.default(_three.Vector3, originalValuesLength);
  var newValuesLength = 0;

  // Collects used values in the order they appear in values
  // Updates faceValueIndices with the mapped value indices
  // [1, 4, 2, 4, 9, 6] -> [0, 2, 1, 2, 4, 3]

  // The used value differs from the default value of Uint32Array elements
  var USED_VALUE = 1;
  var usedValues = new Uint32Array(originalValuesLength);

  // Update usedValues to indicate which positions are in faceValueIndices
  for (var i = 0; i < totalFaceValueIndices; i++) {
    usedValues[faceValueIndices[i]] = USED_VALUE;
  }

  var currentIndex = 0;
  var tmpValue = new _three.Vector3();

  // Update usedValue to map old index for a value to the new index
  // Propagate newValues with used values in the original order they appear
  var addValue = function addValue(index, newValuesList) {
    usedValues[index] = currentIndex; // update to new value index
    values.getAt(index, tmpValue);
    newValuesList.setAt(currentIndex, tmpValue);
    currentIndex++;
  };

  // Add values in faceValueIndices to newValues
  for (var vertexIndex = 0; vertexIndex < originalValuesLength; ++vertexIndex) {
    if (usedValues[vertexIndex] === USED_VALUE) {
      addValue(vertexIndex, newValues);
      newValuesLength++;
    }
  }

  // Use usedValues to update value indices in faceValueIndices
  for (var _i = 0; _i < totalFaceValueIndices; _i++) {
    faceValueIndices[_i] = usedValues[faceValueIndices[_i]];
  }

  if (withLogging) console.log('' + originalValuesLength + ' values reduced to ' + newValuesLength + ', unused values removed: ' + (originalValuesLength - newValuesLength));

  if (originalValuesLength === newValuesLength) return polyMesh;

  var newValuesArray = new _ObjectArrayView2.default(_three.Vector3, newValuesLength);
  newValuesArray.fromArray(newValues.toArray());

  var newPositions = new _PolyMap2.default({
    faceRangeOffsets: polyMesh.faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: newValuesArray
  });

  polyMesh.positions = newPositions;
  var resultMesh = new _PolyMesh2.default(polyMesh);

  return resultMesh;
}

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sign = __webpack_require__(165);

var _sign2 = _interopRequireDefault(_sign);

exports.default = slice;

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _mergePolyMeshes = __webpack_require__(103);

var _mergePolyMeshes2 = _interopRequireDefault(_mergePolyMeshes);

var _Selection = __webpack_require__(70);

var _Selection2 = _interopRequireDefault(_Selection);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import {Vector3, Vector2, Plane, Line3, Math as THREE} from 'three/three.math';
var intersectLineParameter = function () {
  var v1 = new THREE.Vector3();

  return function intersectLineParameter(plane, line) {
    var direction = line.delta(v1);

    var denominator = plane.normal.dot(direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (plane.distanceToPoint(line.start) === 0) {
        return 0;
      }

      // Unsure if this is the correct method to handle this case.
      return -1;
    }

    var alpha = -(line.start.dot(plane.normal) + plane.constant) / denominator;

    if (alpha >= 1 || alpha <= 0) {
      return -2;
    }

    return alpha;
  };
}();

function determineVertexSigns(values, plane) {
  var numValues = values.length;
  var tempVertex = new THREE.Vector3();
  var vertexSignArray = new Float32Array(numValues);
  // vi = valueIndex
  for (var vi = 0; vi < numValues; ++vi) {
    values.getAt(vi, tempVertex);
    vertexSignArray[vi] = (0, _sign2.default)(plane.distanceToPoint(tempVertex));
  }

  return vertexSignArray;
}

function determineEdgeStates(edgeVertexAdjacency, plane, vertexSigns, values) {
  var numEdges = edgeVertexAdjacency.getNumEdges();
  var edgeVertices = new Uint32Array(2);
  var edgeStateArray = new Float32Array(numEdges);
  var tempEdge = new THREE.Line3();

  // ei = edgeIndex
  for (var ei = 0; ei < numEdges; ++ei) {
    edgeVertexAdjacency.getVerticesForEdge(ei, edgeVertices);
    var tempVertexIndexA = edgeVertices[0];
    var tempVertexIndexB = edgeVertices[1];
    var vertexSignA = vertexSigns[tempVertexIndexA];
    var vertexSignB = vertexSigns[tempVertexIndexB];

    if (vertexSignA === 0 || vertexSignB === 0) {
      edgeStateArray[ei] = 0;
    } else if (vertexSignA === vertexSignB) {
      edgeStateArray[ei] = vertexSignA;
    } else {
      values.getAt(tempVertexIndexA, tempEdge.start);
      values.getAt(tempVertexIndexB, tempEdge.end);
      edgeStateArray[ei] = intersectLineParameter(plane, tempEdge);
    }
  }
  return edgeStateArray;
}

function slicePolyMap(polyMap, edgeStateArray, vertexSignArray, positionEdgeVertexAdjacency, positionMap, selectedFaces, optionalFaceRangeOffset) {
  var positionFaceValueIndices = positionMap.faceValueIndices;
  var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;
  var numEdges = edgeVertexAdjacency.getNumEdges();
  var values = polyMap.values;
  var valueType = values.type;
  var numValues = values.length;
  var faceRangeOffsets = polyMap.faceRangeOffsets;
  var numFaces = faceRangeOffsets.length - 1;
  var faceValueIndices = polyMap.faceValueIndices;
  var numFaceValueIndices = faceValueIndices.length;
  var visitedEdges = new Float32Array(numEdges);
  var visitedVertex = new Float32Array(numValues * 2);

  var newFaceRangeOffsets = new Uint32Array(numFaces + 1);
  var faceStates = new Uint32Array(numFaces + 1);
  var newFaceValueIndices = new Uint32Array(numFaceValueIndices * 2);
  var newValues = new _ObjectArrayView2.default(valueType, numValues * 2);

  var faceRangeIndex = 0;
  var faceValueIndex = 0;
  var newNumValues = 0;
  var finalNumFaceRangeOffsets = 0;

  var tempVertex = new valueType();
  var tempVertexA = new valueType();
  var tempVertexB = new valueType();
  var tempVertexS = new valueType();

  for (var f = 0; f < numFaces; ++f) {
    var faceBegin = faceRangeOffsets[f];
    var faceUntil = faceRangeOffsets[f + 1];
    var numFaceValues = faceUntil - faceBegin;
    if (selectedFaces && selectedFaces[f] !== 1) {
      var nextVal = faceValueIndices[faceBegin];
      var nextNextVal = faceValueIndices[faceBegin + 1 % numFaceValues];

      for (var fv = 0; fv < numFaceValues; ++fv) {
        var currVal = nextVal;
        nextVal = nextNextVal;
        nextNextVal = faceValueIndices[faceBegin + (fv + 2) % numFaceValues];

        if (visitedVertex[currVal] === 0) {
          values.getAt(currVal, tempVertex);
          newValues.setAt(newNumValues, tempVertex);
          newFaceValueIndices[faceValueIndex] = newNumValues;
          visitedVertex[currVal] = newNumValues + 1;
          ++faceValueIndex;
          ++newNumValues;
        } else {
          newFaceValueIndices[faceValueIndex] = visitedVertex[currVal] - 1;
          ++faceValueIndex;
        }
      }

      ++finalNumFaceRangeOffsets;
      newFaceRangeOffsets[++faceRangeIndex] = faceValueIndex;
    } else {
      var nextPosVal = positionFaceValueIndices[faceBegin];
      var nextNextPosVal = positionFaceValueIndices[faceBegin + 1 % numFaceValues];
      var tempNumVal = newNumValues;
      var tempFaceValueIndex = faceValueIndex;

      //In case a face is negative, used later to reset the visisted vertices of that face to zero
      var tempVisited = new Uint32Array(numFaceValues);
      for (var _fv = 0; _fv < numFaceValues; ++_fv) {
        var currPosVal = nextPosVal;
        nextPosVal = nextNextPosVal;
        nextNextPosVal = positionFaceValueIndices[faceBegin + (_fv + 2) % numFaceValues];

        var positionEdgeId = positionEdgeVertexAdjacency.findEdgeId(currPosVal, nextPosVal);
        var positionEdgeState = edgeStateArray[positionEdgeId];
        var currPositionSign = vertexSignArray[currPosVal];
        if (currPositionSign === 1) {
          faceStates[f] = faceStates[f] | 1;
        }
        if (currPositionSign === -1) {
          faceStates[f] = faceStates[f] | 2;
        }

        if (positionEdgeState >= 0) {
          var _currVal = faceValueIndices[faceBegin + _fv % numFaceValues];
          values.getAt(_currVal, tempVertex);

          if (currPositionSign >= 0) {
            if (visitedVertex[_currVal] === 0) {
              newValues.setAt(newNumValues, tempVertex);
              newFaceValueIndices[faceValueIndex] = newNumValues;
              visitedVertex[_currVal] = newNumValues + 1;
              tempVisited[_fv] = _currVal;
              ++faceValueIndex;
              ++newNumValues;
            } else {
              newFaceValueIndices[faceValueIndex] = visitedVertex[_currVal] - 1;
              ++faceValueIndex;
            }
          }

          if (positionEdgeState > 0 && positionEdgeState < 1) {
            var _nextVal = faceValueIndices[faceBegin + (_fv + 1) % numFaceValues];
            var tempEdgeId = 0;

            if (!optionalFaceRangeOffset) {
              tempEdgeId = positionEdgeId;
            } else {
              tempEdgeId = edgeVertexAdjacency.findEdgeId(_currVal, _nextVal);
            }

            if (visitedEdges[tempEdgeId] === 0) {
              var startVertex = _currVal;
              var endVertex = _nextVal;

              if (nextPosVal < currPosVal) {
                var temp = endVertex;
                endVertex = startVertex;
                startVertex = temp;
              }

              values.getAt(startVertex, tempVertexA);
              values.getAt(endVertex, tempVertexB);

              var alpha = edgeStateArray[positionEdgeId];
              var beta = 1 - alpha;

              tempVertexA.multiplyScalar(beta);
              tempVertexB.multiplyScalar(alpha);
              tempVertexS.addVectors(tempVertexA, tempVertexB);

              newValues.setAt(newNumValues, tempVertexS);
              newFaceValueIndices[faceValueIndex] = newNumValues;
              visitedEdges[tempEdgeId] = newNumValues + 1;
              ++faceValueIndex;
              ++newNumValues;
            } else {
              newFaceValueIndices[faceValueIndex] = visitedEdges[tempEdgeId] - 1;
              ++faceValueIndex;
            }
          }
        }
      }
      if (faceStates[f] === 2) {
        newNumValues = tempNumVal;
        faceValueIndex = tempFaceValueIndex;
        for (var n = 0; n < numFaceValues; ++n) {
          visitedVertex[tempVisited[n]] = 0;
        }
      } else {
        ++finalNumFaceRangeOffsets;
      }
      newFaceRangeOffsets[++faceRangeIndex] = faceValueIndex;
    }
  }

  var finalFaceRangeOffsets = new Uint32Array(finalNumFaceRangeOffsets + 1);
  var finalFaceValueIndices = new Uint32Array(faceValueIndex);
  var finalValues = new _ObjectArrayView2.default(valueType, newNumValues);
  visitedVertex.fill(-1);

  var finalFaceRangeIndex = 0;
  var finalValuesIndex = 0;
  var finalFaceValueIndex = 0;

  for (var i = 0; i < faceRangeIndex; ++i) {
    var _faceBegin = newFaceRangeOffsets[i];
    var _faceUntil = newFaceRangeOffsets[i + 1];
    var _numFaceValues = _faceUntil - _faceBegin;

    if (faceStates[i] !== 2) {
      if (!optionalFaceRangeOffset) {
        finalFaceRangeOffsets[++finalFaceRangeIndex] = finalFaceRangeOffsets[finalFaceRangeIndex - 1] + _numFaceValues;
      }
      var _nextVal2 = newFaceValueIndices[_faceBegin];
      var _nextNextVal = newFaceValueIndices[_faceBegin + 1 % _numFaceValues];

      for (var _fv2 = 0; _fv2 < _numFaceValues; ++_fv2) {
        var _currVal2 = _nextVal2;
        _nextVal2 = _nextNextVal;
        _nextNextVal = newFaceValueIndices[_faceBegin + (_fv2 + 2) % _numFaceValues];

        if (visitedVertex[_currVal2] === -1) {
          visitedVertex[_currVal2] = finalValuesIndex;
          finalFaceValueIndices[finalFaceValueIndex] = finalValuesIndex;
          newValues.getAt(_currVal2, tempVertex);
          finalValues.setAt(finalValuesIndex, tempVertex);
          ++finalValuesIndex;
          ++finalFaceValueIndex;
        } else {
          finalFaceValueIndices[finalFaceValueIndex] = visitedVertex[_currVal2];
          ++finalFaceValueIndex;
        }
      }
    }
  }

  if (!optionalFaceRangeOffset) {
    optionalFaceRangeOffset = finalFaceRangeOffsets;
  }

  var pm = {
    faceRangeOffsets: optionalFaceRangeOffset,
    faceValueIndices: finalFaceValueIndices,
    values: finalValues
  };
  return new _PolyMap2.default(pm);
}

function slice(mesh, plane, optionCut, optionFlip, optionalFaceSelection) {
  var selectedFaces = optionalFaceSelection ? new Uint32Array(mesh.faceRangeOffsets.length - 1) : null;
  if (optionalFaceSelection) {
    var selections = optionalFaceSelection.indices;
    var numSelectedFaces = selections.length;
    if (numSelectedFaces === 0) {
      return mesh;
    }
    for (var i = 0; i < numSelectedFaces; ++i) {
      var selectedFaceIndex = selections[i];
      selectedFaces[selectedFaceIndex] = 1;
    }
  }
  var edgeVertexAdjacency = mesh.positions.edgeVertexAdjacency;
  var positions = mesh.positions;
  var positionValues = positions.values;

  //find vertex signs
  var vertexSignArray = determineVertexSigns(positionValues, plane);
  //find cut edges of faces, only cuts if the plane passes through vertices without touching either vertex
  var edgeStateArray = determineEdgeStates(edgeVertexAdjacency, plane, vertexSignArray, positionValues);
  //positive mesh
  var positiveResult = new _PolyMesh2.default();

  if (!optionFlip || optionCut) {
    positiveResult.positions = slicePolyMap(positions, edgeStateArray, vertexSignArray, edgeVertexAdjacency, positions, selectedFaces);
    positiveResult.faceRangeOffsets = positiveResult.positions.faceRangeOffsets;

    if (mesh.normalMap) {
      var normals = mesh.normalMap;
      positiveResult.normalMap = slicePolyMap(normals, edgeStateArray, vertexSignArray, edgeVertexAdjacency, positions, selectedFaces, positiveResult.faceRangeOffsets);
    }

    if (mesh.uvMaps) {
      var uvMaps = new _ObjectsByName2.default();
      for (var _i = 0; _i < mesh.uvMaps.length; _i++) {
        var name = mesh.uvMaps.namesByIndex[_i];
        uvMaps.set(name, slicePolyMap(mesh.uvMaps.byName[name], edgeStateArray, vertexSignArray, edgeVertexAdjacency, positions, selectedFaces, positiveResult.faceRangeOffsets));
      }

      positiveResult.uvMaps = uvMaps;
    }

    if (!optionCut) {
      var _finalMesh = new _PolyMesh2.default(positiveResult);
      return _finalMesh;
    }
  }

  //negative mesh
  var negativeResult = new _PolyMesh2.default();

  if (optionCut || optionFlip) {
    for (var _i2 = 0; _i2 < edgeStateArray.length; ++_i2) {
      if (edgeStateArray[_i2] >= 1 || edgeStateArray[_i2] < 0) {
        edgeStateArray[_i2] = edgeStateArray[_i2] * -1;
      }
    }
    for (var _i3 = 0; _i3 < vertexSignArray.length; ++_i3) {
      vertexSignArray[_i3] = vertexSignArray[_i3] * -1;
    }

    negativeResult.positions = slicePolyMap(positions, edgeStateArray, vertexSignArray, edgeVertexAdjacency, positions, selectedFaces);
    negativeResult.faceRangeOffsets = negativeResult.positions.faceRangeOffsets;

    if (mesh.normalMap) {
      var _normals = mesh.normalMap;
      negativeResult.normalMap = slicePolyMap(_normals, edgeStateArray, vertexSignArray, edgeVertexAdjacency, positions, selectedFaces, negativeResult.faceRangeOffsets);
    }

    if (mesh.uvMaps) {
      var _uvMaps = new _ObjectsByName2.default();
      for (var _i4 = 0; _i4 < mesh.uvMaps.length; _i4++) {
        var _name = mesh.uvMaps.namesByIndex[_i4];
        _uvMaps.set(_name, slicePolyMap(mesh.uvMaps.byName[_name], edgeStateArray, vertexSignArray, edgeVertexAdjacency, positions, selectedFaces, negativeResult.faceRangeOffsets));
      }

      negativeResult.uvMaps = _uvMaps;
    }
    if (optionCut) {
      var mergeList = [positiveResult, negativeResult];
      var _finalMesh2 = (0, _mergePolyMeshes2.default)(mergeList, null, null);
      return _finalMesh2;
    }
    if (optionFlip) {
      var _finalMesh3 = new _PolyMesh2.default(negativeResult);
      return _finalMesh3;
    }
  }

  var finalMesh = new _PolyMesh2.default(positiveResult);
  return finalMesh;
}

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transform;

var _Selection = __webpack_require__(70);

var _Selection2 = _interopRequireDefault(_Selection);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _Renormalizer = __webpack_require__(460);

var _Renormalizer2 = _interopRequireDefault(_Renormalizer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function transform(mesh, vectorOrMatrixOrFunction, optionalSelection, optionalMapId, optionalWeights) {
  var newMesh = new _PolyMesh2.default(mesh),
      mapId = optionalMapId || _PolyMaps2.default.IdPositions,
      newPolyMap = new _PolyMap2.default(_PolyMaps2.default.resolveMap(mesh, mapId)),
      newMapValues = newPolyMap.values.clone();

  newPolyMap.values = newMapValues;
  _PolyMaps2.default.assignMap(newMesh, mapId, newPolyMap);

  var vertexIndices = _Selection2.default.getIndices(mesh, _Selection2.default.Vertices, mapId, optionalSelection),
      valueType = newMapValues.type,
      value = new valueType(),
      intermediateValue = new valueType(),
      nonuniform = !!optionalSelection;

  function applyWeightToNewValue(currentIndex) {
    newMapValues.getAt(currentIndex, intermediateValue).lerp(value, optionalWeights[currentIndex]);
    value.copy(intermediateValue);
  }

  if (vectorOrMatrixOrFunction.constructor === valueType) {
    var vector = vectorOrMatrixOrFunction;

    for (var j = 0, n = vertexIndices.length; j !== n; ++j) {
      var i = vertexIndices[j];

      newMapValues.getAt(i, value);
      value.add(vector);

      if (optionalWeights) {
        applyWeightToNewValue(i);
      }

      newMapValues.setAt(i, value);
    }
  } else if (typeof vectorOrMatrixOrFunction === 'function') {
    var func = vectorOrMatrixOrFunction;
    nonuniform = true;

    for (var j = 0, n = vertexIndices.length; j !== n; ++j) {
      var i = vertexIndices[j];

      newMapValues.getAt(i, value);
      func(value, newPolyMap, i);

      if (optionalWeights) {
        applyWeightToNewValue(i);
      }

      newMapValues.setAt(i, value);
    }
  } else if (vectorOrMatrixOrFunction.isMatrix4) {
    var matrix4 = vectorOrMatrixOrFunction;
    nonuniform = true; // could test whether determinant is ~1

    for (var j = 0, n = vertexIndices.length; j !== n; ++j) {
      var i = vertexIndices[j];

      newMapValues.getAt(i, value);
      value.applyMatrix4(matrix4);

      if (optionalWeights) {
        applyWeightToNewValue(i);
      }

      newMapValues.setAt(i, value);
    }
  } else if (vectorOrMatrixOrFunction.isMatrix3) {
    var matrix3 = vectorOrMatrixOrFunction;
    nonuniform = true; // could test whether determinant is ~1

    for (var j = 0, n = vertexIndices.length; j !== n; ++j) {
      var i = vertexIndices[j];

      newMapValues.getAt(i, value);
      value.applyMatrix3(matrix3);

      if (optionalWeights) {
        applyWeightToNewValue(i);
      }

      newMapValues.setAt(i, value);
    }
  } else throw Error('Invalid argument!');

  if (nonuniform && mapId === _PolyMaps2.default.IdPositions && newMesh.normalMap !== null) {
    var renormalizer = new _Renormalizer2.default(newMesh);

    if (!optionalSelection) renormalizer.dirtyFaces.fill();else renormalizer.markPositionsDirty(vertexIndices);

    renormalizer.updateMesh();
  }

  // Transform and renormalizer mutate existing mesh, invalidating some properties (ex. bbox).
  // Once done mutating, we properly initialize a new PolyMesh from it for external use.
  return new _PolyMesh2.default(newMesh);
}

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = triangulateMesh;

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _ScalarArrayView = __webpack_require__(156);

var _ScalarArrayView2 = _interopRequireDefault(_ScalarArrayView);

var _EarCutTriangulation = __webpack_require__(230);

var _EarCutTriangulation2 = _interopRequireDefault(_EarCutTriangulation);

var _applyFunctionToPolyMap = __webpack_require__(157);

var _applyFunctionToPolyMap2 = _interopRequireDefault(_applyFunctionToPolyMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function triangulateMesh(polyMesh) {
  function triangulateMap(polyMap, polyMapName, additionalArguments) {
    var newFaceRangeOffsets = additionalArguments.newFaceRangeOffsets;
    var triangulation = additionalArguments.triangulation;

    var result = new _ScalarArrayView2.default(triangulation.numTriangles * 3);
    triangulation.translateIndices(polyMap.faceValueIndices, result);
    var newFaceValueIndices = result.data;

    return new _PolyMap2.default({
      faceRangeOffsets: newFaceRangeOffsets,
      faceValueIndices: newFaceValueIndices,
      values: polyMap.values
    });
  }

  var triangulation = new _EarCutTriangulation2.default(polyMesh);

  var newFaceRangeOffsets = new Uint32Array(triangulation.numTriangles + 1);
  for (var i = 1; i < newFaceRangeOffsets.length; i++) {
    newFaceRangeOffsets[i] = newFaceRangeOffsets[i - 1] + 3;
  }

  var args = { newFaceRangeOffsets: newFaceRangeOffsets, triangulation: triangulation };
  return (0, _applyFunctionToPolyMap2.default)(polyMesh, triangulateMap, args).topologyChanged();
}

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Cylinder;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _CylinderLathe = __webpack_require__(451);

var _CylinderLathe2 = _interopRequireDefault(_CylinderLathe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Cylinder(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  radiusTop = radiusTop !== undefined ? radiusTop : 20;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  height = height !== undefined ? height : 100;

  openEnded = openEnded || false;

  radialSegments = Math.max(1, Math.floor(radialSegments || 8));
  heightSegments = Math.max(1, Math.floor(heightSegments || 8));

  thetaStart = _three.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
  thetaLength = _three.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);

  var heightSegmentLength = height / heightSegments;
  var halfHeight = height / 2;
  var slope = (radiusTop - radiusBottom) / height;

  var radialSegmentsLengthTop = radiusTop / radialSegments;
  var radialSegmentsLengthBottom = radiusBottom / radialSegments;
  var points = void 0;
  var norms = void 0;

  if (openEnded) {
    points = new _ObjectArrayView2.default(_three.Vector3, heightSegments + 1);
    norms = new _ObjectArrayView2.default(_three.Vector3, heightSegments + 1);
  } else {
    points = new _ObjectArrayView2.default(_three.Vector3, heightSegments + 1 + 4);
    norms = new _ObjectArrayView2.default(_three.Vector3, heightSegments + 1 + 4);
  }

  var pt = new _three.Vector3();
  var normPt = new _three.Vector3(0, -1, 0);

  //bottom
  if (!openEnded) {
    pt.set(0, -1 * halfHeight, 0);
    points.setAt(0, pt);
    norms.setAt(0, normPt);

    pt.set(0, -1 * halfHeight, radiusBottom);
    points.setAt(1, pt);
    norms.setAt(1, normPt);
  }

  //body
  for (var i = 0, il = heightSegments; i <= il; i++) {
    pt.set(0, i * heightSegmentLength - halfHeight, slope * i * heightSegmentLength + radiusBottom);
    if (radiusTop === 0 && i === il) normPt.set(0, 1, 0);else if (radiusBottom === 0 && i === 0) normPt.set(0, -1, 0);else normPt.set(0, 0, 1).applyAxisAngle(new _three.Vector3(1, 0, 0), Math.atan(slope));

    var index = openEnded ? i : i + 2;

    points.setAt(index, pt);
    norms.setAt(index, normPt);
  }
  //top
  if (!openEnded) {
    normPt.set(0, 1, 0);

    pt.set(0, 1 * halfHeight, radiusTop);
    points.setAt(heightSegments + 1 + 2, pt);
    norms.setAt(heightSegments + 1 + 2, normPt);

    pt.set(0, 1 * halfHeight, 0);
    points.setAt(heightSegments + 1 + 3, pt);
    norms.setAt(heightSegments + 1 + 3, normPt);
  }
  var latheSegments = radialSegments < 3 ? 3 : radialSegments;
  return (0, _CylinderLathe2.default)(points, norms, latheSegments, thetaStart, thetaLength, openEnded);
}

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _Exporter = __webpack_require__(458);

var _Exporter2 = _interopRequireDefault(_Exporter);

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ThreeExport = {
  NoIndices: 0,
  SimpleIndices: 1,
  CompactIndices: 2,

  exportBufferGeometry: function exportBufferGeometry(polyMesh, indicesMode, interleaved, exportTangents, oldMesh, prevTriangulation, prevIndexing, prevValueMap) {
    var result = new THREE.BufferGeometry(),
        exportSpec = [],
        _ThreeExport$_prepare = ThreeExport._prepare(polyMesh, exportSpec, indicesMode, interleaved, exportTangents, oldMesh, prevTriangulation, prevIndexing),
        exporter = _ThreeExport$_prepare.exporter,
        triangulationChanged = _ThreeExport$_prepare.triangulationChanged,
        IdPositions = _PolyMaps2.default.IdPositions,
        valueMap = {};


    if (indicesMode !== ThreeExport.NoIndices) {
      var indices = indicesMode === ThreeExport.SimpleIndices ? exporter.getTriangulatingIndices() : exporter.getMapIndices(IdPositions);

      result.setIndex(new THREE.BufferAttribute(indices, 1, false));
    }

    if (!interleaved) {
      for (var i = 0; i !== exportSpec.length; ++i) {
        //console.log(indicesMode);

        var attrSpec = exportSpec[i],
            triangulateValues = indicesMode === ThreeExport.NoIndices;

        var data;
        var newMap = _PolyMaps2.default.resolveMap(polyMesh, attrSpec.mapId),
            oldMap = oldMesh && _PolyMaps2.default.resolveMap(oldMesh, attrSpec.mapId);

        if (oldMap !== newMap || !prevValueMap) {
          data = indicesMode !== ThreeExport.CompactIndices ? exporter.getUnindexedMapValues(attrSpec.mapId, triangulateValues) : exporter.getMapValues(attrSpec.mapId);
        } else {
          //console.log('skip');
          data = prevValueMap[attrSpec.mapId];
        }

        valueMap[attrSpec.mapId] = data;
        result.addAttribute(attrSpec.threeName, new THREE.BufferAttribute(data, attrSpec.itemSize, attrSpec.normalized));
      }
    } else {
      var stride = 0;
      for (var i = 0; i !== exportSpec.length; ++i) {
        stride += exportSpec[i].itemSize;
      }var nValuess = 0;
      switch (indicesMode) {
        case ThreeExport.NoIndices:
          // no. of triangulated vertices
          nValuess = exporter.getNumFaceVertices();
          break;

        case ThreeExport.SimpleIndices:
          // no. of values
          nValuess = exporter.mesh.getNumFaceVertices();
          break;

        case ThreeExport.CompactIndices:
          // as calculated
          nValuess = exporter.getNumMapValues(_PolyMaps2.default.IdPositions);
      }

      var data = new Float32Array(stride * nValuess),
          buffer = new THREE.InterleavedBuffer(data, stride),
          offset = 0;

      for (var i = 0; i !== exportSpec.length; ++i) {
        var attrSpec = exportSpec[i],
            itemSize = attrSpec.itemSize,
            mapId = attrSpec.mapId;

        if (indicesMode !== ThreeExport.CompactIndices) {
          exporter.getUnindexedMapValues(mapId, indicesMode === ThreeExport.NoIndices, data, offset, stride);
        } else {
          exporter.getMapValues(mapId, data, offset, stride);
        }

        result.addAttribute(attrSpec.threeName, new THREE.InterleavedBufferAttribute(buffer, itemSize, offset));

        offset += itemSize;
      }
    }
    // add group to buffer geometry if there is materialId list in polymesh
    var groups = exporter.getGroups();
    if (polyMesh.materialIds && groups) {
      for (var i = 0; i < groups.groupCounts.length; i++) {
        if (groups.groupCounts[i] > 0) {
          result.addGroup(groups.groupStarts[i], groups.groupCounts[i], i);
        }
      }
    } else {
      // Since ThreeJS does not render Multimaterial geometry if it has no material id's, create
      // default group for all mesh positions to use material at index 0
      result.addGroup(0, exporter.triangulation.numTriangles * 3, 0);
    }
    return {
      geometry: result,
      triangulation: exporter.triangulation,
      renderIndexing: exporter.renderIndexing,
      triangulationChanged: triangulationChanged,
      valueMap: valueMap
    };
  },

  _prepare: function _prepare(polyMesh, outSpec, indicesMode, interleaved, exportTangents, oldMesh, prevTriangulation, prevIndexing) {
    var exporter = new _Exporter2.default(polyMesh),
        mapsToExport = [];

    var retriangulate = !oldMesh || !prevTriangulation || oldMesh.positions.faceValueIndices !== polyMesh.positions.faceValueIndices;
    var reIndex = !oldMesh || !prevIndexing;

    var mapOffset = 0;
    //console.log(polyMesh);
    for (var iter = new _PolyMaps2.default.Iterator(polyMesh); iter.next();) {
      var threeName = '',
          itemSize = 3,
          normalized = false;

      switch (iter.typeId) {
        case _PolyMaps2.default.TypePosition:
          threeName = 'position';
          break;

        case _PolyMaps2.default.TypeTangent:
          // Note: Since tangents are normally ignored by the three.js
          // renderer, they must be requested explicitly.
          if (!exportTangents) break;
          itemSize = 4;
          threeName = 'tangent';
          break;

        case _PolyMaps2.default.TypeNormal:
          threeName = 'normal';
          break;

        case _PolyMaps2.default.TypeUV:
          if (iter.index >= 2) break; // max two UV maps
          threeName = 'uv' + (iter.index !== 0 ? iter.index + 1 : '');
          itemSize = 2;
          break;

        case _PolyMaps2.default.TypeColor:
          if (iter.index >= 1) break; // use first color map
          threeName = 'color';
          normalized = true;
      }

      if (!threeName || interleaved && normalized) continue;

      var mapId = iter.getId();
      mapsToExport.push(mapId);

      outSpec.push({
        mapId: mapId,
        threeName: threeName,
        itemSize: itemSize,
        normalized: normalized
      });
      ++mapOffset;
    }

    for (var i = 0; i < outSpec.length && !reIndex; i++) {
      var oldMap = _PolyMaps2.default.resolveMap(oldMesh, outSpec[i].mapId),
          newMap = _PolyMaps2.default.resolveMap(polyMesh, outSpec[i].mapId);
      if (oldMap.faceValueIndices !== newMap.faceValueIndices) reIndex = true;
    }

    //console.log(polyMesh===(prevData && prevData.mesh));
    if (indicesMode === ThreeExport.CompactIndices && !reIndex) {
      prevIndexing.mesh = polyMesh;
      exporter.renderIndexing = prevIndexing;
    } else if (indicesMode === ThreeExport.CompactIndices && reIndex) {
      exporter.reindexForRendering(mapsToExport);
    }

    var triangulationChanged = false;
    if (retriangulate) {
      exporter.triangulate();
      triangulationChanged = true;
    } else {
      exporter.triangulation = prevTriangulation;
    }

    return { exporter: exporter, triangulationChanged: triangulationChanged };
  }
};

exports.default = ThreeExport;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAssetIdFromImage = getAssetIdFromImage;
exports.fetchTextureImage = fetchTextureImage;

var _assets = __webpack_require__(33);

var _actionTypes = __webpack_require__(58);

function getAssetIdFromImage(store, image, preferHDR) {
  var asset = image.asset,
      hdr = image.hdr;

  return preferHDR && image.preferHDR && hdr ? hdr : asset;
}

function fetchTextureImage(store, image, preferHDR) {
  var id = getAssetIdFromImage(store, image, preferHDR);

  var options = ['optimizeImage', 'resizeImage', 'resizeWidth', 'resizeHeight', 'optimizeFormat'].reduce(function (obj, key) {
    obj[key] = image[key];
    return obj;
  }, {});

  return id && (0, _assets.getOrFetchImage)(id, {}, options)(store);
}

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QUALITY_MODE = undefined;

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _values = __webpack_require__(130);

var _values2 = _interopRequireDefault(_values);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = threeTranslator;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _translator = __webpack_require__(480);

var _bingeom = __webpack_require__(162);

var _materials = __webpack_require__(464);

var _polyMesh = __webpack_require__(465);

var _light = __webpack_require__(462);

var _transform = __webpack_require__(479);

var _camera = __webpack_require__(126);

var _manipulators = __webpack_require__(463);

var _setMatrixOnNode = __webpack_require__(127);

var _setMatrixOnNode2 = _interopRequireDefault(_setMatrixOnNode);

var _annotation = __webpack_require__(461);

var _sceneIO = __webpack_require__(20);

var _sceneGraph = __webpack_require__(10);

var _scene = __webpack_require__(7);

var _player = __webpack_require__(8);

var _commands = __webpack_require__(43);

var _selection = __webpack_require__(45);

var _selectors = __webpack_require__(123);

var _calculateBoundingBox = __webpack_require__(252);

var _calculateBoundingBox2 = _interopRequireDefault(_calculateBoundingBox);

var _deviceTracking = __webpack_require__(481);

var _deviceTracking2 = _interopRequireDefault(_deviceTracking);

var _ThreeExport = __webpack_require__(242);

var _ThreeExport2 = _interopRequireDefault(_ThreeExport);

var _runtimeInfo = __webpack_require__(56);

var _runtimeInfo2 = _interopRequireDefault(_runtimeInfo);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isMobile = _runtimeInfo2.default.isMobile;


var BACKGROUND_STYLE_DEFAULT = 0;
var BACKGROUND_STYLE_COLOR = 1;
var BACKGROUND_STYLE_IMAGE = 2;
var BACKGROUND_STYLE_CUBEMAP = 3;
var BACKGROUND_STYLE_ENVIRONMENT = 4;

var QUALITY_MODE = exports.QUALITY_MODE = {
  LOW: 'LOW',
  HIGH: 'HIGH'
};

function initTranslator(store, context, translator) {
  var sceneGraph = store.get('sceneGraph');

  var scene = new THREE.Scene();
  //const camera = new THREE.PerspectiveCamera(75, 4 / 3, 0.1, 1000);
  var camera = new THREE.CombinedCamera(1, 1, 75, 0.1, 1000);
  scene.add(camera);

  var defaultLight = new THREE.DirectionalLight(0xffffff, 1.0);
  camera.add(defaultLight);

  var rendererAttrs = {
    antialias: false,
    precision: 'highp',
    alpha: true,
    preserveDrawingBuffer: true
  };

  if (context) {
    rendererAttrs.canvas = { style: {}, addEventListener: function addEventListener() {} };
    rendererAttrs.context = context;
  }

  var renderer = new THREE.WebGLRenderer(rendererAttrs);
  renderer.setClearColor(0xffffff);
  renderer.autoResizeTextures = false;
  renderer.gammaInput = true;
  renderer.gammaOutput = true;
  renderer.toneMapping = THREE.ReinhardToneMapping;
  renderer.physicallyCorrectLights = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.BasicShadowMap;
  var pixelRatio =  true ? window.devicePixelRatio : 1;
  renderer.setPixelRatio(pixelRatio);
  renderer.isMobile = isMobile;

  var el = null;
  var playerEl = null; // This is the parent element that we control (div.claraplayer)

  var nodes = {};
  var translated = {
    // [ nodeId ]: { [PlugName]: _v }
  };
  var annotations = {};
  var rect = new THREE.Vector2(400, 300);
  var tools = [];
  var interactionHandler = null;
  var cameraId = _sceneGraph.virtualCameraId; // The camera we want to move
  var fromCameraId = _sceneGraph.virtualCameraId; // The camera we want to use to initialize camera position
  var translatedCameraId = null; // The camera that we initialized from
  var pivotId = null;
  var loaded = false;
  var reflectiveFloorMaterial = null;
  var reflectiveFloorMesh = null;
  var hasLight = false;
  var toneMapping = renderer.toneMapping;

  var trackingHandler = void 0;
  var externals = (0, _assign2.default)({}, _runtimeInfo2.default);
  var textureCache = {};
  var translatorState = {};

  function getContext() {
    return renderer.getContext();
  }

  // use ssaa on the server
  var serverRenderingMode = !!context;
  var renderQuality = void 0;

  var composer = new THREE.EffectComposer(renderer, true);

  var clearPass = new THREE.ClearPass();
  clearPass.enabled = true;
  clearPass.cameraAware = true;
  composer.addPass(clearPass);

  var texturePass = new THREE.TexturePass();
  texturePass.clear = false;
  texturePass.enabled = false;
  texturePass.cameraAware = true;
  composer.addPass(texturePass);

  var cubeTexturePass = new THREE.CubeTexturePass(scene, camera);
  cubeTexturePass.clear = false;
  cubeTexturePass.enabled = false;
  cubeTexturePass.cameraAware = true;
  composer.addPass(cubeTexturePass);

  var ssaaRenderPass = new THREE.SSAARenderPass(scene, camera);
  ssaaRenderPass.clear = false;

  ssaaRenderPass.unbiased = true;
  ssaaRenderPass.sampleRenderTarget = composer.requestBuffer('temp');
  ssaaRenderPass.enabled = serverRenderingMode;
  ssaaRenderPass.cameraAware = true;
  composer.addPass(ssaaRenderPass);

  var renderPass = new THREE.RenderPass(scene, camera); //, null, 0xffffff);
  renderPass.clear = false;
  renderPass.renderOver = true;
  renderPass.enabled = !serverRenderingMode;
  renderPass.cameraAware = true;
  composer.addPass(renderPass);

  var oitRenderPass = new THREE.OITRenderPass(scene, camera, renderer, null, 0xfffffff);
  oitRenderPass.clear = false;
  oitRenderPass.enabled = false;
  oitRenderPass.cameraAware = true;
  composer.addPass(oitRenderPass);
  var renderPassType = 'renderPass';

  var saoPass = new THREE.SAOPass(scene, camera);
  saoPass.downSamplingRatio = serverRenderingMode ? 1 : 1; // fast enough if not full screen (I think.)
  saoPass.intensity = 3;
  saoPass.occlusionSphereWorldRadius = 2;
  saoPass.blurEnabled = true;
  saoPass.outputOverride = 'default';
  saoPass.manualCompositing = false;
  saoPass.blurKernelSize = (saoPass.downSamplingRatio === 1 ? 6 : 6) + (serverRenderingMode ? 2 : 0);
  saoPass.enabled = false;
  saoPass.cameraAware = true;
  if (!isMobile) {
    composer.addPass(saoPass);
  }

  var width = 256;
  var height = 256;

  var dofPass = new THREE.DofPass(new THREE.Vector2(width, height), scene, camera);
  dofPass.enabled = false;
  dofPass.cameraAware = true;
  composer.addPass(dofPass);

  var bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 1, 1);
  bloomPass.enabled = false;
  bloomPass.cameraAware = true;
  composer.addPass(bloomPass);

  var sparklePass = new THREE.SparklePass(camera, renderer, null, null);
  sparklePass.enabled = false; // disable it until there's at least one sparkle added to it
  sparklePass.cameraAware = true;
  composer.addPass(sparklePass);

  var outlinePass = new THREE.OutlinePass(new THREE.Vector2(width, height), scene, camera);
  outlinePass.edgeStrength = 10;
  outlinePass.edgeGlow = 0;
  outlinePass.edgeThickness = 1;
  outlinePass.pulsePeriod = 0;
  outlinePass.visibleEdgeColor = new THREE.Color(0, 1, 0);
  outlinePass.hiddenEdgeColor = new THREE.Color(0, 1, 0);
  outlinePass.enabled = false;
  outlinePass.cameraAware = true;
  composer.addPass(outlinePass);

  var indexPass = new THREE.IndexPass(scene, camera, 'nodeId');
  indexPass.enabled = false;
  composer.addPass(indexPass);

  var effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
  effectFXAA.uniforms['resolution'].value.set(1 / width, 1 / height);
  effectFXAA.enabled = !serverRenderingMode;
  effectFXAA.cameraAware = true;
  composer.addPass(effectFXAA);

  var copyPass = new THREE.ShaderPass(THREE.CopyShader);
  copyPass.renderToScreen = true;
  copyPass.cameraAware = true;
  composer.addPass(copyPass);

  var parallaxBarrierEffect = new THREE.ParallaxBarrierEffect(renderer);
  parallaxBarrierEffect.setSize(width, height);
  //if(__BROWSER__ && window.editor)initHelpers();

  var effectStatus = {
    saoPass: false,
    dofPass: false,
    bloomPass: false,
    reflectiveFloorMesh: false
  };

  store.dispatch((0, _player.setThree)({ scene: scene, camera: camera, renderer: renderer, THREE: THREE, composer: composer }));

  function resize(width, height) {
    var renderingMode = (0, _player.getRenderingMode)(store);

    if (true) pixelRatio = window.devicePixelRatio;
    if (el && renderingMode !== _player.RENDER_MODES.vr) {
      var elRect = el.parentNode.getBoundingClientRect();
      width = elRect.width;
      height = elRect.height;
      renderer.setPixelRatio(pixelRatio);
    } else if (renderingMode === _player.RENDER_MODES.vr) {
      width = window.innerWidth;
      height = window.innerHeight;
      externals.vrEffect.setSize(width, height);
    }
    if (renderingMode === _player.RENDER_MODES.lenticular) {
      parallaxBarrierEffect.setSize(width, height);
    }
    if (width < 10 || height < 10) return;

    rect.set(width, height);

    if (renderingMode !== _player.RENDER_MODES.vr) {
      (0, _camera.resizeCamera)(store, cameraId, rect);
      renderer.setSize(rect.width, rect.height);
    }

    if (reflectiveFloorMaterial !== null) {
      reflectiveFloorMaterial.setSize(rect.width, rect.height);
    }

    composer.setSize(rect.width * pixelRatio, rect.height * pixelRatio);

    /*console.log( 'pixelDeviceRatio', pixelRatio );
    console.log( 'renderer size', rect.width, rect.height );
    console.log( 'composer size', rect.width * pixelRatio, rect.height * pixelRatio );
    console.log( 'pixel size', rect.width * window.devicePixelRatio, rect.height * window.devicePixelRatio );*/

    if (interactionHandler) interactionHandler.resize(rect);

    if (height && height !== 0) {
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    effectFXAA.uniforms['resolution'].value.set(1 / (rect.width * pixelRatio), 1 / (rect.height * pixelRatio));
  }

  /*
   * Attach the renderer's canvas element to the DOM?.
   */
  function attach(element) {
    if (el === element) return;

    el = element;
    el.insertBefore(renderer.domElement, el.firstChild);
    renderer.domElement.tabIndex = 1;

    playerEl = el.parentElement;
    store.dispatch((0, _player.setPlayerElement)(playerEl, renderer.domElement));
    resize();
  }

  function deviceTrackingTransition(enabled) {
    if (enabled) {
      trackingHandler = (0, _deviceTracking2.default)(store, externals);
    } else {
      if (true) window.removeEventListener('deviceorientation', trackingHandler);
      trackingHandler = null;
    }
  }

  function handleStateChanges() {
    // TODO: only do this if the player has changed. Requires moving the cameraWorldMatrix
    // out of the player state.
    //

    function stateChange(key, handler) {
      var newState = store.getIn(['player', key]);
      if (translatorState[key] !== newState) {
        handler(newState, translatorState[key]);
        translatorState[key] = newState;
      }
    }

    if (true) stateChange('deviceTracking', deviceTrackingTransition);
  }

  /*
   * After all nodes have been translated.
   */
  var renderDisplaySceneTimeout = null;
  var lastRenderStartTime = -1;
  var lastRenderDeltaTime = -1;

  function updateRenderTime() {
    var currentRenderStartTime = Date.now();
    if (lastRenderStartTime > 0) {
      lastRenderDeltaTime = currentRenderStartTime - lastRenderStartTime;
    } else {
      lastRenderDeltaTime = -1;
    }

    lastRenderStartTime = currentRenderStartTime;
  }

  function renderQualityControl(renderQuality) {
    if (reflectiveFloorMesh) if (indexPass.enabled) scene.remove(reflectiveFloorMesh);else scene.add(reflectiveFloorMesh);
    if (renderQuality === QUALITY_MODE.HIGH) {
      ssaaRenderPass.enabled = true;
      effectFXAA.enabled = false;
      renderPass.enabled = false;
      oitRenderPass.enabled = false;
      saoPass.enabled = effectStatus.saoPass;
      dofPass.enabled = effectStatus.dofPass;
      bloomPass.enabled = effectStatus.bloomPass;
    } else {
      ssaaRenderPass.enabled = false;
      effectFXAA.enabled = true;
      if (renderPassType === 'oitRenderPass' && oitRenderPass.isSupport(renderer) && !isMobile) {
        oitRenderPass.enabled = true;
        renderPass.enabled = false;
      } else {
        oitRenderPass.enabled = false;
        renderPass.enabled = true;
      }
      saoPass.enabled = effectStatus.saoPass;
      if (isMobile) {
        saoPass.enabled = false;
        dofPass.enabled = false;
        bloomPass.enabled = false;
        if (reflectiveFloorMesh) reflectiveFloorMesh.visible = false;
      }
    }
  }

  function postTranslate() {
    var renderingMode = (0, _player.getRenderingMode)(store);
    if (renderDisplaySceneTimeout) {
      clearTimeout(renderDisplaySceneTimeout);
    }

    updateRenderTime();

    var playerCameraId = (0, _player.getCamera)(store);
    // If we are switching the threejs camera, it should already be initialized
    // (from VR controls, or previous camera, so just directly translate it)
    if (cameraId !== playerCameraId) {
      cameraId = playerCameraId;
      fromCameraId = cameraId;
      translatedCameraId = cameraId;
      centerVirtualTarget();

      translate(cameraId, sceneGraph.evaluatedNodes[cameraId], sceneGraph.nodes[cameraId], true);
    }

    if (fromCameraId !== translatedCameraId) {
      // Translate the new camera
      translate(cameraId, sceneGraph.evaluatedNodes[cameraId], sceneGraph.nodes[cameraId], true);
    }

    defaultLight.visible = !hasLight;

    handleStateChanges();

    //if (__BROWSER__ && window.editor) updateHelpers();

    if (interactionHandler) {
      updateTools();
      updateWidgets();
      interactionHandler.frameUpdate(renderingMode);
    }

    var highlighters = (0, _selection.getHighlighters)(store);
    if (highlighters.size) {
      highlighters.forEach(function (highlighter) {
        outlinePass.visibleEdgeColor = highlighter.color;
        outlinePass.hiddenEdgeColor = highlighter.color;
        outlinePass.edgeThickness = highlighter.thickness;
        outlinePass.enabled = true;
        outlinePass.selectedObjects = highlighter.selectedIds.map(function (id) {
          return nodes[id];
        }).filter(function (node) {
          return !!node;
        });
      });
    } else {
      outlinePass.enabled = false;
      outlinePass.selectedObjects = [];
    }

    if (reflectiveFloorMesh && reflectiveFloorMesh.data.reflectiveFloor && !isMobile) {
      reflectiveFloorMaterial.distanceFade = reflectiveFloorMesh.data.reflectiveFloorFade;
      reflectiveFloorMaterial.roughness = reflectiveFloorMesh.data.reflectiveFloorRoughness;
      reflectiveFloorMaterial.metalness = reflectiveFloorMesh.data.reflectiveFloorMetallic;
      reflectiveFloorMaterial.opacity = reflectiveFloorMesh.data.reflectiveFloorOpacity;
      reflectiveFloorMaterial.fresnelStrength = reflectiveFloorMesh.data.reflectiveFloorFresnel;
      reflectiveFloorMaterial.reflectivity = 0.5;

      renderer.setClearColor(renderPass.clearColor, renderPass.clearAlpha);
      reflectiveFloorMaterial.render(renderer, scene, camera, rect.width, rect.height);

      //reflectiveFloorMesh.material = new THREE.MeshStandardMaterial({ emissive: 0xff00ff, emissiveMap: reflectiveFloorMaterial.material.uniforms.tReflection.value });
    }
    //renderer.setClearColor(renderPass.clearColor, renderPass.clearAlpha);

    cubeTexturePass.camera = camera;
    if (renderingMode === _player.RENDER_MODES.normal) {
      renderer.setClearColor(0xffffff);
      if (serverRenderingMode) renderQuality = QUALITY_MODE.HIGH;else renderQuality = QUALITY_MODE.LOW;

      renderQualityControl(renderQuality);

      //renderer.setClearAlpha(0.9);
      if (false) console.log('Passes', 'sao', saoPass.enabled, 'effectFXAA', effectFXAA.enabled, 'ssaa', ssaaRenderPass.enabled, 'render', renderPass.enabled, 'oitRender', oitRenderPass.enabled);
      composer.render();
    } else if (renderingMode === _player.RENDER_MODES.vr) {
      renderQuality = QUALITY_MODE.LOW;
      renderQualityControl(renderQuality);
      saoPass.enabled = false; // DISABLE SAO IN VR
      renderPass.enabled = true;
      oitRenderPass.enabled = false;
      if (!externals.vrEffect) {
        throw new Error('Expect vr mode to initialize vrEffect');
      }
      //externals.vrEffect.render(scene, camera, null, true);
      composer.vrRender(externals.vrEffect, scene, camera, true);
    } else if (renderingMode === _player.RENDER_MODES.lenticular) {
      parallaxBarrierEffect.render(scene, camera);
    }

    if (renderingMode === _player.RENDER_MODES.normal) {
      if (!serverRenderingMode || lastRenderDeltaTime > 0) {
        renderDisplaySceneTimeout = setTimeout(function () {
          updateRenderTime();

          ssaaRenderPass.sampleLevel = 2;
          renderQuality = QUALITY_MODE.HIGH;
          renderQualityControl(renderQuality);
          composer.render();
          ssaaRenderPass.sampleLevel = 1;
          renderQuality = QUALITY_MODE.LOW;
          renderQualityControl(renderQuality);

          lastRenderStartTime = -1;
          /*
           renderDisplaySceneTimeout = setTimeout(function () {
             updateRenderTime();
             ssaaRenderPass.sampleLevel = 3;
            composer.render();
            ssaaRenderPass.sampleLevel = 1;
          }, Math.max(lastRenderDeltaTime, 100) * 4);*/
        }, Math.max(lastRenderDeltaTime, 100) * 4);
      }
    }
  }

  function updateTools() {
    var commands = (0, _commands.getCommands)(store);
    if (tools !== (0, _commands.getTools)(store)) {
      tools = (0, _commands.getTools)(store);
      interactionHandler.updateTools(tools.map(function (n) {
        return commands[n];
      }).toArray());
    }
  }

  function initHelpers() {
    nodes.helpers = {};
  }

  function updateHelpers() {
    (0, _keys2.default)(nodes.helpers).forEach(function (name) {
      var helper = nodes.helpers[name];
      if (helper.isHelper || helper instanceof THREE.CameraHelper) helper.update();
    });
  }

  function initWidgets(command, name, rootName) {
    nodes[rootName] = new THREE.Object3D();
    nodes[rootName].name = name;
    nodes.widgets.add(nodes[rootName]);
    if (command.options.displayGizmo !== false) command.widget.draw.call(command, nodes[rootName]);
  }

  function removeWidgets(command, threeObject, name, rootName) {
    var widget = command.widget;
    if (widget && widget.remove) {
      widget.remove.call(command, threeObject);
    }

    nodes.widgets.remove(threeObject);
    delete nodes[rootName];
  }

  function updateWidgets() {
    var commands = (0, _commands.getCommands)(store);
    var activeCommandsWithWidgets = (0, _commands.getActiveCommandsWithWidgets)(store);

    nodes.widgets.children.forEach(function (child) {
      if (!activeCommandsWithWidgets[child.name]) {
        removeWidgets(commands[child.name], child, child.name, 'widgetsRoot-' + child.name);
      }
    });

    (0, _values2.default)(activeCommandsWithWidgets).forEach(function (command) {
      var name = command.name,
          widget = command.widget;

      var rootName = 'widgetsRoot-' + name;
      if (!nodes[rootName]) initWidgets(command, name, rootName);
      if (widget && widget.position) widget.position.call(command, nodes[rootName]);
    });
  }

  function centerVirtualTarget() {
    (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualTargetId, (0, _scene.getWorldTransform)(store, _sceneGraph.virtualPivotId));
  }

  function centerVirtualPivot() {
    var playerData = sceneGraph.evaluatedNodes[(0, _sceneIO.getSceneId)(store)].Player;
    var cameraData = sceneGraph.evaluatedNodes[(0, _player.getCamera)(store)].Properties;

    if (!playerData.orbitTarget && !cameraData.orbitTarget) {
      var bbCenter = (0, _calculateBoundingBox2.default)(scene).getCenter();
      if (isNaN(bbCenter.x) || isNaN(bbCenter.y) || isNaN(bbCenter.z)) bbCenter.set(0, 0, 0);
      (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualPivotId, new THREE.Matrix4().makeTranslation(bbCenter.x, bbCenter.y, bbCenter.z));
    }
  }

  /*
   * Scene is loaded.
   */
  function onLoad() {
    if (true && !playerEl) return false;
    loaded = true;

    centerVirtualPivot();
    centerVirtualTarget();

    if (!context) {
      interactionHandler = (0, _manipulators.initManipulators)(store, this, renderer.domElement);
      interactionHandler.resize(rect);
    }

    nodes.widgets = new THREE.Object3D();
    nodes.widgets.name = 'Widgets';
    scene.add(nodes.widgets);
    scene.nodeId = (0, _sceneIO.getSceneId)(store);

    //init auto shadow after all nodes loaded
    (0, _light.initAutoShadow)(scene);
    return true;
  }
  /*
   * create and assign basic color material to mesh object by index(uuid).
   */
  function indexRender(enabled) {
    renderer.toneMapping = enabled ? THREE.NoToneMapping : toneMapping;
    renderer.gammaInput = !enabled;
    renderer.gammaOutput = !enabled;
    renderer.autoClear = !enabled;
    indexPass.enabled = enabled;
    indexPass.switchMaterial();
    postTranslate();
  }

  function getAnnotations() {
    return annotations;
  }

  function addToParent(id, node, obj) {
    // console.log('Add toParent: ', node && node.get('parent'), obj);
    var parentId = node && node.parent;
    var parent = parentId && nodes[parentId] || scene;
    obj.name = node.name; // eslint-disable-line no-param-reassign
    obj.nodeId = id;

    var prevObj = nodes[id];

    if (prevObj) {
      var children = [].concat(prevObj.children);
      for (var i = 0; i < children.length; i++) {
        prevObj.remove(children[i]);
        obj.add(children[i]);
      }

      // remove from old parent, if it had one
      var oldParent = prevObj.parent && nodes[prevObj.parent.nodeId] || prevObj.parent && prevObj.parent.nodeId === (0, _sceneIO.getSceneId)(store) && scene;

      if (oldParent) {
        oldParent.remove(prevObj);
      }
      if (prevObj.geometry) prevObj.geometry.dispose();
    }

    nodes[id] = obj;
    parent.add(nodes[id]);
    /* Debugging light and shadow
    if (__BROWSER__ && window.editor && obj.type === "DirectionalLight") {
      if (obj.lightHelper) parent.add(obj.lightHelper);
    }
    */
  }

  var plugs = {
    PolyMesh: function PolyMesh(id, data, node, properties) {
      var castShadow = properties.castShadow,
          receiveShadow = properties.receiveShadow,
          discardable = properties.discardable,
          visible = properties.visible,
          doubleSided = properties.doubleSided;
      var mesh = data.mesh,
          previousMesh = data.previousMesh;

      //const collapseMaps = true;

      var indexingMode = renderer.extensions.get('OES_element_index_uint') ? _ThreeExport2.default.CompactIndices : _ThreeExport2.default.NoIndices;
      var interleaved = false;
      var oldMesh = nodes[id];
      var prevTriangulation = oldMesh && oldMesh.userData.triangulation;
      var prevIndexing = oldMesh && oldMesh.userData.renderIndexing;
      var prevValueMap = oldMesh && oldMesh.userData.valueMap;

      var bufferInfo = mesh && _ThreeExport2.default.exportBufferGeometry(mesh, indexingMode, interleaved, mesh.tangentMap, previousMesh, prevTriangulation, prevIndexing, prevValueMap);

      var geometry = void 0,
          triangulation = void 0,
          triangulationChanged = void 0,
          renderIndexing = void 0,
          valueMap = void 0;
      if (bufferInfo) {
        geometry = bufferInfo.geometry;
        triangulation = bufferInfo.triangulation;
        triangulationChanged = bufferInfo.triangulationChanged;
        renderIndexing = bufferInfo.renderIndexing;
        valueMap = bufferInfo.valueMap;
      }

      var obj = void 0;

      if (triangulationChanged || !oldMesh) {
        obj = geometry && new THREE.Mesh(geometry, (0, _materials.primitiveToMaterial)(store));
      } else {
        obj = oldMesh;
        if (geometry) {
          obj.geometry.dispose();
          obj.geometry = geometry;
        }
        //obj.material.dispose();
        //obj.material = primitiveToMaterial(store);
      }

      if (geometry && discardable) {
        (0, _keys2.default)(geometry.attributes).forEach(function (attrName) {
          geometry.attributes[attrName].onUploadCallback = function () {
            this.array = null;
          };
        });
      }

      if (discardable) {
        data.mesh = null;
        data.previousMesh = null;
      }

      if (obj) {
        obj.castShadow = castShadow;
        obj.receiveShadow = receiveShadow;
        obj.visible = visible;
        if (!discardable) obj.userData.triangulation = triangulation;
        if (!discardable) obj.userData.renderIndexing = renderIndexing;
        if (!discardable) obj.userData.valueMap = valueMap;
        obj.material.side = doubleSided ? THREE.DoubleSide : THREE.FrontSide;
      }

      addToParent(id, node, obj || new THREE.Object3D());
    },

    Light: function Light(id, data, node, properties) {
      var obj = nodes[id];
      if (!obj) {
        obj = (0, _light.createLight)(data, scene, properties.visible); //, nodes.helpers); //Pass helpers only for debugging.
        hasLight = true;
        if (obj) {
          addToParent(id, node, obj);
        }
      } else {
        var objectsRoot = scene.getObjectByName('Objects');
        (0, _light.updateLight)(data, obj, objectsRoot);
      }
      /* Debug light and shadow
      if (__BROWSER__ && window.editor) {
        if (obj.lightHelper) obj.lightHelper.visible = obj.visible;
        if (obj.shadowHelper) obj.shadowHelper.visible = obj.visible && obj.castShadow && data.showShadowCamera;
      }
      */
    },

    Bone: function Bone(id, data, node) {
      addToParent(id, node, new THREE.Object3D());
    },

    Null: function Null(id, data, node, properties) {
      addToParent(id, node, new THREE.Object3D());
    },

    PrefetchMaterialNull: function PrefetchMaterialNull(id, data, node, properties) {
      if (loaded && properties.prefetch && !nodes[id]) {
        //console.log('Add a node for prefetch of material: ', node.name);
        addToParent(id, node, new THREE.Object3D());
      }
    },

    Properties: function Properties(id, data) {
      if (nodes[id] && data) nodes[id].visible = data.visible;
    },

    Transform: function Transform(id, data, node) {
      if (!data || !data.transform) return;
      if (nodes[id]) (0, _transform.setMatrixOn)(nodes[id], data.transform);
    },

    Material: function Material(id, data) {
      if (!nodes[id]) return;
      nodes[id].material = (0, _materials.primitiveToMaterial)(store, renderer, data, nodes[id].material, {
        sparklePass: sparklePass,
        nodeInfo: nodes[id]
      });
    },

    Image: function Image(id, data, node, properties) {
      if (loaded && properties.prefetch) (0, _materials.getTextureImage)(store, data);
    },

    Environment: function Environment(id, data) {
      var backgroundStyle = data.backgroundStyle;
      clearPass.enabled = false;
      cubeTexturePass.enabled = false;
      if (data.environmentMap) hasLight = true;

      switch (backgroundStyle) {
        case BACKGROUND_STYLE_COLOR:
          clearPass.enabled = true;
          clearPass.clearColor = data.backgroundColor;
          clearPass.clearAlpha = data.backgroundOpacity;
          break;
        case BACKGROUND_STYLE_IMAGE:
          texturePass.enabled = true;
          texturePass.map = (0, _materials.assignTexture)(store, renderer, data.background);
          break;
        case BACKGROUND_STYLE_CUBEMAP:
        case BACKGROUND_STYLE_ENVIRONMENT:
          {
            clearPass.enabled = true;
            clearPass.clearColor = 0x000000;
            clearPass.clearAlpha = 0.0;

            cubeTexturePass.enabled = true;

            var cubeMapNode = void 0;
            var cubeMapBlurring = void 0;

            if (backgroundStyle === BACKGROUND_STYLE_ENVIRONMENT) {
              cubeMapNode = data.environmentMap;
              if (cubeMapNode) {
                cubeMapNode = cubeMapNode.specularCubeMap;
              }

              cubeMapBlurring = data.environmentMapBlurring;
            } else {
              cubeMapNode = data.cubeMap;
              cubeMapBlurring = data.cubeMapBlurring;
            }

            if (cubeMapNode) {
              cubeTexturePass.envMap = (0, _materials.getCubeMapTexture)(store, renderer, cubeMapNode, true, true);
              cubeTexturePass.envMapIntensity = 1.0;
              cubeTexturePass.opacity = data.backgroundOpacity;
              cubeTexturePass.roughness = data.cubeMapBlurring;
            } else {
              cubeTexturePass.enabled = false;
            }
          }

          break;

        default:
          clearPass.enabled = true;
          clearPass.clearColor = new THREE.Color(1, 1, 1);
          clearPass.clearAlpha = 0;
          break;
      }
    },

    Player: function Player(id, data, node) {
      if (data.camera && data.camera !== fromCameraId && sceneGraph.nodes[data.camera]) {
        var fromNode = sceneGraph.nodes[data.camera];
        var cameraNode = sceneGraph.nodes[cameraId];
        var copiedNode = (0, _sceneGraph.initNode)(fromNode);
        var target = copiedNode.plugs.Transform.find(function (op) {
          return op.target;
        });
        if (target) copiedNode.plugs.Camera[0].targeted = true;
        store.dispatch((0, _sceneGraph.replace)(cameraId, (0, _assign2.default)(cameraNode, { plugs: copiedNode.plugs })));
        fromCameraId = data.camera;
      }

      if (data.overrideNavigation && data.orbitTarget && data.orbitTarget !== pivotId) {
        pivotId = data.orbitTarget;
        // FIXME: remove scale here?
        (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualPivotId, (0, _scene.getWorldTransform)(store, pivotId));
      } else if (data.overrideNavigation && !data.orbitTarget && data.orbitTarget !== pivotId) {
        pivotId = null;
        centerVirtualPivot();
      }

      var renderPassTypes = {
        0: 'renderPass',
        1: 'oitRenderPass'
      };
      renderPassType = renderPassTypes[data.renderPassType];

      var styleToToneMapping = {
        Linear: THREE.LinearToneMapping,
        Reinhard: THREE.ReinhardToneMapping,
        Cineon: THREE.CineonToneMapping,
        Filmic: THREE.Uncharted2ToneMapping
      };

      var styleToShadowMap = {
        /*
         * Right now keep the old string shadow type to make the old
         * data available, should be removed in the future.
         */
        Basic: THREE.BasicShadowMap,
        PCF: THREE.PCFShadowMap,
        PCFSoft: THREE.PCFSoftShadowMap,
        PCSSSoft: THREE.PCSSSoftShadowMap,

        0: THREE.BasicShadowMap,
        1: THREE.PCFShadowMap,
        2: THREE.PCFSoftShadowMap,
        3: THREE.PCSSSoftShadowMap
      };
      toneMapping = styleToToneMapping[data.toneMapStyle];
      renderer.toneMapping = styleToToneMapping[data.toneMapStyle];
      renderer.toneMappingExposure = data.toneMapExposureGain;
      renderer.toneMappingWhitePoint = data.toneMapWhitePoint;
      renderer.gammaInput = true;
      renderer.gammaOutput = true;
      renderer.autoClear = false;
      renderer.shadowMap.type = (isMobile ? styleToShadowMap[0] : styleToShadowMap[data.shadowType]) || styleToShadowMap[0];

      saoPass.enabled = data.saoPass;
      saoPass.intensity = data.saoIntensity;
      saoPass.occlusionSphereWorldRadius = data.saoScale;
      effectStatus.saoPass = data.saoPass;

      bloomPass.enabled = data.bloomPass;
      bloomPass.threshold = data.bloomThreshold;
      //bloomPass.smoothWidth = data.bloomBlendRange;//not exposed in three.js yet
      effectStatus.bloomPass = data.bloomPass;

      if (data.sparkleTexture) {
        // set the sparkle texture if there's one
        sparklePass.setSparkleTexture((0, _materials.assignTexture)(store, renderer, data.sparkleTexture));
        sparklePass.setWorldSizeOfSparkles(data.sparkleSize);
      }

      dofPass.enabled = data.dofPass;
      //dofPass.dofMaxBlur = data.dofMaxBlur; //not exposed in three.js yet
      effectStatus.dofPass = data.dofPass;

      /**********************Mirror*************************************************/
      if (data.reflectiveFloor && (!data.reflectiveFloorExcludeServer || true) && !isMobile) {
        if (!reflectiveFloorMaterial) {
          var mirrorGeo = new THREE.PlaneBufferGeometry(1, 1);
          reflectiveFloorMaterial = new THREE.GlossyMirror({
            clipBias: 0.003,
            textureWidth: 1024,
            textureHeight: 1024,
            color: 0x777777,
            localMirrorNormal: new THREE.Vector3(0, 1, 0)
          });
          reflectiveFloorMesh = new THREE.Mesh(mirrorGeo, reflectiveFloorMaterial.material);
        }

        reflectiveFloorMaterial.specularColor = new THREE.Color(0xffffff);

        reflectiveFloorMesh.scale.x = data.reflectiveFloorWidth;
        reflectiveFloorMesh.scale.y = data.reflectiveFloorWidth;
        reflectiveFloorMesh.rotation.x = -Math.PI * 0.5;
        reflectiveFloorMesh.position.y = data.reflectiveFloorHeight;

        reflectiveFloorMesh.data = data;
        if (!reflectiveFloorMesh.parent) {
          scene.add(reflectiveFloorMesh);
        }
        effectStatus.reflectiveFloorMesh = true;
      } else {
        if (reflectiveFloorMesh && reflectiveFloorMesh.parent) {
          reflectiveFloorMesh.visible = false;
        }
      }
    },

    Camera: function Camera(id, data, node, properties) {
      if (id === cameraId && loaded) {
        var cameraOverride = sceneGraph.evaluatedNodes[(0, _sceneIO.getSceneId)(store)].Player.overrideNavigation;
        if (!cameraOverride && properties.orbitTarget && properties.orbitTarget !== pivotId) {
          pivotId = properties.orbitTarget;
          // FIXME: remove scale here?
          (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualPivotId, (0, _scene.getWorldTransform)(store, pivotId));
        }

        camera.aspect = data.aspectRatio;
        camera.near = data.nearClip;
        camera.far = data.farClip;
        if (data.projection === 'Orthographic') {
          //disable passes and mirror at this point
          saoPass.enabled = false;
          ssaaRenderPass.enabled = true;
          dofPass.enabled = false;
          if (reflectiveFloorMesh) reflectiveFloorMesh.visible = false;

          camera.zoom = 1 / data.orthoZoom;
          camera.hyperfocusOffset = 1;
          camera.hyperfocusScale = 0;
          camera.inPerspectiveMode = false;
          camera.inOrthographicMode = true;

          // incase of hyperfocusOffset not equals to 1 and hyperfocusScale not equals to 0
          // const d = camera.hyperfocusOffset + camera.hyperfocusScale * (camera.near + camera.far);
          // camera.fov = Math.atan(data.orthoHeight / 2 / d) * 360 / Math.PI;

          camera.fov = Math.atan(data.orthoHeight / 2) * 360 / Math.PI;

          // Set flags for ThreeJS camera type recognition
          camera.isOrthographicCamera = true;
          camera.isPerspectiveCamera = false;
        } else {
          // Set flags for ThreeJS camera type recognition
          camera.isOrthographicCamera = false;
          camera.isPerspectiveCamera = true;

          camera.inPerspectiveMode = true;
          camera.inOrthographicMode = false;

          camera.fov = data.fieldOfView;

          dofPass.focalDistance = data.focalDepthEnabled ? data.focalDepth : data.targetDistance;
        }

        if (properties.constrainCameraSphere && (!data.radiusConstraint || properties.maxZoom !== data.radiusConstraint.outerRadius) && data.upPosition) {
          (0, _camera.initCameraRadiusConstraint)(store, id, data, properties.maxZoom);
        }

        camera.updateProjectionMatrix();
      }
    },

    CameraTransform: function CameraTransform(id, data, node, Properties, nodeData) {
      if (id === cameraId && loaded) {
        var newCamMatix = void 0;
        if (translatedCameraId !== fromCameraId || !nodeData.Camera.upPosition || nodeData.Camera.newAngleAttrs) {
          centerVirtualPivot();
          centerVirtualTarget();

          var cameraParams = (0, _camera.initCamera)(store, true, fromCameraId, id, rect);
          newCamMatix = cameraParams.camera;
          if (cameraParams.newNear) camera.near = cameraParams.newNear;
          if (cameraParams.newFar) camera.far = cameraParams.newFar;
          translatedCameraId = fromCameraId;

          delete nodeData.Camera.newAngleAttrs;
        }

        var cameraData = nodeData.Camera;
        var renderingMode = (0, _player.getRenderingMode)(store);
        var matrix = data.target && cameraData.targeted && cameraData.upPosition && renderingMode !== _player.RENDER_MODES.vr && !translatorState['deviceTracking'] ? (0, _camera.updateLookatTarget)(store, id, data, cameraData) : data.transform;
        (0, _transform.setMatrixOn)(camera, newCamMatix || matrix);
      }
    },

    Annotation: function Annotation(id, data, node, properties) {
      var calcDirection = data.directionMode === 'awayFromOrigin';
      annotations[id] = {
        id: id,
        annotation: data,
        position: (0, _annotation.getScreenPositionNormalAlpha)(id, calcDirection, data.directionAxis, data.directionTarget),
        visible: properties.visible
      };
    },

    AnnotationProperties: function AnnotationProperties(id, data) {
      annotations[id].visible = data.visible;
    }
  };

  var order = {
    Scene: ['Player', 'Environment'],
    PolyMesh: ['PolyMesh', 'Transform', 'Material', 'Properties'],
    Camera: ['Camera', ['Transform', 'CameraTransform']],
    Null: ['Null', 'Transform', 'Properties'],
    Model: ['Null', 'Transform', 'Properties'],
    Objects: ['Null'],
    Light: ['Light', 'Transform', 'Properties'],
    MaterialLibrary: ['Null'],
    Material: ['PrefetchMaterialNull', 'Material'], // for prefetch of material
    Image: ['Image'], // for prefetch of image
    Renderers: [],
    Passes: [],
    Pass: [],
    Renderer: [],
    Bone: ['Bone', 'Transform', 'Properties'],
    Annotation: ['Annotation', ['Properties', 'AnnotationProperties']]
  };

  var forceDeps = {
    // When the mesh has changed, we need to run material translator again
    PolyMesh: { Material: true, Transform: true }
  };

  /*
   * Translate a node, either create or update
   */
  function translate(id, data, node, force) {
    var type = node.type;
    var processPlugs = order[type] || [];
    if (!translated[id]) translated[id] = {};
    var translateAnyway = {};
    var plug = void 0;
    var plugFunction = void 0;
    var plugV = void 0;

    //console.log('translate: ', type, node.name, translated[id]);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(processPlugs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var nextPlug = _step.value;

        var _ref = Array.isArray(nextPlug) ? nextPlug : [nextPlug, nextPlug];

        var _ref2 = (0, _slicedToArray3.default)(_ref, 2);

        plug = _ref2[0];
        plugFunction = _ref2[1];

        var plugData = data[plug];
        plugV = plugData && '' + plugData.id + '--' + plugData._v;
        if (force || !plugData || plugV !== translated[id][plug] || translateAnyway[plug]) {
          if (forceDeps[plug]) translateAnyway = forceDeps[plug];
          //console.log(' - ', plug);
          if (plugs[plugFunction]) {
            plugs[plugFunction](id, plugData, node, data.Properties, data);
            translated[id][plug] = plugV;
          } else {
            console.warn('Unknown plug translator for: ', plug, node.name);
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  /*
   * Delete a node
   */
  function deleteNode(id) {
    var obj = nodes[id];
    var annoObj = annotations[id];

    if (obj || annoObj) delete translated[id];

    if (obj) {
      delete nodes[id];
      obj.parent.remove(obj);
      if (obj.geometry) obj.geometry.dispose();

      if (obj.material) {
        if (obj.material.dispose) {
          obj.material.dispose();
        } else {
          obj.material.materials.forEach(function (mat) {
            mat.dispose();
          });
        }
      }
    } else if (annoObj) {
      delete annotations[id];
    }
    delete translated[id];
  }

  function getNodeBoundingBox(id) {
    var node = id === (0, _sceneIO.getSceneId)(store) ? scene : nodes[id];
    return (0, _calculateBoundingBox2.default)(node);
  }

  function getNodeListBoundingBox(nodeList) {
    var box = new THREE.Box3().makeEmpty();
    nodeList.forEach(function (id) {
      var idBox = id === (0, _sceneIO.getSceneId)(store) ? (0, _calculateBoundingBox2.default)(scene) : getNodeBoundingBox(id);
      box.union(idBox);
    });
    return box;
  }

  function getThreeObject(id) {
    return nodes[id];
  }

  function getCameraMouseRay(ndc) {
    var ray = new THREE.Raycaster();
    ray.setFromCamera(ndc, camera); // camera.inOrthographicMode ? camera.cameraO : camera.cameraP);
    return ray;
  }

  function raycastSelect(mousePosition) {
    var rootNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Objects';
    var origin = arguments[2];
    var direction = arguments[3];

    var hits = [];
    var ray = origin && direction ? new THREE.Raycaster(origin, direction) : getCameraMouseRay(mousePosition);
    var objectsRoot = scene;

    if ((0, _selectors.isUuid)(rootNode) && nodes[rootNode]) {
      objectsRoot = nodes[rootNode];
    } else {
      objectsRoot = scene.children.find(function (child) {
        return child.type === 'Object3D' && child.name === rootNode;
      });
    }

    objectsRoot.traverse(function (node) {
      if (!node.visible || !node.geometry) return;

      if (node.geometry.boundingBox === null) {
        node.geometry.computeBoundingBox();
      }

      var geometry = node.geometry;
      var hasPositions = geometry.isBufferGeometry ? !!geometry.attributes.position.array : !!geometry.vertices;

      if (geometry.boundingBox.isEmpty() === false && hasPositions) {
        node.matrix.compose(node.position, node.quaternion, node.scale);
        node.updateMatrixWorld(true);
        var inter = ray.intersectObject(node);
        if (inter.length > 0) {
          hits.push({ id: node.nodeId, node: node, data: inter });
        }
      }
    });
    hits.sort(function (a, b) {
      return a.data[0].distance - b.data[0].distance;
    });

    return hits;
  }

  function reset() {
    (0, _bingeom.clearGeometryCache)();
    loaded = false;
    cameraId = _sceneGraph.virtualCameraId;
    fromCameraId = _sceneGraph.virtualCameraId;
    translatedCameraId = null;
    pivotId = null;
    translated = {};
    nodes = {};
    (0, _keys2.default)(textureCache).forEach(function (k) {
      return delete textureCache[k];
    });
    scene.nodeId = (0, _sceneIO.getSceneId)(store); // reset this in case new scene is being used
  }

  return {
    attach: attach,
    resize: resize,
    translate: translate,
    deleteNode: deleteNode,
    raycastSelect: raycastSelect,
    getCameraMouseRay: getCameraMouseRay,
    getNodeBoundingBox: getNodeBoundingBox,
    getNodeListBoundingBox: getNodeListBoundingBox,
    getThreeObject: getThreeObject,
    postTranslate: postTranslate,
    onLoad: onLoad,
    getAnnotations: getAnnotations,
    getContext: getContext,
    reset: reset,
    scene: scene,
    camera: camera,
    renderer: renderer,
    composer: composer,
    externals: externals,
    textureCache: textureCache,
    renderQualityControl: renderQualityControl,
    indexRender: indexRender
  };
}

function threeTranslator(store, context) {
  return (0, _translator.createTranslator)(store, initTranslator, context);
}

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.moveNodeOnPlane = exports.moveNodeOnObjects = undefined;
exports.default = nodeMove;
exports.moveNodeFree = moveNodeFree;

var _three = __webpack_require__(0);

var _getProjectionMatrix = __webpack_require__(105);

var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

var _sceneGraph = __webpack_require__(10);

var _selection = __webpack_require__(45);

var _gizmos = __webpack_require__(163);

var _getProjectedPoint = __webpack_require__(250);

var _getProjectedPoint2 = _interopRequireDefault(_getProjectedPoint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PI = Math.PI,
    sin = Math.sin;


var invCameraWorldMatrix = new _three.Matrix4();
var cameraProjectMatrix = new _three.Matrix4();
var cameraUnprojectMatrix = new _three.Matrix4();
var inverseParent = new _three.Matrix4();
var referencePoint = new _three.Vector3();
var deltaReferencePoint = new _three.Vector3();

//const defaultOptions = {
//  displayGizmo: true,
//  useXAxis: true,
//  useYAxis: true,
//  useZAxis: true,
//  defaultPlane: { x: 0, y: 0 },
//}

//updateTool('nodeMove', { displayGizmo: false });

function nodeMove(store, translator) {
  var activeAxis = false;

  return {
    label: 'Move Node',
    enabled: true,
    display: {
      playerTools: false,
      editorTools: true
    },

    options: {
      displayGizmo: true,
      mode: 'free',
      plane: {
        normal: { x: 0, y: 1, z: 0 },
        constant: 0
      },
      surfaceNodeIds: [],
      onChange: undefined,
      onEnd: undefined
    },

    tool: {
      hover: function hover(ev) {
        if (!this.active) return;
        activeAxis = (0, _gizmos.highlightAxis)(translator, ev, activeAxis);
      },

      drag: function drag(ev) {
        if (ev.which !== 1 || !this.active || ev.metaKey) return false;

        var filterNodeList = (0, _player.filterNodesFromPosition)(store, ev);
        var selectedNode = (0, _selection.getSelectedNodes)(store)[0];
        var dragOnSelectedNode = false;
        for (var i = 0; i < filterNodeList.length && !dragOnSelectedNode; i += 1) {
          dragOnSelectedNode = isParentOf(store, filterNodeList[i], selectedNode);
        }

        if (!activeAxis && !dragOnSelectedNode) return false;

        var self = this;
        return {
          momentum: false,
          handle: function handle(ev) {
            switch (self.options.mode) {
              case 'plane':
                moveNodeOnPlane(store, ev.deltaX, ev.deltaY, self.options.plane, ev, self.options.onChange);
                break;
              case 'surface':
                moveNodeOnObjects(store, ev.clientX, ev.clientY, self.options.surfaceNodeIds, ev, self.options.onChange);
                break;
              default:
                moveNodeFree(store, ev.deltaX, ev.deltaY, activeAxis, ev, self.options.onChange);
                break;
            }
          },
          end: function end() {
            // store.dispatch(commit());
            if (typeof self.options.onEnd === 'function') self.options.onEnd(ev);
          }
        };
      }
    },

    widget: {
      draw: function draw(manipulatorsObject) {
        manipulatorsObject.add((0, _gizmos.drawMoveGizmo)());
        var scale = (0, _gizmos.getViewScale)(store);
        manipulatorsObject.scale.set(scale, scale, scale);
      },

      position: function position(manipulatorsObject) {
        var selectedNodes = (0, _selection.getSelectedNodes)(store);
        if (!selectedNodes.length) {
          manipulatorsObject.visible = false;
          return;
        }

        manipulatorsObject.visible = true;
        var manipId = selectedNodes[0];
        var worldTransform = (0, _scene.getWorldTransform)(store, manipId);
        var position = new _three.Vector3();
        position.setFromMatrixPosition(worldTransform);
        manipulatorsObject.position.set(position.x, position.y, position.z);
        //manipulatorsObject.scale.set(2,2,2);
        var scale = (0, _gizmos.getViewScale)(store);
        manipulatorsObject.scale.set(scale, scale, scale);
      }
    }
  };
}

function moveNodeFree(store, x, y, restrictToAxis, ev, onChange) {
  var selectedNodes = (0, _selection.getSelectedNodes)(store);
  if (!selectedNodes.length) return;
  var manipId = selectedNodes[0];

  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
  var nodeMatrix = (0, _scene.getWorldTransform)(store, manipId);
  if (!nodeMatrix) return;

  var parentMatrix = (0, _scene.getWorldTransform)(store, (0, _scene.find)(store, { id: manipId, parent: true }));
  var nodePosition = new _three.Vector3().setFromMatrixPosition(nodeMatrix);
  deltaReferencePoint.copy((0, _getProjectedPoint2.default)(store, manipId, x, y));

  if (restrictToAxis) {
    var projVector = new _three.Vector3(0, 0, 0);
    projVector[restrictToAxis] = 1;

    var targToCam = new _three.Vector3().setFromMatrixPosition(cameraWorldMatrix).sub(nodePosition);
    var origin = new _three.Vector3(0, 0, 0);
    var plane = new _three.Plane().setFromCoplanarPoints(targToCam, projVector, origin);
    deltaReferencePoint.projectOnPlane(plane.normal);

    var camToMove = new _three.Vector3().subVectors(deltaReferencePoint, targToCam);
    deltaReferencePoint.projectOnVector(projVector).normalize();
    var alpha = targToCam.angleTo(deltaReferencePoint);
    var beta = PI - targToCam.angleTo(camToMove);
    var gamma = PI - alpha - beta;
    var axis = targToCam.length() * sin(beta) / sin(gamma);
    deltaReferencePoint.multiplyScalar(axis);
  }

  nodePosition.add(deltaReferencePoint);

  nodeMatrix.setPosition(nodePosition);
  if (parentMatrix) nodeMatrix.premultiply(inverseParent.getInverse(parentMatrix));

  nodePosition.setFromMatrixPosition(nodeMatrix);

  // FIXME: Restrict to axis:
  //if (restrictToAxis) console.log('restrict to axis: ', restrictToAxis);

  store.dispatch((0, _scene.set)({ id: manipId, plug: 'Transform', property: 'translation' }, nodePosition));
  if (typeof onChange === 'function') onChange(ev);
}

var upVector = new _three.Vector3(0, 1, 0);

var stripParentTransform = function () {
  var newLocalTransform = new _three.Matrix4();
  var invParentTransform = new _three.Matrix4();

  return function (store, nodeId, position, quaternion, scale) {
    newLocalTransform.compose(position, quaternion, scale);

    var parentId = (0, _scene.find)(store, { id: nodeId, parent: true });
    var parentTransform = (0, _scene.getWorldTransform)(store, parentId);
    if (parentTransform) {
      invParentTransform.getInverse(parentTransform, true);
      newLocalTransform.premultiply(invParentTransform);
      newLocalTransform.decompose(position, quaternion, scale);
    }
  };
}();

var setNodePosition = function () {
  var scale = new _three.Vector3();
  var quaternion = new _three.Quaternion();
  var euler = new _three.Euler();

  return function (store, nodeId, position) {
    var scaleNode = (0, _scene.get)(store, {
      id: nodeId,
      plug: 'Transform',
      property: 'scale'
    });
    var rotateNode = (0, _scene.get)(store, {
      id: nodeId,
      plug: 'Transform',
      property: 'rotation'
    });
    var rotateOrder = (0, _scene.get)(store, {
      id: nodeId,
      plug: 'Transform',
      property: 'rotateOrder'
    });
    scale.set(scaleNode.x, scaleNode.y, scaleNode.z);
    euler.set(rotateNode, rotateOrder);
    quaternion.setFromEuler(euler);

    stripParentTransform(store, nodeId, position, quaternion, scale);

    //store.dispatch(set({id:nodeId, plug:'Transform', property:'rotation'}, newEuler.toVector3().multiplyScalar(180/Math.PI)));
    store.dispatch((0, _scene.set)({ id: nodeId, plug: 'Transform', property: 'translation' }, position));
  };
}();

var getNodeNdc = function () {
  var oldPosition = new _three.Vector3();
  var inverseCameraMatrix = new _three.Matrix4();

  return function (store, nodeId) {
    oldPosition.setFromMatrixPosition((0, _scene.getWorldTransform)(store, nodeId));
    var camera = (0, _player.getThreeCamera)(store);
    inverseCameraMatrix.getInverse(camera.matrix, true).premultiply(camera.projectionMatrix);
    oldPosition.applyMatrix4(inverseCameraMatrix);
    return oldPosition;
  };
}();

var moveNodeOnObjects = exports.moveNodeOnObjects = function () {
  var newQuaternion = new _three.Quaternion();

  return function (store, x, y, objects, ev, onChange) {
    var rect = (0, _player.getRect)(store);
    var nodeId = (0, _selection.getSelectedNodes)(store)[0];
    if (!nodeId) return;

    var ndc = { x: 2 * x / rect.width - 1, y: -2 * y / rect.height + 1 };
    var hits = store.getTranslator().raycastSelect(ndc);
    var nodeChildren = (0, _scene.filter)(store, { from: { id: nodeId } });
    var nodeHit = hits.find(function (hit) {
      var foundIndex = objects.findIndex(function (id) {
        return id === hit.id && id !== nodeId && nodeChildren.indexOf(id) < 0;
      });
      return foundIndex >= 0;
    });

    if (!nodeHit) return;

    var newPosition = nodeHit.data[0].point;

    setNodePosition(store, nodeId, newPosition);
    if (typeof onChange === 'function') onChange(ev, nodeHit.data);
  };
}();

var moveNodeOnPlane = exports.moveNodeOnPlane = function () {
  var newPosition = new _three.Vector3();
  var newQuaternion = new _three.Quaternion();
  var moveOnPlane = new _three.Plane();
  var moveOnNormal = new _three.Vector3();

  return function (store, x, y, plane, ev, onChange) {
    var rect = (0, _player.getRect)(store);
    var nodeId = (0, _selection.getSelectedNodes)(store)[0];
    if (!nodeId) return;
    var oldNdc = getNodeNdc(store, nodeId);

    //const plane = store.getIn(['selection', 'collisionPlane']);
    var normal = plane.normal;

    moveOnNormal.set(normal.x, normal.y, normal.z);
    moveOnPlane.set(moveOnNormal, plane.constant);

    var ndc = {
      x: oldNdc.x + 2 * x / rect.width,
      y: oldNdc.y - 2 * y / rect.height
    };
    var ray = store.getTranslator().getCameraMouseRay(ndc).ray;
    if (!ray.intersectsPlane(moveOnPlane)) return;
    ray.intersectPlane(moveOnPlane, newPosition);

    store.dispatch((0, _scene.set)({ id: nodeId }));
    setNodePosition(store, nodeId, newPosition);
    if (typeof onChange === 'function') onChange(ev);
  };
}();

function isParentOf(store, childId, parentId) {
  if (!(childId && parentId)) return false;

  while (childId) {
    if (childId === parentId) return true;
    childId = (0, _scene.find)(store, { id: childId, parent: true });
  }
  return false;
}

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nodeRotate;
exports.rotateNode = rotateNode;

var _three = __webpack_require__(0);

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

var _sceneGraph = __webpack_require__(10);

var _selection = __webpack_require__(45);

var _gizmos = __webpack_require__(163);

var _getBoundingRadius = __webpack_require__(249);

var _getBoundingRadius2 = _interopRequireDefault(_getBoundingRadius);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var min = Math.min,
    PI = Math.PI,
    sqrt = Math.sqrt;


var parentInvMatrix = new _three.Matrix4();
var nodeRotationQuaternion = new _three.Quaternion();
var nodePosition = new _three.Vector3();
var nodeScale = new _three.Vector3();
var nodeRotationEuler = new _three.Euler();
var cameraPosition = new _three.Vector3();

function nodeRotate(store, translator) {
  var activeAxis = false;

  return {
    label: 'Rotate Node',
    enabled: true,
    display: {
      playerTools: false,
      editorTools: true
    },
    options: {
      onChange: undefined,
      onEnd: undefined
    },

    tool: {
      hover: function hover(ev) {
        if (!this.active) return;
        activeAxis = (0, _gizmos.highlightAxis)(translator, ev, activeAxis);
      },

      drag: function drag(ev) {
        if (ev.which !== 1 || !this.active || ev.metaKey) return false;
        var self = this;
        return {
          momentum: false,
          handle: function handle(ev) {
            rotateNode(store, ev.deltaX, ev.deltaY, activeAxis);
            if (typeof self.options.onChange === 'function') self.options.onChange(ev);
          },
          end: function end() {
            // store.dispatch(commit());
            if (typeof self.options.onEnd === 'function') self.options.onEnd(ev);
          }
        };
      }
    },

    widget: {
      draw: function draw(manipulatorsObject) {
        manipulatorsObject.add((0, _gizmos.drawRotateGizmo)());
        var scale = (0, _gizmos.getViewScale)(store);
        manipulatorsObject.scale.set(scale, scale, scale);
      },

      position: function position(manipulatorsObject) {
        var selectedNodes = (0, _selection.getSelectedNodes)(store);
        if (!selectedNodes.length) {
          manipulatorsObject.visible = false;
          return;
        }

        manipulatorsObject.visible = true;
        var manipId = selectedNodes[0];
        var worldTransform = (0, _scene.getWorldTransform)(store, manipId);
        var position = new _three.Vector3();
        position.setFromMatrixPosition(worldTransform);
        manipulatorsObject.position.set(position.x, position.y, position.z);

        var scale = (0, _gizmos.getViewScale)(store);
        manipulatorsObject.scale.set(scale, scale, scale);
      }
    }
  };
}

function rotateNode(store, x, y, restrictToAxis) {
  var rect = (0, _player.getRect)(store);
  var selectedNodes = (0, _selection.getSelectedNodes)(store);
  if (!selectedNodes.length) return;
  var manipId = selectedNodes[0];
  var nodeTransform = (0, _scene.getWorldTransform)(store, manipId);
  if (!nodeTransform) return;

  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
  nodeTransform.decompose(nodePosition, nodeRotationQuaternion, nodeScale);
  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);

  var radius = (0, _getBoundingRadius2.default)(store, manipId);

  var relativeDelta = new _three.Vector3().set(2 * x / rect.x / radius, -2 * y / rect.y / radius, 0);

  if (relativeDelta.length() > 1) relativeDelta.normalize();else if (relativeDelta.length() === 0) return;

  var delta = relativeDelta.length();
  relativeDelta.transformDirection(cameraWorldMatrix).multiplyScalar(delta);

  var objNormal = new _three.Vector3().subVectors(cameraPosition, nodePosition).normalize();

  if (restrictToAxis) {
    var projVector = new _three.Vector3(0, 0, 0);
    projVector[restrictToAxis] = 1;
    relativeDelta.projectOnPlane(projVector);
    objNormal.projectOnPlane(projVector);
  }

  var scaleFactor = sqrt(1 - relativeDelta.lengthSq());
  relativeDelta.addScaledVector(objNormal, scaleFactor).normalize();
  var modifyQuaternion = new _three.Quaternion().setFromUnitVectors(objNormal, relativeDelta);
  nodeRotationQuaternion.premultiply(modifyQuaternion);

  nodeTransform.compose(nodePosition, nodeRotationQuaternion, nodeScale);
  var parentMatrix = (0, _scene.getWorldTransform)(store, (0, _scene.find)(store, { id: manipId, parent: true }));
  if (parentMatrix) {
    parentInvMatrix.getInverse(parentMatrix, true);
    nodeTransform.premultiply(parentInvMatrix);
  }

  nodeTransform.decompose(nodePosition, nodeRotationQuaternion, nodeScale);

  // FIXME: resrictToAxis
  // console.log('restrictToAxis: ', restrictToAxis);

  nodeRotationEuler.setFromQuaternion(nodeRotationQuaternion, 'ZYX');
  store.dispatch((0, _scene.set)({ id: manipId, plug: 'Transform', property: 'rotation' }, nodeRotationEuler.toVector3().multiplyScalar(180 / PI)));
}

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nodeScale;
exports.scaleNode = scaleNode;

var _three = __webpack_require__(0);

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

var _sceneGraph = __webpack_require__(10);

var _selection = __webpack_require__(45);

var _gizmos = __webpack_require__(163);

var _getProjectedPoint = __webpack_require__(250);

var _getProjectedPoint2 = _interopRequireDefault(_getProjectedPoint);

var _getBoundingRadius = __webpack_require__(249);

var _getBoundingRadius2 = _interopRequireDefault(_getBoundingRadius);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var max = Math.max,
    pow = Math.pow,
    PI = Math.PI,
    sin = Math.sin,
    min = Math.min,
    sqrt = Math.sqrt;


var EPS = 0.000001;

function nodeScale(store, translator) {
  var activeAxis = false;

  return {
    label: 'Scale Node',
    enabled: true,
    display: {
      playerTools: false,
      editorTools: true
    },
    options: {
      onChange: undefined,
      onEnd: undefined
    },

    tool: {
      hover: function hover(ev) {
        if (!this.active) return;

        activeAxis = (0, _gizmos.highlightAxis)(translator, ev, activeAxis);
      },

      drag: function drag(ev) {
        if (ev.which !== 1 || !this.active || ev.metaKey) return false;
        var self = this;
        return {
          momentum: false,
          handle: function handle(ev) {
            scaleNode(store, ev, activeAxis);
            if (typeof self.options.onChange === 'function') self.options.onChange(ev);
          },
          end: function end() {
            // store.dispatch(commit());
            if (typeof self.options.onEnd === 'function') self.options.onEnd(ev);
          }
        };
      }
    },

    widget: {
      draw: function draw(manipulatorsObject) {
        manipulatorsObject.add((0, _gizmos.drawScaleGizmo)());
        var scale = (0, _gizmos.getViewScale)(store);
        manipulatorsObject.scale.set(scale, scale, scale);
      },

      position: function position(manipulatorsObject) {
        var selectedNodes = (0, _selection.getSelectedNodes)(store);
        if (!selectedNodes.length) {
          manipulatorsObject.visible = false;
          return;
        }

        manipulatorsObject.visible = true;
        var manipId = selectedNodes[0];
        var worldTransform = (0, _scene.getWorldTransform)(store, manipId);
        var position = new _three.Vector3();
        position.setFromMatrixPosition(worldTransform);
        manipulatorsObject.position.set(position.x, position.y, position.z);

        var scale = (0, _gizmos.getViewScale)(store);
        manipulatorsObject.scale.set(scale, scale, scale);
      }
    }
  };
}

function scaleNode(store, ev, restrictToAxis) {
  var rect = (0, _player.getRect)(store);
  var selectedNodes = (0, _selection.getSelectedNodes)(store);
  if (!selectedNodes.length) return;
  var id = selectedNodes[0];

  var nodeGraphScale = (0, _scene.get)(store, {
    id: id,
    plug: 'Transform',
    property: 'scale'
  });
  if (!nodeGraphScale) return;
  var radius = max((0, _getBoundingRadius2.default)(store, id), EPS) || EPS;

  var delta = ev.delta || ev.deltaX / 30 - ev.deltaY / 30;
  var deltaZoom = max(min(2 * delta / rect.y / radius, 0.001), -0.001);
  var decayZoomFactor = pow(2, deltaZoom * 100);

  var nodeMatrix = (0, _scene.getWorldTransform)(store, id);
  var nodePosition = new _three.Vector3().setFromMatrixPosition(nodeMatrix);
  var nodeScale = new _three.Vector3().copy(nodeGraphScale);
  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);

  if (!restrictToAxis) {
    var oldScale = max(nodeScale.length(), EPS);
    nodeScale.setLength(oldScale * decayZoomFactor);
  } else {
    var projVector = new _three.Vector3(0, 0, 0);
    projVector[restrictToAxis] = 1;
    var projectedMouse = (0, _getProjectedPoint2.default)(store, id, ev.deltaX, ev.deltaY);
    projectedMouse.projectOnVector(projVector);

    var targToCam = new _three.Vector3().setFromMatrixPosition(cameraWorldMatrix).sub(nodePosition);
    var origin = new _three.Vector3(0, 0, 0);
    var plane = new _three.Plane().setFromCoplanarPoints(targToCam, projVector, origin);
    projectedMouse.projectOnPlane(plane.normal);

    var camToMove = new _three.Vector3().subVectors(projectedMouse, targToCam);
    projectedMouse.projectOnVector(projVector).normalize();
    var alpha = targToCam.angleTo(projectedMouse);
    var beta = PI - targToCam.angleTo(camToMove);
    var gamma = PI - alpha - beta;
    var axis = targToCam.length() * sin(beta) / sin(gamma);
    projectedMouse.multiplyScalar(axis);

    projVector.set(1, 1, 1);

    projVector[restrictToAxis] = 1 + 2 * projectedMouse[restrictToAxis] / nodeScale[restrictToAxis];
    nodeScale.multiply(projVector);
  }

  // FIXME: restrict axis
  //console.log('scaleToAxis', restrictToAxis);
  store.dispatch((0, _scene.set)({ id: id, plug: 'Transform', property: 'scale' }, nodeScale));
}

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateSphericalRotation = updateSphericalRotation;
exports.default = orbit;

var _three = __webpack_require__(0);

var _clamp = __webpack_require__(164);

var _clamp2 = _interopRequireDefault(_clamp);

var _decompose = __webpack_require__(51);

var _decompose2 = _interopRequireDefault(_decompose);

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

var _sceneGraph = __webpack_require__(10);

var _updateCameraLookAtTarget = __webpack_require__(71);

var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

var _getTargetWorldMatrix = __webpack_require__(59);

var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

var _getOrbitAttrs = __webpack_require__(104);

var _runtimeInfo = __webpack_require__(56);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tan = Math.tan,
    cos = Math.cos,
    atan = Math.atan,
    acos = Math.acos,
    min = Math.min,
    max = Math.max,
    pow = Math.pow,
    PI = Math.PI,
    sqrt = Math.sqrt;
function updateSphericalRotation(store, cameraId, cameraWorldMatrix, targetWorldMatrix, mouseDelta) {
  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });

  var rect = (0, _player.getRect)(store);

  var updateFns = {
    trackball: trackballUpdate,
    firstPerson: firstPersonUpdate
  };
  var updateFn = updateFns[(0, _getOrbitAttrs.getOrbitMode)(store, cameraId)] || gyroscopeUpdate;
  updateFn(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, mouseDelta);
}

function orbit(store, translator) {
  return {
    label: 'Orbit',
    active: true,
    enabled: true,

    display: {
      playerTools: true
    },
    options: {
      touchVerticalDefault: false,
      turnTable: false,
      mobileOnly: false
    },

    tool: {
      drag: function drag(ev) {
        if (ev.which !== 1 || !(this.active || ev.metaKey)) return false;
        var touchVerticalDefault = this.options.touchVerticalDefault;
        var turnTable = this.options.turnTable;
        var mobileOnly = this.options.mobileOnly;

        return {
          momentum: true,
          allowDefault: true,

          handle: function handle(_ref) {
            var deltaX = _ref.deltaX,
                deltaY = _ref.deltaY,
                isTouch = _ref.isTouch,
                originalEvent = _ref.originalEvent;

            if (isTouch && touchVerticalDefault && Math.abs(deltaY) > Math.abs(deltaX)) {
              // Allow event to fall through with default, so can scroll the page in touch mode
              return;
            }
            if (originalEvent) originalEvent.preventDefault();
            var cameraId = (0, _player.getCamera)(store);
            var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
            var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);

            if (turnTable) {
              if (mobileOnly) {
                deltaY = _runtimeInfo.isMobile ? 0 : deltaY;
              } else {
                deltaY = 0;
              }
            }

            updateSphericalRotation(store, cameraId, cameraWorldMatrix, targetWorldMatrix, new _three.Vector2(deltaX, deltaY));
            store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));

            if (!(0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' }).target) {
              store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
            }
          }
        };
      }
    }
  };
}

var cameraPosition = new _three.Vector3();
var targetPosition = new _three.Vector3();
var pivotPosition = new _three.Vector3();
var sphericalCamera = new _three.Spherical();
var sphericalTarget = new _three.Spherical();
var invTargetWorldMatrix = new _three.Matrix4();
var invPivotMatrix = new _three.Matrix4();

// changes cameraWorldMatrix by rotating by delta
function gyroscopeUpdate(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, _ref2) {
  var x = _ref2.x,
      y = _ref2.y;

  var pivotMatrix = (0, _scene.getWorldTransform)(store, _sceneGraph.virtualPivotId);
  pivotPosition.setFromMatrixPosition(pivotMatrix);

  var constraintCameraY = (0, _getOrbitAttrs.getConstrainCameraY)(store, cameraId);

  //to target space
  targetPosition.setFromMatrixPosition(targetWorldMatrix).sub(pivotPosition);
  cameraPosition.setFromMatrixPosition(cameraWorldMatrix).sub(pivotPosition);

  var cameraSpherical = new _three.Spherical().setFromVector3(cameraPosition);
  var targetSpherical = new _three.Spherical().setFromVector3(targetPosition);
  var offsetSpherical = new _three.Spherical().setFromVector3(cameraData.offset);

  var azimuthalAngle = 2 * PI * (-x / rect.x);
  cameraSpherical.theta += azimuthalAngle;
  targetSpherical.theta += azimuthalAngle;
  offsetSpherical.theta += azimuthalAngle;

  cameraSpherical.makeSafe();
  targetSpherical.makeSafe();
  offsetSpherical.makeSafe();

  targetPosition.setFromSpherical(targetSpherical).add(pivotPosition);
  cameraPosition.setFromSpherical(cameraSpherical).add(pivotPosition).sub(targetPosition);
  cameraData.offset.setFromSpherical(offsetSpherical);

  cameraSpherical.setFromVector3(cameraPosition);

  var polarAngle = 2 * PI * (-y / rect.y);
  cameraSpherical.phi += polarAngle;
  var maxPolarAngle = void 0;
  if (targetPosition.y / cameraPosition.length() <= 1) {
    maxPolarAngle = constraintCameraY ? acos(-targetPosition.y / cameraPosition.length()) : PI;
  } else {
    maxPolarAngle = PI;
  }

  cameraSpherical.phi = (0, _clamp2.default)(cameraSpherical.phi, 0.001, maxPolarAngle - 0.001);

  cameraSpherical.makeSafe();
  cameraPosition.setFromSpherical(cameraSpherical).add(targetPosition);

  if (cameraData.radiusConstraint) {
    var _cameraData$radiusCon = cameraData.radiusConstraint,
        maxBoundingSphere = _cameraData$radiusCon.maxBoundingSphere,
        minBoundingSphere = _cameraData$radiusCon.minBoundingSphere;

    var camToTarg = new _three.Vector3().subVectors(targetPosition, cameraPosition);
    if (minBoundingSphere.containsPoint(cameraPosition)) {
      var backwardRay = new _three.Ray(cameraPosition, camToTarg.multiplyScalar(-1));
      var newPosition = backwardRay.intersectSphere(minBoundingSphere).addScaledVector(camToTarg, 0.001);
      cameraPosition.copy(newPosition);
    } else if (!maxBoundingSphere.containsPoint(cameraPosition)) {
      var forwardRay = new _three.Ray(cameraPosition, camToTarg);
      var _newPosition = forwardRay.intersectSphere(maxBoundingSphere).addScaledVector(camToTarg, 0.001);
      cameraPosition.copy(_newPosition);
    } else {}
  }

  cameraWorldMatrix.setPosition(cameraPosition);
  targetWorldMatrix.setPosition(targetPosition);

  // update orientation
  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
}

// changes cameraWorldMatrix by rotating by delta
function trackballUpdate(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, _ref3) {
  var x = _ref3.x,
      y = _ref3.y;

  var radius = min(rect.x, rect.y);

  var pivotMatrix = (0, _scene.getWorldTransform)(store, _sceneGraph.virtualPivotId); //cameraData.pivotMatrix;
  var pivotPosition = new _three.Vector3().setFromMatrixPosition(pivotMatrix);

  var relativeDelta = new _three.Vector3().set(-2 * x / radius, 2 * y / radius, 0);
  if (relativeDelta.length() > 1) relativeDelta.normalize();
  if (relativeDelta.x === 0 && relativeDelta.y === 0) return;
  var delta = relativeDelta.length();

  //world to relative pivot space
  relativeDelta.transformDirection(cameraWorldMatrix).multiplyScalar(delta);
  cameraPosition.setFromMatrixPosition(cameraWorldMatrix).sub(pivotPosition);
  targetPosition.setFromMatrixPosition(targetWorldMatrix).sub(pivotPosition);
  //upPosition.transformDirection(invPivotMatrix);
  var camNorm = new _three.Vector3().copy(cameraPosition).normalize();
  //create rotational Quaternion
  var scaleFactor = sqrt(1 - relativeDelta.lengthSq());
  relativeDelta.addScaledVector(camNorm, scaleFactor).normalize();

  var rotationalAxis = new _three.Vector3().crossVectors(camNorm, relativeDelta).normalize();
  var rotationalAngle = camNorm.angleTo(relativeDelta);
  var rotationalQuaternion = new _three.Quaternion().setFromAxisAngle(rotationalAxis, rotationalAngle);

  //pivot relative to world space
  cameraPosition.applyQuaternion(rotationalQuaternion).add(pivotPosition);
  targetPosition.applyQuaternion(rotationalQuaternion).add(pivotPosition);
  cameraData.upPosition.applyQuaternion(rotationalQuaternion); //.transformDirection(pivotMatrix);
  cameraData.offset.applyQuaternion(rotationalQuaternion);

  //bounding box constraining
  if (cameraData.radiusConstraint) {
    var _cameraData$radiusCon2 = cameraData.radiusConstraint,
        maxBoundingSphere = _cameraData$radiusCon2.maxBoundingSphere,
        minBoundingSphere = _cameraData$radiusCon2.minBoundingSphere;

    var camToTarg = new _three.Vector3().subVectors(targetPosition, cameraPosition);

    if (minBoundingSphere.containsPoint(cameraPosition)) {
      var backwardRay = new _three.Ray(cameraPosition, new _three.Vector3().copy(camToTarg).multiplyScalar(-1));

      var newPosition = backwardRay.intersectSphere(minBoundingSphere).addScaledVector(camToTarg, -0.001);

      cameraPosition.copy(newPosition);
    } else if (!maxBoundingSphere.containsPoint(cameraPosition)) {
      var forwardRay = new _three.Ray(cameraPosition, camToTarg);

      var _newPosition2 = forwardRay.intersectSphere(maxBoundingSphere).addScaledVector(camToTarg, 0.001);

      cameraPosition.copy(_newPosition2);
    } else {}

    if (!minBoundingSphere.containsPoint(targetPosition)) {
      var thirdVector = new _three.Vector3().crossVectors(camToTarg, cameraData.upPosition);
      var _newPosition3 = minBoundingSphere.clampPoint(targetPosition);

      var posChange = new _three.Vector3().subVectors(_newPosition3, targetPosition);
      _newPosition3.addScaledVector(posChange, 0.001);

      cameraData.upPosition.crossVectors(thirdVector, camToTarg.subVectors(_newPosition3, cameraPosition)).normalize();
      targetPosition.copy(_newPosition3);
    }
  }

  cameraWorldMatrix.setPosition(cameraPosition);
  targetWorldMatrix.setPosition(targetPosition);

  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
}

function firstPersonUpdate(store, playerData, cameraId, cameraData, targetWorldMatrix, cameraWorldMatrix, rect, _ref4) {
  var x = _ref4.x,
      y = _ref4.y;

  cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
  targetPosition.setFromMatrixPosition(targetWorldMatrix).sub(cameraPosition);

  var targetSpherical = new _three.Spherical().setFromVector3(targetPosition);

  var azimuthalAngle = 2 * PI * (-x / rect.x);
  targetSpherical.theta += azimuthalAngle;

  var polarAngle = 2 * PI * (y / rect.y);
  targetSpherical.phi += polarAngle;

  targetSpherical.makeSafe();
  targetPosition.setFromSpherical(targetSpherical).add(cameraPosition);

  targetWorldMatrix.setPosition(targetPosition);

  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
}

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBoundingRadius;

var _three = __webpack_require__(0);

var _scene = __webpack_require__(7);

var _player = __webpack_require__(8);

var cameraPosition = new _three.Vector3();
var nodePosition = new _three.Vector3();
var boundingVector = new _three.Vector3();
var boundingSphere = new _three.Sphere();

function getBoundingRadius(store, nodeId) {
  var camera = (0, _player.getThreeCamera)(store);
  var nodeTransform = (0, _scene.getWorldTransform)(store, nodeId);
  cameraPosition.setFromMatrixPosition(camera.matrix);

  var boundingRadius = store.getTranslator().getNodeBoundingBox(nodeId).getBoundingSphere(boundingSphere).radius;
  boundingVector.subVectors(cameraPosition, nodePosition);
  boundingVector.z = -boundingVector.length();
  boundingVector.y = boundingRadius;
  boundingVector.x = 0;

  boundingVector.applyMatrix4(camera.projectionMatrix);
  boundingVector.z = 0;
  return boundingVector.length();
}

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getProjectedPoint;

var _three = __webpack_require__(0);

var _getProjectionMatrix = __webpack_require__(105);

var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var invCameraWorldMatrix = new _three.Matrix4();
var cameraProjectMatrix = new _three.Matrix4();
var cameraUnprojectMatrix = new _three.Matrix4();

var nodePosition = new _three.Vector3();
var referencePoint = new _three.Vector3();
var relativeDelta = new _three.Vector2();
var deltaReferencePoint = new _three.Vector3();

function getProjectedPoint(store, nodeId, x, y) {
  var cameraId = (0, _player.getCamera)(store);
  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
  var projectionMatrix = (0, _getProjectionMatrix2.default)((0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' }));
  invCameraWorldMatrix.getInverse(cameraWorldMatrix, true);
  cameraProjectMatrix.copy(projectionMatrix).multiply(invCameraWorldMatrix);

  var nodeMatrix = (0, _scene.getWorldTransform)(store, nodeId);
  if (!nodeMatrix) return;

  var rect = (0, _player.getRect)(store);
  var parentMatrix = (0, _scene.getWorldTransform)(store, (0, _scene.find)(store, { id: nodeId, parent: true }));
  nodePosition.setFromMatrixPosition(nodeMatrix);
  relativeDelta.set(x, -y).divide(rect).multiplyScalar(2.0);

  referencePoint.copy(nodePosition).applyMatrix4(cameraProjectMatrix);
  referencePoint.x = 0;
  referencePoint.y = 0;
  deltaReferencePoint.set(relativeDelta.x, relativeDelta.y, referencePoint.z);

  cameraUnprojectMatrix.getInverse(cameraProjectMatrix, true);
  referencePoint.applyMatrix4(cameraUnprojectMatrix);
  deltaReferencePoint.applyMatrix4(cameraUnprojectMatrix).sub(referencePoint);

  return deltaReferencePoint;
}

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = zoom;
exports.updateZoom = updateZoom;

var _three = __webpack_require__(0);

var _clamp = __webpack_require__(164);

var _clamp2 = _interopRequireDefault(_clamp);

var _decompose = __webpack_require__(51);

var _decompose2 = _interopRequireDefault(_decompose);

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

var _sceneGraph = __webpack_require__(10);

var _updateCameraLookAtTarget = __webpack_require__(71);

var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

var _getTargetWorldMatrix = __webpack_require__(59);

var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

var _cameraControl = __webpack_require__(476);

var _cameraControl2 = _interopRequireDefault(_cameraControl);

var _getOrbitAttrs = __webpack_require__(104);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tan = Math.tan,
    cos = Math.cos,
    atan = Math.atan,
    acos = Math.acos,
    min = Math.min,
    max = Math.max,
    pow = Math.pow,
    PI = Math.PI,
    sqrt = Math.sqrt;


var EPS = 0.000001;
var cameraPosition = new _three.Vector3();
var targetPosition = new _three.Vector3();
var targetToCamera = new _three.Vector3();

function zoom(store, translator) {
  function zoomBy(_ref) {
    var delta = _ref.delta,
        deltaX = _ref.deltaX,
        deltaY = _ref.deltaY;

    var d = delta !== undefined ? delta : deltaX / 30 + -deltaY / 30;
    var cameraId = (0, _player.getCamera)(store);
    var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
    updateZoom(store, -d, cameraId, cameraWorldMatrix);
    store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
  }

  return {
    label: 'Zoom',
    enabled: true,
    display: {
      playerTools: true
    },
    options: {},

    tool: {
      drag: function drag(ev) {
        if (!this.active && !ev.ctrlKey) return false;

        return {
          momentum: true,
          handle: function handle(ev) {
            var newEv = {
              delta: ev.delta !== undefined ? ev.delta : ev.deltaX / 30 + -ev.deltaY / 30
            };
            zoomBy(newEv);
          }
        };
      },

      pinch: function pinch(ev) {
        zoomBy(ev);
      },

      scroll: function scroll(ev) {
        if ((0, _cameraControl2.default)(store)) zoomBy(ev);
      }
    }
  };
}

function updateZoom(store, mouseDelta, cameraId, cameraWorldMatrix) {
  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
  var rect = (0, _player.getRect)(store);

  var deltaZoom = mouseDelta / rect.y;
  var decayZoomFactor = pow(2, deltaZoom * 100); // this ensures the zoom has consistent speed no matter the size

  if (cameraData.projection === 'Perspective') {
    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
    targetPosition.setFromMatrixPosition(targetWorldMatrix);

    targetToCamera.copy(cameraPosition).sub(targetPosition);
    var targetToCameraDistance = max(targetToCamera.length(), EPS);
    var newTargetToCameraDistance = targetToCameraDistance * decayZoomFactor;

    if (cameraData.radiusConstraint) {
      var _cameraData$radiusCon = cameraData.radiusConstraint,
          maxBoundingSphere = _cameraData$radiusCon.maxBoundingSphere,
          minBoundingSphere = _cameraData$radiusCon.minBoundingSphere;

      var camToTargetBackward = new _three.Vector3().copy(targetToCamera).normalize();
      var camToTargetForward = new _three.Vector3().copy(camToTargetBackward).multiplyScalar(-1);

      var forwardRay = new _three.Ray(cameraPosition, camToTargetForward);
      var backwardRay = new _three.Ray(cameraPosition, camToTargetBackward);

      var lowerBound = new _three.Vector3(),
          upperBound = new _three.Vector3();

      forwardRay.intersectSphere(minBoundingSphere, lowerBound);
      backwardRay.intersectSphere(maxBoundingSphere, upperBound);

      var minZoom = lowerBound.sub(targetPosition).length();
      var maxZoom = maxBoundingSphere.radius === Infinity ? Infinity : upperBound.sub(targetPosition).length();

      newTargetToCameraDistance = (0, _clamp2.default)(newTargetToCameraDistance, minZoom + 0.001, maxZoom - 0.001);
    }

    targetToCamera.multiplyScalar(newTargetToCameraDistance / targetToCameraDistance);
    cameraPosition.copy(targetPosition).add(targetToCamera);
    if (cameraPosition.y < 0 && (0, _getOrbitAttrs.getConstrainCameraY)(store, cameraId) && (0, _getOrbitAttrs.getOrbitMode)(store, cameraId) !== 'trackball') {
      var thirdVector = new _three.Vector3().crossVectors(targetToCamera, cameraData.upPosition).normalize();
      cameraPosition.y = 0;
      targetToCamera.copy(cameraPosition).sub(targetPosition);
    }

    cameraWorldMatrix.setPosition(cameraPosition);

    (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);
  } else if (cameraData.projection === 'Orthographic') {
    var _zoom = (0, _scene.get)(store, {
      id: cameraId,
      plug: 'Camera',
      property: 'orthoZoom'
    });
    store.dispatch((0, _scene.set)({ id: cameraId, plug: 'Camera', property: 'orthoZoom' }, _zoom * decayZoomFactor));
  }
}

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateBoundingBox;

var _three = __webpack_require__(0);

function calculateBoundingBox(object) {
  var box = new _three.Box3();
  var result = new _three.Box3();

  if (!object) return result;

  var objectsRoot = object;
  object.children.forEach(function (child) {
    if (child.type === 'Object3D' && child.name === 'Objects') objectsRoot = child;
  });

  result.makeEmpty();

  object.updateMatrixWorld(true);

  objectsRoot.traverseVisible(function (node) {
    // if (!node.visible) return; // should not be needed if we are using traverseVisible
    if (!node.geometry) return;
    if (node.isDirectionalLightHelper) return;
    if (node.isCameraHelper) return;
    var geometry = node.geometry;

    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }

    if (geometry.boundingBox.isEmpty() === false) {
      box.copy(geometry.boundingBox);
      node.matrix.compose(node.position, node.quaternion, node.scale);
      node.updateMatrixWorld(true);
      box.applyMatrix4(node.matrixWorld);
      result.union(box);
    }
  });

  return result;
}

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = vrControlsWrapper;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function vrControlsWrapper(object, onError) {
  this.offset = new THREE.Vector3(0, 0, 0);
  this.rotationalOffset = new THREE.Quaternion(0, 0, 0, 1);
  this.threeVRControls = new THREE.VRControls(object, onError);

  this.setOffset = function (v) {
    this.offset.copy(v);
  };

  this.setRotationalOffset = function (q) {
    this.rotationalOffset.copy(q);
  };

  this.update = function () {
    this.threeVRControls.update();
    object.quaternion.premultiply(this.rotationalOffset);
    object.position.applyQuaternion(this.rotationalOffset);
    object.position.add(this.offset);
  };

  this.setStanding = function (bool) {
    this.threeVRControls.standing = bool;
  };

  this.resetPose = function () {
    var vrDisplay = this.threeVRControls.getVRDisplay();
    if (vrDisplay && vrDisplay.resetPose) this.threeVRControls.resetPose();
  };

  this.getStandingMatrix = function () {
    return this.threeVRControls.getStandingMatrix();
  };

  this.setUserHeight = function (height) {
    this.threeVRControls.userHeight = Number(height);
  };
}

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

exports.clearCache = clearCache;
exports.default = apiBase;

var _lzmaDecompressor = __webpack_require__(496);

var _rsvp = __webpack_require__(204);

var _rsvp2 = _interopRequireDefault(_rsvp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Simple, persistent api cache for now.
var apiCache = {};
var fetchingCache = {};

function clearCache() {
  apiCache = {};
}

var NUM_CONCURRENT = 15;
var numRequests = 0;
var numRequesting = 0;
var requestQueue = [];

function makeRequest(fn) {
  numRequests++;
  //console.log('makeRequest', numRequesting, requestQueue.length, numRequests);
  if (numRequesting >= NUM_CONCURRENT) {
    requestQueue.push(fn);
  } else {
    numRequesting += 1;
    fn();
  }
}

function doneRequest() {
  //console.log('doneRequest', numRequesting, requestQueue.length);
  numRequesting -= 1;
  if (requestQueue.length && numRequesting < NUM_CONCURRENT) {
    numRequesting += 1;
    requestQueue.shift()();
  }
}

function apiBase(fetchNext) {
  return function (store, _ref) {
    var types = _ref.types,
        url = _ref.url,
        fireAndForget = _ref.fireAndForget,
        payload = _ref.payload,
        queryKey = _ref.queryKey,
        requestPayload = _ref.requestPayload,
        ignoreCache = _ref.ignoreCache,
        method = _ref.method,
        contentType = _ref.contentType,
        body = _ref.body,
        files = _ref.files,
        success = _ref.success,
        failure = _ref.failure,
        decompress = _ref.decompress,
        onReadyStateChange = _ref.onReadyStateChange,
        withCredentials = _ref.withCredentials,
        ignoreErrorMessage = _ref.ignoreErrorMessage,
        responseURL = _ref.responseURL;

    var urls = Array.isArray(url) ? url : [url];
    if (!contentType) contentType = 'json';

    var _ref2 = types || ['IGN', 'IGN', 'IGN'],
        _ref3 = (0, _slicedToArray3.default)(_ref2, 3),
        requestType = _ref3[0],
        successType = _ref3[1],
        failureType = _ref3[2];

    // If we provide a 'queryKey', there can be only one query at once


    if (queryKey) {
      if (apiCache[queryKey]) {
        return fireAndForget ? apiCache[queryKey] : _promise2.default.resolve(apiCache[queryKey]);
      }

      if (fetchingCache[queryKey]) {
        if (fireAndForget) {
          fetchingCache[queryKey].push({ payload: payload, store: store });
          store.dispatch({ type: requestType, payload: payload });
          return;
        } else {
          return new _rsvp2.default.Promise(function (resolve, reject) {
            fetchingCache[queryKey].push({ payload: payload, store: store, resolve: resolve, reject: reject });
            store.dispatch({ type: requestType, payload: payload });
          });
        }
      }

      fetchingCache[queryKey] = [{ payload: payload, store: store }];
    }

    store.dispatch({ type: requestType, payload: payload });

    var promise = new _rsvp2.default.Promise(function (resolve, reject) {
      var meta = {
        queryKey: queryKey,
        payload: payload,
        successType: successType,
        success: success,
        failureType: failureType,
        failure: failure
      };

      function onFailure(error, workerMeta) {
        doneRequest();

        var _ref4 = workerMeta || meta,
            failureType = _ref4.failureType,
            failure = _ref4.failure,
            queryKey = _ref4.queryKey,
            payload = _ref4.payload;

        if (queryKey) {
          fetchingCache[queryKey].forEach(function (_ref5) {
            var payload = _ref5.payload,
                store = _ref5.store,
                reject = _ref5.reject;

            store.dispatch({
              type: failureType,
              payload: payload,
              error: error,
              ignoreErrorMessage: ignoreErrorMessage
            });
            if (reject) reject(error);
          });
          delete fetchingCache[queryKey];
        } else {
          store.dispatch({
            type: failureType,
            payload: payload,
            error: error,
            ignoreErrorMessage: ignoreErrorMessage
          });
        }

        if (failure) failure(error);
        reject(error);
      }

      function onSuccessEnd(buffer, workerMeta) {
        var _ref6 = workerMeta || meta,
            successType = _ref6.successType,
            sucess = _ref6.sucess,
            queryKey = _ref6.queryKey,
            payload = _ref6.payload;

        if (queryKey) {
          if (!ignoreCache) apiCache[queryKey] = buffer;
          fetchingCache[queryKey].forEach(function (_ref7) {
            var payload = _ref7.payload,
                store = _ref7.store,
                resolve = _ref7.resolve;

            store.dispatch({
              type: successType,
              payload: fireAndForget ? payload : buffer,
              response: buffer
            });
            if (resolve) resolve(buffer);
          });
          delete fetchingCache[queryKey];
        } else {
          store.dispatch({
            type: successType,
            payload: fireAndForget ? payload : buffer,
            response: buffer
          });
        }

        if (success) success(buffer);
        resolve(buffer);
      }

      function onSuccess(response) {
        doneRequest();

        if (decompress) {
          (0, _lzmaDecompressor.lzmaDecompressor)(response, meta, onSuccessEnd, onFailure);
        } else {
          onSuccessEnd(response);
        }
      }

      makeRequest(function () {
        return fetchNext(urls[0], urls.slice(1), onSuccess, onFailure, {
          contentType: contentType,
          method: method,
          body: body,
          files: files,
          onReadyStateChange: onReadyStateChange,
          withCredentials: withCredentials,
          responseURL: responseURL
        });
      });
    });

    if (fireAndForget) promise.catch(function (err) {
      // If `fireAndForget`, we need to catch any errors so we don't hit the unhandled exception handler and exit the process.
      // Log the error here and continue, since fireAndForget queries may continue in the face of errors.
      console.error(err);
    });

    return fireAndForget ? null : promise;
  };
}

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = promiseMiddleware;

var _isPromise = __webpack_require__(494);

var _isPromise2 = _interopRequireDefault(_isPromise);

var _isPlainObject = __webpack_require__(256);

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PENDING = 'PENDING';
var FULFILLED = 'FULFILLED';
var REJECTED = 'REJECTED';

function isAction(action) {
  return (0, _isPlainObject2.default)(action) && typeof action.type !== 'undefined';
}

function promiseMiddleware(store) {
  var dispatch = store.dispatch;


  return function (action) {
    if (typeof action === 'function') return action(store);

    if (!isAction(action) || !(0, _isPromise2.default)(action.payload) || action.error) {
      return dispatch(action);
    }

    var type = action.type,
        payload = action.payload,
        meta = action.meta;


    dispatch({ type: type + '_' + PENDING, meta: meta });

    return payload.then(function (result) {
      return dispatch({ type: type + '_' + FULFILLED, payload: result, meta: meta });
    }, function (error) {
      return dispatch({ type: type + '_' + REJECTED, payload: payload, error: error, meta: meta });
    });
  };
}

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = __webpack_require__(317);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _typeof2 = __webpack_require__(38);

var _typeof3 = _interopRequireDefault(_typeof2);

exports.default = isPlainObject;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fnToString = function fnToString(fn) {
  return Function.prototype.toString.call(fn);
};
var objStringValue = fnToString(Object);

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (!obj || (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) !== 'object') {
    return false;
  }

  var proto = typeof obj.constructor === 'function' ? (0, _getPrototypeOf2.default)(obj) : Object.prototype;

  if (proto === null) {
    return true;
  }

  var constructor = proto.constructor;

  return typeof constructor === 'function' && constructor instanceof constructor && fnToString(constructor) === objStringValue;
}

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(512), __esModule: true };

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(515), __esModule: true };

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(516), __esModule: true };

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(517), __esModule: true };

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(521), __esModule: true };

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(29);
var $export = __webpack_require__(11);
var meta = __webpack_require__(72);
var fails = __webpack_require__(60);
var hide = __webpack_require__(62);
var redefineAll = __webpack_require__(135);
var forOf = __webpack_require__(80);
var anInstance = __webpack_require__(131);
var isObject = __webpack_require__(27);
var setToStringTag = __webpack_require__(111);
var dP = __webpack_require__(41).f;
var each = __webpack_require__(167)(0);
var DESCRIPTORS = __webpack_require__(40);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(29).document;
module.exports = document && document.documentElement;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(40) && !__webpack_require__(60)(function () {
  return Object.defineProperty(__webpack_require__(169)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(81);
var ITERATOR = __webpack_require__(25)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(108);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(44);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(25)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 269 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(82);
var gOPS = __webpack_require__(174);
var pIE = __webpack_require__(109);
var toObject = __webpack_require__(83);
var IObject = __webpack_require__(171);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(60)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(41);
var anObject = __webpack_require__(44);
var getKeys = __webpack_require__(82);

module.exports = __webpack_require__(40) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(274);
var hiddenKeys = __webpack_require__(170).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(61);
var toObject = __webpack_require__(83);
var IE_PROTO = __webpack_require__(176)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(61);
var toIObject = __webpack_require__(65);
var arrayIndexOf = __webpack_require__(535)(false);
var IE_PROTO = __webpack_require__(176)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 275 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(44);
var isObject = __webpack_require__(27);
var newPromiseCapability = __webpack_require__(173);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(11);
var aFunction = __webpack_require__(107);
var ctx = __webpack_require__(57);
var forOf = __webpack_require__(80);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(11);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(29);
var core = __webpack_require__(9);
var dP = __webpack_require__(41);
var DESCRIPTORS = __webpack_require__(40);
var SPECIES = __webpack_require__(25)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(44);
var aFunction = __webpack_require__(107);
var SPECIES = __webpack_require__(25)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(77);
var toAbsoluteIndex = __webpack_require__(94);
var toLength = __webpack_require__(30);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(26).f;
var create = __webpack_require__(115);
var redefineAll = __webpack_require__(92);
var ctx = __webpack_require__(52);
var anInstance = __webpack_require__(87);
var forOf = __webpack_require__(142);
var $iterDefine = __webpack_require__(291);
var step = __webpack_require__(292);
var setSpecies = __webpack_require__(145);
var DESCRIPTORS = __webpack_require__(35);
var fastKey = __webpack_require__(114).fastKey;
var validate = __webpack_require__(95);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(92);
var getWeak = __webpack_require__(114).getWeak;
var anObject = __webpack_require__(12);
var isObject = __webpack_require__(14);
var anInstance = __webpack_require__(87);
var forOf = __webpack_require__(142);
var createArrayMethod = __webpack_require__(112);
var $has = __webpack_require__(36);
var validate = __webpack_require__(95);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(13).document;
module.exports = document && document.documentElement;


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(35) && !__webpack_require__(21)(function () {
  return Object.defineProperty(__webpack_require__(188)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 286 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(88);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(14);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(14);
var cof = __webpack_require__(88);
var MATCH = __webpack_require__(16)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(12);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(90);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(64);
var hide = __webpack_require__(42);
var has = __webpack_require__(36);
var Iterators = __webpack_require__(89);
var $iterCreate = __webpack_require__(591);
var setToStringTag = __webpack_require__(93);
var getPrototypeOf = __webpack_require__(117);
var ITERATOR = __webpack_require__(16)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 292 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 293 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(73);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(91);
var gOPS = __webpack_require__(144);
var pIE = __webpack_require__(118);
var toObject = __webpack_require__(77);
var IObject = __webpack_require__(191);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(21)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(36);
var toIObject = __webpack_require__(53);
var arrayIndexOf = __webpack_require__(185)(false);
var IE_PROTO = __webpack_require__(196)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(91);
var toIObject = __webpack_require__(53);
var isEnum = __webpack_require__(118).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(116);
var gOPS = __webpack_require__(144);
var anObject = __webpack_require__(12);
var Reflect = __webpack_require__(13).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(30);
var repeat = __webpack_require__(300);
var defined = __webpack_require__(74);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(76);
var defined = __webpack_require__(74);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(76);
var toLength = __webpack_require__(30);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(13);
var DESCRIPTORS = __webpack_require__(35);
var LIBRARY = __webpack_require__(90);
var $typed = __webpack_require__(201);
var hide = __webpack_require__(42);
var redefineAll = __webpack_require__(92);
var fails = __webpack_require__(21);
var anInstance = __webpack_require__(87);
var toInteger = __webpack_require__(76);
var toLength = __webpack_require__(30);
var toIndex = __webpack_require__(301);
var gOPN = __webpack_require__(116).f;
var dP = __webpack_require__(26).f;
var arrayFill = __webpack_require__(184);
var setToStringTag = __webpack_require__(93);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(16);


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),
/* 305 */
/***/ (function(module, exports) {

var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", 
                "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable", 
                "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", 
                "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", 
                "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate", 
                "truespeed", "typemustmatch", "visible"];
    
var booleanAttrsDict = {};
for(var i=0, len = booleanAttrs.length; i < len; i++) {
  booleanAttrsDict[booleanAttrs[i]] = true;
}
    
function updateAttrs(oldVnode, vnode) {
  var key, cur, old, elm = vnode.elm,
      oldAttrs = oldVnode.data.attrs || {}, attrs = vnode.data.attrs || {};
  
  // update modified attributes, add new attributes
  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      // TODO: add support to namespaced attributes (setAttributeNS)
      if(!cur && booleanAttrsDict[key])
        elm.removeAttribute(key);
      else
        elm.setAttribute(key, cur);
    }
  }
  //remove removed attributes
  // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
  // the other option is to remove all attributes with value == undefined
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}

module.exports = {create: updateAttrs, update: updateAttrs};


/***/ }),
/* 306 */
/***/ (function(module, exports) {

function updateClass(oldVnode, vnode) {
  var cur, name, elm = vnode.elm,
      oldClass = oldVnode.data.class || {},
      klass = vnode.data.class || {};
  for (name in klass) {
    cur = klass[name];
    if (cur !== oldClass[name]) {
      elm.classList[cur ? 'add' : 'remove'](name);
    }
  }
}

module.exports = {create: updateClass, update: updateClass};


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var is = __webpack_require__(205);

function arrInvoker(arr) {
  return function() {
    // Special case when length is two, for performance
    arr.length === 2 ? arr[0](arr[1]) : arr[0].apply(undefined, arr.slice(1));
  };
}

function fnInvoker(o) {
  return function(ev) { o.fn(ev); };
}

function updateEventListeners(oldVnode, vnode) {
  var name, cur, old, elm = vnode.elm,
      oldOn = oldVnode.data.on || {}, on = vnode.data.on;
  if (!on) return;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    if (old === undefined) {
      if (is.array(cur)) {
        elm.addEventListener(name, arrInvoker(cur));
      } else {
        cur = {fn: cur};
        on[name] = cur;
        elm.addEventListener(name, fnInvoker(cur));
      }
    } else if (is.array(old)) {
      // Deliberately modify old array since it's captured in closure created with `arrInvoker`
      old.length = cur.length;
      for (var i = 0; i < old.length; ++i) old[i] = cur[i];
      on[name]  = old;
    } else {
      old.fn = cur;
      on[name] = old;
    }
  }
}

module.exports = {create: updateEventListeners, update: updateEventListeners};


/***/ }),
/* 308 */
/***/ (function(module, exports) {

function updateProps(oldVnode, vnode) {
  var key, cur, old, elm = vnode.elm,
      oldProps = oldVnode.data.props || {}, props = vnode.data.props || {};
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur) {
      elm[key] = cur;
    }
  }
}

module.exports = {create: updateProps, update: updateProps};


/***/ }),
/* 309 */
/***/ (function(module, exports) {

var raf = requestAnimationFrame || setTimeout;
var nextFrame = function(fn) { raf(function() { raf(fn); }); };

function setNextFrame(obj, prop, val) {
  nextFrame(function() { obj[prop] = val; });
}

function updateStyle(oldVnode, vnode) {
  var cur, name, elm = vnode.elm,
      oldStyle = oldVnode.data.style || {},
      style = vnode.data.style || {},
      oldHasDel = 'delayed' in oldStyle;
  for (name in style) {
    cur = style[name];
    if (name === 'delayed') {
      for (name in style.delayed) {
        cur = style.delayed[name];
        if (!oldHasDel || cur !== oldStyle.delayed[name]) {
          setNextFrame(elm.style, name, cur);
        }
      }
    } else if (name !== 'remove' && cur !== oldStyle[name]) {
      elm.style[name] = cur;
    }
  }
}

function applyDestroyStyle(vnode) {
  var style, name, elm = vnode.elm, s = vnode.data.style;
  if (!s || !(style = s.destroy)) return;
  for (name in style) {
    elm.style[name] = style[name];
  }
}

function applyRemoveStyle(vnode, rm) {
  var s = vnode.data.style;
  if (!s || !s.remove) {
    rm();
    return;
  }
  var name, elm = vnode.elm, idx, i = 0, maxDur = 0,
      compStyle, style = s.remove, amount = 0, applied = [];
  for (name in style) {
    applied.push(name);
    elm.style[name] = style[name];
  }
  compStyle = getComputedStyle(elm);
  var props = compStyle['transition-property'].split(', ');
  for (; i < props.length; ++i) {
    if(applied.indexOf(props[i]) !== -1) amount++;
  }
  elm.addEventListener('transitionend', function(ev) {
    if (ev.target === elm) --amount;
    if (amount === 0) rm();
  });
}

module.exports = {create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle};


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint newcap: false
/* global require, module, document, Element */


var VNode = __webpack_require__(311);
var is = __webpack_require__(205);

function isUndef(s) { return s === undefined; }
function isDef(s) { return s !== undefined; }

function emptyNodeAt(elm) {
  return VNode(elm.tagName, {}, [], undefined, elm);
}

var emptyNode = VNode('', {}, [], undefined, undefined);

function sameVnode(vnode1, vnode2) {
  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, map = {}, key;
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) map[key] = i;
  }
  return map;
}

function createRmCb(childElm, listeners) {
  return function() {
    if (--listeners === 0) childElm.parentElement.removeChild(childElm);
  };
}

var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];

function init(modules) {
  var i, j, cbs = {};
  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);
    }
  }

  function createElm(vnode, insertedVnodeQueue) {
    var i, data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) i(vnode);
      if (isDef(i = data.vnode)) vnode = i;
    }
    var elm, children = vnode.children, sel = vnode.sel;
    if (isDef(sel)) {
      // Parse selector
      var hashIdx = sel.indexOf('#');
      var dotIdx = sel.indexOf('.', hashIdx);
      var hash = hashIdx > 0 ? hashIdx : sel.length;
      var dot = dotIdx > 0 ? dotIdx : sel.length;
      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? document.createElementNS(i, tag)
                                                          : document.createElement(tag);
      if (hash < dot) elm.id = sel.slice(hash + 1, dot);
      if (dotIdx > 0) elm.className = sel.slice(dot+1).replace(/\./g, ' ');
      if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
          elm.appendChild(createElm(children[i], insertedVnodeQueue));
        }
      } else if (is.primitive(vnode.text)) {
        elm.appendChild(document.createTextNode(vnode.text));
      }
      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (i.create) i.create(emptyNode, vnode);
        if (i.insert) insertedVnodeQueue.push(vnode);
      }
    } else {
      elm = vnode.elm = document.createTextNode(vnode.text);
    }
    return vnode.elm;
  }

  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      parentElm.insertBefore(createElm(vnodes[startIdx], insertedVnodeQueue), before);
    }
  }

  function invokeDestroyHook(vnode) {
    var i = vnode.data, j;
    if (isDef(i)) {
      if (isDef(i = i.hook) && isDef(i = i.destroy)) i(vnode);
      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var i, listeners, rm, ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm, listeners);
          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {
            i(ch, rm);
          } else {
            rm();
          }
        } else { // Text node
          parentElm.removeChild(ch.elm);
        }
      }
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
    var oldStartIdx = 0, newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, before;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling);
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) { // New element
          parentElm.insertBefore(createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
          oldCh[idxInOld] = undefined;
          parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      before = isUndef(newCh[newEndIdx+1]) ? null : newCh[newEndIdx+1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
    var i, hook;
    if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
      i(oldVnode, vnode);
    }
    if (isDef(i = oldVnode.data) && isDef(i = i.vnode)) oldVnode = i;
    if (isDef(i = vnode.data) && isDef(i = i.vnode)) vnode = i;
    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;
    if (oldVnode === vnode) return;
    if (isDef(vnode.data)) {
      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
      i = vnode.data.hook;
      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) {
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      }
    } else if (oldVnode.text !== vnode.text) {
      elm.textContent = vnode.text;
    }
    if (isDef(hook) && isDef(i = hook.postpatch)) {
      i(oldVnode, vnode);
    }
  }

  return function(oldVnode, vnode) {
    var i;
    var insertedVnodeQueue = [];
    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();
    if (oldVnode instanceof Element) {
      if (oldVnode.parentElement !== null) {
        createElm(vnode, insertedVnodeQueue);
        oldVnode.parentElement.replaceChild(vnode.elm, oldVnode);
      } else {
        oldVnode = emptyNodeAt(oldVnode);
        patchVnode(oldVnode, vnode, insertedVnodeQueue);
      }
    } else {
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    }
    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
    }
    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
    return vnode;
  };
}

module.exports = {init: init};


/***/ }),
/* 311 */
/***/ (function(module, exports) {

module.exports = function(sel, data, children, text, elm) {
  var key = data === undefined ? undefined : data.key;
  return {sel: sel, data: data, children: children,
          text: text, elm: elm, key: key};
};


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = __webpack_require__(23);
var WGLUPreserveGLState = __webpack_require__(313);

var uiVS = [
  'attribute vec2 position;',

  'uniform mat4 projectionMat;',

  'void main() {',
  '  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );',
  '}',
].join('\n');

var uiFS = [
  'precision mediump float;',

  'uniform vec4 color;',

  'void main() {',
  '  gl_FragColor = color;',
  '}',
].join('\n');

var DEG2RAD = Math.PI/180.0;

// The gear has 6 identical sections, each spanning 60 degrees.
var kAnglePerGearSection = 60;

// Half-angle of the span of the outer rim.
var kOuterRimEndAngle = 12;

// Angle between the middle of the outer rim and the start of the inner rim.
var kInnerRimBeginAngle = 20;

// Distance from center to outer rim, normalized so that the entire model
// fits in a [-1, 1] x [-1, 1] square.
var kOuterRadius = 1;

// Distance from center to depressed rim, in model units.
var kMiddleRadius = 0.75;

// Radius of the inner hollow circle, in model units.
var kInnerRadius = 0.3125;

// Center line thickness in DP.
var kCenterLineThicknessDp = 4;

// Button width in DP.
var kButtonWidthDp = 28;

// Factor to scale the touch area that responds to the touch.
var kTouchSlopFactor = 1.5;

var Angles = [
  0, kOuterRimEndAngle, kInnerRimBeginAngle,
  kAnglePerGearSection - kInnerRimBeginAngle,
  kAnglePerGearSection - kOuterRimEndAngle
];

/**
 * Renders the alignment line and "options" gear. It is assumed that the canvas
 * this is rendered into covers the entire screen (or close to it.)
 */
function CardboardUI(gl) {
  this.gl = gl;

  this.attribs = {
    position: 0
  };
  this.program = Util.linkProgram(gl, uiVS, uiFS, this.attribs);
  this.uniforms = Util.getProgramUniforms(gl, this.program);

  this.vertexBuffer = gl.createBuffer();
  this.gearOffset = 0;
  this.gearVertexCount = 0;
  this.arrowOffset = 0;
  this.arrowVertexCount = 0;

  this.projMat = new Float32Array(16);

  this.listener = null;

  this.onResize();
};

/**
 * Tears down all the resources created by the UI renderer.
 */
CardboardUI.prototype.destroy = function() {
  var gl = this.gl;

  if (this.listener) {
    gl.canvas.removeEventListener('click', this.listener, false);
  }

  gl.deleteProgram(this.program);
  gl.deleteBuffer(this.vertexBuffer);
};

/**
 * Adds a listener to clicks on the gear and back icons
 */
CardboardUI.prototype.listen = function(optionsCallback, backCallback) {
  var canvas = this.gl.canvas;
  this.listener = function(event) {
    var midline = canvas.clientWidth / 2;
    var buttonSize = kButtonWidthDp * kTouchSlopFactor;
    // Check to see if the user clicked on (or around) the gear icon
    if (event.clientX > midline - buttonSize &&
        event.clientX < midline + buttonSize &&
        event.clientY > canvas.clientHeight - buttonSize) {
      optionsCallback(event);
    }
    // Check to see if the user clicked on (or around) the back icon
    else if (event.clientX < buttonSize && event.clientY < buttonSize) {
      backCallback(event);
    }
  };
  canvas.addEventListener('click', this.listener, false);
};

/**
 * Builds the UI mesh.
 */
CardboardUI.prototype.onResize = function() {
  var gl = this.gl;
  var self = this;

  var glState = [
    gl.ARRAY_BUFFER_BINDING
  ];

  WGLUPreserveGLState(gl, glState, function(gl) {
    var vertices = [];

    var midline = gl.drawingBufferWidth / 2;

    // The gl buffer size will likely be smaller than the physical pixel count.
    // So we need to scale the dps down based on the actual buffer size vs physical pixel count.
    // This will properly size the ui elements no matter what the gl buffer resolution is
    var physicalPixels = Math.max(screen.width, screen.height) * window.devicePixelRatio;
    var scalingRatio = gl.drawingBufferWidth / physicalPixels;
    var dps = scalingRatio *  window.devicePixelRatio;

    var lineWidth = kCenterLineThicknessDp * dps / 2;
    var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
    var buttonScale = kButtonWidthDp * dps / 2;
    var buttonBorder = ((kButtonWidthDp * kTouchSlopFactor) - kButtonWidthDp) * dps;

    // Build centerline
    vertices.push(midline - lineWidth, buttonSize);
    vertices.push(midline - lineWidth, gl.drawingBufferHeight);
    vertices.push(midline + lineWidth, buttonSize);
    vertices.push(midline + lineWidth, gl.drawingBufferHeight);

    // Build gear
    self.gearOffset = (vertices.length / 2);

    function addGearSegment(theta, r) {
      var angle = (90 - theta) * DEG2RAD;
      var x = Math.cos(angle);
      var y = Math.sin(angle);
      vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale);
      vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
    }

    for (var i = 0; i <= 6; i++) {
      var segmentTheta = i * kAnglePerGearSection;

      addGearSegment(segmentTheta, kOuterRadius);
      addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
      addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
      addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
      addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
    }

    self.gearVertexCount = (vertices.length / 2) - self.gearOffset;

    // Build back arrow
    self.arrowOffset = (vertices.length / 2);

    function addArrowVertex(x, y) {
      vertices.push(buttonBorder + x, gl.drawingBufferHeight - buttonBorder - y);
    }

    var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);

    addArrowVertex(0, buttonScale);
    addArrowVertex(buttonScale, 0);
    addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
    addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);

    addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
    addArrowVertex(0, buttonScale);
    addArrowVertex(buttonScale, buttonScale * 2);
    addArrowVertex(buttonScale + angledLineWidth, (buttonScale * 2) - angledLineWidth);

    addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
    addArrowVertex(0, buttonScale);

    addArrowVertex(angledLineWidth, buttonScale - lineWidth);
    addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
    addArrowVertex(angledLineWidth, buttonScale + lineWidth);
    addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);

    self.arrowVertexCount = (vertices.length / 2) - self.arrowOffset;

    // Buffer data
    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  });
};

/**
 * Performs distortion pass on the injected backbuffer, rendering it to the real
 * backbuffer.
 */
CardboardUI.prototype.render = function() {
  var gl = this.gl;
  var self = this;

  var glState = [
    gl.CULL_FACE,
    gl.DEPTH_TEST,
    gl.BLEND,
    gl.SCISSOR_TEST,
    gl.STENCIL_TEST,
    gl.COLOR_WRITEMASK,
    gl.VIEWPORT,

    gl.CURRENT_PROGRAM,
    gl.ARRAY_BUFFER_BINDING
  ];

  WGLUPreserveGLState(gl, glState, function(gl) {
    // Make sure the GL state is in a good place
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.colorMask(true, true, true, true);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

    self.renderNoState();
  });
};

CardboardUI.prototype.renderNoState = function() {
  var gl = this.gl;

  // Bind distortion program and mesh
  gl.useProgram(this.program);

  gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
  gl.enableVertexAttribArray(this.attribs.position);
  gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 8, 0);

  gl.uniform4f(this.uniforms.color, 1.0, 1.0, 1.0, 1.0);

  Util.orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024.0);
  gl.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);

  // Draws UI element
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
  gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
};

module.exports = CardboardUI;


/***/ }),
/* 313 */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2016, Brandon Jones.
 * https://github.com/toji/webgl-utils/blob/master/src/wglu-preserve-state.js
 * LICENSE: https://github.com/toji/webgl-utils/blob/master/LICENSE.md
 */

function WGLUPreserveGLState(gl, bindings, callback) {
  if (!bindings) {
    callback(gl);
    return;
  }

  var boundValues = [];

  var activeTexture = null;
  for (var i = 0; i < bindings.length; ++i) {
    var binding = bindings[i];
    switch (binding) {
      case gl.TEXTURE_BINDING_2D:
      case gl.TEXTURE_BINDING_CUBE_MAP:
        var textureUnit = bindings[++i];
        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
          console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
          boundValues.push(null, null);
          break;
        }
        if (!activeTexture) {
          activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
        }
        gl.activeTexture(textureUnit);
        boundValues.push(gl.getParameter(binding), null);
        break;
      case gl.ACTIVE_TEXTURE:
        activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
        boundValues.push(null);
        break;
      default:
        boundValues.push(gl.getParameter(binding));
        break;
    }
  }

  callback(gl);

  for (var i = 0; i < bindings.length; ++i) {
    var binding = bindings[i];
    var boundValue = boundValues[i];
    switch (binding) {
      case gl.ACTIVE_TEXTURE:
        break; // Ignore this binding, since we special-case it to happen last.
      case gl.ARRAY_BUFFER_BINDING:
        gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
        break;
      case gl.COLOR_CLEAR_VALUE:
        gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
        break;
      case gl.COLOR_WRITEMASK:
        gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
        break;
      case gl.CURRENT_PROGRAM:
        gl.useProgram(boundValue);
        break;
      case gl.ELEMENT_ARRAY_BUFFER_BINDING:
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
        break;
      case gl.FRAMEBUFFER_BINDING:
        gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
        break;
      case gl.RENDERBUFFER_BINDING:
        gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
        break;
      case gl.TEXTURE_BINDING_2D:
        var textureUnit = bindings[++i];
        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
          break;
        gl.activeTexture(textureUnit);
        gl.bindTexture(gl.TEXTURE_2D, boundValue);
        break;
      case gl.TEXTURE_BINDING_CUBE_MAP:
        var textureUnit = bindings[++i];
        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
          break;
        gl.activeTexture(textureUnit);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
        break;
      case gl.VIEWPORT:
        gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
        break;
      case gl.BLEND:
      case gl.CULL_FACE:
      case gl.DEPTH_TEST:
      case gl.SCISSOR_TEST:
      case gl.STENCIL_TEST:
        if (boundValue) {
          gl.enable(binding);
        } else {
          gl.disable(binding);
        }
        break;
      default:
        console.log("No GL restore behavior for 0x" + binding.toString(16));
        break;
    }

    if (activeTexture) {
      gl.activeTexture(activeTexture);
    }
  }
}

module.exports = WGLUPreserveGLState;


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Distortion = __webpack_require__(704);
var MathUtil = __webpack_require__(96);
var Util = __webpack_require__(23);

function Device(params) {
  this.width = params.width || Util.getScreenWidth();
  this.height = params.height || Util.getScreenHeight();
  this.widthMeters = params.widthMeters;
  this.heightMeters = params.heightMeters;
  this.bevelMeters = params.bevelMeters;
}


// Fallback Android device (based on Nexus 5 measurements) for use when
// we can't recognize an Android device.
var DEFAULT_ANDROID = new Device({
  widthMeters: 0.110,
  heightMeters: 0.062,
  bevelMeters: 0.004
});

// Fallback iOS device (based on iPhone6) for use when
// we can't recognize an Android device.
var DEFAULT_IOS = new Device({
  widthMeters: 0.1038,
  heightMeters: 0.0584,
  bevelMeters: 0.004
});


var Viewers = {
  CardboardV1: new CardboardViewer({
    id: 'CardboardV1',
    label: 'Cardboard I/O 2014',
    fov: 40,
    interLensDistance: 0.060,
    baselineLensDistance: 0.035,
    screenLensDistance: 0.042,
    distortionCoefficients: [0.441, 0.156],
    inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139,
      -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841,
      0.0651772, -0.01488963, 0.001559834]
  }),
  CardboardV2: new CardboardViewer({
    id: 'CardboardV2',
    label: 'Cardboard I/O 2015',
    fov: 60,
    interLensDistance: 0.064,
    baselineLensDistance: 0.035,
    screenLensDistance: 0.039,
    distortionCoefficients: [0.34, 0.55],
    inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051,
      1.0560602, -0.58208317, 0.21609078, -0.05444823, 0.009177956,
      -9.904169E-4, 6.183535E-5, -1.6981803E-6]
  })
};


var DEFAULT_LEFT_CENTER = {x: 0.5, y: 0.5};
var DEFAULT_RIGHT_CENTER = {x: 0.5, y: 0.5};

/**
 * Manages information about the device and the viewer.
 *
 * deviceParams indicates the parameters of the device to use (generally
 * obtained from dpdb.getDeviceParams()). Can be null to mean no device
 * params were found.
 */
function DeviceInfo(deviceParams) {
  this.viewer = Viewers.CardboardV2;
  this.updateDeviceParams(deviceParams);
  this.distortion = new Distortion(this.viewer.distortionCoefficients);
}

DeviceInfo.prototype.updateDeviceParams = function(deviceParams) {
  this.device = this.determineDevice_(deviceParams) || this.device;
};

DeviceInfo.prototype.getDevice = function() {
  return this.device;
};

DeviceInfo.prototype.setViewer = function(viewer) {
  this.viewer = viewer;
  this.distortion = new Distortion(this.viewer.distortionCoefficients);
};

DeviceInfo.prototype.determineDevice_ = function(deviceParams) {
  if (!deviceParams) {
    // No parameters, so use a default.
    if (Util.isIOS()) {
      console.warn('Using fallback iOS device measurements.');
      return DEFAULT_IOS;
    } else {
      console.warn('Using fallback Android device measurements.');
      return DEFAULT_ANDROID;
    }
  }

  // Compute device screen dimensions based on deviceParams.
  var METERS_PER_INCH = 0.0254;
  var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
  var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
  var width = Util.getScreenWidth();
  var height = Util.getScreenHeight();
  return new Device({
    widthMeters: metersPerPixelX * width,
    heightMeters: metersPerPixelY * height,
    bevelMeters: deviceParams.bevelMm * 0.001,
  });
};

/**
 * Calculates field of view for the left eye.
 */
DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function() {
  var viewer = this.viewer;
  var device = this.device;
  var distortion = this.distortion;

  // Device.height and device.width for device in portrait mode, so transpose.
  var eyeToScreenDistance = viewer.screenLensDistance;

  var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
  var innerDist = viewer.interLensDistance / 2;
  var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
  var topDist = device.heightMeters - bottomDist;

  var outerAngle = MathUtil.radToDeg * Math.atan(
      distortion.distort(outerDist / eyeToScreenDistance));
  var innerAngle = MathUtil.radToDeg * Math.atan(
      distortion.distort(innerDist / eyeToScreenDistance));
  var bottomAngle = MathUtil.radToDeg * Math.atan(
      distortion.distort(bottomDist / eyeToScreenDistance));
  var topAngle = MathUtil.radToDeg * Math.atan(
      distortion.distort(topDist / eyeToScreenDistance));

  return {
    leftDegrees: Math.min(outerAngle, viewer.fov),
    rightDegrees: Math.min(innerAngle, viewer.fov),
    downDegrees: Math.min(bottomAngle, viewer.fov),
    upDegrees: Math.min(topAngle, viewer.fov)
  };
};

/**
 * Calculates the tan-angles from the maximum FOV for the left eye for the
 * current device and screen parameters.
 */
DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function() {
  var viewer = this.viewer;
  var device = this.device;
  var distortion = this.distortion;

  // Tan-angles from the max FOV.
  var fovLeft = Math.tan(-MathUtil.degToRad * viewer.fov);
  var fovTop = Math.tan(MathUtil.degToRad * viewer.fov);
  var fovRight = Math.tan(MathUtil.degToRad * viewer.fov);
  var fovBottom = Math.tan(-MathUtil.degToRad * viewer.fov);
  // Viewport size.
  var halfWidth = device.widthMeters / 4;
  var halfHeight = device.heightMeters / 2;
  // Viewport center, measured from left lens position.
  var verticalLensOffset = (viewer.baselineLensDistance - device.bevelMeters - halfHeight);
  var centerX = viewer.interLensDistance / 2 - halfWidth;
  var centerY = -verticalLensOffset;
  var centerZ = viewer.screenLensDistance;
  // Tan-angles of the viewport edges, as seen through the lens.
  var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
  var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
  var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
  var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
  // Compare the two sets of tan-angles and take the value closer to zero on each side.
  var result = new Float32Array(4);
  result[0] = Math.max(fovLeft, screenLeft);
  result[1] = Math.min(fovTop, screenTop);
  result[2] = Math.min(fovRight, screenRight);
  result[3] = Math.max(fovBottom, screenBottom);
  return result;
};

/**
 * Calculates the tan-angles from the maximum FOV for the left eye for the
 * current device and screen parameters, assuming no lenses.
 */
DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function() {
  var viewer = this.viewer;
  var device = this.device;
  var distortion = this.distortion;

  var result = new Float32Array(4);
  // Tan-angles from the max FOV.
  var fovLeft = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
  var fovTop = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
  var fovRight = distortion.distortInverse(Math.tan(MathUtil.degToRad * viewer.fov));
  var fovBottom = distortion.distortInverse(Math.tan(-MathUtil.degToRad * viewer.fov));
  // Viewport size.
  var halfWidth = device.widthMeters / 4;
  var halfHeight = device.heightMeters / 2;
  // Viewport center, measured from left lens position.
  var verticalLensOffset = (viewer.baselineLensDistance - device.bevelMeters - halfHeight);
  var centerX = viewer.interLensDistance / 2 - halfWidth;
  var centerY = -verticalLensOffset;
  var centerZ = viewer.screenLensDistance;
  // Tan-angles of the viewport edges, as seen through the lens.
  var screenLeft = (centerX - halfWidth) / centerZ;
  var screenTop = (centerY + halfHeight) / centerZ;
  var screenRight = (centerX + halfWidth) / centerZ;
  var screenBottom = (centerY - halfHeight) / centerZ;
  // Compare the two sets of tan-angles and take the value closer to zero on each side.
  result[0] = Math.max(fovLeft, screenLeft);
  result[1] = Math.min(fovTop, screenTop);
  result[2] = Math.min(fovRight, screenRight);
  result[3] = Math.max(fovBottom, screenBottom);
  return result;
};

/**
 * Calculates the screen rectangle visible from the left eye for the
 * current device and screen parameters.
 */
DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function(undistortedFrustum) {
  var viewer = this.viewer;
  var device = this.device;

  var dist = viewer.screenLensDistance;
  var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
  var eyeY = viewer.baselineLensDistance - device.bevelMeters;
  var left = (undistortedFrustum[0] * dist + eyeX) / device.widthMeters;
  var top = (undistortedFrustum[1] * dist + eyeY) / device.heightMeters;
  var right = (undistortedFrustum[2] * dist + eyeX) / device.widthMeters;
  var bottom = (undistortedFrustum[3] * dist + eyeY) / device.heightMeters;
  return {
    x: left,
    y: bottom,
    width: right - left,
    height: top - bottom
  };
};

DeviceInfo.prototype.getFieldOfViewLeftEye = function(opt_isUndistorted) {
  return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() :
      this.getDistortedFieldOfViewLeftEye();
};

DeviceInfo.prototype.getFieldOfViewRightEye = function(opt_isUndistorted) {
  var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
  return {
    leftDegrees: fov.rightDegrees,
    rightDegrees: fov.leftDegrees,
    upDegrees: fov.upDegrees,
    downDegrees: fov.downDegrees
  };
};

/**
 * Calculates undistorted field of view for the left eye.
 */
DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function() {
  var p = this.getUndistortedParams_();

  return {
    leftDegrees: MathUtil.radToDeg * Math.atan(p.outerDist),
    rightDegrees: MathUtil.radToDeg * Math.atan(p.innerDist),
    downDegrees: MathUtil.radToDeg * Math.atan(p.bottomDist),
    upDegrees: MathUtil.radToDeg * Math.atan(p.topDist)
  };
};

DeviceInfo.prototype.getUndistortedViewportLeftEye = function() {
  var p = this.getUndistortedParams_();
  var viewer = this.viewer;
  var device = this.device;

  // Distances stored in local variables are in tan-angle units unless otherwise
  // noted.
  var eyeToScreenDistance = viewer.screenLensDistance;
  var screenWidth = device.widthMeters / eyeToScreenDistance;
  var screenHeight = device.heightMeters / eyeToScreenDistance;
  var xPxPerTanAngle = device.width / screenWidth;
  var yPxPerTanAngle = device.height / screenHeight;

  var x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle);
  var y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
  return {
    x: x,
    y: y,
    width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
    height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
  };
};

DeviceInfo.prototype.getUndistortedParams_ = function() {
  var viewer = this.viewer;
  var device = this.device;
  var distortion = this.distortion;

  // Most of these variables in tan-angle units.
  var eyeToScreenDistance = viewer.screenLensDistance;
  var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
  var screenWidth = device.widthMeters / eyeToScreenDistance;
  var screenHeight = device.heightMeters / eyeToScreenDistance;

  var eyePosX = screenWidth / 2 - halfLensDistance;
  var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;

  var maxFov = viewer.fov;
  var viewerMax = distortion.distortInverse(Math.tan(MathUtil.degToRad * maxFov));
  var outerDist = Math.min(eyePosX, viewerMax);
  var innerDist = Math.min(halfLensDistance, viewerMax);
  var bottomDist = Math.min(eyePosY, viewerMax);
  var topDist = Math.min(screenHeight - eyePosY, viewerMax);

  return {
    outerDist: outerDist,
    innerDist: innerDist,
    topDist: topDist,
    bottomDist: bottomDist,
    eyePosX: eyePosX,
    eyePosY: eyePosY
  };
};


function CardboardViewer(params) {
  // A machine readable ID.
  this.id = params.id;
  // A human readable label.
  this.label = params.label;

  // Field of view in degrees (per side).
  this.fov = params.fov;

  // Distance between lens centers in meters.
  this.interLensDistance = params.interLensDistance;
  // Distance between viewer baseline and lens center in meters.
  this.baselineLensDistance = params.baselineLensDistance;
  // Screen-to-lens distance in meters.
  this.screenLensDistance = params.screenLensDistance;

  // Distortion coefficients.
  this.distortionCoefficients = params.distortionCoefficients;
  // Inverse distortion coefficients.
  // TODO: Calculate these from distortionCoefficients in the future.
  this.inverseCoefficients = params.inverseCoefficients;
}

// Export viewer information.
DeviceInfo.Viewers = Viewers;
module.exports = DeviceInfo;


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VRDisplay = __webpack_require__(55).VRDisplay;
var HMDVRDevice = __webpack_require__(55).HMDVRDevice;
var PositionSensorVRDevice = __webpack_require__(55).PositionSensorVRDevice;

/**
 * Wraps a VRDisplay and exposes it as a HMDVRDevice
 */
function VRDisplayHMDDevice(display) {
  this.display = display;

  this.hardwareUnitId = display.displayId;
  this.deviceId = 'webvr-polyfill:HMD:' + display.displayId;
  this.deviceName = display.displayName + ' (HMD)';
}
VRDisplayHMDDevice.prototype = new HMDVRDevice();

VRDisplayHMDDevice.prototype.getEyeParameters = function(whichEye) {
  var eyeParameters = this.display.getEyeParameters(whichEye);

  return {
    currentFieldOfView: eyeParameters.fieldOfView,
    maximumFieldOfView: eyeParameters.fieldOfView,
    minimumFieldOfView: eyeParameters.fieldOfView,
    recommendedFieldOfView: eyeParameters.fieldOfView,
    eyeTranslation: { x: eyeParameters.offset[0], y: eyeParameters.offset[1], z: eyeParameters.offset[2] },
    renderRect: {
      x: (whichEye == 'right') ? eyeParameters.renderWidth : 0,
      y: 0,
      width: eyeParameters.renderWidth,
      height: eyeParameters.renderHeight
    }
  };
};

VRDisplayHMDDevice.prototype.setFieldOfView =
    function(opt_fovLeft, opt_fovRight, opt_zNear, opt_zFar) {
  // Not supported. getEyeParameters reports that the min, max, and recommended
  // FoV is all the same, so no adjustment can be made.
};

// TODO: Need to hook requestFullscreen to see if a wrapped VRDisplay was passed
// in as an option. If so we should prevent the default fullscreen behavior and
// call VRDisplay.requestPresent instead.

/**
 * Wraps a VRDisplay and exposes it as a PositionSensorVRDevice
 */
function VRDisplayPositionSensorDevice(display) {
  this.display = display;

  this.hardwareUnitId = display.displayId;
  this.deviceId = 'webvr-polyfill:PositionSensor: ' + display.displayId;
  this.deviceName = display.displayName + ' (PositionSensor)';
}
VRDisplayPositionSensorDevice.prototype = new PositionSensorVRDevice();

VRDisplayPositionSensorDevice.prototype.getState = function() {
  var pose = this.display.getPose();
  return {
    position: pose.position ? { x: pose.position[0], y: pose.position[1], z: pose.position[2] } : null,
    orientation: pose.orientation ? { x: pose.orientation[0], y: pose.orientation[1], z: pose.orientation[2], w: pose.orientation[3] } : null,
    linearVelocity: null,
    linearAcceleration: null,
    angularVelocity: null,
    angularAcceleration: null
  };
};

VRDisplayPositionSensorDevice.prototype.resetState = function() {
  return this.positionDevice.resetPose();
};


module.exports.VRDisplayHMDDevice = VRDisplayHMDDevice;
module.exports.VRDisplayPositionSensorDevice = VRDisplayPositionSensorDevice;



/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// workaround because src/player.js is es6, and new behavior is to export the module as:
// { __esModule: true, defualt: function }
// Which breaks our previous claraplayer umd export. Use this as a workaround.
module.exports = __webpack_require__(413).default;

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(524), __esModule: true };

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(109);
var createDesc = __webpack_require__(110);
var toIObject = __webpack_require__(65);
var toPrimitive = __webpack_require__(180);
var has = __webpack_require__(61);
var IE8_DOM_DEFINE = __webpack_require__(264);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(40) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {(function (w) {
  "use strict";

  var a2b = w.atob;

  function atob(str) {
    // normal window
    if ('function' === typeof a2b) {
      return a2b(str);
    }
    // browserify (web worker)
    else if ('function' === typeof Buffer) {
      return new Buffer(str, 'base64').toString('binary');
    }
    // ios web worker with base64js
    else if ('object' === typeof w.base64js) {
      // bufferToBinaryString
      // https://github.com/coolaj86/unibabel-js/blob/master/index.js#L50
      var buf = w.base64js.b64ToByteArray(str);

      return Array.prototype.map.call(buf, function (ch) {
        return String.fromCharCode(ch);
      }).join('');
    }
    // ios web worker without base64js
    else {
      throw new Error("you're probably in an ios webworker. please include use beatgammit's base64-js");
    }
  }

  w.atob = atob;

  if (true) {
    module.exports = atob;
  }
}(window));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(99).Buffer))

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
// Drawing utility functions.

// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

exports.default = { line: line };

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _path = __webpack_require__(100);

var _path2 = _interopRequireDefault(_path);

var _sfnt = __webpack_require__(329);

var _sfnt2 = _interopRequireDefault(_sfnt);

var _encoding = __webpack_require__(121);

var _glyphset = __webpack_require__(150);

var _glyphset2 = _interopRequireDefault(_glyphset);

var _substitution = __webpack_require__(324);

var _substitution2 = _interopRequireDefault(_substitution);

var _util = __webpack_require__(224);

var _hintingtt = __webpack_require__(322);

var _hintingtt2 = _interopRequireDefault(_hintingtt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef FontOptions
 * @type Object
 * @property {Boolean} empty - whether to create a new empty font
 * @property {string} familyName
 * @property {string} styleName
 * @property {string=} fullName
 * @property {string=} postScriptName
 * @property {string=} designer
 * @property {string=} designerURL
 * @property {string=} manufacturer
 * @property {string=} manufacturerURL
 * @property {string=} license
 * @property {string=} licenseURL
 * @property {string=} version
 * @property {string=} description
 * @property {string=} copyright
 * @property {string=} trademark
 * @property {Number} unitsPerEm
 * @property {Number} ascender
 * @property {Number} descender
 * @property {Number} createdTimestamp
 * @property {string=} weightClass
 * @property {string=} widthClass
 * @property {string=} fsSelection
 */

/**
 * A Font represents a loaded OpenType font file.
 * It contains a set of glyphs and methods to draw text on a drawing context,
 * or to get a path representing the text.
 * @exports opentype.Font
 * @class
 * @param {FontOptions}
 * @constructor
 */
function Font(options) {
    options = options || {};

    if (!options.empty) {
        // Check that we've provided the minimum set of names.
        (0, _util.checkArgument)(options.familyName, 'When creating a new Font object, familyName is required.');
        (0, _util.checkArgument)(options.styleName, 'When creating a new Font object, styleName is required.');
        (0, _util.checkArgument)(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
        (0, _util.checkArgument)(options.ascender, 'When creating a new Font object, ascender is required.');
        (0, _util.checkArgument)(options.descender, 'When creating a new Font object, descender is required.');
        (0, _util.checkArgument)(options.descender < 0, 'Descender should be negative (e.g. -512).');

        // OS X will complain if the names are empty, so we put a single space everywhere by default.
        this.names = {
            fontFamily: { en: options.familyName || ' ' },
            fontSubfamily: { en: options.styleName || ' ' },
            fullName: { en: options.fullName || options.familyName + ' ' + options.styleName },
            postScriptName: { en: options.postScriptName || options.familyName + options.styleName },
            designer: { en: options.designer || ' ' },
            designerURL: { en: options.designerURL || ' ' },
            manufacturer: { en: options.manufacturer || ' ' },
            manufacturerURL: { en: options.manufacturerURL || ' ' },
            license: { en: options.license || ' ' },
            licenseURL: { en: options.licenseURL || ' ' },
            version: { en: options.version || 'Version 0.1' },
            description: { en: options.description || ' ' },
            copyright: { en: options.copyright || ' ' },
            trademark: { en: options.trademark || ' ' }
        };
        this.unitsPerEm = options.unitsPerEm || 1000;
        this.ascender = options.ascender;
        this.descender = options.descender;
        this.createdTimestamp = options.createdTimestamp;
        this.tables = { os2: {
                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
            } };
    }

    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
    this.glyphs = new _glyphset2.default.GlyphSet(this, options.glyphs || []);
    this.encoding = new _encoding.DefaultEncoding(this);
    this.substitution = new _substitution2.default(this);
    this.tables = this.tables || {};

    Object.defineProperty(this, 'hinting', {
        get: function get() {
            if (this._hinting) return this._hinting;
            if (this.outlinesFormat === 'truetype') {
                return this._hinting = new _hintingtt2.default(this);
            }
        }
    });
}

/**
 * Check if the font has a glyph for the given character.
 * @param  {string}
 * @return {Boolean}
 */
// The Font object

Font.prototype.hasChar = function (c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};

/**
 * Convert the given character to a single glyph index.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {Number}
 */
Font.prototype.charToGlyphIndex = function (s) {
    return this.encoding.charToGlyphIndex(s);
};

/**
 * Convert the given character to a single Glyph object.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {opentype.Glyph}
 */
Font.prototype.charToGlyph = function (c) {
    var glyphIndex = this.charToGlyphIndex(c);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        // .notdef
        glyph = this.glyphs.get(0);
    }

    return glyph;
};

/**
 * Convert the given text to a list of Glyph objects.
 * Note that there is no strict one-to-one mapping between characters and
 * glyphs, so the list of returned glyphs can be larger or smaller than the
 * length of the given string.
 * @param  {string}
 * @param  {GlyphRenderOptions} [options]
 * @return {opentype.Glyph[]}
 */
Font.prototype.stringToGlyphs = function (s, options) {
    options = options || this.defaultRenderOptions;
    // Get glyph indexes
    var indexes = [];
    for (var i = 0; i < s.length; i += 1) {
        var c = s[i];
        indexes.push(this.charToGlyphIndex(c));
    }
    var length = indexes.length;

    // Apply substitutions on glyph indexes
    if (options.features) {
        var script = options.script || this.substitution.getDefaultScriptName();
        var manyToOne = [];
        if (options.features.liga) manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language));
        if (options.features.rlig) manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language));
        for (var _i = 0; _i < length; _i += 1) {
            for (var j = 0; j < manyToOne.length; j++) {
                var ligature = manyToOne[j];
                var components = ligature.sub;
                var compCount = components.length;
                var k = 0;
                while (k < compCount && components[k] === indexes[_i + k]) {
                    k++;
                }if (k === compCount) {
                    indexes.splice(_i, compCount, ligature.by);
                    length = length - compCount + 1;
                }
            }
        }
    }

    // convert glyph indexes to glyph objects
    var glyphs = new Array(length);
    var notdef = this.glyphs.get(0);
    for (var _i2 = 0; _i2 < length; _i2 += 1) {
        glyphs[_i2] = this.glyphs.get(indexes[_i2]) || notdef;
    }
    return glyphs;
};

/**
 * @param  {string}
 * @return {Number}
 */
Font.prototype.nameToGlyphIndex = function (name) {
    return this.glyphNames.nameToGlyphIndex(name);
};

/**
 * @param  {string}
 * @return {opentype.Glyph}
 */
Font.prototype.nameToGlyph = function (name) {
    var glyphIndex = this.nameToGlyphIndex(name);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        // .notdef
        glyph = this.glyphs.get(0);
    }

    return glyph;
};

/**
 * @param  {Number}
 * @return {String}
 */
Font.prototype.glyphIndexToName = function (gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }

    return this.glyphNames.glyphIndexToName(gid);
};

/**
 * Retrieve the value of the kerning pair between the left glyph (or its index)
 * and the right glyph (or its index). If no kerning pair is found, return 0.
 * The kerning value gets added to the advance width when calculating the spacing
 * between glyphs.
 * @param  {opentype.Glyph} leftGlyph
 * @param  {opentype.Glyph} rightGlyph
 * @return {Number}
 */
Font.prototype.getKerningValue = function (leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    var gposKerning = this.getGposKerningValue;
    return gposKerning ? gposKerning(leftGlyph, rightGlyph) : this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
};

/**
 * @typedef GlyphRenderOptions
 * @type Object
 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
 * @property {string} [language='dflt'] - language system used to determine which features to apply.
 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
 * @property {boolean} [kerning=true] - whether to include kerning values
 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
 */
Font.prototype.defaultRenderOptions = {
    kerning: true,
    features: {
        liga: true,
        rlig: true
    }
};

/**
 * Helper function that invokes the given callback for each glyph in the given text.
 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
 * @param {string} text - The text to apply.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @param  {Function} callback
 */
Font.prototype.forEachGlyph = function (text, x, y, fontSize, options, callback) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || this.defaultRenderOptions;
    var fontScale = 1 / this.unitsPerEm * fontSize;
    var glyphs = this.stringToGlyphs(text, options);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        callback.call(this, glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }

        if (options.kerning && i < glyphs.length - 1) {
            var kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }

        if (options.letterSpacing) {
            x += options.letterSpacing * fontSize;
        } else if (options.tracking) {
            x += options.tracking / 1000 * fontSize;
        }
    }
    return x;
};

/**
 * Create a Path object that represents the given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path}
 */
Font.prototype.getPath = function (text, x, y, fontSize, options) {
    var fullPath = new _path2.default();
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        fullPath.extend(glyphPath);
    });
    return fullPath;
};

/**
 * Create an array of Path objects that represent the glyphs of a given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path[]}
 */
Font.prototype.getPaths = function (text, x, y, fontSize, options) {
    var glyphPaths = [];
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        glyphPaths.push(glyphPath);
    });

    return glyphPaths;
};

/**
 * Returns the advance width of a text.
 *
 * This is something different than Path.getBoundingBox() as for example a
 * suffixed whitespace increases the advanceWidth but not the bounding box
 * or an overhanging letter like a calligraphic 'f' might have a quite larger
 * bounding box than its advance width.
 *
 * This corresponds to canvas2dContext.measureText(text).width
 *
 * @param  {string} text - The text to create.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return advance width
 */
Font.prototype.getAdvanceWidth = function (text, fontSize, options) {
    return this.forEachGlyph(text, 0, 0, fontSize, options, function () {});
};

/**
 * Draw the text on the given drawing context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 */
Font.prototype.draw = function (ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};

/**
 * Draw the points of all glyphs in the text.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */
Font.prototype.drawPoints = function (ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {
        glyph.drawPoints(ctx, gX, gY, gFontSize);
    });
};

/**
 * Draw lines indicating important font measurements for all glyphs in the text.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */
Font.prototype.drawMetrics = function (ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {
        glyph.drawMetrics(ctx, gX, gY, gFontSize);
    });
};

/**
 * @param  {string}
 * @return {string}
 */
Font.prototype.getEnglishName = function (name) {
    var translations = this.names[name];
    if (translations) {
        return translations.en;
    }
};

/**
 * Validate
 */
Font.prototype.validate = function () {
    var warnings = [];
    var _this = this;

    function assert(predicate, message) {
        if (!predicate) {
            warnings.push(message);
        }
    }

    function assertNamePresent(name) {
        var englishName = _this.getEnglishName(name);
        assert(englishName && englishName.trim().length > 0, 'No English ' + name + ' specified.');
    }

    // Identification information
    assertNamePresent('fontFamily');
    assertNamePresent('weightName');
    assertNamePresent('manufacturer');
    assertNamePresent('copyright');
    assertNamePresent('version');

    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};

/**
 * Convert the font object to a SFNT data structure.
 * This structure contains all the necessary tables and metadata to create a binary OTF file.
 * @return {opentype.Table}
 */
Font.prototype.toTables = function () {
    return _sfnt2.default.fontToTable(this);
};
/**
 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
 */
Font.prototype.toBuffer = function () {
    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
    return this.toArrayBuffer();
};
/**
 * Converts a `opentype.Font` into an `ArrayBuffer`
 * @return {ArrayBuffer}
 */
Font.prototype.toArrayBuffer = function () {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }

    return buffer;
};

/**
 * Initiate a download of the OpenType font.
 */
Font.prototype.download = function (fileName) {
    var familyName = this.getEnglishName('fontFamily');
    var styleName = this.getEnglishName('fontSubfamily');
    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
    var arrayBuffer = this.toArrayBuffer();

    if ((0, _util.isBrowser)()) {
        window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
        window.requestFileSystem(window.TEMPORARY, arrayBuffer.byteLength, function (fs) {
            fs.root.getFile(fileName, { create: true }, function (fileEntry) {
                fileEntry.createWriter(function (writer) {
                    var dataView = new DataView(arrayBuffer);
                    var blob = new Blob([dataView], { type: 'font/opentype' });
                    writer.write(blob);

                    writer.addEventListener('writeend', function () {
                        // Navigating to the file will download it.
                        location.href = fileEntry.toURL();
                    }, false);
                });
            });
        }, function (err) {
            throw new Error(err.name + ': ' + err.message);
        });
    } else {
        var fs = __webpack_require__(206);
        var buffer = (0, _util.arrayBufferToNodeBuffer)(arrayBuffer);
        fs.writeFileSync(fileName, buffer);
    }
};
/**
 * @private
 */
Font.prototype.fsSelectionValues = {
    ITALIC: 0x001, //1
    UNDERSCORE: 0x002, //2
    NEGATIVE: 0x004, //4
    OUTLINED: 0x008, //8
    STRIKEOUT: 0x010, //16
    BOLD: 0x020, //32
    REGULAR: 0x040, //64
    USER_TYPO_METRICS: 0x080, //128
    WWS: 0x100, //256
    OBLIQUE: 0x200 //512
};

/**
 * @private
 */
Font.prototype.usWidthClasses = {
    ULTRA_CONDENSED: 1,
    EXTRA_CONDENSED: 2,
    CONDENSED: 3,
    SEMI_CONDENSED: 4,
    MEDIUM: 5,
    SEMI_EXPANDED: 6,
    EXPANDED: 7,
    EXTRA_EXPANDED: 8,
    ULTRA_EXPANDED: 9
};

/**
 * @private
 */
Font.prototype.usWeightClasses = {
    THIN: 100,
    EXTRA_LIGHT: 200,
    LIGHT: 300,
    NORMAL: 400,
    MEDIUM: 500,
    SEMI_BOLD: 600,
    BOLD: 700,
    EXTRA_BOLD: 800,
    BLACK: 900
};

exports.default = Font;

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* A TrueType font hinting interpreter.
*
* (c) 2017 Axel Kittenberger
*
* This interpreter has been implemented according to this documentation:
* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
*
* According to the documentation F24DOT6 values are used for pixels.
* That means calculation is 1/64 pixel accurate and uses integer operations.
* However, Javascript has floating point operations by default and only
* those are available. One could make a case to simulate the 1/64 accuracy
* exactly by truncating after every division operation
* (for example with << 0) to get pixel exactly results as other TrueType
* implementations. It may make sense since some fonts are pixel optimized
* by hand using DELTAP instructions. The current implementation doesn't
* and rather uses full floating point precision.
*
* xScale, yScale and rotation is currently ignored.
*
* A few non-trivial instructions are missing as I didn't encounter yet
* a font that used them to test a possible implementation.
*
* Some fonts seem to use undocumented features regarding the twilight zone.
* Only some of them are implemented as they were encountered.
*
* The exports.DEBUG statements are removed on the minified distribution file.
*/


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _preventExtensions = __webpack_require__(501);

var _preventExtensions2 = _interopRequireDefault(_preventExtensions);

var _freeze = __webpack_require__(166);

var _freeze2 = _interopRequireDefault(_freeze);

var _trunc = __webpack_require__(258);

var _trunc2 = _interopRequireDefault(_trunc);

var _sign = __webpack_require__(165);

var _sign2 = _interopRequireDefault(_sign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var instructionTable = void 0;
var exec = void 0;
var execGlyph = void 0;
var execComponent = void 0;

/*
* Creates a hinting object.
*
* There ought to be exactly one
* for each truetype font that is used for hinting.
*/
function Hinting(font) {
    // the font this hinting object is for
    this.font = font;

    // cached states
    this._fpgmState = this._prepState = undefined;

    // errorState
    // 0 ... all okay
    // 1 ... had an error in a glyf,
    //       continue working but stop spamming
    //       the console
    // 2 ... error at prep, stop hinting at this ppem
    // 3 ... error at fpeg, stop hinting for this font at all
    this._errorState = 0;
}

/*
* Not rounding.
*/
function roundOff(v) {
    return v;
}

/*
* Rounding to grid.
*/
function roundToGrid(v) {
    //Rounding in TT is supposed to "symmetrical around zero"
    return (0, _sign2.default)(v) * Math.round(Math.abs(v));
}

/*
* Rounding to double grid.
*/
function roundToDoubleGrid(v) {
    return (0, _sign2.default)(v) * Math.round(Math.abs(v * 2)) / 2;
}

/*
* Rounding to half grid.
*/
function roundToHalfGrid(v) {
    return (0, _sign2.default)(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
}

/*
* Rounding to up to grid.
*/
function roundUpToGrid(v) {
    return (0, _sign2.default)(v) * Math.ceil(Math.abs(v));
}

/*
* Rounding to down to grid.
*/
function roundDownToGrid(v) {
    return (0, _sign2.default)(v) * Math.floor(Math.abs(v));
}

/*
* Super rounding.
*/
var roundSuper = function roundSuper(v) {
    var period = this.srPeriod;
    var phase = this.srPhase;
    var threshold = this.srThreshold;
    var sign = 1;

    if (v < 0) {
        v = -v;
        sign = -1;
    }

    v += threshold - phase;

    v = (0, _trunc2.default)(v / period) * period;

    v += phase;

    // according to http://xgridfit.sourceforge.net/round.html
    if (sign > 0 && v < 0) return phase;
    if (sign < 0 && v > 0) return -phase;

    return v * sign;
};

/*
* Unit vector of x-axis.
*/
var xUnitVector = {
    x: 1,

    y: 0,

    axis: 'x',

    // Gets the projected distance between two points.
    // o1/o2 ... if true, respective original position is used.
    distance: function distance(p1, p2, o1, o2) {
        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
    },

    // Moves point p so the moved position has the same relative
    // position to the moved positions of rp1 and rp2 than the
    // original positions had.
    //
    // See APPENDIX on INTERPOLATE at the bottom of this file.
    interpolate: function interpolate(p, rp1, rp2, pv) {
        var do1 = void 0;
        var do2 = void 0;
        var doa1 = void 0;
        var doa2 = void 0;
        var dm1 = void 0;
        var dm2 = void 0;
        var dt = void 0;

        if (!pv || pv === this) {
            do1 = p.xo - rp1.xo;
            do2 = p.xo - rp2.xo;
            dm1 = rp1.x - rp1.xo;
            dm2 = rp2.x - rp2.xo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;

            if (dt === 0) {
                p.x = p.xo + (dm1 + dm2) / 2;
                return;
            }

            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }

        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;

        if (dt === 0) {
            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }

        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },

    // Slope of line normal to this
    normalSlope: Number.NEGATIVE_INFINITY,

    // Sets the point 'p' relative to point 'rp'
    // by the distance 'd'.
    //
    // See APPENDIX on SETRELATIVE at the bottom of this file.
    //
    // p   ... point to set
    // rp  ... reference point
    // d   ... distance on projection vector
    // pv  ... projection vector (undefined = this)
    // org ... if true, uses the original position of rp as reference.
    setRelative: function setRelative(p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.x = (org ? rp.xo : rp.x) + d;
            return;
        }

        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;

        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
    },

    // Slope of vector line.
    slope: 0,

    // Touches the point p.
    touch: function touch(p) {
        p.xTouched = true;
    },

    // Tests if a point p is touched.
    touched: function touched(p) {
        return p.xTouched;
    },

    // Untouches the point p.
    untouch: function untouch(p) {
        p.xTouched = false;
    }
};

/*
* Unit vector of y-axis.
*/
var yUnitVector = {
    x: 0,

    y: 1,

    axis: 'y',

    // Gets the projected distance between two points.
    // o1/o2 ... if true, respective original position is used.
    distance: function distance(p1, p2, o1, o2) {
        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
    },

    // Moves point p so the moved position has the same relative
    // position to the moved positions of rp1 and rp2 than the
    // original positions had.
    //
    // See APPENDIX on INTERPOLATE at the bottom of this file.
    interpolate: function interpolate(p, rp1, rp2, pv) {
        var do1 = void 0;
        var do2 = void 0;
        var doa1 = void 0;
        var doa2 = void 0;
        var dm1 = void 0;
        var dm2 = void 0;
        var dt = void 0;

        if (!pv || pv === this) {
            do1 = p.yo - rp1.yo;
            do2 = p.yo - rp2.yo;
            dm1 = rp1.y - rp1.yo;
            dm2 = rp2.y - rp2.yo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;

            if (dt === 0) {
                p.y = p.yo + (dm1 + dm2) / 2;
                return;
            }

            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }

        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;

        if (dt === 0) {
            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }

        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },

    // Slope of line normal to this.
    normalSlope: 0,

    // Sets the point 'p' relative to point 'rp'
    // by the distance 'd'
    //
    // See APPENDIX on SETRELATIVE at the bottom of this file.
    //
    // p   ... point to set
    // rp  ... reference point
    // d   ... distance on projection vector
    // pv  ... projection vector (undefined = this)
    // org ... if true, uses the original position of rp as reference.
    setRelative: function setRelative(p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.y = (org ? rp.yo : rp.y) + d;
            return;
        }

        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;

        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
    },

    // Slope of vector line.
    slope: Number.POSITIVE_INFINITY,

    // Touches the point p.
    touch: function touch(p) {
        p.yTouched = true;
    },

    // Tests if a point p is touched.
    touched: function touched(p) {
        return p.yTouched;
    },

    // Untouches the point p.
    untouch: function untouch(p) {
        p.yTouched = false;
    }
};

(0, _freeze2.default)(xUnitVector);
(0, _freeze2.default)(yUnitVector);

/*
* Creates a unit vector that is not x- or y-axis.
*/
function UnitVector(x, y) {
    this.x = x;
    this.y = y;
    this.axis = undefined;
    this.slope = y / x;
    this.normalSlope = -x / y;
    (0, _freeze2.default)(this);
}

/*
* Gets the projected distance between two points.
* o1/o2 ... if true, respective original position is used.
*/
UnitVector.prototype.distance = function (p1, p2, o1, o2) {
    return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2);
};

/*
* Moves point p so the moved position has the same relative
* position to the moved positions of rp1 and rp2 than the
* original positions had.
*
* See APPENDIX on INTERPOLATE at the bottom of this file.
*/
UnitVector.prototype.interpolate = function (p, rp1, rp2, pv) {
    var dm1 = void 0;
    var dm2 = void 0;
    var do1 = void 0;
    var do2 = void 0;
    var doa1 = void 0;
    var doa2 = void 0;
    var dt = void 0;

    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;

    if (dt === 0) {
        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
        return;
    }

    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
};

/*
* Sets the point 'p' relative to point 'rp'
* by the distance 'd'
*
* See APPENDIX on SETRELATIVE at the bottom of this file.
*
* p   ...  point to set
* rp  ... reference point
* d   ... distance on projection vector
* pv  ... projection vector (undefined = this)
* org ... if true, uses the original position of rp as reference.
*/
UnitVector.prototype.setRelative = function (p, rp, d, pv, org) {
    pv = pv || this;

    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;

    var pvns = pv.normalSlope;
    var fvs = this.slope;

    var px = p.x;
    var py = p.y;

    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
    p.y = fvs * (p.x - px) + py;
};

/*
* Touches the point p.
*/
UnitVector.prototype.touch = function (p) {
    p.xTouched = true;
    p.yTouched = true;
};

/*
* Returns a unit vector with x/y coordinates.
*/
function getUnitVector(x, y) {
    var d = Math.sqrt(x * x + y * y);

    x /= d;
    y /= d;

    if (x === 1 && y === 0) return xUnitVector;else if (x === 0 && y === 1) return yUnitVector;else return new UnitVector(x, y);
}

/*
* Creates a point in the hinting engine.
*/
function HPoint(x, y, lastPointOfContour, onCurve) {
    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value

    this.lastPointOfContour = lastPointOfContour;
    this.onCurve = onCurve;
    this.prevPointOnContour = undefined;
    this.nextPointOnContour = undefined;
    this.xTouched = false;
    this.yTouched = false;

    (0, _preventExtensions2.default)(this);
}

/*
* Returns the next touched point on the contour.
*
* v  ... unit vector to test touch axis.
*/
HPoint.prototype.nextTouched = function (v) {
    var p = this.nextPointOnContour;

    while (!v.touched(p) && p !== this) {
        p = p.nextPointOnContour;
    }return p;
};

/*
* Returns the previous touched point on the contour
*
* v  ... unit vector to test touch axis.
*/
HPoint.prototype.prevTouched = function (v) {
    var p = this.prevPointOnContour;

    while (!v.touched(p) && p !== this) {
        p = p.prevPointOnContour;
    }return p;
};

/*
* The zero point.
*/
var HPZero = (0, _freeze2.default)(new HPoint(0, 0));

/*
* The default state of the interpreter.
*
* Note: Freezing the defaultState and then deriving from it
* makes the V8 Javascript engine going awkward,
* so this is avoided, albeit the defaultState shouldn't
* ever change.
*/
var defaultState = {
    cvCutIn: 17 / 16, // control value cut in
    deltaBase: 9,
    deltaShift: 0.125,
    loop: 1, // loops some instructions
    minDis: 1, // minimum distance
    autoFlip: true
};

/*
* The current state of the interpreter.
*
* env  ... 'fpgm' or 'prep' or 'glyf'
* prog ... the program
*/
function State(env, prog) {
    this.env = env;
    this.stack = [];
    this.prog = prog;

    switch (env) {
        case 'glyf':
            this.zp0 = this.zp1 = this.zp2 = 1;
            this.rp0 = this.rp1 = this.rp2 = 0;
        /* fall through */
        case 'prep':
            this.fv = this.pv = this.dpv = xUnitVector;
            this.round = roundToGrid;
    }
}

/*
* Executes a glyph program.
*
* This does the hinting for each glyph.
*
* Returns an array of moved points.
*
* glyph: the glyph to hint
* ppem: the size the glyph is rendered for
*/
Hinting.prototype.exec = function (glyph, ppem) {
    if (typeof ppem !== 'number') {
        throw new Error('Point size is not a number!');
    }

    // Received a fatal error, don't do any hinting anymore.
    if (this._errorState > 2) return;

    var font = this.font;
    var prepState = this._prepState;

    if (!prepState || prepState.ppem !== ppem) {
        var fpgmState = this._fpgmState;

        if (!fpgmState) {
            // Executes the fpgm state.
            // This is used by fonts to define functions.
            State.prototype = defaultState;

            fpgmState = this._fpgmState = new State('fpgm', font.tables.fpgm);

            fpgmState.funcs = [];
            fpgmState.font = font;

            if (exports.DEBUG) {
                console.log('---EXEC FPGM---');
                fpgmState.step = -1;
            }

            try {
                exec(fpgmState);
            } catch (e) {
                console.log('Hinting error in FPGM:' + e);
                this._errorState = 3;
                return;
            }
        }

        // Executes the prep program for this ppem setting.
        // This is used by fonts to set cvt values
        // depending on to be rendered font size.

        State.prototype = fpgmState;
        prepState = this._prepState = new State('prep', font.tables.prep);

        prepState.ppem = ppem;

        // Creates a copy of the cvt table
        // and scales it to the current ppem setting.
        var oCvt = font.tables.cvt;
        if (oCvt) {
            var cvt = prepState.cvt = new Array(oCvt.length);
            var scale = ppem / font.unitsPerEm;
            for (var c = 0; c < oCvt.length; c++) {
                cvt[c] = oCvt[c] * scale;
            }
        } else {
            prepState.cvt = [];
        }

        if (exports.DEBUG) {
            console.log('---EXEC PREP---');
            prepState.step = -1;
        }

        try {
            exec(prepState);
        } catch (e) {
            if (this._errorState < 2) {
                console.log('Hinting error in PREP:' + e);
            }
            this._errorState = 2;
        }
    }

    if (this._errorState > 1) return;

    try {
        return execGlyph(glyph, prepState);
    } catch (e) {
        if (this._errorState < 1) {
            console.log('Hinting error:' + e);
            console.log('Note: further hinting errors are silenced');
        }
        this._errorState = 1;
        return undefined;
    }
};

/*
* Executes the hinting program for a glyph.
*/
execGlyph = function execGlyph(glyph, prepState) {
    // original point positions
    var xScale = prepState.ppem / prepState.font.unitsPerEm;
    var yScale = xScale;
    var components = glyph.components;
    var contours = void 0;
    var gZone = void 0;
    var state = void 0;

    State.prototype = prepState;
    if (!components) {
        state = new State('glyf', glyph.instructions);
        if (exports.DEBUG) {
            console.log('---EXEC GLYPH---');
            state.step = -1;
        }
        execComponent(glyph, state, xScale, yScale);
        gZone = state.gZone;
    } else {
        var font = prepState.font;
        gZone = [];
        contours = [];
        for (var i = 0; i < components.length; i++) {
            var c = components[i];
            var cg = font.glyphs.get(c.glyphIndex);

            state = new State('glyf', cg.instructions);

            if (exports.DEBUG) {
                console.log('---EXEC COMP ' + i + '---');
                state.step = -1;
            }

            execComponent(cg, state, xScale, yScale);
            // appends the computed points to the result array
            // post processes the component points
            var dx = Math.round(c.dx * xScale);
            var dy = Math.round(c.dy * yScale);
            var gz = state.gZone;
            var cc = state.contours;
            for (var pi = 0; pi < gz.length; pi++) {
                var p = gz[pi];
                p.xTouched = p.yTouched = false;
                p.xo = p.x = p.x + dx;
                p.yo = p.y = p.y + dy;
            }

            var gLen = gZone.length;
            gZone.push.apply(gZone, gz);
            for (var j = 0; j < cc.length; j++) {
                contours.push(cc[j] + gLen);
            }
        }

        if (glyph.instructions && !state.inhibitGridFit) {
            // the composite has instructions on its own
            state = new State('glyf', glyph.instructions);

            state.gZone = state.z0 = state.z1 = state.z2 = gZone;

            state.contours = contours;

            // note: HPZero cannot be used here, since
            //       the point might be modified
            gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));

            if (exports.DEBUG) {
                console.log('---EXEC COMPOSITE---');
                state.step = -1;
            }

            exec(state);

            gZone.length -= 2;
        }
    }

    return gZone;
};

/*
* Executes the hinting program for a component of a multi-component glyph
* or of the glyph itself by a non-component glyph.
*/
execComponent = function execComponent(glyph, state, xScale, yScale) {
    var points = glyph.points || [];
    var pLen = points.length;
    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
    var contours = state.contours = [];

    // Scales the original points and
    // makes copies for the hinted points.
    var cp = void 0; // current point
    for (var i = 0; i < pLen; i++) {
        cp = points[i];

        gZone[i] = new HPoint(cp.x * xScale, cp.y * yScale, cp.lastPointOfContour, cp.onCurve);
    }

    // Chain links the contours.
    var sp = void 0; // start point
    var np = void 0; // next point

    for (var _i = 0; _i < pLen; _i++) {
        cp = gZone[_i];

        if (!sp) {
            sp = cp;
            contours.push(_i);
        }

        if (cp.lastPointOfContour) {
            cp.nextPointOnContour = sp;
            sp.prevPointOnContour = cp;
            sp = undefined;
        } else {
            np = gZone[_i + 1];
            cp.nextPointOnContour = np;
            np.prevPointOnContour = cp;
        }
    }

    if (state.inhibitGridFit) return;

    gZone.push(new HPoint(0, 0), new HPoint(Math.round(glyph.advanceWidth * xScale), 0));

    exec(state);

    // Removes the extra points.
    gZone.length -= 2;

    if (exports.DEBUG) {
        console.log('FINISHED GLYPH', state.stack);
        for (var _i2 = 0; _i2 < pLen; _i2++) {
            console.log(_i2, gZone[_i2].x, gZone[_i2].y);
        }
    }
};

/*
* Executes the program loaded in state.
*/
exec = function exec(state) {
    var prog = state.prog;

    if (!prog) return;

    var pLen = prog.length;
    var ins = void 0;

    for (state.ip = 0; state.ip < pLen; state.ip++) {
        if (exports.DEBUG) state.step++;
        ins = instructionTable[prog[state.ip]];

        if (!ins) {
            throw new Error('unknown instruction: 0x' + Number(prog[state.ip]).toString(16));
        }

        ins(state);

        // very extensive debugging for each step
        /*
        if (exports.DEBUG) {
            var da;
            if (state.gZone) {
                da = [];
                for (let i = 0; i < state.gZone.length; i++)
                {
                    da.push(i + ' ' +
                        state.gZone[i].x * 64 + ' ' +
                        state.gZone[i].y * 64 + ' ' +
                        (state.gZone[i].xTouched ? 'x' : '') +
                        (state.gZone[i].yTouched ? 'y' : '')
                    );
                }
                console.log('GZ', da);
            }
             if (state.tZone) {
                da = [];
                for (let i = 0; i < state.tZone.length; i++) {
                    da.push(i + ' ' +
                        state.tZone[i].x * 64 + ' ' +
                        state.tZone[i].y * 64 + ' ' +
                        (state.tZone[i].xTouched ? 'x' : '') +
                        (state.tZone[i].yTouched ? 'y' : '')
                    );
                }
                console.log('TZ', da);
            }
             if (state.stack.length > 10) {
                console.log(
                    state.stack.length,
                    '...', state.stack.slice(state.stack.length - 10)
                );
            } else {
                console.log(state.stack.length, state.stack);
            }
        }
        */
    }
};

/*
* Initializes the twilight zone.
*
* This is only done if a SZPx instruction
* refers to the twilight zone.
*/
function initTZone(state) {
    var tZone = state.tZone = new Array(state.gZone.length);

    // no idea if this is actually correct...
    for (var i = 0; i < tZone.length; i++) {
        tZone[i] = new HPoint(0, 0);
    }
}

/*
* Skips the instruction pointer ahead over an IF/ELSE block.
* handleElse .. if true breaks on matching ELSE
*/
function skip(state, handleElse) {
    var prog = state.prog;
    var ip = state.ip;
    var nesting = 1;
    var ins = void 0;

    do {
        ins = prog[++ip];
        if (ins === 0x58) // IF
            nesting++;else if (ins === 0x59) // EIF
            nesting--;else if (ins === 0x40) // NPUSHB
            ip += prog[ip + 1] + 1;else if (ins === 0x41) // NPUSHW
            ip += 2 * prog[ip + 1] + 1;else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
            ip += ins - 0xB0 + 1;else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
            ip += (ins - 0xB8 + 1) * 2;else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
            break;
    } while (nesting > 0);

    state.ip = ip;
}

/*----------------------------------------------------------*
*          And then a lot of instructions...                *
*----------------------------------------------------------*/

// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
// 0x00-0x01
function SVTCA(v, state) {
    if (exports.DEBUG) console.log(state.step, 'SVTCA[' + v.axis + ']');

    state.fv = state.pv = state.dpv = v;
}

// SPVTCA[a] Set Projection Vector to Coordinate Axis
// 0x02-0x03
function SPVTCA(v, state) {
    if (exports.DEBUG) console.log(state.step, 'SPVTCA[' + v.axis + ']');

    state.pv = state.dpv = v;
}

// SFVTCA[a] Set Freedom Vector to Coordinate Axis
// 0x04-0x05
function SFVTCA(v, state) {
    if (exports.DEBUG) console.log(state.step, 'SFVTCA[' + v.axis + ']');

    state.fv = v;
}

// SPVTL[a] Set Projection Vector To Line
// 0x06-0x07
function SPVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) console.log('SPVTL[' + a + ']', p2i, p1i);

    var dx = void 0;
    var dy = void 0;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.pv = state.dpv = getUnitVector(dx, dy);
}

// SFVTL[a] Set Freedom Vector To Line
// 0x08-0x09
function SFVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) console.log('SFVTL[' + a + ']', p2i, p1i);

    var dx = void 0;
    var dy = void 0;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.fv = getUnitVector(dx, dy);
}

// SPVFS[] Set Projection Vector From Stack
// 0x0A
function SPVFS(state) {
    var stack = state.stack;
    var y = stack.pop();
    var x = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);

    state.pv = state.dpv = getUnitVector(x, y);
}

// SFVFS[] Set Freedom Vector From Stack
// 0x0B
function SFVFS(state) {
    var stack = state.stack;
    var y = stack.pop();
    var x = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);

    state.fv = getUnitVector(x, y);
}

// GPV[] Get Projection Vector
// 0x0C
function GPV(state) {
    var stack = state.stack;
    var pv = state.pv;

    if (exports.DEBUG) console.log(state.step, 'GPV[]');

    stack.push(pv.x * 0x4000);
    stack.push(pv.y * 0x4000);
}

// GFV[] Get Freedom Vector
// 0x0C
function GFV(state) {
    var stack = state.stack;
    var fv = state.fv;

    if (exports.DEBUG) console.log(state.step, 'GFV[]');

    stack.push(fv.x * 0x4000);
    stack.push(fv.y * 0x4000);
}

// SFVTPV[] Set Freedom Vector To Projection Vector
// 0x0E
function SFVTPV(state) {
    state.fv = state.pv;

    if (exports.DEBUG) console.log(state.step, 'SFVTPV[]');
}

// ISECT[] moves point p to the InterSECTion of two lines
// 0x0F
function ISECT(state) {
    var stack = state.stack;
    var pa0i = stack.pop();
    var pa1i = stack.pop();
    var pb0i = stack.pop();
    var pb1i = stack.pop();
    var pi = stack.pop();
    var z0 = state.z0;
    var z1 = state.z1;
    var pa0 = z0[pa0i];
    var pa1 = z0[pa1i];
    var pb0 = z1[pb0i];
    var pb1 = z1[pb1i];
    var p = state.z2[pi];

    if (exports.DEBUG) console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi);

    // math from
    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

    var x1 = pa0.x;
    var y1 = pa0.y;
    var x2 = pa1.x;
    var y2 = pa1.y;
    var x3 = pb0.x;
    var y3 = pb0.y;
    var x4 = pb1.x;
    var y4 = pb1.y;

    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    var f1 = x1 * y2 - y1 * x2;
    var f2 = x3 * y4 - y3 * x4;

    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
}

// SRP0[] Set Reference Point 0
// 0x10
function SRP0(state) {
    state.rp0 = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SRP0[]', state.rp0);
}

// SRP1[] Set Reference Point 1
// 0x11
function SRP1(state) {
    state.rp1 = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SRP1[]', state.rp1);
}

// SRP1[] Set Reference Point 2
// 0x12
function SRP2(state) {
    state.rp2 = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SRP2[]', state.rp2);
}

// SZP0[] Set Zone Pointer 0
// 0x13
function SZP0(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SZP0[]', n);

    state.zp0 = n;

    switch (n) {
        case 0:
            if (!state.tZone) initTZone(state);
            state.z0 = state.tZone;
            break;
        case 1:
            state.z0 = state.gZone;
            break;
        default:
            throw new Error('Invalid zone pointer');
    }
}

// SZP1[] Set Zone Pointer 1
// 0x14
function SZP1(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SZP1[]', n);

    state.zp1 = n;

    switch (n) {
        case 0:
            if (!state.tZone) initTZone(state);
            state.z1 = state.tZone;
            break;
        case 1:
            state.z1 = state.gZone;
            break;
        default:
            throw new Error('Invalid zone pointer');
    }
}

// SZP2[] Set Zone Pointer 2
// 0x15
function SZP2(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SZP2[]', n);

    state.zp2 = n;

    switch (n) {
        case 0:
            if (!state.tZone) initTZone(state);
            state.z2 = state.tZone;
            break;
        case 1:
            state.z2 = state.gZone;
            break;
        default:
            throw new Error('Invalid zone pointer');
    }
}

// SZPS[] Set Zone PointerS
// 0x16
function SZPS(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SZPS[]', n);

    state.zp0 = state.zp1 = state.zp2 = n;

    switch (n) {
        case 0:
            if (!state.tZone) initTZone(state);
            state.z0 = state.z1 = state.z2 = state.tZone;
            break;
        case 1:
            state.z0 = state.z1 = state.z2 = state.gZone;
            break;
        default:
            throw new Error('Invalid zone pointer');
    }
}

// SLOOP[] Set LOOP variable
// 0x17
function SLOOP(state) {
    state.loop = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SLOOP[]', state.loop);
}

// RTG[] Round To Grid
// 0x18
function RTG(state) {
    if (exports.DEBUG) console.log(state.step, 'RTG[]');

    state.round = roundToGrid;
}

// RTHG[] Round To Half Grid
// 0x19
function RTHG(state) {
    if (exports.DEBUG) console.log(state.step, 'RTHG[]');

    state.round = roundToHalfGrid;
}

// SMD[] Set Minimum Distance
// 0x1A
function SMD(state) {
    var d = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SMD[]', d);

    state.minDis = d / 0x40;
}

// ELSE[] ELSE clause
// 0x1B
function ELSE(state) {
    // This instruction has been reached by executing a then branch
    // so it just skips ahead until matching EIF.
    //
    // In case the IF was negative the IF[] instruction already
    // skipped forward over the ELSE[]

    if (exports.DEBUG) console.log(state.step, 'ELSE[]');

    skip(state, false);
}

// JMPR[] JuMP Relative
// 0x1C
function JMPR(state) {
    var o = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'JMPR[]', o);

    // A jump by 1 would do nothing.
    state.ip += o - 1;
}

// SCVTCI[] Set Control Value Table Cut-In
// 0x1D
function SCVTCI(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SCVTCI[]', n);

    state.cvCutIn = n / 0x40;
}

// DUP[] DUPlicate top stack element
// 0x20
function DUP(state) {
    var stack = state.stack;

    if (exports.DEBUG) console.log(state.step, 'DUP[]');

    stack.push(stack[stack.length - 1]);
}

// POP[] POP top stack element
// 0x21
function POP(state) {
    if (exports.DEBUG) console.log(state.step, 'POP[]');

    state.stack.pop();
}

// CLEAR[] CLEAR the stack
// 0x22
function CLEAR(state) {
    if (exports.DEBUG) console.log(state.step, 'CLEAR[]');

    state.stack.length = 0;
}

// SWAP[] SWAP the top two elements on the stack
// 0x23
function SWAP(state) {
    var stack = state.stack;

    var a = stack.pop();
    var b = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SWAP[]');

    stack.push(a);
    stack.push(b);
}

// DEPTH[] DEPTH of the stack
// 0x24
function DEPTH(state) {
    var stack = state.stack;

    if (exports.DEBUG) console.log(state.step, 'DEPTH[]');

    stack.push(stack.length);
}

// LOOPCALL[] LOOPCALL function
// 0x2A
function LOOPCALL(state) {
    var stack = state.stack;
    var fn = stack.pop();
    var c = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'LOOPCALL[]', fn, c);

    // saves callers program
    var cip = state.ip;
    var cprog = state.prog;

    state.prog = state.funcs[fn];

    // executes the function
    for (var i = 0; i < c; i++) {
        exec(state);

        if (exports.DEBUG) console.log(++state.step, i + 1 < c ? 'next loopcall' : 'done loopcall', i);
    }

    // restores the callers program
    state.ip = cip;
    state.prog = cprog;
}

// CALL[] CALL function
// 0x2B
function CALL(state) {
    var fn = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'CALL[]', fn);

    // saves callers program
    var cip = state.ip;
    var cprog = state.prog;

    state.prog = state.funcs[fn];

    // executes the function
    exec(state);

    // restores the callers program
    state.ip = cip;
    state.prog = cprog;

    if (exports.DEBUG) console.log(++state.step, 'returning from', fn);
}

// CINDEX[] Copy the INDEXed element to the top of the stack
// 0x25
function CINDEX(state) {
    var stack = state.stack;
    var k = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'CINDEX[]', k);

    // In case of k == 1, it copies the last element after popping
    // thus stack.length - k.
    stack.push(stack[stack.length - k]);
}

// MINDEX[] Move the INDEXed element to the top of the stack
// 0x26
function MINDEX(state) {
    var stack = state.stack;
    var k = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'MINDEX[]', k);

    stack.push(stack.splice(stack.length - k, 1)[0]);
}

// FDEF[] Function DEFinition
// 0x2C
function FDEF(state) {
    if (state.env !== 'fpgm') throw new Error('FDEF not allowed here');
    var stack = state.stack;
    var prog = state.prog;
    var ip = state.ip;

    var fn = stack.pop();
    var ipBegin = ip;

    if (exports.DEBUG) console.log(state.step, 'FDEF[]', fn);

    while (prog[++ip] !== 0x2D) {}

    state.ip = ip;
    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
}

// MDAP[a] Move Direct Absolute Point
// 0x2E-0x2F
function MDAP(round, state) {
    var pi = state.stack.pop();
    var p = state.z0[pi];
    var fv = state.fv;
    var pv = state.pv;

    if (exports.DEBUG) console.log(state.step, 'MDAP[' + round + ']', pi);

    var d = pv.distance(p, HPZero);

    if (round) d = state.round(d);

    fv.setRelative(p, HPZero, d, pv);
    fv.touch(p);

    state.rp0 = state.rp1 = pi;
}

// IUP[a] Interpolate Untouched Points through the outline
// 0x30
function IUP(v, state) {
    var z2 = state.z2;
    var pLen = z2.length - 2;
    var cp = void 0;
    var pp = void 0;
    var np = void 0;

    if (exports.DEBUG) console.log(state.step, 'IUP[' + v.axis + ']');

    for (var i = 0; i < pLen; i++) {
        cp = z2[i]; // current point

        // if this point has been touched go on
        if (v.touched(cp)) continue;

        pp = cp.prevTouched(v);

        // no point on the contour has been touched?
        if (pp === cp) continue;

        np = cp.nextTouched(v);

        if (pp === np) {
            // only one point on the contour has been touched
            // so simply moves the point like that

            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
        }

        v.interpolate(cp, pp, np, v);
    }
}

// SHP[] SHift Point using reference point
// 0x32-0x33
function SHP(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var loop = state.loop;
    var z2 = state.z2;

    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];

        var d = pv.distance(rp, rp, false, true);
        fv.setRelative(p, p, d, pv);
        fv.touch(p);

        if (exports.DEBUG) {
            console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi);
        }
    }

    state.loop = 1;
}

// SHC[] SHift Contour using reference point
// 0x36-0x37
function SHC(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var ci = stack.pop();
    var sp = state.z2[state.contours[ci]];
    var p = sp;

    if (exports.DEBUG) console.log(state.step, 'SHC[' + a + ']', ci);

    var d = pv.distance(rp, rp, false, true);

    do {
        if (p !== rp) fv.setRelative(p, p, d, pv);
        p = p.nextPointOnContour;
    } while (p !== sp);
}

// SHZ[] SHift Zone using reference point
// 0x36-0x37
function SHZ(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;

    var e = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SHZ[' + a + ']', e);

    var z = void 0;
    switch (e) {
        case 0:
            z = state.tZone;break;
        case 1:
            z = state.gZone;break;
        default:
            throw new Error('Invalid zone');
    }

    var p = void 0;
    var d = pv.distance(rp, rp, false, true);
    var pLen = z.length - 2;
    for (var i = 0; i < pLen; i++) {
        p = z[i];
        if (p !== rp) fv.setRelative(p, p, d, pv);
    }
}

// SHPIX[] SHift point by a PIXel amount
// 0x38
function SHPIX(state) {
    var stack = state.stack;
    var loop = state.loop;
    var fv = state.fv;
    var d = stack.pop() / 0x40;
    var z2 = state.z2;

    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];

        if (exports.DEBUG) {
            console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'SHPIX[]', pi, d);
        }

        fv.setRelative(p, p, d);
        fv.touch(p);
    }

    state.loop = 1;
}

// IP[] Interpolate Point
// 0x39
function IP(state) {
    var stack = state.stack;
    var rp1i = state.rp1;
    var rp2i = state.rp2;
    var loop = state.loop;
    var rp1 = state.z0[rp1i];
    var rp2 = state.z1[rp2i];
    var fv = state.fv;
    var pv = state.dpv;
    var z2 = state.z2;

    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];

        if (exports.DEBUG) {
            console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'IP[]', pi, rp1i, '<->', rp2i);
        }

        fv.interpolate(p, rp1, rp2, pv);

        fv.touch(p);
    }

    state.loop = 1;
}

// MSIRP[a] Move Stack Indirect Relative Point
// 0x3A-0x3B
function MSIRP(a, state) {
    var stack = state.stack;
    var d = stack.pop() / 64;
    var pi = stack.pop();
    var p = state.z1[pi];
    var rp0 = state.z0[state.rp0];
    var fv = state.fv;
    var pv = state.pv;

    fv.setRelative(p, rp0, d, pv);
    fv.touch(p);

    if (exports.DEBUG) console.log(state.step, 'MSIRP[' + a + ']', d, pi);

    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (a) state.rp0 = pi;
}

// ALIGNRP[] Align to reference point.
// 0x3C
function ALIGNRP(state) {
    var stack = state.stack;
    var rp0i = state.rp0;
    var rp0 = state.z0[rp0i];
    var loop = state.loop;
    var fv = state.fv;
    var pv = state.pv;
    var z1 = state.z1;

    while (loop--) {
        var pi = stack.pop();
        var p = z1[pi];

        if (exports.DEBUG) {
            console.log(state.step, (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') + 'ALIGNRP[]', pi);
        }

        fv.setRelative(p, rp0, 0, pv);
        fv.touch(p);
    }

    state.loop = 1;
}

// RTG[] Round To Double Grid
// 0x3D
function RTDG(state) {
    if (exports.DEBUG) console.log(state.step, 'RTDG[]');

    state.round = roundToDoubleGrid;
}

// MIAP[a] Move Indirect Absolute Point
// 0x3E-0x3F
function MIAP(round, state) {
    var stack = state.stack;
    var n = stack.pop();
    var pi = stack.pop();
    var p = state.z0[pi];
    var fv = state.fv;
    var pv = state.pv;
    var cv = state.cvt[n];

    // TODO cvtcutin should be considered here
    if (round) cv = state.round(cv);

    if (exports.DEBUG) {
        console.log(state.step, 'MIAP[' + round + ']', n, '(', cv, ')', pi);
    }

    fv.setRelative(p, HPZero, cv, pv);

    if (state.zp0 === 0) {
        p.xo = p.x;
        p.yo = p.y;
    }

    fv.touch(p);

    state.rp0 = state.rp1 = pi;
}

// NPUSB[] PUSH N Bytes
// 0x40
function NPUSHB(state) {
    var prog = state.prog;
    var ip = state.ip;
    var stack = state.stack;

    var n = prog[++ip];

    if (exports.DEBUG) console.log(state.step, 'NPUSHB[]', n);

    for (var i = 0; i < n; i++) {
        stack.push(prog[++ip]);
    }state.ip = ip;
}

// NPUSHW[] PUSH N Words
// 0x41
function NPUSHW(state) {
    var ip = state.ip;
    var prog = state.prog;
    var stack = state.stack;
    var n = prog[++ip];

    if (exports.DEBUG) console.log(state.step, 'NPUSHW[]', n);

    for (var i = 0; i < n; i++) {
        var w = prog[++ip] << 8 | prog[++ip];
        if (w & 0x8000) w = -((w ^ 0xffff) + 1);
        stack.push(w);
    }

    state.ip = ip;
}

// WS[] Write Store
// 0x42
function WS(state) {
    var stack = state.stack;
    var store = state.store;

    if (!store) store = state.store = [];

    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'WS', v, l);

    store[l] = v;
}

// RS[] Read Store
// 0x43
function RS(state) {
    var stack = state.stack;
    var store = state.store;

    var l = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'RS', l);

    var v = store && store[l] || 0;

    stack.push(v);
}

// WCVTP[] Write Control Value Table in Pixel units
// 0x44
function WCVTP(state) {
    var stack = state.stack;

    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'WCVTP', v, l);

    state.cvt[l] = v / 0x40;
}

// RCVT[] Read Control Value Table entry
// 0x45
function RCVT(state) {
    var stack = state.stack;
    var cvte = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'RCVT', cvte);

    stack.push(state.cvt[cvte] * 0x40);
}

// GC[] Get Coordinate projected onto the projection vector
// 0x46-0x47
function GC(a, state) {
    var stack = state.stack;
    var pi = stack.pop();
    var p = state.z2[pi];

    if (exports.DEBUG) console.log(state.step, 'GC[' + a + ']', pi);

    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
}

// MD[a] Measure Distance
// 0x49-0x4A
function MD(a, state) {
    var stack = state.stack;
    var pi2 = stack.pop();
    var pi1 = stack.pop();
    var p2 = state.z1[pi2];
    var p1 = state.z0[pi1];
    var d = state.dpv.distance(p1, p2, a, a);

    if (exports.DEBUG) console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d);

    state.stack.push(Math.round(d * 64));
}

// MPPEM[] Measure Pixels Per EM
// 0x4B
function MPPEM(state) {
    if (exports.DEBUG) console.log(state.step, 'MPPEM[]');
    state.stack.push(state.ppem);
}

// FLIPON[] set the auto FLIP Boolean to ON
// 0x4D
function FLIPON(state) {
    if (exports.DEBUG) console.log(state.step, 'FLIPON[]');
    state.autoFlip = true;
}

// LT[] Less Than
// 0x50
function LT(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'LT[]', e2, e1);

    stack.push(e1 < e2 ? 1 : 0);
}

// LTEQ[] Less Than or EQual
// 0x53
function LTEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'LTEQ[]', e2, e1);

    stack.push(e1 <= e2 ? 1 : 0);
}

// GTEQ[] Greater Than
// 0x52
function GT(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'GT[]', e2, e1);

    stack.push(e1 > e2 ? 1 : 0);
}

// GTEQ[] Greater Than or EQual
// 0x53
function GTEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'GTEQ[]', e2, e1);

    stack.push(e1 >= e2 ? 1 : 0);
}

// EQ[] EQual
// 0x54
function EQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'EQ[]', e2, e1);

    stack.push(e2 === e1 ? 1 : 0);
}

// NEQ[] Not EQual
// 0x55
function NEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'NEQ[]', e2, e1);

    stack.push(e2 !== e1 ? 1 : 0);
}

// ODD[] ODD
// 0x56
function ODD(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'ODD[]', n);

    stack.push((0, _trunc2.default)(n) % 2 ? 1 : 0);
}

// EVEN[] EVEN
// 0x57
function EVEN(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'EVEN[]', n);

    stack.push((0, _trunc2.default)(n) % 2 ? 0 : 1);
}

// IF[] IF test
// 0x58
function IF(state) {
    var test = state.stack.pop();
    var ins = void 0;

    if (exports.DEBUG) console.log(state.step, 'IF[]', test);

    // if test is true it just continues
    // if not the ip is skipped until matching ELSE or EIF
    if (!test) {
        skip(state, true);

        if (exports.DEBUG) console.log(state.step, ins === 0x1B ? 'ELSE[]' : 'EIF[]');
    }
}

// EIF[] End IF
// 0x59
function EIF(state) {
    // this can be reached normally when
    // executing an else branch.
    // -> just ignore it

    if (exports.DEBUG) console.log(state.step, 'EIF[]');
}

// AND[] logical AND
// 0x5A
function AND(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'AND[]', e2, e1);

    stack.push(e2 && e1 ? 1 : 0);
}

// OR[] logical OR
// 0x5B
function OR(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'OR[]', e2, e1);

    stack.push(e2 || e1 ? 1 : 0);
}

// NOT[] logical NOT
// 0x5C
function NOT(state) {
    var stack = state.stack;
    var e = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'NOT[]', e);

    stack.push(e ? 0 : 1);
}

// DELTAP1[] DELTA exception P1
// DELTAP2[] DELTA exception P2
// DELTAP3[] DELTA exception P3
// 0x5D, 0x71, 0x72
function DELTAP123(b, state) {
    var stack = state.stack;
    var n = stack.pop();
    var fv = state.fv;
    var pv = state.pv;
    var ppem = state.ppem;
    var base = state.deltaBase + (b - 1) * 16;
    var ds = state.deltaShift;
    var z0 = state.z0;

    if (exports.DEBUG) console.log(state.step, 'DELTAP[' + b + ']', n, stack);

    for (var i = 0; i < n; i++) {
        var pi = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) continue;

        var mag = (arg & 0x0F) - 8;
        if (mag >= 0) mag++;
        if (exports.DEBUG) console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds);

        var p = z0[pi];
        fv.setRelative(p, p, mag * ds, pv);
    }
}

// SDB[] Set Delta Base in the graphics state
// 0x5E
function SDB(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SDB[]', n);

    state.deltaBase = n;
}

// SDS[] Set Delta Shift in the graphics state
// 0x5F
function SDS(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SDS[]', n);

    state.deltaShift = Math.pow(0.5, n);
}

// ADD[] ADD
// 0x60
function ADD(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'ADD[]', n2, n1);

    stack.push(n1 + n2);
}

// SUB[] SUB
// 0x61
function SUB(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SUB[]', n2, n1);

    stack.push(n1 - n2);
}

// DIV[] DIV
// 0x62
function DIV(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'DIV[]', n2, n1);

    stack.push(n1 * 64 / n2);
}

// MUL[] MUL
// 0x63
function MUL(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'MUL[]', n2, n1);

    stack.push(n1 * n2 / 64);
}

// ABS[] ABSolute value
// 0x64
function ABS(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'ABS[]', n);

    stack.push(Math.abs(n));
}

// NEG[] NEGate
// 0x65
function NEG(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'NEG[]', n);

    stack.push(-n);
}

// FLOOR[] FLOOR
// 0x66
function FLOOR(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'FLOOR[]', n);

    stack.push(Math.floor(n / 0x40) * 0x40);
}

// CEILING[] CEILING
// 0x67
function CEILING(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'CEILING[]', n);

    stack.push(Math.ceil(n / 0x40) * 0x40);
}

// ROUND[ab] ROUND value
// 0x68-0x6B
function ROUND(dt, state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'ROUND[]');

    stack.push(state.round(n / 0x40) * 0x40);
}

// WCVTF[] Write Control Value Table in Funits
// 0x70
function WCVTF(state) {
    var stack = state.stack;
    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'WCVTF[]', v, l);

    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
}

// DELTAC1[] DELTA exception C1
// DELTAC2[] DELTA exception C2
// DELTAC3[] DELTA exception C3
// 0x73, 0x74, 0x75
function DELTAC123(b, state) {
    var stack = state.stack;
    var n = stack.pop();
    var ppem = state.ppem;
    var base = state.deltaBase + (b - 1) * 16;
    var ds = state.deltaShift;

    if (exports.DEBUG) console.log(state.step, 'DELTAC[' + b + ']', n, stack);

    for (var i = 0; i < n; i++) {
        var c = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) continue;

        var mag = (arg & 0x0F) - 8;
        if (mag >= 0) mag++;

        var delta = mag * ds;

        if (exports.DEBUG) console.log(state.step, 'DELTACFIX', c, 'by', delta);

        state.cvt[c] += delta;
    }
}

// SROUND[] Super ROUND
// 0x76
function SROUND(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'SROUND[]', n);

    state.round = roundSuper;

    var period = void 0;

    switch (n & 0xC0) {
        case 0x00:
            period = 0.5;
            break;
        case 0x40:
            period = 1;
            break;
        case 0x80:
            period = 2;
            break;
        default:
            throw new Error('invalid SROUND value');
    }

    state.srPeriod = period;

    switch (n & 0x30) {
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5 * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default:
            throw new Error('invalid SROUND value');
    }

    n &= 0x0F;

    if (n === 0) state.srThreshold = 0;else state.srThreshold = (n / 8 - 0.5) * period;
}

// S45ROUND[] Super ROUND 45 degrees
// 0x77
function S45ROUND(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'S45ROUND[]', n);

    state.round = roundSuper;

    var period = void 0;

    switch (n & 0xC0) {
        case 0x00:
            period = Math.sqrt(2) / 2;
            break;
        case 0x40:
            period = Math.sqrt(2);
            break;
        case 0x80:
            period = 2 * Math.sqrt(2);
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }

    state.srPeriod = period;

    switch (n & 0x30) {
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5 * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }

    n &= 0x0F;

    if (n === 0) state.srThreshold = 0;else state.srThreshold = (n / 8 - 0.5) * period;
}

// ROFF[] Round Off
// 0x7A
function ROFF(state) {
    if (exports.DEBUG) console.log(state.step, 'ROFF[]');

    state.round = roundOff;
}

// RUTG[] Round Up To Grid
// 0x7C
function RUTG(state) {
    if (exports.DEBUG) console.log(state.step, 'RUTG[]');

    state.round = roundUpToGrid;
}

// RDTG[] Round Down To Grid
// 0x7D
function RDTG(state) {
    if (exports.DEBUG) console.log(state.step, 'RDTG[]');

    state.round = roundDownToGrid;
}

// SCANCTRL[] SCAN conversion ConTRoL
// 0x85
function SCANCTRL(state) {
    var n = state.stack.pop();

    // ignored by opentype.js

    if (exports.DEBUG) console.log(state.step, 'SCANCTRL[]', n);
}

// SDPVTL[a] Set Dual Projection Vector To Line
// 0x86-0x87
function SDPVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) console.log('SDPVTL[' + a + ']', p2i, p1i);

    var dx = void 0;
    var dy = void 0;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.dpv = getUnitVector(dx, dy);
}

// GETINFO[] GET INFOrmation
// 0x88
function GETINFO(state) {
    var stack = state.stack;
    var sel = stack.pop();
    var r = 0;

    if (exports.DEBUG) console.log(state.step, 'GETINFO[]', sel);

    // v35 as in no subpixel hinting
    if (sel & 0x01) r = 35;

    // TODO rotation and stretch currently not supported
    // and thus those GETINFO are always 0.

    // opentype.js is always gray scaling
    if (sel & 0x20) r |= 0x1000;

    stack.push(r);
}

// ROLL[] ROLL the top three stack elements
// 0x8A
function ROLL(state) {
    var stack = state.stack;
    var a = stack.pop();
    var b = stack.pop();
    var c = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'ROLL[]');

    stack.push(b);
    stack.push(a);
    stack.push(c);
}

// MAX[] MAXimum of top two stack elements
// 0x8B
function MAX(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'MAX[]', e2, e1);

    stack.push(Math.max(e1, e2));
}

// MIN[] MINimum of top two stack elements
// 0x8C
function MIN(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) console.log(state.step, 'MIN[]', e2, e1);

    stack.push(Math.min(e1, e2));
}

// SCANTYPE[] SCANTYPE
// 0x8D
function SCANTYPE(state) {
    var n = state.stack.pop();
    // ignored by opentype.js
    if (exports.DEBUG) console.log(state.step, 'SCANTYPE[]', n);
}

// INSTCTRL[] INSTCTRL
// 0x8D
function INSTCTRL(state) {
    var s = state.stack.pop();
    var v = state.stack.pop();

    if (exports.DEBUG) console.log(state.step, 'INSTCTRL[]', s, v);

    switch (s) {
        case 1:
            state.inhibitGridFit = !!v;return;
        case 2:
            state.ignoreCvt = !!v;return;
        default:
            throw new Error('invalid INSTCTRL[] selector');
    }
}

// PUSHB[abc] PUSH Bytes
// 0xB0-0xB7
function PUSHB(n, state) {
    var stack = state.stack;
    var prog = state.prog;
    var ip = state.ip;

    if (exports.DEBUG) console.log(state.step, 'PUSHB[' + n + ']');

    for (var i = 0; i < n; i++) {
        stack.push(prog[++ip]);
    }state.ip = ip;
}

// PUSHW[abc] PUSH Words
// 0xB8-0xBF
function PUSHW(n, state) {
    var ip = state.ip;
    var prog = state.prog;
    var stack = state.stack;

    if (exports.DEBUG) console.log(state.ip, 'PUSHW[' + n + ']');

    for (var i = 0; i < n; i++) {
        var w = prog[++ip] << 8 | prog[++ip];
        if (w & 0x8000) w = -((w ^ 0xffff) + 1);
        stack.push(w);
    }

    state.ip = ip;
}

// MDRP[abcde] Move Direct Relative Point
// 0xD0-0xEF
// (if indirect is 0)
//
// and
//
// MIRP[abcde] Move Indirect Relative Point
// 0xE0-0xFF
// (if indirect is 1)

function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
    var stack = state.stack;
    var cvte = indirect && stack.pop();
    var pi = stack.pop();
    var rp0i = state.rp0;
    var rp = state.z0[rp0i];
    var p = state.z1[pi];

    var md = state.minDis;
    var fv = state.fv;
    var pv = state.dpv;
    var od = void 0; // original distance
    var d = void 0; // moving distance
    var sign = void 0; // sign of distance
    var cv = void 0;

    d = od = pv.distance(p, rp, true, true);
    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

    // TODO consider autoFlip
    d = Math.abs(d);

    if (indirect) {
        cv = state.cvt[cvte];

        if (ro && Math.abs(d - cv) < state.cvCutIn) d = cv;
    }

    if (keepD && d < md) d = md;

    if (ro) d = state.round(d);

    fv.setRelative(p, rp, sign * d, pv);
    fv.touch(p);

    if (exports.DEBUG) {
        console.log(state.step, (indirect ? 'MIRP[' : 'MDRP[') + (setRp0 ? 'M' : 'm') + (keepD ? '>' : '_') + (ro ? 'R' : '_') + (dt === 0 ? 'Gr' : dt === 1 ? 'Bl' : dt === 2 ? 'Wh' : '') + ']', indirect ? cvte + '(' + state.cvt[cvte] + ',' + cv + ')' : '', pi, '(d =', od, '->', sign * d, ')');
    }

    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (setRp0) state.rp0 = pi;
}

/*
* The instruction table.
*/
instructionTable = [
/* 0x00 */SVTCA.bind(undefined, yUnitVector),
/* 0x01 */SVTCA.bind(undefined, xUnitVector),
/* 0x02 */SPVTCA.bind(undefined, yUnitVector),
/* 0x03 */SPVTCA.bind(undefined, xUnitVector),
/* 0x04 */SFVTCA.bind(undefined, yUnitVector),
/* 0x05 */SFVTCA.bind(undefined, xUnitVector),
/* 0x06 */SPVTL.bind(undefined, 0),
/* 0x07 */SPVTL.bind(undefined, 1),
/* 0x08 */SFVTL.bind(undefined, 0),
/* 0x09 */SFVTL.bind(undefined, 1),
/* 0x0A */SPVFS,
/* 0x0B */SFVFS,
/* 0x0C */GPV,
/* 0x0D */GFV,
/* 0x0E */SFVTPV,
/* 0x0F */ISECT,
/* 0x10 */SRP0,
/* 0x11 */SRP1,
/* 0x12 */SRP2,
/* 0x13 */SZP0,
/* 0x14 */SZP1,
/* 0x15 */SZP2,
/* 0x16 */SZPS,
/* 0x17 */SLOOP,
/* 0x18 */RTG,
/* 0x19 */RTHG,
/* 0x1A */SMD,
/* 0x1B */ELSE,
/* 0x1C */JMPR,
/* 0x1D */SCVTCI,
/* 0x1E */undefined, // TODO SSWCI
/* 0x1F */undefined, // TODO SSW
/* 0x20 */DUP,
/* 0x21 */POP,
/* 0x22 */CLEAR,
/* 0x23 */SWAP,
/* 0x24 */DEPTH,
/* 0x25 */CINDEX,
/* 0x26 */MINDEX,
/* 0x27 */undefined, // TODO ALIGNPTS
/* 0x28 */undefined,
/* 0x29 */undefined, // TODO UTP
/* 0x2A */LOOPCALL,
/* 0x2B */CALL,
/* 0x2C */FDEF,
/* 0x2D */undefined, // ENDF (eaten by FDEF)
/* 0x2E */MDAP.bind(undefined, 0),
/* 0x2F */MDAP.bind(undefined, 1),
/* 0x30 */IUP.bind(undefined, yUnitVector),
/* 0x31 */IUP.bind(undefined, xUnitVector),
/* 0x32 */SHP.bind(undefined, 0),
/* 0x33 */SHP.bind(undefined, 1),
/* 0x34 */SHC.bind(undefined, 0),
/* 0x35 */SHC.bind(undefined, 1),
/* 0x36 */SHZ.bind(undefined, 0),
/* 0x37 */SHZ.bind(undefined, 1),
/* 0x38 */SHPIX,
/* 0x39 */IP,
/* 0x3A */MSIRP.bind(undefined, 0),
/* 0x3B */MSIRP.bind(undefined, 1),
/* 0x3C */ALIGNRP,
/* 0x3D */RTDG,
/* 0x3E */MIAP.bind(undefined, 0),
/* 0x3F */MIAP.bind(undefined, 1),
/* 0x40 */NPUSHB,
/* 0x41 */NPUSHW,
/* 0x42 */WS,
/* 0x43 */RS,
/* 0x44 */WCVTP,
/* 0x45 */RCVT,
/* 0x46 */GC.bind(undefined, 0),
/* 0x47 */GC.bind(undefined, 1),
/* 0x48 */undefined, // TODO SCFS
/* 0x49 */MD.bind(undefined, 0),
/* 0x4A */MD.bind(undefined, 1),
/* 0x4B */MPPEM,
/* 0x4C */undefined, // TODO MPS
/* 0x4D */FLIPON,
/* 0x4E */undefined, // TODO FLIPOFF
/* 0x4F */undefined, // TODO DEBUG
/* 0x50 */LT,
/* 0x51 */LTEQ,
/* 0x52 */GT,
/* 0x53 */GTEQ,
/* 0x54 */EQ,
/* 0x55 */NEQ,
/* 0x56 */ODD,
/* 0x57 */EVEN,
/* 0x58 */IF,
/* 0x59 */EIF,
/* 0x5A */AND,
/* 0x5B */OR,
/* 0x5C */NOT,
/* 0x5D */DELTAP123.bind(undefined, 1),
/* 0x5E */SDB,
/* 0x5F */SDS,
/* 0x60 */ADD,
/* 0x61 */SUB,
/* 0x62 */DIV,
/* 0x63 */MUL,
/* 0x64 */ABS,
/* 0x65 */NEG,
/* 0x66 */FLOOR,
/* 0x67 */CEILING,
/* 0x68 */ROUND.bind(undefined, 0),
/* 0x69 */ROUND.bind(undefined, 1),
/* 0x6A */ROUND.bind(undefined, 2),
/* 0x6B */ROUND.bind(undefined, 3),
/* 0x6C */undefined, // TODO NROUND[ab]
/* 0x6D */undefined, // TODO NROUND[ab]
/* 0x6E */undefined, // TODO NROUND[ab]
/* 0x6F */undefined, // TODO NROUND[ab]
/* 0x70 */WCVTF,
/* 0x71 */DELTAP123.bind(undefined, 2),
/* 0x72 */DELTAP123.bind(undefined, 3),
/* 0x73 */DELTAC123.bind(undefined, 1),
/* 0x74 */DELTAC123.bind(undefined, 2),
/* 0x75 */DELTAC123.bind(undefined, 3),
/* 0x76 */SROUND,
/* 0x77 */S45ROUND,
/* 0x78 */undefined, // TODO JROT[]
/* 0x79 */undefined, // TODO JROF[]
/* 0x7A */ROFF,
/* 0x7B */undefined,
/* 0x7C */RUTG,
/* 0x7D */RDTG,
/* 0x7E */POP, // actually SANGW, supposed to do only a pop though
/* 0x7F */POP, // actually AA, supposed to do only a pop though
/* 0x80 */undefined, // TODO FLIPPT
/* 0x81 */undefined, // TODO FLIPRGON
/* 0x82 */undefined, // TODO FLIPRGOFF
/* 0x83 */undefined,
/* 0x84 */undefined,
/* 0x85 */SCANCTRL,
/* 0x86 */SDPVTL.bind(undefined, 0),
/* 0x87 */SDPVTL.bind(undefined, 1),
/* 0x88 */GETINFO,
/* 0x89 */undefined, // TODO IDEF
/* 0x8A */ROLL,
/* 0x8B */MAX,
/* 0x8C */MIN,
/* 0x8D */SCANTYPE,
/* 0x8E */INSTCTRL,
/* 0x8F */undefined,
/* 0x90 */undefined,
/* 0x91 */undefined,
/* 0x92 */undefined,
/* 0x93 */undefined,
/* 0x94 */undefined,
/* 0x95 */undefined,
/* 0x96 */undefined,
/* 0x97 */undefined,
/* 0x98 */undefined,
/* 0x99 */undefined,
/* 0x9A */undefined,
/* 0x9B */undefined,
/* 0x9C */undefined,
/* 0x9D */undefined,
/* 0x9E */undefined,
/* 0x9F */undefined,
/* 0xA0 */undefined,
/* 0xA1 */undefined,
/* 0xA2 */undefined,
/* 0xA3 */undefined,
/* 0xA4 */undefined,
/* 0xA5 */undefined,
/* 0xA6 */undefined,
/* 0xA7 */undefined,
/* 0xA8 */undefined,
/* 0xA9 */undefined,
/* 0xAA */undefined,
/* 0xAB */undefined,
/* 0xAC */undefined,
/* 0xAD */undefined,
/* 0xAE */undefined,
/* 0xAF */undefined,
/* 0xB0 */PUSHB.bind(undefined, 1),
/* 0xB1 */PUSHB.bind(undefined, 2),
/* 0xB2 */PUSHB.bind(undefined, 3),
/* 0xB3 */PUSHB.bind(undefined, 4),
/* 0xB4 */PUSHB.bind(undefined, 5),
/* 0xB5 */PUSHB.bind(undefined, 6),
/* 0xB6 */PUSHB.bind(undefined, 7),
/* 0xB7 */PUSHB.bind(undefined, 8),
/* 0xB8 */PUSHW.bind(undefined, 1),
/* 0xB9 */PUSHW.bind(undefined, 2),
/* 0xBA */PUSHW.bind(undefined, 3),
/* 0xBB */PUSHW.bind(undefined, 4),
/* 0xBC */PUSHW.bind(undefined, 5),
/* 0xBD */PUSHW.bind(undefined, 6),
/* 0xBE */PUSHW.bind(undefined, 7),
/* 0xBF */PUSHW.bind(undefined, 8),
/* 0xC0 */MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
/* 0xC1 */MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
/* 0xC2 */MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
/* 0xC3 */MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
/* 0xC4 */MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
/* 0xC5 */MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
/* 0xC6 */MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
/* 0xC7 */MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
/* 0xC8 */MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
/* 0xC9 */MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
/* 0xCA */MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
/* 0xCB */MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
/* 0xCC */MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
/* 0xCD */MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
/* 0xCE */MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
/* 0xCF */MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
/* 0xD0 */MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
/* 0xD1 */MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
/* 0xD2 */MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
/* 0xD3 */MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
/* 0xD4 */MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
/* 0xD5 */MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
/* 0xD6 */MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
/* 0xD7 */MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
/* 0xD8 */MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
/* 0xD9 */MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
/* 0xDA */MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
/* 0xDB */MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
/* 0xDC */MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
/* 0xDD */MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
/* 0xDE */MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
/* 0xDF */MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
/* 0xE0 */MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
/* 0xE1 */MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
/* 0xE2 */MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
/* 0xE3 */MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
/* 0xE4 */MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
/* 0xE5 */MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
/* 0xE6 */MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
/* 0xE7 */MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
/* 0xE8 */MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
/* 0xE9 */MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
/* 0xEA */MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
/* 0xEB */MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
/* 0xEC */MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
/* 0xED */MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
/* 0xEE */MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
/* 0xEF */MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
/* 0xF0 */MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
/* 0xF1 */MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
/* 0xF2 */MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
/* 0xF3 */MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
/* 0xF4 */MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
/* 0xF5 */MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
/* 0xF6 */MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
/* 0xF7 */MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
/* 0xF8 */MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
/* 0xF9 */MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
/* 0xFA */MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
/* 0xFB */MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
/* 0xFC */MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
/* 0xFD */MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
/* 0xFE */MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
/* 0xFF */MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)];

exports.default = Hinting;

/*****************************
  Mathematical Considerations
******************************

fv ... refers to freedom vector
pv ... refers to projection vector
rp ... refers to reference point
p  ... refers to to point being operated on
d  ... refers to distance

SETRELATIVE:
============

case freedom vector == x-axis:
------------------------------

                        (pv)
                     .-'
              rpd .-'
               .-*
          d .-'90'
         .-'       '
      .-'           '
   *-'               ' b
  rp                  '
                       '
                        '
            p *----------*-------------- (fv)
                          pm

  rpdx = rpx + d * pv.x
  rpdy = rpy + d * pv.y

  equation of line b

   y - rpdy = pvns * (x- rpdx)

   y = p.y

   x = rpdx + ( p.y - rpdy ) / pvns


case freedom vector == y-axis:
------------------------------

    * pm
    |\
    | \
    |  \
    |   \
    |    \
    |     \
    |      \
    |       \
    |        \
    |         \ b
    |          \
    |           \
    |            \    .-' (pv)
    |         90 \.-'
    |           .-'* rpd
    |        .-'
    *     *-'  d
    p     rp

  rpdx = rpx + d * pv.x
  rpdy = rpy + d * pv.y

  equation of line b:
           pvns ... normal slope to pv

   y - rpdy = pvns * (x - rpdx)

   x = p.x

   y = rpdy +  pvns * (p.x - rpdx)



generic case:
-------------


                              .'(fv)
                            .'
                          .* pm
                        .' !
                      .'    .
                    .'      !
                  .'         . b
                .'           !
               *              .
              p               !
                         90   .    ... (pv)
                           ...-*-'''
                  ...---'''    rpd
         ...---'''   d
   *--'''
  rp

    rpdx = rpx + d * pv.x
    rpdy = rpy + d * pv.y

 equation of line b:
    pvns... normal slope to pv

    y - rpdy = pvns * (x - rpdx)

 equation of freedom vector line:
    fvs ... slope of freedom vector (=fy/fx)

    y - py = fvs * (x - px)


  on pm both equations are true for same x/y

    y - rpdy = pvns * (x - rpdx)

    y - py = fvs * (x - px)

  form to y and set equal:

    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

  expand:

    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

  switch:

    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

  solve for x:

    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



          fvs * px - pvns * rpdx + rpdy - py
    x =  -----------------------------------
                 fvs - pvns

  and:

    y = fvs * (x - px) + py



INTERPOLATE:
============

Examples of point interpolation.

The weight of the movement of the reference point gets bigger
the further the other reference point is away, thus the safest
option (that is avoiding 0/0 divisions) is to weight the
original distance of the other point by the sum of both distances.

If the sum of both distances is 0, then move the point by the
arithmetic average of the movement of both reference points.




           (+6)
    rp1o *---->*rp1
         .     .                          (+12)
         .     .                  rp2o *---------->* rp2
         .     .                       .           .
         .     .                       .           .
         .    10          20           .           .
         |.........|...................|           .
               .   .                               .
               .   . (+8)                          .
                po *------>*p                      .
               .           .                       .
               .    12     .          24           .
               |...........|.......................|
                                  36


-------



           (+10)
    rp1o *-------->*rp1
         .         .                      (-10)
         .         .              rp2 *<---------* rpo2
         .         .                   .         .
         .         .                   .         .
         .    10   .          30       .         .
         |.........|.............................|
                   .                   .
                   . (+5)              .
                po *--->* p            .
                   .    .              .
                   .    .   20         .
                   |....|..............|
                     5        15


-------


           (+10)
    rp1o *-------->*rp1
         .         .
         .         .
    rp2o *-------->*rp2


                               (+10)
                          po *-------->* p

-------


           (+10)
    rp1o *-------->*rp1
         .         .
         .         .(+30)
    rp2o *---------------------------->*rp2


                                        (+25)
                          po *----------------------->* p



vim: set ts=4 sw=4 expandtab:
*****/

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function searchTag(arr, tag) {
    /* jshint bitwise: false */
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = imin + imax >>> 1;
        var val = arr[imid].tag;
        if (val === tag) {
            return imid;
        } else if (val < tag) {
            imin = imid + 1;
        } else {
            imax = imid - 1;
        }
    }
    // Not found: return -1-insertion point
    return -imin - 1;
} // The Layout object is the prototype of Substitution objects, and provides
// utility methods to manipulate common layout tables (GPOS, GSUB, GDEF...)

function binSearch(arr, value) {
    /* jshint bitwise: false */
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = imin + imax >>> 1;
        var val = arr[imid];
        if (val === value) {
            return imid;
        } else if (val < value) {
            imin = imid + 1;
        } else {
            imax = imid - 1;
        }
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}

/**
 * @exports opentype.Layout
 * @class
 */
function Layout(font, tableName) {
    this.font = font;
    this.tableName = tableName;
}

Layout.prototype = {

    /**
     * Binary search an object by "tag" property
     * @instance
     * @function searchTag
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {string} tag
     * @return {number}
     */
    searchTag: searchTag,

    /**
     * Binary search in a list of numbers
     * @instance
     * @function binSearch
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {number} value
     * @return {number}
     */
    binSearch: binSearch,

    /**
     * Get or create the Layout table (GSUB, GPOS etc).
     * @param  {boolean} create - Whether to create a new one.
     * @return {Object} The GSUB or GPOS table.
     */
    getTable: function getTable(create) {
        var layout = this.font.tables[this.tableName];
        if (!layout && create) {
            layout = this.font.tables[this.tableName] = this.createDefaultTable();
        }
        return layout;
    },

    /**
     * Returns all scripts in the substitution table.
     * @instance
     * @return {Array}
     */
    getScriptNames: function getScriptNames() {
        var layout = this.getTable();
        if (!layout) {
            return [];
        }
        return layout.scripts.map(function (script) {
            return script.tag;
        });
    },

    /**
     * Returns the best bet for a script name.
     * Returns 'DFLT' if it exists.
     * If not, returns 'latn' if it exists.
     * If neither exist, returns undefined.
     */
    getDefaultScriptName: function getDefaultScriptName() {
        var layout = this.getTable();
        if (!layout) {
            return;
        }
        var hasLatn = false;
        for (var i = 0; i < layout.scripts.length; i++) {
            var name = layout.scripts[i].tag;
            if (name === 'DFLT') return name;
            if (name === 'latn') hasLatn = true;
        }
        if (hasLatn) return 'latn';
    },

    /**
     * Returns all LangSysRecords in the given script.
     * @instance
     * @param {string} [script='DFLT']
     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
     * @return {Object} An object with tag and script properties.
     */
    getScriptTable: function getScriptTable(script, create) {
        var layout = this.getTable(create);
        if (layout) {
            script = script || 'DFLT';
            var scripts = layout.scripts;
            var pos = searchTag(layout.scripts, script);
            if (pos >= 0) {
                return scripts[pos].script;
            } else if (create) {
                var scr = {
                    tag: script,
                    script: {
                        defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
                        langSysRecords: []
                    }
                };
                scripts.splice(-1 - pos, 0, scr);
                return scr.script;
            }
        }
    },

    /**
     * Returns a language system table
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
     * @return {Object}
     */
    getLangSysTable: function getLangSysTable(script, language, create) {
        var scriptTable = this.getScriptTable(script, create);
        if (scriptTable) {
            if (!language || language === 'dflt' || language === 'DFLT') {
                return scriptTable.defaultLangSys;
            }
            var pos = searchTag(scriptTable.langSysRecords, language);
            if (pos >= 0) {
                return scriptTable.langSysRecords[pos].langSys;
            } else if (create) {
                var langSysRecord = {
                    tag: language,
                    langSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] }
                };
                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
                return langSysRecord.langSys;
            }
        }
    },

    /**
     * Get a specific feature table.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
     * @return {Object}
     */
    getFeatureTable: function getFeatureTable(script, language, feature, create) {
        var langSysTable = this.getLangSysTable(script, language, create);
        if (langSysTable) {
            var featureRecord = void 0;
            var featIndexes = langSysTable.featureIndexes;
            var allFeatures = this.font.tables[this.tableName].features;
            // The FeatureIndex array of indices is in arbitrary order,
            // even if allFeatures is sorted alphabetically by feature tag.
            for (var i = 0; i < featIndexes.length; i++) {
                featureRecord = allFeatures[featIndexes[i]];
                if (featureRecord.tag === feature) {
                    return featureRecord.feature;
                }
            }
            if (create) {
                var index = allFeatures.length;
                // Automatic ordering of features would require to shift feature indexes in the script list.
                _check2.default.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
                featureRecord = {
                    tag: feature,
                    feature: { params: 0, lookupListIndexes: [] }
                };
                allFeatures.push(featureRecord);
                featIndexes.push(index);
                return featureRecord.feature;
            }
        }
    },

    /**
     * Get the lookup tables of a given type for a script/language/feature.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - 4-letter feature code
     * @param {number} lookupType - 1 to 8
     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
     * @return {Object[]}
     */
    getLookupTables: function getLookupTables(script, language, feature, lookupType, create) {
        var featureTable = this.getFeatureTable(script, language, feature, create);
        var tables = [];
        if (featureTable) {
            var lookupTable = void 0;
            var lookupListIndexes = featureTable.lookupListIndexes;
            var allLookups = this.font.tables[this.tableName].lookups;
            // lookupListIndexes are in no particular order, so use naive search.
            for (var i = 0; i < lookupListIndexes.length; i++) {
                lookupTable = allLookups[lookupListIndexes[i]];
                if (lookupTable.lookupType === lookupType) {
                    tables.push(lookupTable);
                }
            }
            if (tables.length === 0 && create) {
                lookupTable = {
                    lookupType: lookupType,
                    lookupFlag: 0,
                    subtables: [],
                    markFilteringSet: undefined
                };
                var index = allLookups.length;
                allLookups.push(lookupTable);
                lookupListIndexes.push(index);
                return [lookupTable];
            }
        }
        return tables;
    },

    /**
     * Returns the list of glyph indexes of a coverage table.
     * Format 1: the list is stored raw
     * Format 2: compact list as range records.
     * @instance
     * @param  {Object} coverageTable
     * @return {Array}
     */
    expandCoverage: function expandCoverage(coverageTable) {
        if (coverageTable.format === 1) {
            return coverageTable.glyphs;
        } else {
            var glyphs = [];
            var ranges = coverageTable.ranges;
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                var start = range.start;
                var end = range.end;
                for (var j = start; j <= end; j++) {
                    glyphs.push(j);
                }
            }
            return glyphs;
        }
    }

};

exports.default = Layout;

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _layout = __webpack_require__(323);

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @exports opentype.Substitution
 * @class
 * @extends opentype.Layout
 * @param {opentype.Font}
 * @constructor
 */
// The Substitution object provides utility methods to manipulate
// the GSUB substitution table.

function Substitution(font) {
    _layout2.default.call(this, font, 'gsub');
}

// Check if 2 arrays of primitives are equal.
function arraysEqual(ar1, ar2) {
    var n = ar1.length;
    if (n !== ar2.length) {
        return false;
    }
    for (var i = 0; i < n; i++) {
        if (ar1[i] !== ar2[i]) {
            return false;
        }
    }
    return true;
}

// Find the first subtable of a lookup table in a particular format.
function getSubstFormat(lookupTable, format, defaultSubtable) {
    var subtables = lookupTable.subtables;
    for (var i = 0; i < subtables.length; i++) {
        var subtable = subtables[i];
        if (subtable.substFormat === format) {
            return subtable;
        }
    }
    if (defaultSubtable) {
        subtables.push(defaultSubtable);
        return defaultSubtable;
    }
    return undefined;
}

Substitution.prototype = _layout2.default.prototype;

/**
 * Create a default GSUB table.
 * @return {Object} gsub - The GSUB table.
 */
Substitution.prototype.createDefaultTable = function () {
    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
    return {
        version: 1,
        scripts: [{
            tag: 'DFLT',
            script: {
                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
                langSysRecords: []
            }
        }],
        features: [],
        lookups: []
    };
};

/**
 * List all single substitutions (lookup type 1) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getSingle = function (feature, script, language) {
    var substitutions = [];
    var lookupTables = this.getLookupTables(script, language, feature, 1);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this.expandCoverage(subtable.coverage);
            var j = void 0;
            if (subtable.substFormat === 1) {
                var delta = subtable.deltaGlyphId;
                for (j = 0; j < glyphs.length; j++) {
                    var glyph = glyphs[j];
                    substitutions.push({ sub: glyph, by: glyph + delta });
                }
            } else {
                var substitute = subtable.substitute;
                for (j = 0; j < glyphs.length; j++) {
                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
                }
            }
        }
    }
    return substitutions;
};

/**
 * List all alternates (lookup type 3) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
 * @return {Array} alternates - The list of alternates
 */
Substitution.prototype.getAlternates = function (feature, script, language) {
    var alternates = [];
    var lookupTables = this.getLookupTables(script, language, feature, 3);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this.expandCoverage(subtable.coverage);
            var alternateSets = subtable.alternateSets;
            for (var j = 0; j < glyphs.length; j++) {
                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
            }
        }
    }
    return alternates;
};

/**
 * List all ligatures (lookup type 4) for a given script, language, and feature.
 * The result is an array of ligature objects like { sub: [ids], by: id }
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} ligatures - The list of ligatures.
 */
Substitution.prototype.getLigatures = function (feature, script, language) {
    var ligatures = [];
    var lookupTables = this.getLookupTables(script, language, feature, 4);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this.expandCoverage(subtable.coverage);
            var ligatureSets = subtable.ligatureSets;
            for (var j = 0; j < glyphs.length; j++) {
                var startGlyph = glyphs[j];
                var ligSet = ligatureSets[j];
                for (var k = 0; k < ligSet.length; k++) {
                    var lig = ligSet[k];
                    ligatures.push({
                        sub: [startGlyph].concat(lig.components),
                        by: lig.ligGlyph
                    });
                }
            }
        }
    }
    return ligatures;
};

/**
 * Add or modify a single substitution (lookup type 1)
 * Format 2, more flexible, is always used.
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addSingle = function (feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
    var subtable = getSubstFormat(lookupTable, 2, { // lookup type 1 subtable, format 2, coverage format 1
        substFormat: 2,
        coverage: { format: 1, glyphs: [] },
        substitute: []
    });
    _check2.default.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.substitute.splice(pos, 0, 0);
    }
    subtable.substitute[pos] = substitution.by;
};

/**
 * Add or modify an alternate substitution (lookup type 1)
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, by: [ids] }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addAlternate = function (feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
    var subtable = getSubstFormat(lookupTable, 1, { // lookup type 3 subtable, format 1, coverage format 1
        substFormat: 1,
        coverage: { format: 1, glyphs: [] },
        alternateSets: []
    });
    _check2.default.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.alternateSets.splice(pos, 0, 0);
    }
    subtable.alternateSets[pos] = substitution.by;
};

/**
 * Add a ligature (lookup type 4)
 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} ligature - { sub: [ids], by: id }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addLigature = function (feature, ligature, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
    var subtable = lookupTable.subtables[0];
    if (!subtable) {
        subtable = { // lookup type 4 subtable, format 1, coverage format 1
            substFormat: 1,
            coverage: { format: 1, glyphs: [] },
            ligatureSets: []
        };
        lookupTable.subtables[0] = subtable;
    }
    _check2.default.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = ligature.sub[0];
    var ligComponents = ligature.sub.slice(1);
    var ligatureTable = {
        ligGlyph: ligature.by,
        components: ligComponents
    };
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos >= 0) {
        // ligatureSet already exists
        var ligatureSet = subtable.ligatureSets[pos];
        for (var i = 0; i < ligatureSet.length; i++) {
            // If ligature already exists, return.
            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
                return;
            }
        }
        // ligature does not exist: add it.
        ligatureSet.push(ligatureTable);
    } else {
        // Create a new ligatureSet and add coverage for the first glyph.
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
    }
};

/**
 * List all feature data for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getFeature = function (feature, script, language) {
    if (/ss\d\d/.test(feature)) {
        // ss01 - ss20
        return this.getSingle(feature, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            return this.getSingle(feature, script, language).concat(this.getAlternates(feature, script, language));
        case 'dlig':
        case 'liga':
        case 'rlig':
            return this.getLigatures(feature, script, language);
    }
    return undefined;
};

/**
 * Add a substitution to a feature for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.add = function (feature, sub, script, language) {
    if (/ss\d\d/.test(feature)) {
        // ss01 - ss20
        return this.addSingle(feature, sub, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            if (typeof sub.by === 'number') {
                return this.addSingle(feature, sub, script, language);
            }
            return this.addAlternate(feature, sub, script, language);
        case 'dlig':
        case 'liga':
        case 'rlig':
            return this.addLigature(feature, sub, script, language);
    }
    return undefined;
};

exports.default = Substitution;

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _stringify = __webpack_require__(47);

var _stringify2 = _interopRequireDefault(_stringify);

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addName(name, names) {
    var nameString = (0, _stringify2.default)(name);
    var nameID = 256;
    for (var nameKey in names) {
        var n = parseInt(nameKey);
        if (!n || n < 256) {
            continue;
        }

        if ((0, _stringify2.default)(names[nameKey]) === nameString) {
            return n;
        }

        if (nameID <= n) {
            nameID = n + 1;
        }
    }

    names[nameID] = name;
    return nameID;
} // The `fvar` table stores font variation axes and instances.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6fvar.html

function makeFvarAxis(n, axis, names) {
    var nameID = addName(axis.name, names);
    return [{ name: 'tag_' + n, type: 'TAG', value: axis.tag }, { name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16 }, { name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16 }, { name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16 }, { name: 'flags_' + n, type: 'USHORT', value: 0 }, { name: 'nameID_' + n, type: 'USHORT', value: nameID }];
}

function parseFvarAxis(data, start, names) {
    var axis = {};
    var p = new _parse2.default.Parser(data, start);
    axis.tag = p.parseTag();
    axis.minValue = p.parseFixed();
    axis.defaultValue = p.parseFixed();
    axis.maxValue = p.parseFixed();
    p.skip('uShort', 1); // reserved for flags; no values defined
    axis.name = names[p.parseUShort()] || {};
    return axis;
}

function makeFvarInstance(n, inst, axes, names) {
    var nameID = addName(inst.name, names);
    var fields = [{ name: 'nameID_' + n, type: 'USHORT', value: nameID }, { name: 'flags_' + n, type: 'USHORT', value: 0 }];

    for (var i = 0; i < axes.length; ++i) {
        var axisTag = axes[i].tag;
        fields.push({
            name: 'axis_' + n + ' ' + axisTag,
            type: 'FIXED',
            value: inst.coordinates[axisTag] << 16
        });
    }

    return fields;
}

function parseFvarInstance(data, start, axes, names) {
    var inst = {};
    var p = new _parse2.default.Parser(data, start);
    inst.name = names[p.parseUShort()] || {};
    p.skip('uShort', 1); // reserved for flags; no values defined

    inst.coordinates = {};
    for (var i = 0; i < axes.length; ++i) {
        inst.coordinates[axes[i].tag] = p.parseFixed();
    }

    return inst;
}

function makeFvarTable(fvar, names) {
    var result = new _table2.default.Table('fvar', [{ name: 'version', type: 'ULONG', value: 0x10000 }, { name: 'offsetToData', type: 'USHORT', value: 0 }, { name: 'countSizePairs', type: 'USHORT', value: 2 }, { name: 'axisCount', type: 'USHORT', value: fvar.axes.length }, { name: 'axisSize', type: 'USHORT', value: 20 }, { name: 'instanceCount', type: 'USHORT', value: fvar.instances.length }, { name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4 }]);
    result.offsetToData = result.sizeOf();

    for (var i = 0; i < fvar.axes.length; i++) {
        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
    }

    for (var j = 0; j < fvar.instances.length; j++) {
        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
    }

    return result;
}

function parseFvarTable(data, start, names) {
    var p = new _parse2.default.Parser(data, start);
    var tableVersion = p.parseULong();
    _check2.default.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
    var offsetToData = p.parseOffset16();
    // Skip countSizePairs.
    p.skip('uShort', 1);
    var axisCount = p.parseUShort();
    var axisSize = p.parseUShort();
    var instanceCount = p.parseUShort();
    var instanceSize = p.parseUShort();

    var axes = [];
    for (var i = 0; i < axisCount; i++) {
        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
    }

    var instances = [];
    var instanceStart = start + offsetToData + axisCount * axisSize;
    for (var j = 0; j < instanceCount; j++) {
        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
    }

    return { axes: axes, instances: instances };
}

exports.default = { make: makeFvarTable, parse: parseFvarTable };

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.
// These lists are unused by now, this function is just the basis for a real parsing.
// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

function parseTaggedListTable(data, start) {
    var p = new _parse2.default.Parser(data, start);
    var n = p.parseUShort();
    var list = [];
    for (var i = 0; i < n; i++) {
        list[p.parseTag()] = { offset: p.parseUShort() };
    }

    return list;
}

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// Format 1 is a simple list of glyph ids,
// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.
function parseCoverageTable(data, start) {
    var p = new _parse2.default.Parser(data, start);
    var format = p.parseUShort();
    var count = p.parseUShort();
    if (format === 1) {
        return p.parseUShortList(count);
    } else if (format === 2) {
        var coverage = [];
        for (; count--;) {
            var begin = p.parseUShort();
            var end = p.parseUShort();
            var index = p.parseUShort();
            for (var i = begin; i <= end; i++) {
                coverage[index++] = i;
            }
        }

        return coverage;
    }
}

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// Returns a function that gets a class value from a glyph ID.
function parseClassDefTable(data, start) {
    var p = new _parse2.default.Parser(data, start);
    var format = p.parseUShort();
    if (format === 1) {
        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.
        var startGlyph = p.parseUShort();
        var glyphCount = p.parseUShort();
        var classes = p.parseUShortList(glyphCount);
        return function (glyphID) {
            return classes[glyphID - startGlyph] || 0;
        };
    } else if (format === 2) {
        // Format 2 defines multiple groups of glyph indices that belong to the same class.
        var rangeCount = p.parseUShort();
        var startGlyphs = [];
        var endGlyphs = [];
        var classValues = [];
        for (var i = 0; i < rangeCount; i++) {
            startGlyphs[i] = p.parseUShort();
            endGlyphs[i] = p.parseUShort();
            classValues[i] = p.parseUShort();
        }

        return function (glyphID) {
            var l = 0;
            var r = startGlyphs.length - 1;
            while (l < r) {
                var c = l + r + 1 >> 1;
                if (glyphID < startGlyphs[c]) {
                    r = c - 1;
                } else {
                    l = c;
                }
            }

            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {
                return classValues[l] || 0;
            }

            return 0;
        };
    }
}

// Parse a pair adjustment positioning subtable, format 1 or format 2
// The subtable is returned in the form of a lookup function.
function parsePairPosSubTable(data, start) {
    var p = new _parse2.default.Parser(data, start);
    // This part is common to format 1 and format 2 subtables
    var format = p.parseUShort();
    var coverageOffset = p.parseUShort();
    var coverage = parseCoverageTable(data, start + coverageOffset);
    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph
    // Only valueFormat1=4 and valueFormat2=0 is supported.
    var valueFormat1 = p.parseUShort();
    var valueFormat2 = p.parseUShort();
    var value1 = void 0;
    var value2 = void 0;
    if (valueFormat1 !== 4 || valueFormat2 !== 0) return;
    var sharedPairSets = {};
    if (format === 1) {
        // Pair Positioning Adjustment: Format 1
        var pairSetCount = p.parseUShort();
        var pairSet = [];
        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index
        var pairSetOffsets = p.parseOffset16List(pairSetCount);
        for (var firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {
            var pairSetOffset = pairSetOffsets[firstGlyph];
            var sharedPairSet = sharedPairSets[pairSetOffset];
            if (!sharedPairSet) {
                // Parse a pairset table in a pair adjustment subtable format 1
                sharedPairSet = {};
                p.relativeOffset = pairSetOffset;
                var pairValueCount = p.parseUShort();
                for (; pairValueCount--;) {
                    var secondGlyph = p.parseUShort();
                    if (valueFormat1) value1 = p.parseShort();
                    if (valueFormat2) value2 = p.parseShort();
                    // We only support valueFormat1 = 4 and valueFormat2 = 0,
                    // so value1 is the XAdvance and value2 is empty.
                    sharedPairSet[secondGlyph] = value1;
                }
            }

            pairSet[coverage[firstGlyph]] = sharedPairSet;
        }

        return function (leftGlyph, rightGlyph) {
            var pairs = pairSet[leftGlyph];
            if (pairs) return pairs[rightGlyph];
        };
    } else if (format === 2) {
        // Pair Positioning Adjustment: Format 2
        var classDef1Offset = p.parseUShort();
        var classDef2Offset = p.parseUShort();
        var class1Count = p.parseUShort();
        var class2Count = p.parseUShort();
        var getClass1 = parseClassDefTable(data, start + classDef1Offset);
        var getClass2 = parseClassDefTable(data, start + classDef2Offset);

        // Parse kerning values by class pair.
        var kerningMatrix = [];
        for (var i = 0; i < class1Count; i++) {
            var kerningRow = kerningMatrix[i] = [];
            for (var j = 0; j < class2Count; j++) {
                if (valueFormat1) value1 = p.parseShort();
                if (valueFormat2) value2 = p.parseShort();
                // We only support valueFormat1 = 4 and valueFormat2 = 0,
                // so value1 is the XAdvance and value2 is empty.
                kerningRow[j] = value1;
            }
        }

        // Convert coverage list to a hash
        var covered = {};
        for (var _i = 0; _i < coverage.length; _i++) {
            covered[coverage[_i]] = 1;
        }

        // Get the kerning value for a specific glyph pair.
        return function (leftGlyph, rightGlyph) {
            if (!covered[leftGlyph]) return;
            var class1 = getClass1(leftGlyph);
            var class2 = getClass2(rightGlyph);
            var kerningRow = kerningMatrix[class1];

            if (kerningRow) {
                return kerningRow[class2];
            }
        };
    }
}

// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).
function parseLookupTable(data, start) {
    var p = new _parse2.default.Parser(data, start);
    var lookupType = p.parseUShort();
    var lookupFlag = p.parseUShort();
    var useMarkFilteringSet = lookupFlag & 0x10;
    var subTableCount = p.parseUShort();
    var subTableOffsets = p.parseOffset16List(subTableCount);
    var table = {
        lookupType: lookupType,
        lookupFlag: lookupFlag,
        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1
    };
    // LookupType 2, Pair adjustment
    if (lookupType === 2) {
        var subtables = [];
        for (var i = 0; i < subTableCount; i++) {
            var pairPosSubTable = parsePairPosSubTable(data, start + subTableOffsets[i]);
            if (pairPosSubTable) subtables.push(pairPosSubTable);
        }
        // Return a function which finds the kerning values in the subtables.
        table.getKerningValue = function (leftGlyph, rightGlyph) {
            for (var _i2 = subtables.length; _i2--;) {
                var value = subtables[_i2](leftGlyph, rightGlyph);
                if (value !== undefined) return value;
            }

            return 0;
        };
    }

    return table;
}

// Parse the `GPOS` table which contains, among other things, kerning pairs.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm
function parseGposTable(data, start, font) {
    var p = new _parse2.default.Parser(data, start);
    var tableVersion = p.parseFixed();
    _check2.default.argument(tableVersion === 1, 'Unsupported GPOS table version.');

    // ScriptList and FeatureList - ignored for now
    parseTaggedListTable(data, start + p.parseUShort());
    // 'kern' is the feature we are looking for.
    parseTaggedListTable(data, start + p.parseUShort());

    // LookupList
    var lookupListOffset = p.parseUShort();
    p.relativeOffset = lookupListOffset;
    var lookupCount = p.parseUShort();
    var lookupTableOffsets = p.parseOffset16List(lookupCount);
    var lookupListAbsoluteOffset = start + lookupListOffset;
    for (var i = 0; i < lookupCount; i++) {
        var table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);
        if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;
    }
}

exports.default = { parse: parseGposTable };

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm

function parseWindowsKernTable(p) {
    var pairs = {};
    // Skip nTables.
    p.skip('uShort');
    var subtableVersion = p.parseUShort();
    _check2.default.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subtableLength, subtableCoverage
    p.skip('uShort', 2);
    var nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for (var i = 0; i < nPairs; i += 1) {
        var leftIndex = p.parseUShort();
        var rightIndex = p.parseUShort();
        var value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}

function parseMacKernTable(p) {
    var pairs = {};
    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
    // Skip the rest.
    p.skip('uShort');
    var nTables = p.parseULong();
    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
    if (nTables > 1) {
        console.warn('Only the first kern subtable is supported.');
    }
    p.skip('uLong');
    var coverage = p.parseUShort();
    var subtableVersion = coverage & 0xFF;
    p.skip('uShort');
    if (subtableVersion === 0) {
        var nPairs = p.parseUShort();
        // Skip searchRange, entrySelector, rangeShift.
        p.skip('uShort', 3);
        for (var i = 0; i < nPairs; i += 1) {
            var leftIndex = p.parseUShort();
            var rightIndex = p.parseUShort();
            var value = p.parseShort();
            pairs[leftIndex + ',' + rightIndex] = value;
        }
    }
    return pairs;
}

// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    var p = new _parse2.default.Parser(data, start);
    var tableVersion = p.parseUShort();
    if (tableVersion === 0) {
        return parseWindowsKernTable(p);
    } else if (tableVersion === 1) {
        return parseMacKernTable(p);
    } else {
        throw new Error('Unsupported kern table version (' + tableVersion + ').');
    }
}

exports.default = { parse: parseKernTable };

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _parse = __webpack_require__(17);

var _parse2 = _interopRequireDefault(_parse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
// relative to the beginning of the glyphData table.
// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
// version where offsets are stored as uLongs. The `head` table specifies which version to use
// (under indexToLocFormat).
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p = new _parse2.default.Parser(data, start);
    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    var glyphOffsets = [];
    for (var i = 0; i < numGlyphs + 1; i += 1) {
        var glyphOffset = parseFn.call(p);
        if (shortVersion) {
            // The short table version stores the actual offset divided by 2.
            glyphOffset *= 2;
        }

        glyphOffsets.push(glyphOffset);
    }

    return glyphOffsets;
} // The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm

exports.default = { parse: parseLocaTable };

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _check = __webpack_require__(22);

var _check2 = _interopRequireDefault(_check);

var _table = __webpack_require__(28);

var _table2 = _interopRequireDefault(_table);

var _cmap = __webpack_require__(212);

var _cmap2 = _interopRequireDefault(_cmap);

var _cff = __webpack_require__(211);

var _cff2 = _interopRequireDefault(_cff);

var _head = __webpack_require__(215);

var _head2 = _interopRequireDefault(_head);

var _hhea = __webpack_require__(216);

var _hhea2 = _interopRequireDefault(_hhea);

var _hmtx = __webpack_require__(217);

var _hmtx2 = _interopRequireDefault(_hmtx);

var _ltag = __webpack_require__(218);

var _ltag2 = _interopRequireDefault(_ltag);

var _maxp = __webpack_require__(219);

var _maxp2 = _interopRequireDefault(_maxp);

var _name2 = __webpack_require__(221);

var _name3 = _interopRequireDefault(_name2);

var _os = __webpack_require__(222);

var _os2 = _interopRequireDefault(_os);

var _post = __webpack_require__(223);

var _post2 = _interopRequireDefault(_post);

var _gsub = __webpack_require__(214);

var _gsub2 = _interopRequireDefault(_gsub);

var _meta = __webpack_require__(220);

var _meta2 = _interopRequireDefault(_meta);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm

function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}

function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }

    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) + (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3];
    }

    sum %= Math.pow(2, 32);
    return sum;
}

function makeTableRecord(tag, checkSum, offset, length) {
    return new _table2.default.Record('Table Record', [{ name: 'tag', type: 'TAG', value: tag !== undefined ? tag : '' }, { name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0 }, { name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0 }, { name: 'length', type: 'ULONG', value: length !== undefined ? length : 0 }]);
}

function makeSfntTable(tables) {
    var sfnt = new _table2.default.Table('sfnt', [{ name: 'version', type: 'TAG', value: 'OTTO' }, { name: 'numTables', type: 'USHORT', value: 0 }, { name: 'searchRange', type: 'USHORT', value: 0 }, { name: 'entrySelector', type: 'USHORT', value: 0 }, { name: 'rangeShift', type: 'USHORT', value: 0 }]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

    var recordFields = [];
    var tableFields = [];

    var offset = sfnt.sizeOf() + makeTableRecord().sizeOf() * sfnt.numTables;
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({ name: 'padding', type: 'BYTE', value: 0 });
    }

    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        _check2.default.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({ name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord });
        tableFields.push({ name: t.tableName + ' table', type: 'RECORD', value: t });
        offset += tableLength;
        _check2.default.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({ name: 'padding', type: 'BYTE', value: 0 });
        }
    }

    // Table records need to be sorted alphabetically.
    recordFields.sort(function (r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });

    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}

// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs.get(glyphIndex);
            return glyph.getMetrics();
        }
    }

    return notFoundMetrics;
}

function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }

    return sum / vs.length;
}

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    var firstCharIndex = void 0;
    var lastCharIndex = 0;
    var ulUnicodeRange1 = 0;
    var ulUnicodeRange2 = 0;
    var ulUnicodeRange3 = 0;
    var ulUnicodeRange4 = 0;

    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs.get(i);
        var unicode = glyph.unicode | 0;

        if (isNaN(glyph.advanceWidth)) {
            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
        }

        if (firstCharIndex > unicode || firstCharIndex === undefined) {
            // ignore .notdef char
            if (unicode > 0) {
                firstCharIndex = unicode;
            }
        }

        if (lastCharIndex < unicode) {
            lastCharIndex = unicode;
        }

        var position = _os2.default.getUnicodeRange(unicode);
        if (position < 32) {
            ulUnicodeRange1 |= 1 << position;
        } else if (position < 64) {
            ulUnicodeRange2 |= 1 << position - 32;
        } else if (position < 96) {
            ulUnicodeRange3 |= 1 << position - 64;
        } else if (position < 123) {
            ulUnicodeRange4 |= 1 << position - 96;
        } else {
            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
        }
        // Skip non-important characters.
        if (glyph.name === '.notdef') continue;
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }

    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = font.ascender;
    globals.descender = font.descender;

    var headTable = _head2.default.make({
        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax,
        lowestRecPPEM: 3,
        createdTimestamp: font.createdTimestamp
    });

    var hheaTable = _hhea2.default.make({
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });

    var maxpTable = _maxp2.default.make(font.glyphs.length);

    var os2Table = _os2.default.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: font.tables.os2.usWeightClass,
        usWidthClass: font.tables.os2.usWidthClass,
        usFirstCharIndex: firstCharIndex,
        usLastCharIndex: lastCharIndex,
        ulUnicodeRange1: ulUnicodeRange1,
        ulUnicodeRange2: ulUnicodeRange2,
        ulUnicodeRange3: ulUnicodeRange3,
        ulUnicodeRange4: ulUnicodeRange4,
        fsSelection: font.tables.os2.fsSelection, // REGULAR
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.yMax,
        usWinDescent: Math.abs(globals.yMin),
        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
        sxHeight: metricsForChar(font, 'xyvw', { yMax: Math.round(globals.ascender / 2) }).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });

    var hmtxTable = _hmtx2.default.make(font.glyphs);
    var cmapTable = _cmap2.default.make(font.glyphs);

    var englishFamilyName = font.getEnglishName('fontFamily');
    var englishStyleName = font.getEnglishName('fontSubfamily');
    var englishFullName = englishFamilyName + ' ' + englishStyleName;
    var postScriptName = font.getEnglishName('postScriptName');
    if (!postScriptName) {
        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
    }

    var names = {};
    for (var n in font.names) {
        names[n] = font.names[n];
    }

    if (!names.uniqueID) {
        names.uniqueID = { en: font.getEnglishName('manufacturer') + ':' + englishFullName };
    }

    if (!names.postScriptName) {
        names.postScriptName = { en: postScriptName };
    }

    if (!names.preferredFamily) {
        names.preferredFamily = font.names.fontFamily;
    }

    if (!names.preferredSubfamily) {
        names.preferredSubfamily = font.names.fontSubfamily;
    }

    var languageTags = [];
    var nameTable = _name3.default.make(names, languageTags);
    var ltagTable = languageTags.length > 0 ? _ltag2.default.make(languageTags) : undefined;

    var postTable = _post2.default.make();
    var cffTable = _cff2.default.make(font.glyphs, {
        version: font.getEnglishName('version'),
        fullName: englishFullName,
        familyName: englishFamilyName,
        weightName: englishStyleName,
        postScriptName: postScriptName,
        unitsPerEm: font.unitsPerEm,
        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
    });

    var metaTable = font.metas && (0, _keys2.default)(font.metas).length > 0 ? _meta2.default.make(font.metas) : undefined;

    // The order does not matter because makeSfntTable() will sort them.
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
    if (ltagTable) {
        tables.push(ltagTable);
    }
    // Optional tables
    if (font.tables.gsub) {
        tables.push(_gsub2.default.make(font.tables.gsub));
    }
    if (metaTable) {
        tables.push(metaTable);
    }

    var sfntTable = makeSfntTable(tables);

    // Compute the font's checkSum and store it in head.checkSumAdjustment.
    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    var tableFields = sfntTable.fields;
    var checkSumAdjusted = false;
    for (var _i = 0; _i < tableFields.length; _i += 1) {
        if (tableFields[_i].name === 'head table') {
            tableFields[_i].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
            checkSumAdjusted = true;
            break;
        }
    }

    if (!checkSumAdjusted) {
        throw new Error('Could not find head table with checkSum to adjust.');
    }

    return sfntTable;
}

exports.default = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _isInteger=__webpack_require__(260);var _isInteger2=_interopRequireDefault(_isInteger);var _defineProperty=__webpack_require__(129);var _defineProperty2=_interopRequireDefault(_defineProperty);var _freeze=__webpack_require__(166);var _freeze2=_interopRequireDefault(_freeze);var _keys=__webpack_require__(4);var _keys2=_interopRequireDefault(_keys);var _stringify=__webpack_require__(47);var _stringify2=_interopRequireDefault(_stringify);var _defineProperties=__webpack_require__(261);var _defineProperties2=_interopRequireDefault(_defineProperties);var _create=__webpack_require__(48);var _create2=_interopRequireDefault(_create);var _assign=__webpack_require__(2);var _assign2=_interopRequireDefault(_assign);var _sign=__webpack_require__(165);var _sign2=_interopRequireDefault(_sign);var _epsilon=__webpack_require__(259);var _epsilon2=_interopRequireDefault(_epsilon);var _typeof2=__webpack_require__(38);var _typeof3=_interopRequireDefault(_typeof2);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}(function(global,factory){( false?'undefined':(0,_typeof3.default)(exports))==='object'&&typeof module!=='undefined'?factory(exports): true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):factory(global.THREE=global.THREE||{});})(undefined,function(exports){'use strict';// Polyfills
if(_epsilon2.default===undefined){Number.EPSILON=Math.pow(2,-52);}//
if(_sign2.default===undefined){// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
Math.sign=function(x){return x<0?-1:x>0?1:+x;};}if(Function.prototype.name===undefined){// Missing in IE9-11.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
Object.defineProperty(Function.prototype,'name',{get:function get(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];}});}if(_assign2.default===undefined){// Missing in IE.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
(function(){Object.assign=function(target){'use strict';if(target===undefined||target===null){throw new TypeError('Cannot convert undefined or null to object');}var output=Object(target);for(var index=1;index<arguments.length;index++){var source=arguments[index];if(source!==undefined&&source!==null){for(var nextKey in source){if(Object.prototype.hasOwnProperty.call(source,nextKey)){output[nextKey]=source[nextKey];}}}}return output;};})();}/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */function EventDispatcher(){}EventDispatcher.prototype={addEventListener:function addEventListener(type,listener){if(this._listeners===undefined)this._listeners={};var listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}},hasEventListener:function hasEventListener(type,listener){if(this._listeners===undefined)return false;var listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;},removeEventListener:function removeEventListener(type,listener){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[type];if(listenerArray!==undefined){var index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}},dispatchEvent:function dispatchEvent(event){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;var array=[],i=0;var length=listenerArray.length;for(i=0;i<length;i++){array[i]=listenerArray[i];}for(i=0;i<length;i++){array[i].call(this,event);}}}};var REVISION='84-threekit';var MOUSE={LEFT:0,MIDDLE:1,RIGHT:2};var CullFaceNone=0;var CullFaceBack=1;var CullFaceFront=2;var CullFaceFrontBack=3;var FrontFaceDirectionCW=0;var FrontFaceDirectionCCW=1;var BasicShadowMap=0;var PCFShadowMap=1;var PCFSoftShadowMap=2;var PCSSSoftShadowMap=3;var FrontSide=0;var BackSide=1;var DoubleSide=2;var FlatShading=1;var SmoothShading=2;var NoColors=0;var FaceColors=1;var VertexColors=2;var NoBlending=0;var NormalBlending=1;var AdditiveBlending=2;var SubtractiveBlending=3;var MultiplyBlending=4;var CustomBlending=5;var AddEquation=100;var SubtractEquation=101;var ReverseSubtractEquation=102;var MinEquation=103;var MaxEquation=104;var ZeroFactor=200;var OneFactor=201;var SrcColorFactor=202;var OneMinusSrcColorFactor=203;var SrcAlphaFactor=204;var OneMinusSrcAlphaFactor=205;var DstAlphaFactor=206;var OneMinusDstAlphaFactor=207;var DstColorFactor=208;var OneMinusDstColorFactor=209;var SrcAlphaSaturateFactor=210;var NeverDepth=0;var AlwaysDepth=1;var LessDepth=2;var LessEqualDepth=3;var EqualDepth=4;var GreaterEqualDepth=5;var GreaterDepth=6;var NotEqualDepth=7;var MultiplyOperation=0;var MixOperation=1;var AddOperation=2;var NoToneMapping=0;var LinearToneMapping=1;var ReinhardToneMapping=2;var Uncharted2ToneMapping=3;var CineonToneMapping=4;var UVMapping=300;var CubeReflectionMapping=301;var CubeRefractionMapping=302;var EquirectangularReflectionMapping=303;var EquirectangularRefractionMapping=304;var SphericalReflectionMapping=305;var CubeUVReflectionMapping=306;var CubeUVRefractionMapping=307;var RepeatWrapping=1000;var ClampToEdgeWrapping=1001;var MirroredRepeatWrapping=1002;var NearestFilter=1003;var NearestMipMapNearestFilter=1004;var NearestMipMapLinearFilter=1005;var LinearFilter=1006;var LinearMipMapNearestFilter=1007;var LinearMipMapLinearFilter=1008;var UnsignedByteType=1009;var ByteType=1010;var ShortType=1011;var UnsignedShortType=1012;var IntType=1013;var UnsignedIntType=1014;var FloatType=1015;var HalfFloatType=1016;var UnsignedShort4444Type=1017;var UnsignedShort5551Type=1018;var UnsignedShort565Type=1019;var UnsignedInt248Type=1020;var AlphaFormat=1021;var RGBFormat=1022;var RGBAFormat=1023;var LuminanceFormat=1024;var LuminanceAlphaFormat=1025;var RGBEFormat=RGBAFormat;var DepthFormat=1026;var DepthStencilFormat=1027;var RGB_S3TC_DXT1_Format=2001;var RGBA_S3TC_DXT1_Format=2002;var RGBA_S3TC_DXT3_Format=2003;var RGBA_S3TC_DXT5_Format=2004;var RGB_PVRTC_4BPPV1_Format=2100;var RGB_PVRTC_2BPPV1_Format=2101;var RGBA_PVRTC_4BPPV1_Format=2102;var RGBA_PVRTC_2BPPV1_Format=2103;var RGB_ETC1_Format=2151;var LoopOnce=2200;var LoopRepeat=2201;var LoopPingPong=2202;var InterpolateDiscrete=2300;var InterpolateLinear=2301;var InterpolateSmooth=2302;var ZeroCurvatureEnding=2400;var ZeroSlopeEnding=2401;var WrapAroundEnding=2402;var TrianglesDrawMode=0;var TriangleStripDrawMode=1;var TriangleFanDrawMode=2;var LinearEncoding=3000;var sRGBEncoding=3001;var GammaEncoding=3007;var RGBEEncoding=3002;var LogLuvEncoding=3003;var RGBM7Encoding=3004;var RGBM16Encoding=3005;var RGBDEncoding=3006;var BasicDepthPacking=3200;var RGBADepthPacking=3201;var OrderIndependentTransperancy=3300;var PaintersTransperancy=3301;/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */var _Math={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){// http://www.broofa.com/Tools/Math.uuid.htm
var chars='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');var uuid=new Array(36);var rnd=0,r;return function generateUUID(){for(var i=0;i<36;i++){if(i===8||i===13||i===18||i===23){uuid[i]='-';}else if(i===14){uuid[i]='4';}else{if(rnd<=0x02)rnd=0x2000000+Math.random()*0x1000000|0;r=rnd&0xf;rnd=rnd>>4;uuid[i]=chars[i===19?r&0x3|0x8:r];}}return uuid.join('');};}(),clamp:function clamp(value,min,max){return Math.max(min,Math.min(max,value));},// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
euclideanModulo:function euclideanModulo(n,m){return(n%m+m)%m;},// Linear mapping from range <a1, a2> to range <b1, b2>
mapLinear:function mapLinear(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1);},// https://en.wikipedia.org/wiki/Linear_interpolation
lerp:function lerp(x,y,t){return(1-t)*x+t*y;},// http://en.wikipedia.org/wiki/Smoothstep
smoothstep:function smoothstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x);},smootherstep:function smootherstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10);},// Random integer from <low, high> interval
randInt:function randInt(low,high){return low+Math.floor(Math.random()*(high-low+1));},// Random float from <low, high> interval
randFloat:function randFloat(low,high){return low+Math.random()*(high-low);},// Random float from <-range/2, range/2> interval
randFloatSpread:function randFloatSpread(range){return range*(0.5-Math.random());},degToRad:function degToRad(degrees){return degrees*_Math.DEG2RAD;},radToDeg:function radToDeg(radians){return radians*_Math.RAD2DEG;},isPowerOfTwo:function isPowerOfTwo(value){return(value&value-1)===0&&value!==0;},nearestPowerOfTwo:function nearestPowerOfTwo(value){return Math.pow(2,Math.round(Math.log(value)/Math.LN2));},nextPowerOfTwo:function nextPowerOfTwo(value){value--;value|=value>>1;value|=value>>2;value|=value>>4;value|=value>>8;value|=value>>16;value++;return value;}};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */function Vector2(x,y){this.x=x||0;this.y=y||0;}Vector2.prototype={constructor:Vector2,isVector2:true,get width(){return this.x;},set width(value){this.x=value;},get height(){return this.y;},set height(value){this.y=value;},//
set:function set(x,y){this.x=x;this.y=y;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y);},copy:function copy(v){this.x=v.x;this.y=v.y;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;},multiply:function multiply(v){this.x*=v.x;this.y*=v.y;return this;},multiplyScalar:function multiplyScalar(scalar){if(isFinite(scalar)){this.x*=scalar;this.y*=scalar;}else{this.x=0;this.y=0;}return this;},divide:function divide(v){this.x/=v.x;this.y/=v.y;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;},clamp:function clamp(min,max){// This function assumes min < max, if this assumption isn't true it will not operate correctly
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this;},clampScalar:function(){var min,max;return function clampScalar(minVal,maxVal){if(min===undefined){min=new Vector2();max=new Vector2();}min.set(minVal,minVal);max.set(maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function clampLength(min,max){var length=this.length();return this.multiplyScalar(Math.max(min,Math.min(max,length))/length);},floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y;},lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y);},lengthManhattan:function lengthManhattan(){return Math.abs(this.x)+Math.abs(this.y);},normalize:function normalize(){return this.divideScalar(this.length());},angle:function angle(){// computes the angle in radians with respect to the positive x-axis
var angle=Math.atan2(this.y,this.x);if(angle<0)angle+=2*Math.PI;return angle;},distanceTo:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;},distanceToManhattan:function distanceToManhattan(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);},setLength:function setLength(length){return this.multiplyScalar(length/this.length());},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function equals(v){return v.x===this.x&&v.y===this.y;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);return this;},rotateAround:function rotateAround(center,angle){var c=Math.cos(angle),s=Math.sin(angle);var x=this.x-center.x;var y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */var textureId=0;function Texture(image,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){Object.defineProperty(this,'id',{value:textureId++});this.uuid=_Math.generateUUID();this.name='';this.image=image!==undefined?image:Texture.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=mapping!==undefined?mapping:Texture.DEFAULT_MAPPING;this.wrapS=wrapS!==undefined?wrapS:ClampToEdgeWrapping;this.wrapT=wrapT!==undefined?wrapT:ClampToEdgeWrapping;this.magFilter=magFilter!==undefined?magFilter:LinearFilter;this.minFilter=minFilter!==undefined?minFilter:LinearMipMapLinearFilter;this.anisotropy=anisotropy!==undefined?anisotropy:1;this.format=format!==undefined?format:RGBAFormat;this.type=type!==undefined?type:UnsignedByteType;this.offset=new Vector2(0,0);this.repeat=new Vector2(1,1);this.generateMipmaps=true;this.premultiplyAlpha=false;this.flipY=true;this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
//
// Also changing the encoding after already used by a Material will not automatically make the Material
// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
this.encoding=encoding!==undefined?encoding:LinearEncoding;this.version=0;this.onUpdate=null;}Texture.DEFAULT_IMAGE=undefined;Texture.DEFAULT_MAPPING=UVMapping;Texture.prototype={constructor:Texture,isTexture:true,set needsUpdate(value){if(value===true)this.version++;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.name=source.name+" (Copy)";this.image=source.image;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;return this;},toJSON:function toJSON(meta){if(meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}function getDataURL(image){var canvas;if(image.toDataURL!==undefined){canvas=image;}else{canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=image.width;canvas.height=image.height;canvas.getContext('2d').drawImage(image,0,0,image.width,image.height);}if(canvas.width>2048||canvas.height>2048){return canvas.toDataURL('image/jpeg',0.6);}else{return canvas.toDataURL('image/png');}}var output={metadata:{version:4.4,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],wrap:[this.wrapS,this.wrapT],minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY};if(this.image!==undefined){// TODO: Move to THREE.Image
var image=this.image;if(image.uuid===undefined){image.uuid=_Math.generateUUID();// UGH
}if(meta.images[image.uuid]===undefined){meta.images[image.uuid]={uuid:image.uuid,url:getDataURL(image)};}output.image=image.uuid;}meta.textures[this.uuid]=output;return output;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});},transformUv:function transformUv(uv){if(this.mapping!==UVMapping)return;uv.multiply(this.repeat);uv.add(this.offset);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else{uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else{uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}}};(0,_assign2.default)(Texture.prototype,EventDispatcher.prototype);/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */function Vector4(x,y,z,w){this.x=x||0;this.y=y||0;this.z=z||0;this.w=w!==undefined?w:1;}Vector4.prototype={constructor:Vector4,isVector4:true,set:function set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setZ:function setZ(z){this.z=z;return this;},setW:function setW(w){this.w=w;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y,this.z,this.w);},copy:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;},multiplyScalar:function multiplyScalar(scalar){if(isFinite(scalar)){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;}else{this.x=0;this.y=0;this.z=0;this.w=0;}return this;},applyMatrix4:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z,w=this.w;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},setAxisAngleFromQuaternion:function setAxisAngleFromQuaternion(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
// q is assumed to be normalized
this.w=2*Math.acos(q.w);var s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else{this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;},setAxisAngleFromRotationMatrix:function setAxisAngleFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var angle,x,y,z,// variables for result
epsilon=0.01,// margin to allow for rounding errors
epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
// first check for identity matrix which must have +1 for all terms
// in leading diagonal and zero in other terms
if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
this.set(1,0,0,0);return this;// zero angle, arbitrary axis
}// otherwise this singularity is angle = 180
angle=Math.PI;var xx=(m11+1)/2;var yy=(m22+1)/2;var zz=(m33+1)/2;var xy=(m12+m21)/4;var xz=(m13+m31)/4;var yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else{x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else{y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else{// m33 is the largest diagonal term so base result on this
if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else{z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
}// as we have reached here there are no singularities so we can handle normally
var s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
// caught by singularity test above, but I've left it in just in case
this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;},clamp:function clamp(min,max){// This function assumes min < max, if this assumption isn't true it will not operate correctly
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this;},clampScalar:function(){var min,max;return function clampScalar(minVal,maxVal){if(min===undefined){min=new Vector4();max=new Vector4();}min.set(minVal,minVal,minVal,minVal);max.set(maxVal,maxVal,maxVal,maxVal);return this.clamp(min,max);};}(),floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;},lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);},lengthManhattan:function lengthManhattan(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);},normalize:function normalize(){return this.divideScalar(this.length());},setLength:function setLength(length){return this.multiplyScalar(length/this.length());},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}};/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 *//*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/function WebGLRenderTarget(width,height,options){this.uuid=_Math.generateUUID();this.width=width;this.height=height;this.scissor=new Vector4(0,0,width,height);this.scissorTest=false;this.viewport=new Vector4(0,0,width,height);options=options||{};if(options.minFilter===undefined)options.minFilter=LinearFilter;this.texture=new Texture(undefined,undefined,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;this.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:true;this.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;this.texture.name=options.name!==undefined?options.name:"";}WebGLRenderTarget.prototype={constructor:WebGLRenderTarget,isWebGLRenderTarget:true,setSize:function setSize(width,height){if(this.width!==width||this.height!==height){this.width=width;this.height=height;this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.width=source.width;this.height=source.height;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}};(0,_assign2.default)(WebGLRenderTarget.prototype,EventDispatcher.prototype);/**
	 * @author alteredq / http://alteredqualia.com
	 */function WebGLRenderTargetCube(width,height,options){WebGLRenderTarget.call(this,width,height,options);this.activeCubeFace=0;// PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
this.activeMipMapLevel=0;}WebGLRenderTargetCube.prototype=(0,_create2.default)(WebGLRenderTarget.prototype);WebGLRenderTargetCube.prototype.constructor=WebGLRenderTargetCube;WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube=true;/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */function Quaternion(x,y,z,w){this._x=x||0;this._y=y||0;this._z=z||0;this._w=w!==undefined?w:1;}Quaternion.prototype={constructor:Quaternion,get x(){return this._x;},set x(value){this._x=value;this.onChangeCallback();},get y(){return this._y;},set y(value){this._y=value;this.onChangeCallback();},get z(){return this._z;},set z(value){this._z=value;this.onChangeCallback();},get w(){return this._w;},set w(value){this._w=value;this.onChangeCallback();},set:function set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this.onChangeCallback();return this;},clone:function clone(){return new this.constructor(this._x,this._y,this._z,this._w);},copy:function copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this.onChangeCallback();return this;},setFromEuler:function setFromEuler(euler,update){if((euler&&euler.isEuler)===false){throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');}// http://www.mathworks.com/matlabcentral/fileexchange/
// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
//	content/SpinCalc.m
var c1=Math.cos(euler._x/2);var c2=Math.cos(euler._y/2);var c3=Math.cos(euler._z/2);var s1=Math.sin(euler._x/2);var s2=Math.sin(euler._y/2);var s3=Math.sin(euler._z/2);var order=euler.order;if(order==='XYZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='YXZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='ZXY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='ZYX'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='YZX'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='XZY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}if(update!==false)this.onChangeCallback();return this;},setFromAxisAngle:function setFromAxisAngle(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
// assumes axis is normalized
var halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this.onChangeCallback();return this;},setFromRotationMatrix:function setFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33,s;if(trace>0){s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/s;this._x=0.25*s;this._y=(m12+m21)/s;this._z=(m13+m31)/s;}else if(m22>m33){s=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/s;this._x=(m12+m21)/s;this._y=0.25*s;this._z=(m23+m32)/s;}else{s=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/s;this._x=(m13+m31)/s;this._y=(m23+m32)/s;this._z=0.25*s;}this.onChangeCallback();return this;},setFromUnitVectors:function(){// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
// assumes direction vectors vFrom and vTo are normalized
var v1,r;var EPS=0.000001;return function setFromUnitVectors(vFrom,vTo){if(v1===undefined)v1=new Vector3();r=vFrom.dot(vTo)+1;if(r<EPS){r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){v1.set(-vFrom.y,vFrom.x,0);}else{v1.set(0,-vFrom.z,vFrom.y);}}else{v1.crossVectors(vFrom,vTo);}this._x=v1.x;this._y=v1.y;this._z=v1.z;this._w=r;return this.normalize();};}(),inverse:function inverse(){return this.conjugate().normalize();},conjugate:function conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this;},dot:function dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;},lengthSq:function lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;},length:function length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);},normalize:function normalize(){var l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else{l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this.onChangeCallback();return this;},multiply:function multiply(q,p){if(p!==undefined){console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');return this.multiplyQuaternions(q,p);}return this.multiplyQuaternions(this,q);},premultiply:function premultiply(q){return this.multiplyQuaternions(q,this);},multiplyQuaternions:function multiplyQuaternions(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
var qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;var qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this.onChangeCallback();return this;},slerp:function slerp(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);var x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else{this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}var sinHalfTheta=Math.sqrt(1.0-cosHalfTheta*cosHalfTheta);if(Math.abs(sinHalfTheta)<0.001){this._w=0.5*(w+this._w);this._x=0.5*(x+this._x);this._y=0.5*(y+this._y);this._z=0.5*(z+this._z);return this;}var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);var ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this.onChangeCallback();return this;},equals:function equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this.onChangeCallback();return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;},onChange:function onChange(callback){this.onChangeCallback=callback;return this;},onChangeCallback:function onChangeCallback(){}};(0,_assign2.default)(Quaternion,{slerp:function slerp(qa,qb,qm,t){return qm.copy(qa).slerp(qb,t);},slerpFlat:function slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
var x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3],x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){var s=1-t,cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
if(sqrSin>_epsilon2.default){var sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}var tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
if(s===1-t){var f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */function Vector3(x,y,z){this.x=x||0;this.y=y||0;this.z=z||0;}Vector3.prototype={constructor:Vector3,isVector3:true,set:function set(x,y,z){this.x=x;this.y=y;this.z=z;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setZ:function setZ(z){this.z=z;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y,this.z);},copy:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;},multiply:function multiply(v,w){if(w!==undefined){console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');return this.multiplyVectors(v,w);}this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;},multiplyScalar:function multiplyScalar(scalar){if(isFinite(scalar)){this.x*=scalar;this.y*=scalar;this.z*=scalar;}else{this.x=0;this.y=0;this.z=0;}return this;},multiplyVectors:function multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;},applyEuler:function(){var quaternion;return function applyEuler(euler){if((euler&&euler.isEuler)===false){console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');}if(quaternion===undefined)quaternion=new Quaternion();return this.applyQuaternion(quaternion.setFromEuler(euler));};}(),applyAxisAngle:function(){var quaternion;return function applyAxisAngle(axis,angle){if(quaternion===undefined)quaternion=new Quaternion();return this.applyQuaternion(quaternion.setFromAxisAngle(axis,angle));};}(),applyMatrix3:function applyMatrix3(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;},applyMatrix4:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12];this.y=e[1]*x+e[5]*y+e[9]*z+e[13];this.z=e[2]*x+e[6]*y+e[10]*z+e[14];var w=e[3]*x+e[7]*y+e[11]*z+e[15];return this.divideScalar(w);},applyQuaternion:function applyQuaternion(q){var x=this.x,y=this.y,z=this.z;var qx=q.x,qy=q.y,qz=q.z,qw=q.w;// calculate quat * vector
var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;},project:function(){var matrix;return function project(camera){if(matrix===undefined)matrix=new Matrix4();matrix.multiplyMatrices(camera.projectionMatrix,matrix.getInverse(camera.matrixWorld));return this.applyMatrix4(matrix);};}(),unproject:function(){var matrix;return function unproject(camera){if(matrix===undefined)matrix=new Matrix4();matrix.multiplyMatrices(camera.matrixWorld,matrix.getInverse(camera.projectionMatrix));return this.applyMatrix4(matrix);};}(),transformDirection:function transformDirection(m){// input: THREE.Matrix4 affine matrix
// vector interpreted as a direction
var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();},divide:function divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;},clamp:function clamp(min,max){// This function assumes min < max, if this assumption isn't true it will not operate correctly
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this;},clampScalar:function(){var min,max;return function clampScalar(minVal,maxVal){if(min===undefined){min=new Vector3();max=new Vector3();}min.set(minVal,minVal,minVal);max.set(maxVal,maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function clampLength(min,max){var length=this.length();return this.multiplyScalar(Math.max(min,Math.min(max,length))/length);},floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;},lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);},lengthManhattan:function lengthManhattan(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);},normalize:function normalize(){return this.divideScalar(this.length());},setLength:function setLength(length){return this.multiplyScalar(length/this.length());},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},cross:function cross(v,w){if(w!==undefined){console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');return this.crossVectors(v,w);}var x=this.x,y=this.y,z=this.z;this.x=y*v.z-z*v.y;this.y=z*v.x-x*v.z;this.z=x*v.y-y*v.x;return this;},crossVectors:function crossVectors(a,b){var ax=a.x,ay=a.y,az=a.z;var bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;},projectOnVector:function projectOnVector(vector){var scalar=vector.dot(this)/vector.lengthSq();return this.copy(vector).multiplyScalar(scalar);},projectOnPlane:function(){var v1;return function projectOnPlane(planeNormal){if(v1===undefined)v1=new Vector3();v1.copy(this).projectOnVector(planeNormal);return this.sub(v1);};}(),reflect:function(){// reflect incident vector off plane orthogonal to normal
// normal is assumed to have unit length
var v1;return function reflect(normal){if(v1===undefined)v1=new Vector3();return this.sub(v1.copy(normal).multiplyScalar(2*this.dot(normal)));};}(),angleTo:function angleTo(v){var theta=this.dot(v)/Math.sqrt(this.lengthSq()*v.lengthSq());// clamp, to handle numerical problems
return Math.acos(_Math.clamp(theta,-1,1));},distanceTo:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;},distanceToManhattan:function distanceToManhattan(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);},setFromSpherical:function setFromSpherical(s){var sinPhiRadius=Math.sin(s.phi)*s.radius;this.x=sinPhiRadius*Math.sin(s.theta);this.y=Math.cos(s.phi)*s.radius;this.z=sinPhiRadius*Math.cos(s.theta);return this;},setFromCylindrical:function setFromCylindrical(c){this.x=c.radius*Math.sin(c.theta);this.y=c.y;this.z=c.radius*Math.cos(c.theta);return this;},setFromMatrixPosition:function setFromMatrixPosition(m){return this.setFromMatrixColumn(m,3);},setFromMatrixScale:function setFromMatrixScale(m){var sx=this.setFromMatrixColumn(m,0).length();var sy=this.setFromMatrixColumn(m,1).length();var sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;},setFromMatrixColumn:function setFromMatrixColumn(m,index){if(typeof m==='number'){console.warn('THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).');var temp=m;m=index;index=temp;}return this.fromArray(m.elements,index*4);},equals:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */function Matrix4(){this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);if(arguments.length>0){console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');}}Matrix4.prototype={constructor:Matrix4,isMatrix4:true,set:function set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){var te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;},identity:function identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;},clone:function clone(){return new Matrix4().fromArray(this.elements);},copy:function copy(m){this.elements.set(m.elements);return this;},copyPosition:function copyPosition(m){var te=this.elements;var me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;},extractBasis:function extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;},makeBasis:function makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;},extractRotation:function(){var v1;return function extractRotation(m){if(v1===undefined)v1=new Vector3();var te=this.elements;var me=m.elements;var scaleX=1/v1.setFromMatrixColumn(m,0).length();var scaleY=1/v1.setFromMatrixColumn(m,1).length();var scaleZ=1/v1.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;return this;};}(),makeRotationFromEuler:function makeRotationFromEuler(euler){if((euler&&euler.isEuler)===false){console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');}var te=this.elements;var x=euler.x,y=euler.y,z=euler.z;var a=Math.cos(x),b=Math.sin(x);var c=Math.cos(y),d=Math.sin(y);var e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b;te[4]=-a*f;te[8]=de+cf*b;te[1]=cf+de*b;te[5]=a*e;te[9]=df-ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=be*d-af;te[8]=ae*d+bf;te[1]=c*f;te[5]=bf*d+ae;te[9]=af*d-be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=ac*f+bd;te[5]=a*e;te[9]=ad*f-bc;te[2]=bc*f-ad;te[6]=b*e;te[10]=bd*f+ac;}// last column
te[3]=0;te[7]=0;te[11]=0;// bottom row
te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},makeRotationFromQuaternion:function makeRotationFromQuaternion(q){var te=this.elements;var x=q.x,y=q.y,z=q.z,w=q.w;var x2=x+x,y2=y+y,z2=z+z;var xx=x*x2,xy=x*y2,xz=x*z2;var yy=y*y2,yz=y*z2,zz=z*z2;var wx=w*x2,wy=w*y2,wz=w*z2;te[0]=1-(yy+zz);te[4]=xy-wz;te[8]=xz+wy;te[1]=xy+wz;te[5]=1-(xx+zz);te[9]=yz-wx;te[2]=xz-wy;te[6]=yz+wx;te[10]=1-(xx+yy);// last column
te[3]=0;te[7]=0;te[11]=0;// bottom row
te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},lookAt:function(){var x,y,z;return function lookAt(eye,target,up){if(x===undefined){x=new Vector3();y=new Vector3();z=new Vector3();}var te=this.elements;z.subVectors(eye,target).normalize();if(z.lengthSq()===0){z.z=1;}x.crossVectors(up,z).normalize();if(x.lengthSq()===0){z.z+=0.0001;x.crossVectors(up,z).normalize();}y.crossVectors(z,x);te[0]=x.x;te[4]=y.x;te[8]=z.x;te[1]=x.y;te[5]=y.y;te[9]=z.y;te[2]=x.z;te[6]=y.z;te[10]=z.z;return this;};}(),multiply:function multiply(m,n){if(n!==undefined){console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');return this.multiplyMatrices(m,n);}return this.multiplyMatrices(this,m);},premultiply:function premultiply(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];var a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];var a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];var a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];var b11=be[0],b12=be[4],b13=be[8],b14=be[12];var b21=be[1],b22=be[5],b23=be[9],b24=be[13];var b31=be[2],b32=be[6],b33=be[10],b34=be[14];var b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;},multiplyToArray:function multiplyToArray(a,b,r){var te=this.elements;this.multiplyMatrices(a,b);r[0]=te[0];r[1]=te[1];r[2]=te[2];r[3]=te[3];r[4]=te[4];r[5]=te[5];r[6]=te[6];r[7]=te[7];r[8]=te[8];r[9]=te[9];r[10]=te[10];r[11]=te[11];r[12]=te[12];r[13]=te[13];r[14]=te[14];r[15]=te[15];return this;},multiplyScalar:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;},applyToBufferAttribute:function(){var v1;return function applyToBufferAttribute(attribute){if(v1===undefined)v1=new Vector3();for(var i=0,l=attribute.count;i<l;i++){v1.x=attribute.getX(i);v1.y=attribute.getY(i);v1.z=attribute.getZ(i);v1.applyMatrix4(this);attribute.setXYZ(i,v1.x,v1.y,v1.z);}return attribute;};}(),determinant:function determinant(){var te=this.elements;var n11=te[0],n12=te[4],n13=te[8],n14=te[12];var n21=te[1],n22=te[5],n23=te[9],n24=te[13];var n31=te[2],n32=te[6],n33=te[10],n34=te[14];var n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);},transpose:function transpose(){var te=this.elements;var tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;},setPosition:function setPosition(v){var te=this.elements;te[12]=v.x;te[13]=v.y;te[14]=v.z;return this;},getInverse:function getInverse(m,throwOnDegenerate){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
var te=this.elements,me=m.elements,n11=me[0],n21=me[1],n31=me[2],n41=me[3],n12=me[4],n22=me[5],n32=me[6],n42=me[7],n13=me[8],n23=me[9],n33=me[10],n43=me[11],n14=me[12],n24=me[13],n34=me[14],n44=me[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;var det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0){var msg="THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";if(throwOnDegenerate===true){throw new Error(msg);}else{console.warn(msg);}return this.identity();}var detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;},scale:function scale(v){var te=this.elements;var x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;},getMaxScaleOnAxis:function getMaxScaleOnAxis(){var te=this.elements;var scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];var scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];var scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));},makeTranslation:function makeTranslation(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this;},makeRotationX:function makeRotationX(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;},makeRotationY:function makeRotationY(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;},makeRotationZ:function makeRotationZ(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;},makeRotationAxis:function makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
var c=Math.cos(angle);var s=Math.sin(angle);var t=1-c;var x=axis.x,y=axis.y,z=axis.z;var tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;},makeScale:function makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;},makeShear:function makeShear(xy,xz,yz,reserveStyle){this.set(1,xy,xz,0,0,1,yz,0,0,0,1,0,0,0,0,1);if(reserveStyle)this.transpose();return this;},compose:function compose(position,quaternion,scale,shear){this.makeRotationFromQuaternion(quaternion);if(shear){this.multiply(new Matrix4().makeShear(shear.x,shear.y,shear.z));}this.scale(scale);this.setPosition(position);return this;},decompose:function(){var vector,matrix;return function decompose(position,quaternion,scale,shear){if(shear){return this.decompose2(position,quaternion,scale,shear);}if(vector===undefined){vector=new Vector3();matrix=new Matrix4();}var te=this.elements;var sx=vector.set(te[0],te[1],te[2]).length();var sy=vector.set(te[4],te[5],te[6]).length();var sz=vector.set(te[8],te[9],te[10]).length();// if determinant is negative, we need to invert one scale
var det=this.determinant();if(det<0){sx=-sx;}position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
matrix.elements.set(this.elements);// at this point matrix is incomplete so we can't use .copy()
var invSX=1/sx;var invSY=1/sy;var invSZ=1/sz;matrix.elements[0]*=invSX;matrix.elements[1]*=invSX;matrix.elements[2]*=invSX;matrix.elements[4]*=invSY;matrix.elements[5]*=invSY;matrix.elements[6]*=invSY;matrix.elements[8]*=invSZ;matrix.elements[9]*=invSZ;matrix.elements[10]*=invSZ;quaternion.setFromRotationMatrix(matrix);scale.x=sx;scale.y=sy;scale.z=sz;return this;};}(),// Transformations.py, decompose_matrix
// Source code also handles perspective partition of matrix
// Laboratory for Fluorescence Dynamics, University of California, Irvine
// Reference: http://www.lfd.uci.edu/~gohlke/code/transformations.py.html
decompose2:function(){return function decompose2(position,quaternion,scale,shear){var p=this.clone();p[3]=0;p[7]=0;p[11]=0;p[15]=1;var det=p.determinant();if(det===0){console.error("THREE.Matrix4.decompose2(): Cannot apply decompose2 on singular matrix");return this;}var matrix=new Matrix4().copy(this);var me=matrix.elements;position.set(me[12],me[13],me[14]);me[12]=me[13]=me[14]=0;var xAxis=new Vector3(me[0],me[1],me[2]);var yAxis=new Vector3(me[4],me[5],me[6]);var zAxis=new Vector3(me[8],me[9],me[10]);scale.setX(xAxis.length());xAxis.divideScalar(scale.x);shear.setX(xAxis.dot(yAxis));yAxis.sub(xAxis.clone().multiplyScalar(shear.x));scale.setY(yAxis.length());yAxis.divideScalar(scale.y);shear.setX(shear.x/scale.y);shear.setY(xAxis.dot(zAxis));zAxis.sub(xAxis.clone().multiplyScalar(shear.y));shear.setZ(yAxis.dot(zAxis));zAxis.sub(yAxis.clone().multiplyScalar(shear.z));scale.setZ(zAxis.length());zAxis.divideScalar(scale.z);shear.setY(shear.y/scale.z);shear.setZ(shear.z/scale.z);me[0]=xAxis.x;me[4]=yAxis.x;me[8]=zAxis.x;me[1]=xAxis.y;me[5]=yAxis.y;me[9]=zAxis.y;me[2]=xAxis.z;me[6]=yAxis.z;me[10]=zAxis.z;if(xAxis.dot(new Vector3().crossVectors(yAxis,zAxis))<0){scale.multiplyScalar(-1);matrix.multiplyScalar(-1);}quaternion.setFromRotationMatrix(matrix);return this;};}(),makePerspective:function makePerspective(left,right,top,bottom,near,far){if(far===undefined){console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');}var te=this.elements;var x=2*near/(right-left);var y=2*near/(top-bottom);var a=(right+left)/(right-left);var b=(top+bottom)/(top-bottom);var c=-(far+near)/(far-near);var d=-2*far*near/(far-near);te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;},makeOrthographic:function makeOrthographic(left,right,top,bottom,near,far){var te=this.elements;var w=1.0/(right-left);var h=1.0/(top-bottom);var p=1.0/(far-near);var x=(right+left)*w;var y=(top+bottom)*h;var z=(far+near)*p;te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;},equals:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<16;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;for(var i=0;i<16;i++){this.elements[i]=array[i+offset];}return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function CubeTexture(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;Texture.call(this,images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.flipY=false;}CubeTexture.prototype=(0,_create2.default)(Texture.prototype);CubeTexture.prototype.constructor=CubeTexture;CubeTexture.prototype.isCubeTexture=true;Object.defineProperty(CubeTexture.prototype,'images',{get:function get(){return this.image;},set:function set(value){this.image=value;}});/**
	 * @author tschw
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */var emptyTexture=new Texture();var emptyCubeTexture=new CubeTexture();// --- Base for inner nodes (including the root) ---
function UniformContainer(){this.seq=[];this.map={};}// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
var arrayCacheF32=[];var arrayCacheI32=[];// Flattening for arrays of vectors and matrices
function flatten(array,nBlocks,blockSize){var firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
// see http://jacksondunstan.com/articles/983
var n=nBlocks*blockSize,r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(var i=1,offset=0;i!==nBlocks;++i){offset+=blockSize;array[i].toArray(r,offset);}}return r;}// Texture unit allocation
function allocTexUnits(renderer,n){var r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(var i=0;i!==n;++i){r[i]=renderer.allocTextureUnit();}return r;}// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function setValue1f(gl,v){gl.uniform1f(this.addr,v);}function setValue1i(gl,v){gl.uniform1i(this.addr,v);}// Single float vector (from flat array or THREE.VectorN)
function setValue2fv(gl,v){if(v.x===undefined)gl.uniform2fv(this.addr,v);else gl.uniform2f(this.addr,v.x,v.y);}function setValue3fv(gl,v){if(v.x!==undefined)gl.uniform3f(this.addr,v.x,v.y,v.z);else if(v.r!==undefined)gl.uniform3f(this.addr,v.r,v.g,v.b);else gl.uniform3fv(this.addr,v);}function setValue4fv(gl,v){if(v.x===undefined)gl.uniform4fv(this.addr,v);else gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);}// Single matrix (from flat array or MatrixN)
function setValue2fm(gl,v){gl.uniformMatrix2fv(this.addr,false,v.elements||v);}function setValue3fm(gl,v){gl.uniformMatrix3fv(this.addr,false,v.elements||v);}function setValue4fm(gl,v){gl.uniformMatrix4fv(this.addr,false,v.elements||v);}// Single texture (2D / Cube)
function setValueT1(gl,v,renderer){var unit=renderer.allocTextureUnit();gl.uniform1i(this.addr,unit);renderer.setTexture2D(v||emptyTexture,unit);}function setValueT6(gl,v,renderer){var unit=renderer.allocTextureUnit();gl.uniform1i(this.addr,unit);renderer.setTextureCube(v||emptyCubeTexture,unit);}// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValue2iv(gl,v){gl.uniform2iv(this.addr,v);}function setValue3iv(gl,v){gl.uniform3iv(this.addr,v);}function setValue4iv(gl,v){gl.uniform4iv(this.addr,v);}// Helper to pick the right setter for the singular case
function getSingularSetter(type){switch(type){case 0x1406:return setValue1f;// FLOAT
case 0x8b50:return setValue2fv;// _VEC2
case 0x8b51:return setValue3fv;// _VEC3
case 0x8b52:return setValue4fv;// _VEC4
case 0x8b5a:return setValue2fm;// _MAT2
case 0x8b5b:return setValue3fm;// _MAT3
case 0x8b5c:return setValue4fm;// _MAT4
case 0x8b5e:return setValueT1;// SAMPLER_2D
case 0x8b60:return setValueT6;// SAMPLER_CUBE
case 0x1404:case 0x8b56:return setValue1i;// INT, BOOL
case 0x8b53:case 0x8b57:return setValue2iv;// _VEC2
case 0x8b54:case 0x8b58:return setValue3iv;// _VEC3
case 0x8b55:case 0x8b59:return setValue4iv;// _VEC4
}}// Array of scalars
function setValue1fv(gl,v){gl.uniform1fv(this.addr,v);}function setValue1iv(gl,v){gl.uniform1iv(this.addr,v);}// Array of vectors (flat or from THREE classes)
function setValueV2a(gl,v){gl.uniform2fv(this.addr,flatten(v,this.size,2));}function setValueV3a(gl,v){gl.uniform3fv(this.addr,flatten(v,this.size,3));}function setValueV4a(gl,v){gl.uniform4fv(this.addr,flatten(v,this.size,4));}// Array of matrices (flat or from THREE clases)
function setValueM2a(gl,v){gl.uniformMatrix2fv(this.addr,false,flatten(v,this.size,4));}function setValueM3a(gl,v){gl.uniformMatrix3fv(this.addr,false,flatten(v,this.size,9));}function setValueM4a(gl,v){gl.uniformMatrix4fv(this.addr,false,flatten(v,this.size,16));}// Array of textures (2D / Cube)
function setValueT1a(gl,v,renderer){var n=v.length,units=allocTexUnits(renderer,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){renderer.setTexture2D(v[i]||emptyTexture,units[i]);}}function setValueT6a(gl,v,renderer){var n=v.length,units=allocTexUnits(renderer,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){renderer.setTextureCube(v[i]||emptyCubeTexture,units[i]);}}// Helper to pick the right setter for a pure (bottom-level) array
function getPureArraySetter(type){switch(type){case 0x1406:return setValue1fv;// FLOAT
case 0x8b50:return setValueV2a;// _VEC2
case 0x8b51:return setValueV3a;// _VEC3
case 0x8b52:return setValueV4a;// _VEC4
case 0x8b5a:return setValueM2a;// _MAT2
case 0x8b5b:return setValueM3a;// _MAT3
case 0x8b5c:return setValueM4a;// _MAT4
case 0x8b5e:return setValueT1a;// SAMPLER_2D
case 0x8b60:return setValueT6a;// SAMPLER_CUBE
case 0x1404:case 0x8b56:return setValue1iv;// INT, BOOL
case 0x8b53:case 0x8b57:return setValue2iv;// _VEC2
case 0x8b54:case 0x8b58:return setValue3iv;// _VEC3
case 0x8b55:case 0x8b59:return setValue4iv;// _VEC4
}}// --- Uniform Classes ---
function SingleUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
}function PureArrayUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
}function StructuredUniform(id){this.id=id;UniformContainer.call(this);// mix-in
}StructuredUniform.prototype.setValue=function(gl,value){// Note: Don't need an extra 'renderer' parameter, since samplers
// are not allowed in structured uniforms.
var seq=this.seq;for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];u.setValue(gl,value[u.id]);}};// --- Top-level ---
// Parser - builds up the property tree from the path strings
var RePathPart=/([\w\d_]+)(\])?(\[|\.)?/g;// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){var path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
RePathPart.lastIndex=0;for(;;){var match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex,id=match[1],idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else{// step into inner node / create it in case it doesn't exist
var map=container.map,next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
function WebGLUniforms(gl,program,renderer){UniformContainer.call(this);this.renderer=renderer;var n=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(var i=0;i!==n;++i){var info=gl.getActiveUniform(program,i),path=info.name,addr=gl.getUniformLocation(program,path);parseUniform(info,addr,this);}}WebGLUniforms.prototype.setValue=function(gl,name,value){var u=this.map[name];if(u!==undefined)u.setValue(gl,value,this.renderer);};WebGLUniforms.prototype.set=function(gl,object,name){var u=this.map[name];if(u!==undefined)u.setValue(gl,object[name],this.renderer);};WebGLUniforms.prototype.setOptional=function(gl,object,name){var v=object[name];if(v!==undefined)this.setValue(gl,name,v);};// Static interface
WebGLUniforms.upload=function(gl,seq,values,renderer){for(var i=0,n=seq.length;i!==n;++i){var u=seq[i],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
u.setValue(gl,v.value,renderer);}}};WebGLUniforms.seqWithValue=function(seq,values){var r=[];for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];if(u.id in values)r.push(u);}return r;};/**
	 * Uniform Utilities
	 */var UniformsUtils={merge:function merge(uniforms){var merged={};for(var u=0;u<uniforms.length;u++){var tmp=this.clone(uniforms[u]);for(var p in tmp){merged[p]=tmp[p];}}return merged;},clone:function clone(uniforms_src){var uniforms_dst={};for(var u in uniforms_src){uniforms_dst[u]=UniformsUtils.cloneParameters(uniforms_src[u]);}return uniforms_dst;},cloneParameters:function cloneParameters(parameters_src){var parameters_dst={};for(var p in parameters_src){parameters_dst[p]=UniformsUtils.cloneParameter(parameters_src[p]);}return parameters_dst;},cloneParameter:function cloneParameter(parameter_src){if(parameter_src&&(parameter_src.isColor||parameter_src.isMatrix3||parameter_src.isMatrix4||parameter_src.isVector2||parameter_src.isVector3||parameter_src.isVector4||parameter_src.isTexture)){return parameter_src.clone();}else if(Array.isArray(parameter_src)){return parameter_src.slice();}else{return parameter_src;}}};var alphamap_fragment="#ifdef USE_ALPHAMAP\n#if defined( TEXTURE_SLOTS )\n\tvec2 alphaUv = alphaMapUV();\n#else\n\tvec2 alphaUv = vUv;\n#endif\n\tdiffuseColor.a *= alphaMapTexelTransform( texture2D( alphaMap, alphaUv ) ).g;\n#endif\n";var alphamap_pars_fragment="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_ALPHAMAP\n\t\tuniform sampler2D alphaMap;\n\t#endif\n#endif\n";var alphatest_fragment="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";var anisotropy_fragment="\n#ifdef ANISOTROPY\n  #ifdef USE_ANISOTROPYMAP\n    float texelAnisotropyRed = anisotropyMapTexelTransform( texture2D( anisotropyMap, anisotropyMapUV() ) ).r;\n    float anisotropyStrength = clamp( anisotropy + texelAnisotropyRed, -1.0, 1.0 );\n  #else\n    float anisotropyStrength = anisotropy;\n  #endif\n  #if defined( ANISOTROPYROTATION ) || defined( USE_ANISOTROPYROTATIONMAP )\n    #ifdef USE_ANISOTROPYROTATIONMAP\n      float anisotropyRotationStrength = anisotropyRotation +\n                                         anisotropyRotationMapTexelTransform( texture2D( anisotropyRotationMap, anisotropyRotationMapUV() ) ).r;\n    #else\n      float anisotropyRotationStrength = anisotropyRotation;\n    #endif\n  #endif\n#endif\n";var anisotropy_pars_fragment="\n#ifdef ANISOTROPY\n  uniform float anisotropy;\n  varying vec4 vTangent;\n  #ifdef USE_ANISOTROPYMAP\n    #if ! defined( TEXTURE_SLOTS )\n      uniform sampler2D anisotropyMap;\n    #endif\n  #endif\n  #if defined( ANISOTROPYROTATION ) || defined( USE_ANISOTROPYROTATIONMAP )\n    uniform float anisotropyRotation;\n  #endif\n  #ifdef USE_ANISOTROPYROTATIONMAP\n    #if ! defined( TEXTURE_SLOTS )\n      uniform sampler2D anisotropyRotationMap;\n    #endif\n  #endif\n  float applyGainBrightnessRed( float redTexel, vec4 gainBrightnessCoeff ) {\n    if( gainBrightnessCoeff.w < 0.0 ) {\n      redTexel = whiteCompliment( redTexel );\n    }\n    return ( redTexel - gainBrightnessCoeff.x ) * gainBrightnessCoeff.y + ( gainBrightnessCoeff.z + gainBrightnessCoeff.x );\n  }\n  vec2 calcAnisotropyUV( float anisotropyLocal) {\n    float oneMinusAbsAnisotropy = 1.0 - min( abs( anisotropyLocal ) * 0.9, 0.9 );\n    vec2 anisotropyUV = vec2 ( 1.0 / oneMinusAbsAnisotropy, oneMinusAbsAnisotropy );\n    if( anisotropyLocal < 0.0 ) {\n      anisotropyUV.xy = anisotropyUV.yx;    }\n    return anisotropyUV;\n  }\n#endif\n";var anisotropy_pars_vertex="#ifdef ANISOTROPY\n  varying vec4 vTangent;\n#endif\n";var anisotropy_vertex="#ifdef ANISOTROPY\n  vTangent = vec4(normalize( normalMatrix * tangent.xyz ), tangent.w);\n#endif\n";var aomap_fragment="#ifdef USE_AOMAP\n#if defined( TEXTURE_SLOTS )\n\tvec2 aoUv = aoMapUV();\n#else\n\tvec2 aoUv = vUv2;\n#endif\n\tfloat ambientOcclusion = ( aoMapTexelTransform( texture2D( aoMap, aoUv ) ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";var aomap_pars_fragment="#ifdef USE_AOMAP\n#if ! defined( TEXTURE_SLOTS )\n\tuniform sampler2D aoMap;\n#endif\n\tuniform float aoMapIntensity;\n#endif\n";var begin_vertex="\nvec3 transformed = vec3( position );\n";var beginnormal_vertex="\nvec3 objectNormal = vec3( normal );\n";var bsdfs="\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif ( decayExponent > 0.0 && cutoffDistance > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\telse if ( decayExponent < 0.0 ) {\n\t\tfloat maxDistanceCutoffFactor = 0.0;\n\t\tif ( lightDistance > 0.0 ) {\n\t\t\tmaxDistanceCutoffFactor = 1.0;\n\t\t\tif( cutoffDistance > 0.0 ) {\n\t\t\t\tmaxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\t}\n\t\t\tfloat distanceFalloff = 1.0 / ( pow2( lightDistance ) );\n\t\t\tmaxDistanceCutoffFactor * distanceFalloff;\n\t\t}\n\t\treturn maxDistanceCutoffFactor;\n\t}\n\telse {\n\t\treturn 1.0;\n\t}\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nfloat F_Schlick( const in float specular, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specular ) * fresnel + specular;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\n#ifdef ANISOTROPY\n  float D_GGXAniso( const in vec2 anisotropicM, const in vec2 xyDotH, const in float dotNH ) {\n  \tvec3 aniso = vec3(xyDotH.x / anisotropicM.x, xyDotH.y / anisotropicM.y, dotNH);\n  \tfloat anisoTerm = dot(aniso, aniso);\n    return RECIPROCAL_PI / ( anisotropicM.x * anisotropicM.y * anisoTerm * anisoTerm + EPSILON );\n  }\n#else\n\tfloat D_GGX( const in float alpha, const in float dotNH ) {\n\t\tfloat a2 = pow2( alpha );\n\t\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\t\treturn RECIPROCAL_PI * pow2( alpha / denom );\n\t}\n#endif\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = clamp( dot( geometry.normal, incidentLight.direction ), EPSILON, 1.0 );\tfloat dotNV = clamp( dot( geometry.normal, geometry.viewDir ), EPSILON, 1.0 );\tfloat dotNH = clamp( dot( geometry.normal, halfDir ), EPSILON, 1.0 );\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n#ifdef ANISOTROPY\n\tvec2 xyDotH = vec2( dot( geometry.anisotropicS, halfDir ), dot( geometry.anisotropicT, halfDir ) );\n\tfloat D = D_GGXAniso( geometry.anisotropicM, xyDotH, dotNH );\n#else\n\tfloat D = D_GGX( alpha, dotNH );\n#endif\n\treturn F * ( G * D );\n}\nfloat BRDF_ClearCoat_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in float specular, const in float roughness, out float layerAttenuation ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = clamp( dot( geometry.normal, incidentLight.direction ), EPSILON, 1.0 );\tfloat dotNV = clamp( dot( geometry.normal, geometry.viewDir ), EPSILON, 1.0 );\tfloat dotNH = clamp( dot( geometry.normal, halfDir ), EPSILON, 1.0 );\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tfloat F = F_Schlick( specular, dotLH );\n\tlayerAttenuation = F;\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n#ifdef ANISOTROPY\n\tvec2 xyDotH = vec2( dot( geometry.anisotropicS, halfDir ), dot( geometry.anisotropicT, halfDir ) );\n\tfloat D = D_GGXAniso( geometry.anisotropicM, xyDotH, dotNH );\n#else\n\tfloat D = D_GGX( alpha, dotNH );\n#endif\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat BRDF_ClearCoat_GGX_Environment( const in GeometricContext geometry, const in float specular, const in float roughness, out float layerAttention ) {\n\tvec3 incidentLightDirection = reflect( geometry.viewDir, geometry.normal );\n\tvec3 halfDir = normalize( incidentLightDirection + geometry.viewDir );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotLH = saturate( dot( incidentLightDirection, halfDir ) );\n\tlayerAttention = F_Schlick( specular, dotLH );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specular * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n#if ! defined( TEXTURE_SLOTS )\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n#endif\n\tvec2 dHdxy_fwd() {\n#if defined( TEXTURE_SLOTS )\n\t\tvec2 bumpUv = bumpMapUV();\n#else\n\t\tvec2 bumpUv = vUv;\n#endif\n\t\tvec2 dSTdx = dFdx( bumpUv );\n\t\tvec2 dSTdy = dFdy( bumpUv );\n\t\tfloat Hll = bumpMapTexelTransform( texture2D( bumpMap, bumpUv ) ).x;\n\t\tfloat dBx = bumpMapTexelTransform( texture2D( bumpMap, bumpUv + dSTdx ) ).x - Hll;\n\t\tfloat dBy = bumpMapTexelTransform( texture2D( bumpMap, bumpUv + dSTdy ) ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( VARYING_VVIEWPOSITION )\n\t\tvarying vec3 vViewPosition;\n\t\t#define VARYING_VVIEWPOSITION 1\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\t#if ! defined( VARYING_VVIEWPOSITION )\n    \tvarying vec3 vViewPosition;\n    \t#define VARYING_VVIEWPOSITION 1\n    #endif\n#endif\n";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";var color_fragment="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif\n";var color_pars_fragment="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";var color_pars_vertex="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";var color_vertex="#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif\n";var common="#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand_OLD( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nhighp float rand_NEW( const in vec2 p ) {\n\tvec2 p2  = fract(p * vec2(5.3987, 5.4421));\n\tp2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\tfloat pxy = p2.x * p2.y;\n\treturn ( fract(pxy * 95.4307) + fract(pxy * 75.04961) ) * 0.5;\n}\n#define rand rand_NEW\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef ANISOTROPY\n\tvec2 anisotropicM;\n\tvec3 anisotropicS;\n\tvec3 anisotropicT;\n#endif\n};\nvec3 transformPosition( in vec3 pos, in mat4 matrix ) {\n\treturn ( matrix * vec4( pos, 1.0 ) ).xyz;\n}\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nfloat MipLevelInfo_standard( vec3 vec, vec3 normal, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn mipLevel;\n}\nfloat MipLevelInfo_aa( vec3 vec, vec3 normal, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tvec3 dx = dFdx( vec ) * 128.0;\n\tvec3 dy = dFdy( vec ) * 128.0;\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = pow( d, 0.5);\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn mipLevel;\n}\n#define MipLevelInfo MipLevelInfo_standard\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 1.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, vec3 normal, float roughness ) {\n\troughness *= 0.88;\n\tfloat roughnessVal = roughness * cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tfloat mipLevel = MipLevelInfo(reflectedDirection, normal, r1, roughness);\n\tfloat s = fract( mipLevel );\n\tfloat level0 = floor( mipLevel );\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\t\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";var defaultnormal_vertex="#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";var dithering_fragment="#if defined( DITHERING )\n  gl_FragColor.rgb += ditherScale * ditherOffset( gl_FragCoord.xy + gl_FragColor.rg + gl_FragColor.ba + normal.xy );\n  \n#endif";var dithering_pars_fragment="#if defined( DITHERING )\n\t#if defined( DITHERING_SCALE )\n\t\tuniform float ditherScale;\n\t#endif\n\tvec3 ditherOffset( vec2 uv ) {\n\t\tfloat grid_position = rand( uv );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB *= 2.0 * ( 2.0 * grid_position - 1.0 );\n\t\treturn dither_shift_RGB;\n\t}\n#endif";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n#if defined( TEXTURE_SLOTS )\n\tvec2 emissiveUv = emissiveMapUV();\n#else\n\tvec2 emissiveUv = vUv;\n#endif\n\tvec4 emissiveColor = texture2D( emissiveMap, emissiveUv );\n\temissiveColor.rgb = emissiveMapTexelTransform( emissiveMapTexelToLinear( emissiveColor ) ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";var emissivemap_pars_fragment="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_EMISSIVEMAP\n\t\tuniform sampler2D emissiveMap;\n\t#endif\n#endif\n";var encodings_fragment="  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";var encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";var envmap_fragment="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";var envmap_pars_fragment="#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";var envmap_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";var falloff_fragment="#ifdef FALLOFF\nfloat falloffModulator = abs( dot( normal, normalize( vViewPosition ) ) );\nfalloffModulator = ( falloffModulator * falloffModulator * ( 3.0 - 2.0 * falloffModulator ) );\ndiffuseColor = mix( falloffDiffuseColor, diffuseColor, falloffModulator );\n#endif";var falloffalphamap_fragment="#ifdef USE_FALLOFFALPHAMAP\n#if defined( TEXTURE_SLOTS )\n\tvec2 falloffAlphaUv = falloffAlphaMapUV();\n#else\n\tvec2 falloffAlphaUv = vUv;\n#endif\n\tfalloffDiffuseColor.a *= falloffAlphaMapTexelTransform( texture2D( falloffAlphaMap, falloffAlphaUv ) ).g;\n#endif\n";var falloffmap_fragment="#ifdef USE_FALLOFFMAP\n#if defined( TEXTURE_SLOTS )\n\tvec2 falloffMapUv = falloffMapUV();\n#else\n\tvec2 falloffMapUv = vUv;\n#endif\n\tvec4 falloffTexelColor = texture2D( falloffMap, falloffMapUv );\n\tfalloffTexelColor = falloffMapTexelTransform( falloffMapTexelToLinear( falloffTexelColor ) );\n\tfalloffDiffuseColor *= falloffTexelColor;\n#endif\n";var fog_fragment="#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";var gradientmap_pars_fragment="#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";var lightmap_fragment="#ifdef USE_LIGHTMAP\n#if defined( TEXTURE_SLOTS )\n\tvec2 lightUv = lightMapUV();\n#else\n\tvec2 lightUv = vUv2;\n#endif\n\treflectedLight.indirectDiffuse += PI * emissiveMapTexelTransform( texture2D( lightMap, lightUv ) ).xyz;\n#endif\n";var lightmap_pars_fragment="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_LIGHTMAP\n\t\tuniform sampler2D lightMap;\n\t\tuniform float lightMapIntensity;\n\t#endif\n#endif\n";var lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";var lights_pars="uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat spreadAngle;\n\t\tvec2 shadowMapSize;\n\t\tvec3 shadowCameraParams;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.direction = lVector / lightDistance;\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tvec3 shadowCameraParams;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.direction = lVector / lightDistance;\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, worldNormal, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";var lights_phong_pars_fragment="#if ! defined( VARYING_VVIEWPOSITION )\n    varying vec3 vViewPosition;\n    #define VARYING_VVIEWPOSITION 1\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n    void RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n        vec3 matDiffColor = material.diffuseColor;\n        vec3 matSpecColor = material.specularColor;\n        vec3 lightColor   = rectAreaLight.color;\n        float roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n        vec3 spec = Rect_Area_Light_Specular_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n                roughness,\n                ltcMat, ltcMag );\n        vec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n        reflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n        reflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n    }\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n    void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n        vec3 matDiffColor = material.diffuseColor;\n        vec3 matSpecColor = material.specularColor;\n        vec3 lightColor   = rectAreaLight.color;\n        float roughness = material.specularRoughness;\n        vec3 spec = Rect_Area_Light_Specular_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n                roughness,\n                ltcMat, ltcMag );\n        vec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n        reflectedLight.directSpecular += lightColor * matSpecColor * spec;\n        reflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n    }\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\tvec3 specularRadiance = irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\tvec3 diffuseRadiance = irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\tfloat layerAttention;\n\t\tvec3 clearCoatSpecularRadiance = irradiance * BRDF_ClearCoat_GGX( directLight, geometry, material.clearCoat, material.clearCoatRoughness, layerAttention );\n\t\tspecularRadiance = mix( specularRadiance, clearCoatSpecularRadiance, material.clearCoat );\n\t\tdiffuseRadiance = mix( diffuseRadiance, vec3( 0.0 ), material.clearCoat );\n\t#endif\n\treflectedLight.directSpecular += specularRadiance;\n\treflectedLight.directDiffuse += diffuseRadiance;\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 diffuseRadiance = irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\tdiffuseRadiance = mix( diffuseRadiance, vec3( 0.0 ), material.clearCoat );\n\t#endif\n\treflectedLight.indirectDiffuse += diffuseRadiance;\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 specularRadiance = radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\tfloat layerAttention;\n\t\tvec3 clearCoatSpecularRadiance = clearCoatRadiance * BRDF_ClearCoat_GGX_Environment( geometry, material.clearCoat, material.clearCoatRoughness, layerAttention );\n\t\tspecularRadiance = mix( specularRadiance, clearCoatSpecularRadiance, material.clearCoat );\n\t#endif\n\treflectedLight.indirectSpecular += specularRadiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";var lights_template="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef ANISOTROPY\n\tgeometry.anisotropicM = calcAnisotropyUV( anisotropyStrength ) * pow2( clamp( roughnessFactor, 0.02, 1.0 ) );\n\tvec3 unitTangent  = normalize( vTangent.xyz  );\n\tvec3 unitBinormal = cross( normal, unitTangent );\n\t#ifdef ANISOTROPYROTATION\n\t\tfloat anisotropyRotationAngle = anisotropyRotationStrength * 2.0 * PI;\n\t\tfloat anisoCos = cos(anisotropyRotationAngle);\n\t\tfloat anisoSin = sin(anisotropyRotationAngle);\n\t\tgeometry.anisotropicS = (unitBinormal * anisoCos - unitTangent  * anisoSin) * vTangent.w;\n\t\tgeometry.anisotropicT =  unitTangent  * anisoCos + unitBinormal * anisoSin;\n\t#else\n\t\tgeometry.anisotropicS = unitBinormal * vTangent.w;\t\tgeometry.anisotropicT = unitTangent;\n\t#endif\n#endif\nIncidentLight directLight;\n#ifdef USE_SHADOWMAP\n\tinitShadows();\n#endif\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, 0.0, spotLight.shadowCameraParams, vSpotShadowCoord[ i ], 1 ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, 0.0, directionalLight.spreadAngle, directionalLight.shadowCameraParams, vDirectionalShadowCoord[ i ], 0 ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\t#if defined( TEXTURE_SLOTS )\n\t\t\tvec2 lightUv = lightMapUV();\n\t\t\tvec3 lightMapIrradiance = lightMapTexelTransform( texture2D( lightMap, vUv2 ) ).xyz;\n\t\t#else\n\t\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#endif\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";var logdepthbuf_fragment="#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif\n";var logdepthbuf_pars_fragment="#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif\n";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";var map_fragment="#ifdef USE_MAP\n#if defined( TEXTURE_SLOTS )\n\tvec2 mapUv = mapUV();\n#else\n\tvec2 mapUv = vUv;\n#endif\n\tvec4 texelColor = texture2D( map, mapUv );\n\ttexelColor = mapTexelTransform( mapTexelToLinear( texelColor ) );\n\tdiffuseColor *= texelColor;\n#endif\n";var map_pars_fragment="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_MAP\n\t\tuniform sampler2D map;\n\t#endif\n#endif\n";var map_particle_fragment="#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";var map_particle_pars_fragment="#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\t#if defined( TEXTURE_SLOTS )\n\t\tvec2 metalnessUv = metalnessMapUV();\n\t#else\n\t\tvec2 metalnessUv = vUv;\n\t#endif\n\tvec4 texelMetalness = metalnessMapTexelTransform( texture2D( metalnessMap, metalnessUv ) );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";var metalnessmap_pars_fragment="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_METALNESSMAP\n\t\tuniform sampler2D metalnessMap;\n\t#endif\n#endif\n";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif\n";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";var normal_flip="#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";var normal_fragment="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#endif\n#ifdef USE_BUMPMAP\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\t#if ! defined( TEXTURE_SLOTS )\n\t\tuniform sampler2D normalMap;\n\t#endif\n\t\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t#if defined( TEXTURE_SLOTS )\n\t\t\tvec2 normalUv = normalMapUV();\n\t\t#else\n\t\t\tvec2 normalUv = vUv;\n\t\t#endif\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( normalUv.st );\n\t\tvec2 st1 = dFdy( normalUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\t\t\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 NfromST = cross( S, T );\n\t\tif( dot( NfromST, N ) < 0.0 ) {\n\t\t\tS *= -1.0;\n\t\t\tT *= -1.0;\n\t\t}\n\t\tvec3 mapN = texture2D( normalMap, normalUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nvec4 packDepthToRGBA( const in highp float v ) {\n  const highp vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const highp vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n  highp vec4 res = mod( v * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );  res -= res.xxyz * bit_mask;\n  return res;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n  const highp vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\treturn dot( v, bit_shift );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";var project_vertex="#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\t#if defined( TEXTURE_SLOTS )\n\t\tvec2 roughnessUv = roughnessMapUV();\n\t#else\n\t\tvec2 roughnessUv = vUv;\n\t#endif\n\tvec4 texelRoughness = roughnessMapTexelTransform( texture2D( roughnessMap, roughnessUv ) );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";var roughnessmap_pars_fragment="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_ROUGHNESSMAP\n\t\tuniform sampler2D roughnessMap;\n\t#endif\n#endif\n";var shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\t#if defined( SHADOWMAP_TYPE_PCSS )\n\t\t#define PCSS_QUALITY_LEVEL 5\n\t\t#define PCSS_NUM_POISSON_SAMPLES 16\n\t\t#define PCSS_ROTATE_POISSON_SAMPLES 1\n\t\tvec2 poissonDisk[PCSS_NUM_POISSON_SAMPLES];\n\t\tvoid initPercentCloserSoftShadow( const in vec2 randomSeed )\t{\n\t\t\tpoissonDisk[0] = vec2(-0.94201624, -0.39906216 );\n\t\t\tpoissonDisk[1] = vec2( 0.94558609, -0.76890725 );\n\t\t\tpoissonDisk[2] = vec2( -0.094184101, -0.92938870 );\n\t\t\tpoissonDisk[3] = vec2( 0.34495938, 0.29387760 );\n\t\t\tpoissonDisk[4] = vec2( -0.91588581, 0.45771432 );\n\t\t\tpoissonDisk[5] = vec2( -0.81544232, -0.87912464 );\n\t\t\tpoissonDisk[6] = vec2( -0.38277543, 0.27676845 );\n\t\t\tpoissonDisk[7] = vec2( 0.97484398, 0.75648379 );\n\t\t\tpoissonDisk[8] = vec2( 0.44323325, -0.97511554 );\n\t\t\tpoissonDisk[9] = vec2( 0.53742981, -0.47373420 );\n\t\t\tpoissonDisk[10] = vec2( -0.26496911, -0.41893023 );\n\t\t\tpoissonDisk[11] = vec2( 0.79197514, 0.19090188 );\n\t\t\tpoissonDisk[12] = vec2( -0.24188840, 0.99706507 );\n\t\t\tpoissonDisk[13] = vec2( -0.81409955, 0.91437590 );\n\t\t\tpoissonDisk[14] = vec2( 0.19984126, 0.78641367 );\n\t\t\tpoissonDisk[15] = vec2( 0.14383161, -0.14100790 );\n\t\t}\n\t\tmat2 createRotationMatrix( const in vec2 randomSeed ) {\n\t\t\tfloat angle = rand( randomSeed + cameraPosition.x + cameraPosition.y + cameraPosition.z ) * PI2;\n\t\t\tfloat c = cos( angle ), s = sin( angle );\n\t\t\treturn mat2( c, s, -s, c );\n\t\t}\n\t\tfloat penumbraSize( const in float zReceiverLightSpace, const in float zBlockerLightSpace ) {\t\t\treturn (zReceiverLightSpace - zBlockerLightSpace) / zBlockerLightSpace;\n\t\t}\n\t\tfloat findBlockerLightZ( sampler2D shadowMap, const in vec2 uv, const in float zReceiverClipSpace, const in float zReceiverLightSpace, const in float shadowRadius, const in float spreadAngle, const in vec3 shadowCameraParams, const in vec2 randomSeed, const int lightType ) {\n\t\t\tfloat lightFrustrumWidth = 2.0 * shadowCameraParams.y * tan(shadowCameraParams.x * 0.5);\n\t\t\tfloat searchRadius = 0.0;\n\t\t\tsearchRadius = ( lightType == 0) ? zReceiverLightSpace * spreadAngle/shadowCameraParams.x : ( shadowRadius / lightFrustrumWidth ) * ( zReceiverLightSpace - shadowCameraParams.y ) / zReceiverLightSpace;\n\t\t\tfloat blockerLightZSum = 0.0;\n\t\t\tint numBlockers = 0;\n\t\t\tfloat angle = rand( randomSeed ) * PI2;\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\tfor( int i = 0; i < PCSS_NUM_POISSON_SAMPLES; i++ ) {\n\t\t\t#if PCSS_ROTATE_POISSON_SAMPLES == 1\n\t\t\t\tvec2 poissonSample = vec2(poissonDisk[i].y * c + poissonDisk[i].x * s, poissonDisk[i].y * -s + poissonDisk[i].x * c);\n\t\t\t#else\n\t\t\t\tvec2 poissonSample = poissonDisk[i];\n\t\t\t#endif\n\t\t\t\tfloat shadowMapDepth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonSample * searchRadius ) );\n\t\t\t\tif ( shadowMapDepth < zReceiverClipSpace ) {\n\t\t\t\t\tblockerLightZSum += shadowMapDepth;\n\t\t\t\t\tnumBlockers ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( numBlockers == 0 ) return -1.0;\n\t\t\treturn blockerLightZSum / float( numBlockers );\n\t\t}\n\t\tfloat percentCloserFilter( sampler2D shadowMap, vec2 uv, float receiverClipZ, float filterRadius, const in vec2 randomSeed ) {\n\t\t\tint numBlockers = 0;\n\t\t\tfloat angle = rand( randomSeed ) * PI2;\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\tfor( int i = 0; i < PCSS_NUM_POISSON_SAMPLES; i ++ ) {\n\t\t\t#if PCSS_ROTATE_POISSON_SAMPLES == 1\n\t\t\t\tvec2 poissonSample = vec2(poissonDisk[i].y * c + poissonDisk[i].x * s, poissonDisk[i].y * -s + poissonDisk[i].x * c);\n\t\t\t#else\n\t\t\t\tvec2 poissonSample = poissonDisk[i];\n\t\t\t#endif\n\t\t\t\tvec2 uvOffset = poissonSample * filterRadius;\n\t\t\t\tfloat blockerClipZ = unpackRGBAToDepth( texture2D( shadowMap, uv + uvOffset ) );\n\t\t\t\tif( receiverClipZ <= blockerClipZ ) numBlockers ++;\n\t\t\t\tblockerClipZ = unpackRGBAToDepth( texture2D( shadowMap, uv - uvOffset ) );\n\t\t\t\tif( receiverClipZ <= blockerClipZ ) numBlockers ++;\n\t\t\t}\n\t\t\treturn float( numBlockers ) / ( 2.0 * float( PCSS_NUM_POISSON_SAMPLES ) );\n\t\t}\n\t\tfloat percentCloserSoftShadow( sampler2D shadowMap, const in float shadowRadius, const in float spreadAngle, const in vec3 shadowCameraParams, const in vec4 coords, const int lightType ) {\n\t\t\tvec2 uv = coords.xy;\n\t\t\tfloat receiverLightZ = coords.z;\n\t\t\tfloat cameraNear = shadowCameraParams.y, cameraFar = shadowCameraParams.z;\n\t\t\tfloat zReceiverLightSpace;\n\t\t\tif(lightType == 0)\n\t\t\t\tzReceiverLightSpace = -orthographicDepthToViewZ( receiverLightZ, cameraNear, cameraFar );\n\t\t\telse\n\t\t\t\tzReceiverLightSpace = -perspectiveDepthToViewZ( receiverLightZ, cameraNear, cameraFar );\n\t\t\tfloat blockerLightZ = findBlockerLightZ( shadowMap, uv, receiverLightZ, zReceiverLightSpace, shadowRadius, spreadAngle, shadowCameraParams, uv, lightType );\n\t\t\tif( blockerLightZ == -1.0 ) return 1.0;\n\t\t\tfloat avgBlockerDepthLightSpace;\n\t\t\tfloat filterRadius = 0.0;\n\t\t\tif(lightType == 0) {\n\t\t\t\tavgBlockerDepthLightSpace = -orthographicDepthToViewZ( blockerLightZ, cameraNear, cameraFar );\n\t\t\t\tfilterRadius = (zReceiverLightSpace - avgBlockerDepthLightSpace) * spreadAngle/shadowCameraParams.x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tavgBlockerDepthLightSpace = -perspectiveDepthToViewZ( blockerLightZ, cameraNear, cameraFar );\n\t\t\t\tfloat penumbraRatio = penumbraSize( zReceiverLightSpace, avgBlockerDepthLightSpace );\n\t\t\t\tfloat lightFrustrumWidth = 2.0 * cameraNear * tan(shadowCameraParams.x * 0.5);\n\t\t\t\tfilterRadius = penumbraRatio * ( shadowRadius/lightFrustrumWidth ) * cameraNear / zReceiverLightSpace;\n\t\t\t}\n\t\t\t\n\t\t\treturn  percentCloserFilter( shadowMap, uv, receiverLightZ, filterRadius, uv );\n\t\t}\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tvoid initShadows() {\n\t\t#if defined( SHADOWMAP_TYPE_PCSS )\n\t\t  initPercentCloserSoftShadow( vViewPosition.xy );\n\t\t#endif\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, float spreadAngle, vec3 shadowCameraParams, vec4 shadowCoord, const int lightType ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCSS )\n\t\t  return percentCloserSoftShadow( shadowMap, shadowRadius, spreadAngle, shadowCameraParams, shadowCoord, lightType );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";var shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n#endif\n";var shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n#endif\n";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, 0.0, directionalLight.spreadAngle, directionalLight.shadowCameraParams, vDirectionalShadowCoord[ i ], 0 ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, 0.0, spotLight.shadowCameraParams, vSpotShadowCoord[ i ], 1 ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif\n";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";var slot_texel_transform_template="uniform vec2 $SLOT_NAME$TexelTransformParams;\nvec4 $SLOT_NAME$TexelTransform( vec4 value ) {\n    value.rgb *= $SLOT_NAME$TexelTransformParams.x;\n    value.rgb += vec3( $SLOT_NAME$TexelTransformParams.y );\n    return value;\n}\n";var slot_uv_transform_template="uniform vec4 $SLOT_NAME$UVTransformParams;\nvec2 $SLOT_NAME$UV() {\n  vec2 value = $UV_VAR_NAME$;\n  value.xy *= $SLOT_NAME$UVTransformParams.xy;\n  value.xy += $SLOT_NAME$UVTransformParams.zw;\n  return value;\n}\n";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\t#if defined( TEXTURE_SLOTS )\n\t\tvec2 specularUv = specularMapUV();\n\t#else\n\t\tvec2 specularUv = vUv;\n\t#endif\n\tvec4 texelSpecular = specularMapTexelTransform( texture2D( specularMap, specularUv ) );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif\n";var specularmap_pars_fragment="#if ! defined( TEXTURE_SLOTS )\n\t#ifdef USE_SPECULARMAP\n\t\tuniform sampler2D specularMap;\n\t#endif\n#endif\n";var tonemapping_fragment="#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";var tonemapping_pars_fragment="#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";var uv_pars_fragment="#if ! defined( TEXTURE_SLOTS )\n\t#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_FALLOFFALPHAMAP ) || defined( ANISOTROPY )\n\t\tvarying vec2 vUv;\n\t#endif\n#endif\n";var uv_pars_vertex="\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )  || defined( USE_FALLOFFMAP ) || defined( ANISOTROPY )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";var uv_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_FALLOFFALPHAMAP ) || defined( ANISOTROPY )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif\n";var uv2_pars_fragment="#if ! defined( TEXTURE_SLOTS )\n\t#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\t\tvarying vec2 vUv2;\n\t#endif\n#endif\n";var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif\n";var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif\n";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";var oit_fragment="#ifdef USE_OIT\n    if( oitMode == 0 ) {      float z = abs(vPositionZ);\n      float weight = pow( gl_FragColor.a, 1.0 ) * clamp( 10.0 / ( 1e-5 + pow( abs( z ) / 5.0, 1.0 ) + pow( abs( z ) / 200.0, 1.0 ) ), 1e-2, 3e3 );\n      gl_FragColor = vec4(gl_FragColor.rgb * gl_FragColor.a, gl_FragColor.a) * weight;\n    }\n    else if( oitMode == 1 ) {      gl_FragColor = vec4(gl_FragColor.a);\n    }\n#endif\n";var oit_vertex="#ifdef USE_OIT\n  vPositionZ = mvPosition.z;\n#endif\n";var oit_pars_vertex="#ifdef USE_OIT\n  varying float vPositionZ;\n#endif\n";var oit_pars_fragment="#ifdef USE_OIT\n  varying float vPositionZ;\n  uniform int oitMode;\n#endif\n";var cube_frag="uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";var cube_vert="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";var cubeEnv_frag="uniform float tFlip;\nuniform float opacity;\nuniform float roughness;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 queryReflectVec = vec3( tFlip * vWorldPosition.x, vWorldPosition.yz );\n\tvec4 envMapColor = vec4( 0.0 );\n\t#if defined( ENVMAP_TYPE_CUBE )\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\tenvMapColor = textureCubeLodEXT( envMap, queryReflectVec, roughness * 8.0 );\n\t\t#else\n\t\t\tenvMapColor = textureCube( envMap, queryReflectVec, roughness * 8.0 );\n\t\t#endif\n\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\tenvMapColor.rgb *= envMapIntensity;\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tenvMapColor = textureCubeUV( queryReflectVec, queryReflectVec, roughness );\n\t\tenvMapColor.rgb *= envMapIntensity;\n\t#endif\n\tgl_FragColor = envMapColor;\n\tgl_FragColor.a = opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <logdepthbuf_fragment>\n}\n";var cubeEnv_vert="varying vec3 vWorldPosition;\n#include <common>\n#include <clipping_planes_pars_vertex>\n#if NUM_CLIPPING_PLANES == 0\n\t#if ! defined( VARYING_VVIEWPOSITION )\n   \t\tvarying vec3 vViewPosition;\n   \t\t#define VARYING_VVIEWPOSITION 1\n   #endif\n#endif\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}\n";var depth_frag="precision highp float;\n#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";var depth_vert="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";var distanceRGBA_frag="uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";var distanceRGBA_vert="varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";var equirect_frag="uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";var equirect_vert="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";var linedashed_frag="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = mapTexelToLinear( vec4( diffuse, opacity ) );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <fog_fragment>\n}\n";var linedashed_vert="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";var meshbasic_frag="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <oit_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = mapTexelToLinear( vec4( diffuse, opacity ) );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <oit_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <fog_fragment>\n}\n";var meshbasic_vert="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <oit_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <oit_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";var meshlambert_frag="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <oit_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = mapTexelToLinear( vec4( diffuse, opacity ) );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <oit_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <fog_fragment>\n}\n";var meshlambert_vert="#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <oit_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <oit_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";var meshphong_frag="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <oit_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = mapTexelToLinear( vec4( diffuse, opacity ) );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <oit_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <fog_fragment>\n}\n";var meshphong_vert="#define PHONG\n#if ! defined( VARYING_VVIEWPOSITION )\n\tvarying vec3 vViewPosition;\n\t#define VARYING_VVIEWPOSITION 1\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <oit_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <oit_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";var meshphysical_frag="precision highp float;\n#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#define DITHERING\n#define DITHERING_SCALE\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n\t#ifdef FALLOFF\n\t\tuniform vec3 falloffDiffuse;\n\t\tuniform float falloffOpacity;\n\t#endif\n#endif\n#if ! defined( VARYING_VVIEWPOSITION )\n\tvarying vec3 vViewPosition;\n\t#define VARYING_VVIEWPOSITION 1\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <oit_pars_fragment>\n#include <anisotropy_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = mapTexelToLinear( vec4( diffuse, opacity ) );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef FALLOFF\n\t\tvec4 falloffDiffuseColor = mapTexelToLinear( vec4( falloffDiffuse, falloffOpacity ) );\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <falloffmap_fragment>\n\t#include <falloffalphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <anisotropy_fragment>\n\t#include <falloff_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <oit_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var meshphysical_vert="#define PHYSICAL\n#if ! defined( VARYING_VVIEWPOSITION )\n\tvarying vec3 vViewPosition;\n\t#define VARYING_VVIEWPOSITION 1\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <oit_pars_vertex>\n#include <anisotropy_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <oit_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <anisotropy_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";var normal_frag="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\t#if ! defined( VARYING_VVIEWPOSITION )\n\t\tvarying vec3 vViewPosition;\n\t\t#define VARYING_VVIEWPOSITION 1\n\t#endif\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n   \tgl_FragColor = vec4( packNormalToRGB( vNormal * flipNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n";var normal_vert="#define NORMAL\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\t#if ! defined( VARYING_VVIEWPOSITION )\n   \t\tvarying vec3 vViewPosition;\n   \t\t#define VARYING_VVIEWPOSITION 1\n   #endif\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\t\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";var points_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <fog_fragment>\n}\n";var points_vert="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";var shadow_frag="uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";var shadow_vert="#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";var ShaderChunk={alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,anisotropy_fragment:anisotropy_fragment,anisotropy_pars_fragment:anisotropy_pars_fragment,anisotropy_pars_vertex:anisotropy_pars_vertex,anisotropy_vertex:anisotropy_vertex,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,encodings_fragment:encodings_fragment,encodings_pars_fragment:encodings_pars_fragment,envmap_fragment:envmap_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_vertex:envmap_vertex,falloff_fragment:falloff_fragment,falloffalphamap_fragment:falloffalphamap_fragment,falloffmap_fragment:falloffmap_fragment,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_fragment:lightmap_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_vertex:lights_lambert_vertex,lights_pars:lights_pars,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_template:lights_template,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_flip:normal_flip,normal_fragment:normal_fragment,normalmap_pars_fragment:normalmap_pars_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,slot_texel_transform_template:slot_texel_transform_template,slot_uv_transform_template:slot_uv_transform_template,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,uv2_pars_fragment:uv2_pars_fragment,uv2_pars_vertex:uv2_pars_vertex,uv2_vertex:uv2_vertex,worldpos_vertex:worldpos_vertex,oit_fragment:oit_fragment,oit_vertex:oit_vertex,oit_pars_vertex:oit_pars_vertex,oit_pars_fragment:oit_pars_fragment,cube_frag:cube_frag,cube_vert:cube_vert,cubeEnv_frag:cubeEnv_frag,cubeEnv_vert:cubeEnv_vert,depth_frag:depth_frag,depth_vert:depth_vert,distanceRGBA_frag:distanceRGBA_frag,distanceRGBA_vert:distanceRGBA_vert,equirect_frag:equirect_frag,equirect_vert:equirect_vert,linedashed_frag:linedashed_frag,linedashed_vert:linedashed_vert,meshbasic_frag:meshbasic_frag,meshbasic_vert:meshbasic_vert,meshlambert_frag:meshlambert_frag,meshlambert_vert:meshlambert_vert,meshphong_frag:meshphong_frag,meshphong_vert:meshphong_vert,meshphysical_frag:meshphysical_frag,meshphysical_vert:meshphysical_vert,normal_frag:normal_frag,normal_vert:normal_vert,points_frag:points_frag,points_vert:points_vert,shadow_frag:shadow_frag,shadow_vert:shadow_vert};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Color(r,g,b){if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
return this.set(r);}return this.setRGB(r,g,b);}Color.prototype={constructor:Color,isColor:true,r:1,g:1,b:1,set:function set(value){if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}return this;},setScalar:function setScalar(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;},setHex:function setHex(hex){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;return this;},setRGB:function setRGB(r,g,b){this.r=r;this.g=g;this.b=b;return this;},setHSL:function(){function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}return function setHSL(h,s,l){// h,s,l ranges are in 0.0 - 1.0
h=_Math.euclideanModulo(h,1);s=_Math.clamp(s,0,1);l=_Math.clamp(l,0,1);if(s===0){this.r=this.g=this.b=l;}else{var p=l<=0.5?l*(1+s):l+s-l*s;var q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}return this;};}(),setStyle:function setStyle(style){function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}var m;if(m=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)){// rgb / hsl
var color;var name=m[1];var components=m[2];switch(name){case'rgb':case'rgba':if(color=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
this.r=Math.min(255,parseInt(color[1],10))/255;this.g=Math.min(255,parseInt(color[2],10))/255;this.b=Math.min(255,parseInt(color[3],10))/255;handleAlpha(color[5]);return this;}if(color=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
this.r=Math.min(100,parseInt(color[1],10))/100;this.g=Math.min(100,parseInt(color[2],10))/100;this.b=Math.min(100,parseInt(color[3],10))/100;handleAlpha(color[5]);return this;}break;case'hsl':case'hsla':if(color=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
var h=parseFloat(color[1])/360;var s=parseInt(color[2],10)/100;var l=parseInt(color[3],10)/100;handleAlpha(color[5]);return this.setHSL(h,s,l);}break;}}else if(m=/^\#([A-Fa-f0-9]+)$/.exec(style)){// hex color
var hex=m[1];var size=hex.length;if(size===3){// #ff0
this.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;this.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;this.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;return this;}else if(size===6){// #ff0000
this.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;this.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;this.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;return this;}}if(style&&style.length>0){// color keywords
var hex=ColorKeywords[style];if(hex!==undefined){// red
this.setHex(hex);}else{// unknown color
console.warn('THREE.Color: Unknown color '+style);}}return this;},clone:function clone(){return new this.constructor(this.r,this.g,this.b);},copy:function copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;},copyGammaToLinear:function copyGammaToLinear(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;this.r=Math.pow(color.r,gammaFactor);this.g=Math.pow(color.g,gammaFactor);this.b=Math.pow(color.b,gammaFactor);return this;},copyLinearToGamma:function copyLinearToGamma(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;var safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;this.r=Math.pow(color.r,safeInverse);this.g=Math.pow(color.g,safeInverse);this.b=Math.pow(color.b,safeInverse);return this;},convertGammaToLinear:function convertGammaToLinear(){var r=this.r,g=this.g,b=this.b;this.r=r*r;this.g=g*g;this.b=b*b;return this;},convertLinearToGamma:function convertLinearToGamma(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this;},getHex:function getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0;},getHexString:function getHexString(){return('000000'+this.getHex().toString(16)).slice(-6);},getHSL:function getHSL(optionalTarget){// h,s,l ranges are in 0.0 - 1.0
var hsl=optionalTarget||{h:0,s:0,l:0};var r=this.r,g=this.g,b=this.b;var max=Math.max(r,g,b);var min=Math.min(r,g,b);var hue,saturation;var lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else{var delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}hsl.h=hue;hsl.s=saturation;hsl.l=lightness;return hsl;},getStyle:function getStyle(){return'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';},offsetHSL:function offsetHSL(h,s,l){var hsl=this.getHSL();hsl.h+=h;hsl.s+=s;hsl.l+=l;this.setHSL(hsl.h,hsl.s,hsl.l);return this;},add:function add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;},addColors:function addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;},addScalar:function addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this;},sub:function sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;},multiply:function multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;},multiplyScalar:function multiplyScalar(s){this.r*=s;this.g*=s;this.b*=s;return this;},lerp:function lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;},equals:function equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;},toJSON:function toJSON(){return this.getHex();}};var ColorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};/**
	 * @author alteredq / http://alteredqualia.com/
	 */function DataTexture(data,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={data:data,width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;}DataTexture.prototype=(0,_create2.default)(Texture.prototype);DataTexture.prototype.constructor=DataTexture;DataTexture.prototype.isDataTexture=true;/**
	 * Uniforms library for shared webgl shaders
	 */var UniformsLib$1={common:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},"map":{value:null},"mapUVTransformParams":{value:new Vector4(0,0,1,1)},"mapTexelTransformParams":{value:new Vector2(1,0)},"offsetRepeat":{value:new Vector4(0,0,1,1)},"specularMap":{value:null},"specularMapUVTransformParams":{value:new Vector4(0,0,1,1)},"specularMapTexelTransformParams":{value:new Vector2(1,0)},"alphaMap":{value:null},"alphaMapUVTransformParams":{value:new Vector4(0,0,1,1)},"alphaMapTexelTransformParams":{value:new Vector2(1,0)},ditheringScale:{value:1.0},envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1.0},refractionRatio:{value:0.98}},anisotropymap:{"anisotropy":{value:0.0},"anisotropyMap":{value:null},"anisotropyMapUVTransformParams":{value:new Vector4(0,0,1,1)},"anisotropyMapTexelTransformParams":{value:new Vector2(1,0)}},anisotropyrotationmap:{"anisotropyRotation":{value:0.0},"anisotropyRotationMap":{value:null},"anisotropyRotationMapUVTransformParams":{value:new Vector4(0,0,1,1)},"anisotropyRotationMapTexelTransformParams":{value:new Vector2(1,0)}},aomap:{"aoMap":{value:null},"aoMapUVTransformParams":{value:new Vector4(0,0,1,1)},"aoMapTexelTransformParams":{value:new Vector2(1,0)},"aoMapIntensity":{value:1}},lightmap:{"lightMap":{value:null},"lightMapUVTransformParams":{value:new Vector4(0,0,1,1)},"lightMapTexelTransformParams":{value:new Vector2(1,0)},"lightMapIntensity":{value:1}},emissivemap:{"emissiveMap":{value:null},"emissiveMapUVTransformParams":{value:new Vector4(0,0,1,1)},"emissiveMapTexelTransformParams":{value:new Vector2(1,0)}},bumpmap:{"bumpMap":{value:null},"bumpScale":{value:1},"bumpMapUVTransformParams":{value:new Vector4(0,0,1,1)},"bumpMapTexelTransformParams":{value:new Vector2(1,0)}},normalmap:{"normalMap":{value:null},"normalScale":{value:new Vector2(1,1)},// for backwards compatibility
"normalMapUVTransformParams":{value:new Vector4(0,0,1,1)},"normalMapTexelTransformParams":{value:new Vector2(1,0)}},displacementmap:{"displacementMap":{value:null},"displacementScale":{value:1},// for backwards compatibility
"displacementBias":{value:0},// for backwards compatibility
"displacementMapUVTransformParams":{value:new Vector4(0,0,1,1)},"displacementMapTexelTransformParams":{value:new Vector2(1,0)}},falloffmap:{"falloffMap":{value:null},"falloffMapUVTransformParams":{value:new Vector4(0,0,1,1)},"falloffMapTexelTransformParams":{value:new Vector2(1,0)}},falloffalphamap:{"falloffAlphaMap":{value:null},"falloffAlphaMapUVTransformParams":{value:new Vector4(0,0,1,1)},"falloffAlphaMapTexelTransformParams":{value:new Vector2(1,0)}},roughnessmap:{"roughnessMap":{value:null},"roughnessMapUVTransformParams":{value:new Vector4(0,0,1,1)},"roughnessMapTexelTransformParams":{value:new Vector2(1,0)}},metalnessmap:{"metalnessMap":{value:null},"metalnessMapUVTransformParams":{value:new Vector4(0,0,1,1)},"metalnessMapTexelTransformParams":{value:new Vector2(1,0)}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new Color(0xffffff)}},lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{},shadowSpreadAngle:{},shadowCameraParams:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraParams:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},offsetRepeat:{value:new Vector4(0,0,1,1)}}};/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */var ShaderLib={basic:{uniforms:UniformsUtils.merge([UniformsLib$1.common,UniformsLib$1.aomap,UniformsLib$1.lightmap,UniformsLib$1.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:UniformsUtils.merge([UniformsLib$1.common,UniformsLib$1.aomap,UniformsLib$1.lightmap,UniformsLib$1.emissivemap,UniformsLib$1.fog,UniformsLib$1.lights,{emissive:{value:new Color(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:UniformsUtils.merge([UniformsLib$1.common,UniformsLib$1.aomap,UniformsLib$1.lightmap,UniformsLib$1.emissivemap,UniformsLib$1.bumpmap,UniformsLib$1.normalmap,UniformsLib$1.displacementmap,UniformsLib$1.gradientmap,UniformsLib$1.fog,UniformsLib$1.lights,{emissive:{value:new Color(0x000000)},specular:{value:new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:UniformsUtils.merge([UniformsLib$1.common,UniformsLib$1.aomap,UniformsLib$1.lightmap,UniformsLib$1.emissivemap,UniformsLib$1.bumpmap,UniformsLib$1.normalmap,UniformsLib$1.displacementmap,UniformsLib$1.roughnessmap,UniformsLib$1.metalnessmap,UniformsLib$1.fog,UniformsLib$1.lights,{emissive:{value:new Color(0x000000)},roughness:{value:0.5},metalness:{value:0},envMapIntensity:{value:1// temporary
}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},points:{uniforms:UniformsUtils.merge([UniformsLib$1.points,UniformsLib$1.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:UniformsUtils.merge([UniformsLib$1.common,UniformsLib$1.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:UniformsUtils.merge([UniformsLib$1.common,UniformsLib$1.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:UniformsUtils.merge([UniformsLib$1.common,UniformsLib$1.bumpmap,UniformsLib$1.normalmap,UniformsLib$1.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.normal_vert,fragmentShader:ShaderChunk.normal_frag},/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1.0}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */equirect:{uniforms:{tEquirect:{value:null},tFlip:{value:-1}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:{lightPos:{value:new Vector3()}},vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag}};/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */ShaderLib.cubeEnv={uniforms:UniformsUtils.merge([UniformsLib$1.common,ShaderLib.standard.uniforms,{envMap:{value:null},envMapIntensity:{value:1.0},tFlip:{value:-1},opacity:{value:1.0},roughness:{value:0.0}}]),vertexShader:ShaderChunk.cubeEnv_vert,fragmentShader:ShaderChunk.cubeEnv_frag};ShaderLib.physical={uniforms:UniformsUtils.merge([ShaderLib.standard.uniforms,UniformsLib$1.falloffmap,UniformsLib$1.falloffalphamap,UniformsLib$1.anisotropymap,UniformsLib$1.anisotropyrotationmap,{falloffDiffuse:{value:new Color(0xffffff)},falloffOpacity:{value:0},clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};/**
	 * @author bhouston / http://clara.io
	 */function Box2(min,max){this.min=min!==undefined?min:new Vector2(+Infinity,+Infinity);this.max=max!==undefined?max:new Vector2(-Infinity,-Infinity);}Box2.prototype={constructor:Box2,set:function set(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromPoints:function setFromPoints(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function(){var v1=new Vector2();return function setFromCenterAndSize(center,size){var halfSize=v1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;};}(),clone:function clone(){return new this.constructor().copy(this);},copy:function copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function makeEmpty(){this.min.x=this.min.y=+Infinity;this.max.x=this.max.y=-Infinity;return this;},isEmpty:function isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y;},getCenter:function getCenter(optionalTarget){var result=optionalTarget||new Vector2();return this.isEmpty()?result.set(0,0):result.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function getSize(optionalTarget){var result=optionalTarget||new Vector2();return this.isEmpty()?result.set(0,0):result.subVectors(this.max,this.min);},expandByPoint:function expandByPoint(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},containsPoint:function containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y?false:true;},containsBox:function containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y;},getParameter:function getParameter(point,optionalTarget){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
var result=optionalTarget||new Vector2();return result.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y));},intersectsBox:function intersectsBox(box){// using 6 splitting planes to rule out intersections.
return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y?false:true;},clampPoint:function clampPoint(point,optionalTarget){var result=optionalTarget||new Vector2();return result.copy(point).clamp(this.min,this.max);},distanceToPoint:function(){var v1=new Vector2();return function distanceToPoint(point){var clampedPoint=v1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();};}(),intersect:function intersect(box){this.min.max(box.min);this.max.min(box.max);return this;},union:function union(box){this.min.min(box.min);this.max.max(box.max);return this;},translate:function translate(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}};/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */function LensFlarePlugin(renderer,flares){var gl=renderer.context;var state=renderer.state;var vertexBuffer,elementBuffer;var shader,program,attributes,uniforms;var tempTexture,occlusionTexture;function init(){var vertices=new Float32Array([-1,-1,0,0,1,-1,1,0,1,1,1,1,-1,1,0,1]);var faces=new Uint16Array([0,1,2,0,2,3]);// buffers
vertexBuffer=gl.createBuffer();elementBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,faces,gl.STATIC_DRAW);// textures
tempTexture=gl.createTexture();occlusionTexture=gl.createTexture();state.bindTexture(gl.TEXTURE_2D,tempTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGB,16,16,0,gl.RGB,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);state.bindTexture(gl.TEXTURE_2D,occlusionTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,16,16,0,gl.RGBA,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);shader={vertexShader:["uniform lowp int renderType;","uniform vec3 screenPosition;","uniform vec2 scale;","uniform float rotation;","uniform sampler2D occlusionMap;","attribute vec2 position;","attribute vec2 uv;","varying vec2 vUV;","varying float vVisibility;","void main() {","vUV = uv;","vec2 pos = position;","if ( renderType == 2 ) {","vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );","visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );","visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );","visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );","visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );","visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );","visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );","visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );","visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );","vVisibility =        visibility.r / 9.0;","vVisibility *= 1.0 - visibility.g / 9.0;","vVisibility *=       visibility.b / 9.0;","vVisibility *= 1.0 - visibility.a / 9.0;","pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;","pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;","}","gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );","}"].join("\n"),fragmentShader:["uniform lowp int renderType;","uniform sampler2D map;","uniform float opacity;","uniform vec3 color;","varying vec2 vUV;","varying float vVisibility;","void main() {",// pink square
"if ( renderType == 0 ) {","gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",// restore
"} else if ( renderType == 1 ) {","gl_FragColor = texture2D( map, vUV );",// flare
"} else {","vec4 texture = texture2D( map, vUV );","texture.a *= opacity * vVisibility;","gl_FragColor = texture;","gl_FragColor.rgb *= color;","}","}"].join("\n")};program=createProgram(shader);attributes={vertex:gl.getAttribLocation(program,"position"),uv:gl.getAttribLocation(program,"uv")};uniforms={renderType:gl.getUniformLocation(program,"renderType"),map:gl.getUniformLocation(program,"map"),occlusionMap:gl.getUniformLocation(program,"occlusionMap"),opacity:gl.getUniformLocation(program,"opacity"),color:gl.getUniformLocation(program,"color"),scale:gl.getUniformLocation(program,"scale"),rotation:gl.getUniformLocation(program,"rotation"),screenPosition:gl.getUniformLocation(program,"screenPosition")};}/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */this.render=function(scene,camera,viewport){if(flares.length===0)return;var tempPosition=new Vector3();var invAspect=viewport.w/viewport.z,halfViewportWidth=viewport.z*0.5,halfViewportHeight=viewport.w*0.5;var size=16/viewport.w,scale=new Vector2(size*invAspect,size);var screenPosition=new Vector3(1,1,0),screenPositionPixels=new Vector2(1,1);var validArea=new Box2();validArea.min.set(viewport.x,viewport.y);validArea.max.set(viewport.x+(viewport.z-16),viewport.y+(viewport.w-16));if(program===undefined){init();}gl.useProgram(program);state.initAttributes();state.enableAttribute(attributes.vertex);state.enableAttribute(attributes.uv);state.disableUnusedAttributes();// loop through all lens flares to update their occlusion and positions
// setup gl and common used attribs/uniforms
gl.uniform1i(uniforms.occlusionMap,0);gl.uniform1i(uniforms.map,1);gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.vertexAttribPointer(attributes.vertex,2,gl.FLOAT,false,2*8,0);gl.vertexAttribPointer(attributes.uv,2,gl.FLOAT,false,2*8,8);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);state.disable(gl.CULL_FACE);state.setDepthWrite(false);for(var i=0,l=flares.length;i<l;i++){size=16/viewport.w;scale.set(size*invAspect,size);// calc object screen position
var flare=flares[i];tempPosition.set(flare.matrixWorld.elements[12],flare.matrixWorld.elements[13],flare.matrixWorld.elements[14]);tempPosition.applyMatrix4(camera.matrixWorldInverse);tempPosition.applyMatrix4(camera.projectionMatrix);// setup arrays for gl programs
screenPosition.copy(tempPosition);// horizontal and vertical coordinate of the lower left corner of the pixels to copy
screenPositionPixels.x=viewport.x+screenPosition.x*halfViewportWidth+halfViewportWidth-8;screenPositionPixels.y=viewport.y+screenPosition.y*halfViewportHeight+halfViewportHeight-8;// screen cull
if(validArea.containsPoint(screenPositionPixels)===true){// save current RGB to temp texture
state.activeTexture(gl.TEXTURE0);state.bindTexture(gl.TEXTURE_2D,null);state.activeTexture(gl.TEXTURE1);state.bindTexture(gl.TEXTURE_2D,tempTexture);gl.copyTexImage2D(gl.TEXTURE_2D,0,gl.RGB,screenPositionPixels.x,screenPositionPixels.y,16,16,0);// render pink quad
gl.uniform1i(uniforms.renderType,0);gl.uniform2f(uniforms.scale,scale.x,scale.y);gl.uniform3f(uniforms.screenPosition,screenPosition.x,screenPosition.y,screenPosition.z);state.disable(gl.BLEND);state.enable(gl.DEPTH_TEST);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);// copy result to occlusionMap
state.activeTexture(gl.TEXTURE0);state.bindTexture(gl.TEXTURE_2D,occlusionTexture);gl.copyTexImage2D(gl.TEXTURE_2D,0,gl.RGBA,screenPositionPixels.x,screenPositionPixels.y,16,16,0);// restore graphics
gl.uniform1i(uniforms.renderType,1);state.disable(gl.DEPTH_TEST);state.activeTexture(gl.TEXTURE1);state.bindTexture(gl.TEXTURE_2D,tempTexture);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);// update object positions
flare.positionScreen.copy(screenPosition);if(flare.customUpdateCallback){flare.customUpdateCallback(flare);}else{flare.updateLensFlares();}// render flares
gl.uniform1i(uniforms.renderType,2);state.enable(gl.BLEND);for(var j=0,jl=flare.lensFlares.length;j<jl;j++){var sprite=flare.lensFlares[j];if(sprite.opacity>0.001&&sprite.scale>0.001){screenPosition.x=sprite.x;screenPosition.y=sprite.y;screenPosition.z=sprite.z;size=sprite.size*sprite.scale/viewport.w;scale.x=size*invAspect;scale.y=size;gl.uniform3f(uniforms.screenPosition,screenPosition.x,screenPosition.y,screenPosition.z);gl.uniform2f(uniforms.scale,scale.x,scale.y);gl.uniform1f(uniforms.rotation,sprite.rotation);gl.uniform1f(uniforms.opacity,sprite.opacity);gl.uniform3f(uniforms.color,sprite.color.r,sprite.color.g,sprite.color.b);state.setBlending(sprite.blending,sprite.blendEquation,sprite.blendSrc,sprite.blendDst);renderer.setTexture2D(sprite.texture,1);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);}}}}// restore gl
state.enable(gl.CULL_FACE);state.enable(gl.DEPTH_TEST);state.setDepthWrite(true);renderer.resetGLState();};function createProgram(shader){var program=gl.createProgram();var fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);var vertexShader=gl.createShader(gl.VERTEX_SHADER);var prefix="precision "+renderer.getPrecision()+" float;\n";gl.shaderSource(fragmentShader,prefix+shader.fragmentShader);gl.shaderSource(vertexShader,prefix+shader.vertexShader);gl.compileShader(fragmentShader);gl.compileShader(vertexShader);gl.attachShader(program,fragmentShader);gl.attachShader(program,vertexShader);gl.linkProgram(program);return program;}}/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */function SpritePlugin(renderer,sprites){var gl=renderer.context;var state=renderer.state;var vertexBuffer,elementBuffer;var program,attributes,uniforms;var texture;// decompose matrixWorld
var spritePosition=new Vector3();var spriteRotation=new Quaternion();var spriteScale=new Vector3();function init(){var vertices=new Float32Array([-0.5,-0.5,0,0,0.5,-0.5,1,0,0.5,0.5,1,1,-0.5,0.5,0,1]);var faces=new Uint16Array([0,1,2,0,2,3]);vertexBuffer=gl.createBuffer();elementBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,faces,gl.STATIC_DRAW);program=createProgram();attributes={position:gl.getAttribLocation(program,'position'),uv:gl.getAttribLocation(program,'uv')};uniforms={uvOffset:gl.getUniformLocation(program,'uvOffset'),uvScale:gl.getUniformLocation(program,'uvScale'),rotation:gl.getUniformLocation(program,'rotation'),scale:gl.getUniformLocation(program,'scale'),color:gl.getUniformLocation(program,'color'),map:gl.getUniformLocation(program,'map'),opacity:gl.getUniformLocation(program,'opacity'),modelViewMatrix:gl.getUniformLocation(program,'modelViewMatrix'),projectionMatrix:gl.getUniformLocation(program,'projectionMatrix'),fogType:gl.getUniformLocation(program,'fogType'),fogDensity:gl.getUniformLocation(program,'fogDensity'),fogNear:gl.getUniformLocation(program,'fogNear'),fogFar:gl.getUniformLocation(program,'fogFar'),fogColor:gl.getUniformLocation(program,'fogColor'),alphaTest:gl.getUniformLocation(program,'alphaTest')};var canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=8;canvas.height=8;var context=canvas.getContext('2d');context.fillStyle='white';context.fillRect(0,0,8,8);texture=new Texture(canvas);texture.needsUpdate=true;}this.render=function(scene,camera){if(sprites.length===0)return;// setup gl
if(program===undefined){init();}gl.useProgram(program);state.initAttributes();state.enableAttribute(attributes.position);state.enableAttribute(attributes.uv);state.disableUnusedAttributes();state.disable(gl.CULL_FACE);state.enable(gl.BLEND);gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.vertexAttribPointer(attributes.position,2,gl.FLOAT,false,2*8,0);gl.vertexAttribPointer(attributes.uv,2,gl.FLOAT,false,2*8,8);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.uniformMatrix4fv(uniforms.projectionMatrix,false,camera.projectionMatrix.elements);state.activeTexture(gl.TEXTURE0);gl.uniform1i(uniforms.map,0);var oldFogType=0;var sceneFogType=0;var fog=scene.fog;if(fog){gl.uniform3f(uniforms.fogColor,fog.color.r,fog.color.g,fog.color.b);if(fog.isFog){gl.uniform1f(uniforms.fogNear,fog.near);gl.uniform1f(uniforms.fogFar,fog.far);gl.uniform1i(uniforms.fogType,1);oldFogType=1;sceneFogType=1;}else if(fog.isFogExp2){gl.uniform1f(uniforms.fogDensity,fog.density);gl.uniform1i(uniforms.fogType,2);oldFogType=2;sceneFogType=2;}}else{gl.uniform1i(uniforms.fogType,0);oldFogType=0;sceneFogType=0;}// update positions and sort
for(var i=0,l=sprites.length;i<l;i++){var sprite=sprites[i];sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,sprite.matrixWorld);sprite.z=-sprite.modelViewMatrix.elements[14];}sprites.sort(painterSortStable);// render all sprites
var scale=[];for(var i=0,l=sprites.length;i<l;i++){var sprite=sprites[i];var material=sprite.material;if(material.visible===false)continue;gl.uniform1f(uniforms.alphaTest,material.alphaTest);gl.uniformMatrix4fv(uniforms.modelViewMatrix,false,sprite.modelViewMatrix.elements);sprite.matrixWorld.decompose(spritePosition,spriteRotation,spriteScale);scale[0]=spriteScale.x;scale[1]=spriteScale.y;var fogType=0;if(scene.fog&&material.fog){fogType=sceneFogType;}if(oldFogType!==fogType){gl.uniform1i(uniforms.fogType,fogType);oldFogType=fogType;}if(material.map!==null){gl.uniform2f(uniforms.uvOffset,material.map.offset.x,material.map.offset.y);gl.uniform2f(uniforms.uvScale,material.map.repeat.x,material.map.repeat.y);}else{gl.uniform2f(uniforms.uvOffset,0,0);gl.uniform2f(uniforms.uvScale,1,1);}gl.uniform1f(uniforms.opacity,material.opacity);gl.uniform3f(uniforms.color,material.color.r,material.color.g,material.color.b);gl.uniform1f(uniforms.rotation,material.rotation);gl.uniform2fv(uniforms.scale,scale);state.setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst);state.setDepthTest(material.depthTest);state.setDepthWrite(material.depthWrite);if(material.map){renderer.setTexture2D(material.map,0);}else{renderer.setTexture2D(texture,0);}gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);}// restore gl
state.enable(gl.CULL_FACE);renderer.resetGLState();};function createProgram(){var program=gl.createProgram();var vertexShader=gl.createShader(gl.VERTEX_SHADER);var fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(vertexShader,['precision '+renderer.getPrecision()+' float;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform float rotation;','uniform vec2 scale;','uniform vec2 uvOffset;','uniform vec2 uvScale;','attribute vec2 position;','attribute vec2 uv;','varying vec2 vUV;','void main() {','vUV = uvOffset + uv * uvScale;','vec2 alignedPosition = position * scale;','vec2 rotatedPosition;','rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;','rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;','vec4 finalPosition;','finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );','finalPosition.xy += rotatedPosition;','finalPosition = projectionMatrix * finalPosition;','gl_Position = finalPosition;','}'].join('\n'));gl.shaderSource(fragmentShader,['precision '+renderer.getPrecision()+' float;','uniform vec3 color;','uniform sampler2D map;','uniform float opacity;','uniform int fogType;','uniform vec3 fogColor;','uniform float fogDensity;','uniform float fogNear;','uniform float fogFar;','uniform float alphaTest;','varying vec2 vUV;','void main() {','vec4 texture = texture2D( map, vUV );','if ( texture.a < alphaTest ) discard;','gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );','if ( fogType > 0 ) {','float depth = gl_FragCoord.z / gl_FragCoord.w;','float fogFactor = 0.0;','if ( fogType == 1 ) {','fogFactor = smoothstep( fogNear, fogFar, depth );','} else {','const float LOG2 = 1.442695;','fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );','fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );','}','gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );','}','}'].join('\n'));gl.compileShader(vertexShader);gl.compileShader(fragmentShader);gl.attachShader(program,vertexShader);gl.attachShader(program,fragmentShader);gl.linkProgram(program);return program;}function painterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else{return b.id-a.id;}}}/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */var materialId=0;function Material(){Object.defineProperty(this,'id',{value:materialId++});this.uuid=_Math.generateUUID();this.name='';this.type='Material';this.fog=true;this.lights=true;this.blending=NormalBlending;this.side=FrontSide;this.shading=SmoothShading;// THREE.FlatShading, THREE.SmoothShading
this.vertexColors=NoColors;// THREE.NoColors, THREE.VertexColors, THREE.FaceColors
this.opacity=1;this.transparent=false;this.blendSrc=SrcAlphaFactor;this.blendDst=OneMinusSrcAlphaFactor;this.blendEquation=AddEquation;this.blendSrcAlpha=null;this.blendDstAlpha=null;this.blendEquationAlpha=null;this.depthFunc=LessEqualDepth;this.depthTest=true;this.depthWrite=true;this.clippingPlanes=null;this.clipIntersection=false;this.clipShadows=false;this.colorWrite=true;this.precision=null;// override the renderer's default precision for this material
this.polygonOffset=false;this.polygonOffsetFactor=0;this.polygonOffsetUnits=0;this.alphaTest=0;this.premultipliedAlpha=false;this.overdraw=0;// Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
this.visible=true;this._needsUpdate=true;this.version=0;}Material.prototype={constructor:Material,isMaterial:true,get needsUpdate(){return this._needsUpdate;},set needsUpdate(value){if(value===true)this.update();this._needsUpdate=value;this.version++;},setValues:function setValues(values){if(values===undefined)return;for(var key in values){var newValue=values[key];if(newValue===undefined){console.warn("THREE.Material: '"+key+"' parameter is undefined.");continue;}var currentValue=this[key];if(currentValue===undefined){console.warn("THREE."+this.type+": '"+key+"' is not a property of this material.");continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else if(key==='overdraw'){// ensure overdraw is backwards-compatible with legacy boolean type
this[key]=Number(newValue);}else{this[key]=newValue;}}},toJSON:function toJSON(meta){var isRoot=meta===undefined;if(isRoot){meta={textures:{},images:{}};}var data={metadata:{version:4.4,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearCoat!==undefined)data.clearCoat=this.clearCoat;if(this.clearCoatRoughness!==undefined)data.clearCoatRoughness=this.clearCoatRoughness;if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture)data.lightMap=this.lightMap.toJSON(meta).uuid;if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;data.reflectivity=this.reflectivity;// Scale behind envMap
}if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.size!==undefined)data.size=this.size;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.shading!==SmoothShading)data.shading=this.shading;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors!==NoColors)data.vertexColors=this.vertexColors;if(this.opacity<1)data.opacity=this.opacity;if(this.transparent===true)data.transparent=this.transparent;data.depthFunc=this.depthFunc;data.depthTest=this.depthTest;data.depthWrite=this.depthWrite;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;if(this.wireframe===true)data.wireframe=this.wireframe;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;data.skinning=this.skinning;data.morphTargets=this.morphTargets;// TODO: Copied from Object3D.toJSON
function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}if(isRoot){var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.name=source.name;this.fog=source.fog;this.lights=source.lights;this.blending=source.blending;this.side=source.side;this.shading=source.shading;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.alphaTest=source.alphaTest;this.premultipliedAlpha=source.premultipliedAlpha;this.overdraw=source.overdraw;this.visible=source.visible;this.clipShadows=source.clipShadows;this.clipIntersection=source.clipIntersection;var srcPlanes=source.clippingPlanes,dstPlanes=null;if(srcPlanes!==null){var n=srcPlanes.length;dstPlanes=new Array(n);for(var i=0;i!==n;++i){dstPlanes[i]=srcPlanes[i].clone();}}this.clippingPlanes=dstPlanes;return this;},update:function update(){this.dispatchEvent({type:'update'});},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}};(0,_assign2.default)(Material.prototype,EventDispatcher.prototype);/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */function ShaderMaterial(parameters){Material.call(this);this.type='ShaderMaterial';this.defines={};this.uniforms={};this.vertexShader='void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';this.fragmentShader='void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';this.linewidth=1;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;// set to use scene fog
this.lights=false;// set to use scene lights
this.clipping=false;// set to use user-defined clipping planes
this.skinning=false;// set to use skinning attribute streams
this.morphTargets=false;// set to use morph targets
this.morphNormals=false;// set to use morph normals
this.extensions={derivatives:false,// set to use derivatives
fragDepth:false,// set to use fragment depth values
drawBuffers:false,// set to use draw buffers
shaderTextureLOD:false// set to use shader texture LOD
};// When rendered geometry doesn't include these attributes but the material does,
// use these default values in WebGL. This avoids errors when buffer data is missing.
this.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv2':[0,0]};this.index0AttributeName=undefined;if(parameters!==undefined){if(parameters.attributes!==undefined){console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');}this.setValues(parameters);}}ShaderMaterial.prototype=(0,_create2.default)(Material.prototype);ShaderMaterial.prototype.constructor=ShaderMaterial;ShaderMaterial.prototype.isShaderMaterial=true;ShaderMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=UniformsUtils.clone(source.uniforms);this.defines=source.defines;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.lights=source.lights;this.clipping=source.clipping;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;this.extensions=source.extensions;return this;};ShaderMaterial.prototype.toJSON=function(meta){var data=Material.prototype.toJSON.call(this,meta);data.uniforms=this.uniforms;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;return data;};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */function MeshDepthMaterial(parameters){Material.call(this);this.type='MeshDepthMaterial';this.depthPacking=BasicDepthPacking;this.skinning=false;this.morphTargets=false;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.lights=false;// far clipping plane in both RGBA and Basic encoding
this.clearColor=new Color(1.0,1.0,1.0);this.clearAlpha=1.0;this.setValues(parameters);}MeshDepthMaterial.prototype=(0,_create2.default)(Material.prototype);MeshDepthMaterial.prototype.constructor=MeshDepthMaterial;MeshDepthMaterial.prototype.isMeshDepthMaterial=true;MeshDepthMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.depthPacking=source.depthPacking;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.clearColor=source.clearColor;this.clearAlpha=source.clearAlpha;return this;};/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */function Box3(min,max){this.min=min!==undefined?min:new Vector3(+Infinity,+Infinity,+Infinity);this.max=max!==undefined?max:new Vector3(-Infinity,-Infinity,-Infinity);}Box3.prototype={constructor:Box3,isBox3:true,set:function set(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromArray:function setFromArray(array){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=array.length;i<l;i+=3){var x=array[i];var y=array[i+1];var z=array[i+2];if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);},setFromBufferAttribute:function setFromBufferAttribute(attribute){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=attribute.count;i<l;i++){var x=attribute.getX(i);var y=attribute.getY(i);var z=attribute.getZ(i);if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);},setFromPoints:function setFromPoints(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function(){var v1=new Vector3();return function setFromCenterAndSize(center,size){var halfSize=v1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;};}(),setFromObject:function(){// Computes the world-axis-aligned bounding box of an object (including its children),
// accounting for both the object's, and children's, world transforms
var v1=new Vector3();return function setFromObject(object){var scope=this;object.updateMatrixWorld(true);this.makeEmpty();object.traverse(function(node){var i,l;var geometry=node.geometry;if(geometry!==undefined){if(geometry.isGeometry){var vertices=geometry.vertices;for(i=0,l=vertices.length;i<l;i++){v1.copy(vertices[i]);v1.applyMatrix4(node.matrixWorld);scope.expandByPoint(v1);}}else if(geometry.isBufferGeometry){var attribute=geometry.attributes.position;if(attribute!==undefined){for(i=0,l=attribute.count;i<l;i++){v1.fromBufferAttribute(attribute,i).applyMatrix4(node.matrixWorld);scope.expandByPoint(v1);}}}}});return this;};}(),clone:function clone(){return new this.constructor().copy(this);},copy:function copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;},isEmpty:function isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;},getCenter:function getCenter(optionalTarget){var result=optionalTarget||new Vector3();return this.isEmpty()?result.set(0,0,0):result.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function getSize(optionalTarget){var result=optionalTarget||new Vector3();return this.isEmpty()?result.set(0,0,0):result.subVectors(this.max,this.min);},expandByPoint:function expandByPoint(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},containsPoint:function containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?false:true;},containsBox:function containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;},getParameter:function getParameter(point,optionalTarget){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
var result=optionalTarget||new Vector3();return result.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));},intersectsBox:function intersectsBox(box){// using 6 splitting planes to rule out intersections.
return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?false:true;},intersectsSphere:function(){var closestPoint;return function intersectsSphere(sphere){if(closestPoint===undefined)closestPoint=new Vector3();// Find the point on the AABB closest to the sphere center.
this.clampPoint(sphere.center,closestPoint);// If that point is inside the sphere, the AABB and sphere intersect.
return closestPoint.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;};}(),intersectsPlane:function intersectsPlane(plane){// We compute the minimum and maximum dot product values. If those values
// are on the same side (back or front) of the plane, then there is no intersection.
var min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else{min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else{min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else{min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=-plane.constant&&max>=-plane.constant;},clampPoint:function clampPoint(point,optionalTarget){var result=optionalTarget||new Vector3();return result.copy(point).clamp(this.min,this.max);},distanceToPoint:function(){var v1=new Vector3();return function distanceToPoint(point){var clampedPoint=v1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();};}(),getBoundingSphere:function(){var v1=new Vector3();return function getBoundingSphere(optionalTarget){var result=optionalTarget||new Sphere();this.getCenter(result.center);result.radius=this.getSize(v1).length()*0.5;return result;};}(),intersect:function intersect(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
if(this.isEmpty())this.makeEmpty();return this;},union:function union(box){this.min.min(box.min);this.max.max(box.max);return this;},applyMatrix4:function(){var points=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];return function applyMatrix4(matrix){// transform of empty box is an empty box.
if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
this.setFromPoints(points);return this;};}(),translate:function translate(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}};/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */function Sphere(center,radius){this.center=center!==undefined?center:new Vector3();this.radius=radius!==undefined?radius:0;}Sphere.prototype={constructor:Sphere,set:function set(center,radius){this.center.copy(center);this.radius=radius;return this;},setFromPoints:function(){var box=new Box3();return function setFromPoints(points,optionalCenter){var center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else{box.setFromPoints(points).getCenter(center);}var maxRadiusSq=0;for(var i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));}this.radius=Math.sqrt(maxRadiusSq);return this;};}(),clone:function clone(){return new this.constructor().copy(this);},copy:function copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;},empty:function empty(){return this.radius<=0;},containsPoint:function containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;},distanceToPoint:function distanceToPoint(point){return point.distanceTo(this.center)-this.radius;},intersectsSphere:function intersectsSphere(sphere){var radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;},intersectsBox:function intersectsBox(box){return box.intersectsSphere(this);},intersectsPlane:function intersectsPlane(plane){// We use the following equation to compute the signed distance from
// the center of the sphere to the plane.
//
// distance = q * n - d
//
// If this distance is greater than the radius of the sphere,
// then there is no intersection.
return Math.abs(this.center.dot(plane.normal)-plane.constant)<=this.radius;},clampPoint:function clampPoint(point,optionalTarget){var deltaLengthSq=this.center.distanceToSquared(point);var result=optionalTarget||new Vector3();result.copy(point);if(deltaLengthSq>this.radius*this.radius){result.sub(this.center).normalize();result.multiplyScalar(this.radius).add(this.center);}return result;},getBoundingBox:function getBoundingBox(optionalTarget){var box=optionalTarget||new Box3();box.set(this.center,this.center);box.expandByScalar(this.radius);return box;},applyMatrix4:function applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;},translate:function translate(offset){this.center.add(offset);return this;},equals:function equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}};/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */function Matrix3(){this.elements=new Float32Array([1,0,0,0,1,0,0,0,1]);if(arguments.length>0){console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');}}Matrix3.prototype={constructor:Matrix3,isMatrix3:true,set:function set(n11,n12,n13,n21,n22,n23,n31,n32,n33){var te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;},identity:function identity(){this.set(1,0,0,0,1,0,0,0,1);return this;},clone:function clone(){return new this.constructor().fromArray(this.elements);},copy:function copy(m){var me=m.elements;this.set(me[0],me[3],me[6],me[1],me[4],me[7],me[2],me[5],me[8]);return this;},setFromMatrix4:function setFromMatrix4(m){var me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;},applyToBufferAttribute:function(){var v1;return function applyToBufferAttribute(attribute){if(v1===undefined)v1=new Vector3();for(var i=0,l=attribute.count;i<l;i++){v1.x=attribute.getX(i);v1.y=attribute.getY(i);v1.z=attribute.getZ(i);v1.applyMatrix3(this);attribute.setXYZ(i,v1.x,v1.y,v1.z);}return attribute;};}(),multiplyScalar:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;},determinant:function determinant(){var te=this.elements;var a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;},getInverse:function getInverse(matrix,throwOnDegenerate){if(matrix&&matrix.isMatrix4){console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");}var me=matrix.elements,te=this.elements,n11=me[0],n21=me[1],n31=me[2],n12=me[3],n22=me[4],n32=me[5],n13=me[6],n23=me[7],n33=me[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0){var msg="THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";if(throwOnDegenerate===true){throw new Error(msg);}else{console.warn(msg);}return this.identity();}var detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;},transpose:function transpose(){var tmp,m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;},getNormalMatrix:function getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).getInverse(this).transpose();},transposeIntoArray:function transposeIntoArray(r){var m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;for(var i=0;i<9;i++){this.elements[i]=array[i+offset];}return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}};/**
	 * @author bhouston / http://clara.io
	 */function Plane(normal,constant){this.normal=normal!==undefined?normal:new Vector3(1,0,0);this.constant=constant!==undefined?constant:0;}Plane.prototype={constructor:Plane,set:function set(normal,constant){this.normal.copy(normal);this.constant=constant;return this;},setComponents:function setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;},setFromNormalAndCoplanarPoint:function setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);// must be this.normal, not normal, as this.normal is normalized
return this;},setFromCoplanarPoints:function(){var v1=new Vector3();var v2=new Vector3();return function setFromCoplanarPoints(a,b,c){var normal=v1.subVectors(c,b).cross(v2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
this.setFromNormalAndCoplanarPoint(normal,a);return this;};}(),clone:function clone(){return new this.constructor().copy(this);},copy:function copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;},normalize:function normalize(){// Note: will lead to a divide by zero if the plane is invalid.
var inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;},negate:function negate(){this.constant*=-1;this.normal.negate();return this;},distanceToPoint:function distanceToPoint(point){return this.normal.dot(point)+this.constant;},distanceToSphere:function distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;},projectPoint:function projectPoint(point,optionalTarget){return this.orthoPoint(point,optionalTarget).sub(point).negate();},orthoPoint:function orthoPoint(point,optionalTarget){var perpendicularMagnitude=this.distanceToPoint(point);var result=optionalTarget||new Vector3();return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);},intersectLine:function(){var v1=new Vector3();return function intersectLine(line,optionalTarget){var result=optionalTarget||new Vector3();var direction=line.delta(v1);var denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
if(this.distanceToPoint(line.start)===0){return result.copy(line.start);}// Unsure if this is the correct method to handle this case.
return undefined;}var t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return undefined;}return result.copy(direction).multiplyScalar(t).add(line.start);};}(),intersectsLine:function intersectsLine(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
var startSign=this.distanceToPoint(line.start);var endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;},intersectsBox:function intersectsBox(box){return box.intersectsPlane(this);},intersectsSphere:function intersectsSphere(sphere){return sphere.intersectsPlane(this);},coplanarPoint:function coplanarPoint(optionalTarget){var result=optionalTarget||new Vector3();return result.copy(this.normal).multiplyScalar(-this.constant);},applyMatrix4:function(){var v1=new Vector3();var m1=new Matrix3();return function applyMatrix4(matrix,optionalNormalMatrix){var referencePoint=this.coplanarPoint(v1).applyMatrix4(matrix);// transform normal based on theory here:
// http://www.songho.ca/opengl/gl_normaltransform.html
var normalMatrix=optionalNormalMatrix||m1.getNormalMatrix(matrix);var normal=this.normal.applyMatrix3(normalMatrix).normalize();// recalculate constant (like in setFromNormalAndCoplanarPoint)
this.constant=-referencePoint.dot(normal);return this;};}(),translate:function translate(offset){this.constant=this.constant-offset.dot(this.normal);return this;},equals:function equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */function Frustum(p0,p1,p2,p3,p4,p5){this.planes=[p0!==undefined?p0:new Plane(),p1!==undefined?p1:new Plane(),p2!==undefined?p2:new Plane(),p3!==undefined?p3:new Plane(),p4!==undefined?p4:new Plane(),p5!==undefined?p5:new Plane()];}Frustum.prototype={constructor:Frustum,set:function set(p0,p1,p2,p3,p4,p5){var planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(frustum){var planes=this.planes;for(var i=0;i<6;i++){planes[i].copy(frustum.planes[i]);}return this;},setFromMatrix:function setFromMatrix(m){var planes=this.planes;var me=m.elements;var me0=me[0],me1=me[1],me2=me[2],me3=me[3];var me4=me[4],me5=me[5],me6=me[6],me7=me[7];var me8=me[8],me9=me[9],me10=me[10],me11=me[11];var me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();return this;},intersectsObject:function(){var sphere=new Sphere();return function intersectsObject(object){var geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(sphere);};}(),intersectsSprite:function(){var sphere=new Sphere();return function intersectsSprite(sprite){sphere.center.set(0,0,0);sphere.radius=0.7071067811865476;sphere.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(sphere);};}(),intersectsSphere:function intersectsSphere(sphere){var planes=this.planes;var center=sphere.center;var negRadius=-sphere.radius;for(var i=0;i<6;i++){var distance=planes[i].distanceToPoint(center);if(distance<negRadius){return false;}}return true;},intersectsBox:function(){var p1=new Vector3(),p2=new Vector3();return function intersectsBox(box){var planes=this.planes;for(var i=0;i<6;i++){var plane=planes[i];p1.x=plane.normal.x>0?box.min.x:box.max.x;p2.x=plane.normal.x>0?box.max.x:box.min.x;p1.y=plane.normal.y>0?box.min.y:box.max.y;p2.y=plane.normal.y>0?box.max.y:box.min.y;p1.z=plane.normal.z>0?box.min.z:box.max.z;p2.z=plane.normal.z>0?box.max.z:box.min.z;var d1=plane.distanceToPoint(p1);var d2=plane.distanceToPoint(p2);// if both outside plane, no intersection
if(d1<0&&d2<0){return false;}}return true;};}(),containsPoint:function containsPoint(point){var planes=this.planes;for(var i=0;i<6;i++){if(planes[i].distanceToPoint(point)<0){return false;}}return true;}};/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLShadowMap(_renderer,_lights,_objects,capabilities){var _gl=_renderer.context,_state=_renderer.state,_frustum=new Frustum(),_projScreenMatrix=new Matrix4(),_lightShadows=_lights.shadows,_shadowMapSize=new Vector2(),_maxShadowMapSize=new Vector2(capabilities.maxTextureSize,capabilities.maxTextureSize),_lookTarget=new Vector3(),_lightPositionWorld=new Vector3(),_renderList=[],_MorphingFlag=1,_SkinningFlag=2,_NumberOfMaterialVariants=(_MorphingFlag|_SkinningFlag)+1,_depthMaterials=new Array(_NumberOfMaterialVariants),_distanceMaterials=new Array(_NumberOfMaterialVariants),_materialCache={};var cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];var cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];var cube2DViewPorts=[new Vector4(),new Vector4(),new Vector4(),new Vector4(),new Vector4(),new Vector4()];// init
var depthMaterialTemplate=new MeshDepthMaterial();depthMaterialTemplate.depthPacking=RGBADepthPacking;depthMaterialTemplate.clipping=true;var distanceShader=ShaderLib["distanceRGBA"];var distanceUniforms=UniformsUtils.clone(distanceShader.uniforms);for(var i=0;i!==_NumberOfMaterialVariants;++i){var useMorphing=(i&_MorphingFlag)!==0;var useSkinning=(i&_SkinningFlag)!==0;var depthMaterial=depthMaterialTemplate.clone();depthMaterial.morphTargets=useMorphing;depthMaterial.skinning=useSkinning;_depthMaterials[i]=depthMaterial;var distanceMaterial=new ShaderMaterial({defines:{'USE_SHADOWMAP':''},uniforms:distanceUniforms,vertexShader:distanceShader.vertexShader,fragmentShader:distanceShader.fragmentShader,morphTargets:useMorphing,skinning:useSkinning,clipping:true});_distanceMaterials[i]=distanceMaterial;}//
var scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;this.renderReverseSided=true;this.renderSingleSided=true;this.render=function(scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(_lightShadows.length===0)return;// Set GL state for depth map.
_state.buffers.color.setClear(1,1,1,1);_state.disable(_gl.BLEND);_state.setDepthTest(true);_state.setScissorTest(false);// render depth map
var faceCount,isPointLight;for(var i=0,il=_lightShadows.length;i<il;i++){var light=_lightShadows[i];var shadow=light.shadow;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}var shadowCamera=shadow.camera;_shadowMapSize.copy(shadow.mapSize);_shadowMapSize.min(_maxShadowMapSize);if(light&&light.isPointLight){faceCount=6;isPointLight=true;var vpWidth=_shadowMapSize.x;var vpHeight=_shadowMapSize.y;// These viewports map a cube-map onto a 2D texture with the
// following orientation:
//
//  xzXZ
//   y Y
//
// X - Positive x direction
// x - Negative x direction
// Y - Positive y direction
// y - Negative y direction
// Z - Positive z direction
// z - Negative z direction
// positive X
cube2DViewPorts[0].set(vpWidth*2,vpHeight,vpWidth,vpHeight);// negative X
cube2DViewPorts[1].set(0,vpHeight,vpWidth,vpHeight);// positive Z
cube2DViewPorts[2].set(vpWidth*3,vpHeight,vpWidth,vpHeight);// negative Z
cube2DViewPorts[3].set(vpWidth,vpHeight,vpWidth,vpHeight);// positive Y
cube2DViewPorts[4].set(vpWidth*3,0,vpWidth,vpHeight);// negative Y
cube2DViewPorts[5].set(vpWidth,0,vpWidth,vpHeight);_shadowMapSize.x*=4.0;_shadowMapSize.y*=2.0;}else{faceCount=1;isPointLight=false;}if(shadow.map===null){var pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat,name:light.name+".shadowMap"};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadowCamera.updateProjectionMatrix();}if(shadow.isSpotLightShadow||shadow.isDirectionalLightShadow){shadow.update(light);}// TODO (abelnation / sam-g-steel): is this needed?
if(shadow&&shadow.isRectAreaLightShadow){shadow.update(light);}var shadowMap=shadow.map;var shadowMatrix=shadow.matrix;_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(shadow.virtualPosition?shadow.virtualPosition:_lightPositionWorld);_renderer.setRenderTarget(shadowMap);_renderer.clear();// render shadow map for each cube face (if omni-directional) or
// run a single pass if not
for(var face=0;face<faceCount;face++){if(isPointLight){_lookTarget.copy(shadowCamera.position);_lookTarget.add(cubeDirections[face]);shadowCamera.up.copy(cubeUps[face]);shadowCamera.lookAt(_lookTarget);var vpDimensions=cube2DViewPorts[face];_state.viewport(vpDimensions);}else{_lookTarget.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget);}if(shadow.virtualPosition){var offset=shadowCamera.position.clone().sub(_lightPositionWorld);_lookTarget.add(offset);shadowCamera.lookAt(_lookTarget);}shadowCamera.updateMatrixWorld();shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);// compute shadow matrix
shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(shadowCamera.projectionMatrix);shadowMatrix.multiply(shadowCamera.matrixWorldInverse);// update camera matrices and frustum
_projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);_frustum.setFromMatrix(_projScreenMatrix);// set object matrices & frustum culling
_renderList.length=0;projectObject(scene,camera,shadowCamera);// render shadow map
// render regular objects
for(var j=0,jl=_renderList.length;j<jl;j++){var object=_renderList[j];var geometry=_objects.update(object);var material=object.material;if(material&&material.isMultiMaterial){var groups=geometry.groups;var materials=material.materials;for(var k=0,kl=groups.length;k<kl;k++){var group=groups[k];var groupMaterial=materials[group.materialIndex];if(groupMaterial.visible===true){var depthMaterial=getDepthMaterial(object,groupMaterial,isPointLight,_lightPositionWorld);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);}}}else{var depthMaterial=getDepthMaterial(object,material,isPointLight,_lightPositionWorld);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);}}}}// Restore GL state.
var clearColor=_renderer.getClearColor(),clearAlpha=_renderer.getClearAlpha();_renderer.setClearColor(clearColor,clearAlpha);scope.needsUpdate=false;};function getDepthMaterial(object,material,isPointLight,lightPositionWorld){var geometry=object.geometry;var result=null;var materialVariants=_depthMaterials;var customMaterial=object.customDepthMaterial;if(isPointLight){materialVariants=_distanceMaterials;customMaterial=object.customDistanceMaterial;}if(!customMaterial){var useMorphing=false;if(material.morphTargets){if(geometry&&geometry.isBufferGeometry){useMorphing=geometry.morphAttributes&&geometry.morphAttributes.position&&geometry.morphAttributes.position.length>0;}else if(geometry&&geometry.isGeometry){useMorphing=geometry.morphTargets&&geometry.morphTargets.length>0;}}var useSkinning=object.isSkinnedMesh&&material.skinning;var variantIndex=0;if(useMorphing)variantIndex|=_MorphingFlag;if(useSkinning)variantIndex|=_SkinningFlag;result=materialVariants[variantIndex];}else{result=customMaterial;}if(_renderer.localClippingEnabled&&material.clipShadows===true&&material.clippingPlanes.length!==0){// in this case we need a unique material instance reflecting the
// appropriate state
var keyA=result.uuid,keyB=material.uuid;var materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}var cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;}result=cachedMaterial;}result.visible=material.visible;result.wireframe=material.wireframe;var side=material.side;if(scope.renderSingleSided&&side==DoubleSide){side=FrontSide;}if(scope.renderReverseSided){if(side===FrontSide)side=BackSide;else if(side===BackSide)side=FrontSide;}result.side=side;result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(isPointLight&&result.uniforms.lightPos!==undefined){result.uniforms.lightPos.value.copy(lightPositionWorld);}return result;}function projectObject(object,camera,shadowCamera){if(object.visible===false)return;var visible=(object.layers.mask&camera.layers.mask)!==0;if(visible&&(object.isMesh||object.isLine||object.isPoints)){if(object.castShadow&&(object.frustumCulled===false||_frustum.intersectsObject(object)===true)){var material=object.material;if(material.visible===true){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);_renderList.push(object);}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){projectObject(children[i],camera,shadowCamera);}}}/**
	 * @author bhouston / http://clara.io
	 */function Ray(origin,direction){this.origin=origin!==undefined?origin:new Vector3();this.direction=direction!==undefined?direction:new Vector3();}Ray.prototype={constructor:Ray,set:function set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;},at:function at(t,optionalTarget){var result=optionalTarget||new Vector3();return result.copy(this.direction).multiplyScalar(t).add(this.origin);},lookAt:function lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this;},recast:function(){var v1=new Vector3();return function recast(t){this.origin.copy(this.at(t,v1));return this;};}(),closestPointToPoint:function closestPointToPoint(point,optionalTarget){var result=optionalTarget||new Vector3();result.subVectors(point,this.origin);var directionDistance=result.dot(this.direction);if(directionDistance<0){return result.copy(this.origin);}return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);},distanceToPoint:function distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point));},distanceSqToPoint:function(){var v1=new Vector3();return function distanceSqToPoint(point){var directionDistance=v1.subVectors(point,this.origin).dot(this.direction);// point behind the ray
if(directionDistance<0){return this.origin.distanceToSquared(point);}v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return v1.distanceToSquared(point);};}(),distanceSqToSegment:function(){var segCenter=new Vector3();var segDir=new Vector3();var diff=new Vector3();return function distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
// It returns the min distance between the ray and the segment
// defined by v0 and v1
// It can also set two optional targets :
// - The closest point on the ray
// - The closest point on the segment
segCenter.copy(v0).add(v1).multiplyScalar(0.5);segDir.copy(v1).sub(v0).normalize();diff.copy(this.origin).sub(segCenter);var segExtent=v0.distanceTo(v1)*0.5;var a01=-this.direction.dot(segDir);var b0=diff.dot(this.direction);var b1=-diff.dot(segDir);var c=diff.lengthSq();var det=Math.abs(1-a01*a01);var s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
// Minimum at interior points of ray and segment.
var invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else{// region 1
s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{// region 5
s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{if(s1<=-extDet){// region 4
s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else{// region 2
s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else{// Ray and segment are parallel.
s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);}if(optionalPointOnSegment){optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);}return sqrDist;};}(),intersectSphere:function(){var v1=new Vector3();return function intersectSphere(sphere,optionalTarget){v1.subVectors(sphere.center,this.origin);var tca=v1.dot(this.direction);var d2=v1.dot(v1)-tca*tca;var radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;var thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
var t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
var t1=tca+thc;// test to see if both t0 and t1 are behind the ray - if so, return null
if(t0<0&&t1<0)return null;// test to see if t0 is behind the ray:
// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
// in order to always return an intersect point that is in front of the ray.
if(t0<0)return this.at(t1,optionalTarget);// else t0 is in front of the ray, so return the first collision point scaled by t0
return this.at(t0,optionalTarget);};}(),intersectsSphere:function intersectsSphere(sphere){return this.distanceToPoint(sphere.center)<=sphere.radius;},distanceToPlane:function distanceToPlane(plane){var denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
return null;}var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
return t>=0?t:null;},intersectPlane:function intersectPlane(plane,optionalTarget){var t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,optionalTarget);},intersectsPlane:function intersectsPlane(plane){// check if the ray lies on the plane first
var distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}var denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
return false;},intersectBox:function intersectBox(box,optionalTarget){var tmin,tmax,tymin,tymax,tzmin,tzmax;var invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;var origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else{tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else{tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;// These lines also handle the case where tmin or tmax is NaN
// (result of 0 * Infinity). x !== x returns true if x is NaN
if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else{tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,optionalTarget);},intersectsBox:function(){var v=new Vector3();return function intersectsBox(box){return this.intersectBox(box,v)!==null;};}(),intersectTriangle:function(){// Compute the offset origin, edges, and normal.
var diff=new Vector3();var edge1=new Vector3();var edge2=new Vector3();var normal=new Vector3();return function intersectTriangle(a,b,c,backfaceCulling,optionalTarget){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
edge1.subVectors(b,a);edge2.subVectors(c,a);normal.crossVectors(edge1,edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
var DdN=this.direction.dot(normal);var sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else{return null;}diff.subVectors(this.origin,a);var DdQxE2=sign*this.direction.dot(edge2.crossVectors(diff,edge2));// b1 < 0, no intersection
if(DdQxE2<0){return null;}var DdE1xQ=sign*this.direction.dot(edge1.cross(diff));// b2 < 0, no intersection
if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
var QdN=-sign*diff.dot(normal);// t < 0, no intersection
if(QdN<0){return null;}// Ray intersects triangle.
return this.at(QdN/DdN,optionalTarget);};}(),applyMatrix4:function applyMatrix4(matrix4){this.direction.add(this.origin).applyMatrix4(matrix4);this.origin.applyMatrix4(matrix4);this.direction.sub(this.origin);this.direction.normalize();return this;},equals:function equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */function Euler(x,y,z,order){this._x=x||0;this._y=y||0;this._z=z||0;this._order=order||Euler.DefaultOrder;}Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];Euler.DefaultOrder='XYZ';Euler.prototype={constructor:Euler,isEuler:true,get x(){return this._x;},set x(value){this._x=value;this.onChangeCallback();},get y(){return this._y;},set y(value){this._y=value;this.onChangeCallback();},get z(){return this._z;},set z(value){this._z=value;this.onChangeCallback();},get order(){return this._order;},set order(value){this._order=value;this.onChangeCallback();},set:function set(x,y,z,order){this._x=x;this._y=y;this._z=z;this._order=order||this._order;this.onChangeCallback();return this;},clone:function clone(){return new this.constructor(this._x,this._y,this._z,this._order);},copy:function copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this.onChangeCallback();return this;},setFromRotationMatrix:function setFromRotationMatrix(m,order,update){var clamp=_Math.clamp;// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var te=m.elements;var m11=te[0],m12=te[4],m13=te[8];var m21=te[1],m22=te[5],m23=te[9];var m31=te[2],m32=te[6],m33=te[10];order=order||this._order;if(order==='XYZ'){this._y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.99999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else{this._x=Math.atan2(m32,m22);this._z=0;}}else if(order==='YXZ'){this._x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.99999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else{this._y=Math.atan2(-m31,m11);this._z=0;}}else if(order==='ZXY'){this._x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.99999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else{this._y=0;this._z=Math.atan2(m21,m11);}}else if(order==='ZYX'){this._y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.99999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else{this._x=0;this._z=Math.atan2(-m12,m22);}}else if(order==='YZX'){this._z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.99999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else{this._x=0;this._y=Math.atan2(m13,m33);}}else if(order==='XZY'){this._z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.99999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else{this._x=Math.atan2(-m23,m33);this._y=0;}}else{console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: '+order);}this._order=order;if(update!==false)this.onChangeCallback();return this;},setFromQuaternion:function(){var matrix;return function setFromQuaternion(q,order,update){if(matrix===undefined)matrix=new Matrix4();matrix.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(matrix,order,update);};}(),setFromVector3:function setFromVector3(v,order){return this.set(v.x,v.y,v.z,order||this._order);},reorder:function(){// WARNING: this discards revolution information -bhouston
var q=new Quaternion();return function reorder(newOrder){q.setFromEuler(this);return this.setFromQuaternion(q,newOrder);};}(),equals:function equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;},fromArray:function fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this.onChangeCallback();return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;},toVector3:function toVector3(optionalResult){if(optionalResult){return optionalResult.set(this._x,this._y,this._z);}else{return new Vector3(this._x,this._y,this._z);}},onChange:function onChange(callback){this.onChangeCallback=callback;return this;},onChangeCallback:function onChangeCallback(){}};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Layers(){this.mask=1;}Layers.prototype={constructor:Layers,set:function set(channel){this.mask=1<<channel;},enable:function enable(channel){this.mask|=1<<channel;},toggle:function toggle(channel){this.mask^=1<<channel;},disable:function disable(channel){this.mask&=~(1<<channel);},test:function test(layers){return(this.mask&layers.mask)!==0;}};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */var object3DId=0;function Object3D(){Object.defineProperty(this,'id',{value:object3DId++});this.uuid=_Math.generateUUID();this.name='';this.type='Object3D';this.parent=null;this.children=[];this.up=Object3D.DefaultUp.clone();var position=new Vector3();var rotation=new Euler();var quaternion=new Quaternion();var scale=new Vector3(1,1,1);var shear=new Vector3();function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation.onChange(onRotationChange);quaternion.onChange(onQuaternionChange);(0,_defineProperties2.default)(this,{position:{enumerable:true,value:position},rotation:{enumerable:true,value:rotation},quaternion:{enumerable:true,value:quaternion},scale:{enumerable:true,value:scale},shear:{enumerable:true,value:shear},modelViewMatrix:{value:new Matrix4()},normalMatrix:{value:new Matrix3()}});this.matrix=new Matrix4();this.matrixWorld=new Matrix4();this.matrixWorldInverse=new Matrix4();this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=false;this.layers=new Layers();this.visible=true;this.castShadow=false;this.receiveShadow=false;this.frustumCulled=true;this.renderOrder=0;this.userData={};this.onBeforeRender=function(){};this.onAfterRender=function(){};}Object3D.DefaultUp=new Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=true;Object3D.prototype={constructor:Object3D,isObject3D:true,applyMatrix:function applyMatrix(matrix){this.matrix.multiplyMatrices(matrix,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale,this.shear);},setRotationFromAxisAngle:function setRotationFromAxisAngle(axis,angle){// assumes axis is normalized
this.quaternion.setFromAxisAngle(axis,angle);},setRotationFromEuler:function setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,true);},setRotationFromMatrix:function setRotationFromMatrix(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
this.quaternion.setFromRotationMatrix(m);},setRotationFromQuaternion:function setRotationFromQuaternion(q){// assumes q is normalized
this.quaternion.copy(q);},rotateOnAxis:function(){// rotate object on axis in object space
// axis is assumed to be normalized
var q1=new Quaternion();return function rotateOnAxis(axis,angle){q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(q1);return this;};}(),rotateX:function(){var v1=new Vector3(1,0,0);return function rotateX(angle){return this.rotateOnAxis(v1,angle);};}(),rotateY:function(){var v1=new Vector3(0,1,0);return function rotateY(angle){return this.rotateOnAxis(v1,angle);};}(),rotateZ:function(){var v1=new Vector3(0,0,1);return function rotateZ(angle){return this.rotateOnAxis(v1,angle);};}(),translateOnAxis:function(){// translate object by distance along axis in object space
// axis is assumed to be normalized
var v1=new Vector3();return function translateOnAxis(axis,distance){v1.copy(axis).applyQuaternion(this.quaternion);this.position.add(v1.multiplyScalar(distance));return this;};}(),translateX:function(){var v1=new Vector3(1,0,0);return function translateX(distance){return this.translateOnAxis(v1,distance);};}(),translateY:function(){var v1=new Vector3(0,1,0);return function translateY(distance){return this.translateOnAxis(v1,distance);};}(),translateZ:function(){var v1=new Vector3(0,0,1);return function translateZ(distance){return this.translateOnAxis(v1,distance);};}(),localToWorld:function localToWorld(vector){return vector.applyMatrix4(this.matrixWorld);},worldToLocal:function(){var m1=new Matrix4();return function worldToLocal(vector){return vector.applyMatrix4(m1.getInverse(this.matrixWorld));};}(),lookAt:function(){// This routine does not support objects with rotated and/or translated parent(s)
var m1=new Matrix4();return function lookAt(vector){m1.lookAt(vector,this.position,this.up);this.quaternion.setFromRotationMatrix(m1);};}(),add:function add(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.add(arguments[i]);}return this;}if(object===this){console.error("THREE.Object3D.add: object can't be added as a child of itself.",object);return this;}if(object&&object.isObject3D){if(object.parent!==null){object.parent.remove(object);}object.parent=this;object.dispatchEvent({type:'added'});this.children.push(object);}else{console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",object);}return this;},remove:function remove(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.remove(arguments[i]);}}var index=this.children.indexOf(object);if(index!==-1){object.parent=null;object.dispatchEvent({type:'removed'});this.children.splice(index,1);}},getObjectById:function getObjectById(id){return this.getObjectByProperty('id',id);},getObjectByName:function getObjectByName(name){return this.getObjectByProperty('name',name);},getObjectByProperty:function getObjectByProperty(name,value){if(this[name]===value)return this;for(var i=0,l=this.children.length;i<l;i++){var child=this.children[i];var object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;},getWorldPosition:function getWorldPosition(optionalTarget){var result=optionalTarget||new Vector3();this.updateMatrixWorld(true);return result.setFromMatrixPosition(this.matrixWorld);},getWorldQuaternion:function(){var position=new Vector3();var scale=new Vector3();var shear=new Vector3();return function getWorldQuaternion(optionalTarget){var result=optionalTarget||new Quaternion();this.updateMatrixWorld(true);this.matrixWorld.decompose(position,result,scale,shear);return result;};}(),getWorldRotation:function(){var quaternion=new Quaternion();return function getWorldRotation(optionalTarget){var result=optionalTarget||new Euler();this.getWorldQuaternion(quaternion);return result.setFromQuaternion(quaternion,this.rotation.order,false);};}(),getWorldScale:function(){var position=new Vector3();var quaternion=new Quaternion();var shear=new Vector3();return function getWorldScale(optionalTarget){var result=optionalTarget||new Vector3();this.updateMatrixWorld(true);this.matrixWorld.decompose(position,quaternion,result,shear);return result;};}(),getWorldDirection:function(){var quaternion=new Quaternion();return function getWorldDirection(optionalTarget){var result=optionalTarget||new Vector3();this.getWorldQuaternion(quaternion);return result.set(0,0,1).applyQuaternion(quaternion);};}(),raycast:function raycast(){},traverse:function traverse(callback){callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverse(callback);}},traverseVisible:function traverseVisible(callback){if(this.visible===false)return;callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverseVisible(callback);}},traverseAncestors:function traverseAncestors(callback){var parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}},updateMatrix:function updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale,this.shear);this.matrixWorldNeedsUpdate=true;},updateMatrixWorld:function updateMatrixWorld(force){if(this.matrixAutoUpdate===true)this.updateMatrix();if(this.matrixWorldNeedsUpdate===true||force===true){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else{this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldInverse.getInverse(this.matrixWorld);this.matrixWorldNeedsUpdate=false;force=true;}// update children
var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].updateMatrixWorld(force);}},toJSON:function toJSON(meta){// meta is '' when called from JSON.stringify
var isRootObject=meta===undefined||meta==='';var output={};// meta is a hash used to collect geometries, materials.
// not providing it implies that this is the root object
// being serialized.
if(isRootObject){// initialize meta obj
meta={geometries:{},materials:{},textures:{},images:{}};output.metadata={version:4.4,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
var object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if((0,_stringify2.default)(this.userData)!=='{}')object.userData=this.userData;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;object.matrix=this.matrix.toArray();//
if(this.geometry!==undefined){if(meta.geometries[this.geometry.uuid]===undefined){meta.geometries[this.geometry.uuid]=this.geometry.toJSON(meta);}object.geometry=this.geometry.uuid;}if(this.material!==undefined){if(meta.materials[this.material.uuid]===undefined){meta.materials[this.material.uuid]=this.material.toJSON(meta);}object.material=this.material.uuid;}//
if(this.children.length>0){object.children=[];for(var i=0;i<this.children.length;i++){object.children.push(this.children[i].toJSON(meta).object);}}if(isRootObject){var geometries=extractFromCache(meta.geometries);var materials=extractFromCache(meta.materials);var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;}output.object=object;return output;// extract data from the cache hash
// remove metadata on each item
// and return as array
function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}},clone:function clone(recursive){return new this.constructor().copy(this,recursive);},copy:function copy(source,recursive){if(recursive===undefined)recursive=true;this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.shear.copy(source.shear);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse((0,_stringify2.default)(source.userData));if(recursive===true){for(var i=0;i<source.children.length;i++){var child=source.children[i];this.add(child.clone());}}return this;}};(0,_assign2.default)(Object3D.prototype,EventDispatcher.prototype);/**
	 * @author bhouston / http://clara.io
	 */function Line3(start,end){this.start=start!==undefined?start:new Vector3();this.end=end!==undefined?end:new Vector3();}Line3.prototype={constructor:Line3,set:function set(start,end){this.start.copy(start);this.end.copy(end);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(line){this.start.copy(line.start);this.end.copy(line.end);return this;},getCenter:function getCenter(optionalTarget){var result=optionalTarget||new Vector3();return result.addVectors(this.start,this.end).multiplyScalar(0.5);},delta:function delta(optionalTarget){var result=optionalTarget||new Vector3();return result.subVectors(this.end,this.start);},distanceSq:function distanceSq(){return this.start.distanceToSquared(this.end);},distance:function distance(){return this.start.distanceTo(this.end);},at:function at(t,optionalTarget){var result=optionalTarget||new Vector3();return this.delta(result).multiplyScalar(t).add(this.start);},closestPointToPointParameter:function(){var startP=new Vector3();var startEnd=new Vector3();return function closestPointToPointParameter(point,clampToLine){startP.subVectors(point,this.start);startEnd.subVectors(this.end,this.start);var startEnd2=startEnd.dot(startEnd);var startEnd_startP=startEnd.dot(startP);var t=startEnd_startP/startEnd2;if(clampToLine){t=_Math.clamp(t,0,1);}return t;};}(),closestPointToPoint:function closestPointToPoint(point,clampToLine,optionalTarget){var t=this.closestPointToPointParameter(point,clampToLine);var result=optionalTarget||new Vector3();return this.delta(result).multiplyScalar(t).add(this.start);},applyMatrix4:function applyMatrix4(matrix){this.start.applyMatrix4(matrix);this.end.applyMatrix4(matrix);return this;},equals:function equals(line){return line.start.equals(this.start)&&line.end.equals(this.end);}};/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */function Triangle(a,b,c){this.a=a!==undefined?a:new Vector3();this.b=b!==undefined?b:new Vector3();this.c=c!==undefined?c:new Vector3();}Triangle.normal=function(){var v0=new Vector3();return function normal(a,b,c,optionalTarget){var result=optionalTarget||new Vector3();result.subVectors(c,b);v0.subVectors(a,b);result.cross(v0);var resultLengthSq=result.lengthSq();if(resultLengthSq>0){return result.multiplyScalar(1/Math.sqrt(resultLengthSq));}return result.set(0,0,0);};}();// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
Triangle.barycoordFromPoint=function(){var v0=new Vector3();var v1=new Vector3();var v2=new Vector3();return function barycoordFromPoint(point,a,b,c,optionalTarget){v0.subVectors(c,a);v1.subVectors(b,a);v2.subVectors(point,a);var dot00=v0.dot(v0);var dot01=v0.dot(v1);var dot02=v0.dot(v2);var dot11=v1.dot(v1);var dot12=v1.dot(v2);var denom=dot00*dot11-dot01*dot01;var result=optionalTarget||new Vector3();// collinear or singular triangle
if(denom===0){// arbitrary location outside of triangle?
// not sure if this is the best idea, maybe should be returning undefined
return result.set(-2,-1,-1);}var invDenom=1/denom;var u=(dot11*dot02-dot01*dot12)*invDenom;var v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
return result.set(1-u-v,v,u);};}();Triangle.containsPoint=function(){var v1=new Vector3();return function containsPoint(point,a,b,c){var result=Triangle.barycoordFromPoint(point,a,b,c,v1);return result.x>=0&&result.y>=0&&result.x+result.y<=1;};}();Triangle.prototype={constructor:Triangle,set:function set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;},setFromPointsAndIndices:function setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;},area:function(){var v0=new Vector3();var v1=new Vector3();return function area(){v0.subVectors(this.c,this.b);v1.subVectors(this.a,this.b);return v0.cross(v1).length()*0.5;};}(),midpoint:function midpoint(optionalTarget){var result=optionalTarget||new Vector3();return result.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);},normal:function normal(optionalTarget){return Triangle.normal(this.a,this.b,this.c,optionalTarget);},plane:function plane(optionalTarget){var result=optionalTarget||new Plane();return result.setFromCoplanarPoints(this.a,this.b,this.c);},barycoordFromPoint:function barycoordFromPoint(point,optionalTarget){return Triangle.barycoordFromPoint(point,this.a,this.b,this.c,optionalTarget);},containsPoint:function containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c);},closestPointToPoint:function(){var plane,edgeList,projectedPoint,closestPoint;return function closestPointToPoint(point,optionalTarget){if(plane===undefined){plane=new Plane();edgeList=[new Line3(),new Line3(),new Line3()];projectedPoint=new Vector3();closestPoint=new Vector3();}var result=optionalTarget||new Vector3();var minDistance=Infinity;// project the point onto the plane of the triangle
plane.setFromCoplanarPoints(this.a,this.b,this.c);plane.projectPoint(point,projectedPoint);// check if the projection lies within the triangle
if(this.containsPoint(projectedPoint)===true){// if so, this is the closest point
result.copy(projectedPoint);}else{// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
edgeList[0].set(this.a,this.b);edgeList[1].set(this.b,this.c);edgeList[2].set(this.c,this.a);for(var i=0;i<edgeList.length;i++){edgeList[i].closestPointToPoint(projectedPoint,true,closestPoint);var distance=projectedPoint.distanceToSquared(closestPoint);if(distance<minDistance){minDistance=distance;result.copy(closestPoint);}}}return result;};}(),equals:function equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function Face3(a,b,c,normal,color,materialIndex){this.a=a;this.b=b;this.c=c;this.normal=normal&&normal.isVector3?normal:new Vector3();this.vertexNormals=Array.isArray(normal)?normal:[];this.color=color&&color.isColor?color:new Color();this.vertexColors=Array.isArray(color)?color:[];this.materialIndex=materialIndex!==undefined?materialIndex:0;}Face3.prototype={constructor:Face3,clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.a=source.a;this.b=source.b;this.c=source.c;this.normal.copy(source.normal);this.color.copy(source.color);this.materialIndex=source.materialIndex;for(var i=0,il=source.vertexNormals.length;i<il;i++){this.vertexNormals[i]=source.vertexNormals[i].clone();}for(var i=0,il=source.vertexColors.length;i<il;i++){this.vertexColors[i]=source.vertexColors[i].clone();}return this;}};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */function MeshBasicMaterial(parameters){Material.call(this);this.type='MeshBasicMaterial';this.color=new Color(0xffffff);// emissive
this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.lights=false;this.setValues(parameters);}MeshBasicMaterial.prototype=(0,_create2.default)(Material.prototype);MeshBasicMaterial.prototype.constructor=MeshBasicMaterial;MeshBasicMaterial.prototype.isMeshBasicMaterial=true;MeshBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;return this;};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function BufferAttribute(array,itemSize,normalized){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.uuid=_Math.generateUUID();this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized===true;this.dynamic=false;this.updateRange={offset:0,count:-1};this.onUploadCallback=function(){};this.version=0;}BufferAttribute.prototype={constructor:BufferAttribute,isBufferAttribute:true,set needsUpdate(value){if(value===true)this.version++;},setArray:function setArray(array){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.count=array!==undefined?array.length/this.itemSize:0;this.array=array;},setDynamic:function setDynamic(value){this.dynamic=value;return this;},copy:function copy(source){this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.dynamic=source.dynamic;return this;},copyAt:function copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(var i=0,l=this.itemSize;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},copyArray:function copyArray(array){this.array.set(array);return this;},copyColorsArray:function copyColorsArray(colors){var array=this.array,offset=0;for(var i=0,l=colors.length;i<l;i++){var color=colors[i];if(color===undefined){console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',i);color=new Color();}array[offset++]=color.r;array[offset++]=color.g;array[offset++]=color.b;}return this;},copyIndicesArray:function copyIndicesArray(indices){var array=this.array,offset=0;for(var i=0,l=indices.length;i<l;i++){var index=indices[i];array[offset++]=index.a;array[offset++]=index.b;array[offset++]=index.c;}return this;},copyVector2sArray:function copyVector2sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',i);vector=new Vector2();}array[offset++]=vector.x;array[offset++]=vector.y;}return this;},copyVector3sArray:function copyVector3sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',i);vector=new Vector3();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;}return this;},copyVector4sArray:function copyVector4sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',i);vector=new Vector4();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;array[offset++]=vector.w;}return this;},set:function set(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},getX:function getX(index){return this.array[index*this.itemSize];},setX:function setX(index,x){this.array[index*this.itemSize]=x;return this;},getY:function getY(index){return this.array[index*this.itemSize+1];},setY:function setY(index,y){this.array[index*this.itemSize+1]=y;return this;},getZ:function getZ(index){return this.array[index*this.itemSize+2];},setZ:function setZ(index,z){this.array[index*this.itemSize+2]=z;return this;},getW:function getW(index){return this.array[index*this.itemSize+3];},setW:function setW(index,w){this.array[index*this.itemSize+3]=w;return this;},setXY:function setXY(index,x,y){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;return this;},setXYZ:function setXYZ(index,x,y,z){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;},setXYZW:function setXYZW(index,x,y,z,w){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;},onUpload:function onUpload(callback){this.onUploadCallback=callback;return this;},clone:function clone(){return new this.constructor().copy(this);}};//
function Int8BufferAttribute(array,itemSize){BufferAttribute.call(this,new Int8Array(array),itemSize);}Int8BufferAttribute.prototype=(0,_create2.default)(BufferAttribute.prototype);Int8BufferAttribute.prototype.constructor=Int8BufferAttribute;function Uint8BufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint8Array(array),itemSize);}Uint8BufferAttribute.prototype=(0,_create2.default)(BufferAttribute.prototype);Uint8BufferAttribute.prototype.constructor=Uint8BufferAttribute;function Uint8ClampedBufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint8ClampedArray(array),itemSize);}Uint8ClampedBufferAttribute.prototype=(0,_create2.default)(BufferAttribute.prototype);Uint8ClampedBufferAttribute.prototype.constructor=Uint8ClampedBufferAttribute;function Int16BufferAttribute(array,itemSize){BufferAttribute.call(this,new Int16Array(array),itemSize);}Int16BufferAttribute.prototype=(0,_create2.default)(BufferAttribute.prototype);Int16BufferAttribute.prototype.constructor=Int16BufferAttribute;function Uint16BufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint16Array(array),itemSize);}Uint16BufferAttribute.prototype=(0,_create2.default)(BufferAttribute.prototype);Uint16BufferAttribute.prototype.constructor=Uint16BufferAttribute;function Int32BufferAttribute(array,itemSize){BufferAttribute.call(this,new Int32Array(array),itemSize);}Int32BufferAttribute.prototype=(0,_create2.default)(BufferAttribute.prototype);Int32BufferAttribute.prototype.constructor=Int32BufferAttribute;function Uint32BufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint32Array(array),itemSize);}Uint32BufferAttribute.prototype=(0,_create2.default)(BufferAttribute.prototype);Uint32BufferAttribute.prototype.constructor=Uint32BufferAttribute;function Float32BufferAttribute(array,itemSize){BufferAttribute.call(this,new Float32Array(array),itemSize);}Float32BufferAttribute.prototype=(0,_create2.default)(BufferAttribute.prototype);Float32BufferAttribute.prototype.constructor=Float32BufferAttribute;function Float64BufferAttribute(array,itemSize){BufferAttribute.call(this,new Float64Array(array),itemSize);}Float64BufferAttribute.prototype=(0,_create2.default)(BufferAttribute.prototype);Float64BufferAttribute.prototype.constructor=Float64BufferAttribute;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function DirectGeometry(){this.indices=[];this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=[];this.morphTargets={};this.skinWeights=[];this.skinIndices=[];// this.lineDistances = [];
this.boundingBox=null;this.boundingSphere=null;// update flags
this.verticesNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.uvsNeedUpdate=false;this.groupsNeedUpdate=false;}(0,_assign2.default)(DirectGeometry.prototype,{computeGroups:function computeGroups(geometry){var group;var groups=[];var materialIndex=undefined;var faces=geometry.faces;for(var i=0;i<faces.length;i++){var face=faces[i];// materials
if(face.materialIndex!==materialIndex){materialIndex=face.materialIndex;if(group!==undefined){group.count=i*3-group.start;groups.push(group);}group={start:i*3,materialIndex:materialIndex};}}if(group!==undefined){group.count=i*3-group.start;groups.push(group);}this.groups=groups;},fromGeometry:function fromGeometry(geometry){var faces=geometry.faces;var vertices=geometry.vertices;var faceVertexUvs=geometry.faceVertexUvs;var hasFaceVertexUv=faceVertexUvs[0]&&faceVertexUvs[0].length>0;var hasFaceVertexUv2=faceVertexUvs[1]&&faceVertexUvs[1].length>0;// morphs
var morphTargets=geometry.morphTargets;var morphTargetsLength=morphTargets.length;var morphTargetsPosition;if(morphTargetsLength>0){morphTargetsPosition=[];for(var i=0;i<morphTargetsLength;i++){morphTargetsPosition[i]=[];}this.morphTargets.position=morphTargetsPosition;}var morphNormals=geometry.morphNormals;var morphNormalsLength=morphNormals.length;var morphTargetsNormal;if(morphNormalsLength>0){morphTargetsNormal=[];for(var i=0;i<morphNormalsLength;i++){morphTargetsNormal[i]=[];}this.morphTargets.normal=morphTargetsNormal;}// skins
var skinIndices=geometry.skinIndices;var skinWeights=geometry.skinWeights;var hasSkinIndices=skinIndices.length===vertices.length;var hasSkinWeights=skinWeights.length===vertices.length;//
for(var i=0;i<faces.length;i++){var face=faces[i];this.vertices.push(vertices[face.a],vertices[face.b],vertices[face.c]);var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){this.normals.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]);}else{var normal=face.normal;this.normals.push(normal,normal,normal);}var vertexColors=face.vertexColors;if(vertexColors.length===3){this.colors.push(vertexColors[0],vertexColors[1],vertexColors[2]);}else{var color=face.color;this.colors.push(color,color,color);}if(hasFaceVertexUv===true){var vertexUvs=faceVertexUvs[0][i];if(vertexUvs!==undefined){this.uvs.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',i);this.uvs.push(new Vector2(),new Vector2(),new Vector2());}}if(hasFaceVertexUv2===true){var vertexUvs=faceVertexUvs[1][i];if(vertexUvs!==undefined){this.uvs2.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',i);this.uvs2.push(new Vector2(),new Vector2(),new Vector2());}}// morphs
for(var j=0;j<morphTargetsLength;j++){var morphTarget=morphTargets[j].vertices;morphTargetsPosition[j].push(morphTarget[face.a],morphTarget[face.b],morphTarget[face.c]);}for(var j=0;j<morphNormalsLength;j++){var morphNormal=morphNormals[j].vertexNormals[i];morphTargetsNormal[j].push(morphNormal.a,morphNormal.b,morphNormal.c);}// skins
if(hasSkinIndices){this.skinIndices.push(skinIndices[face.a],skinIndices[face.b],skinIndices[face.c]);}if(hasSkinWeights){this.skinWeights.push(skinWeights[face.a],skinWeights[face.b],skinWeights[face.c]);}}this.computeGroups(geometry);this.verticesNeedUpdate=geometry.verticesNeedUpdate;this.normalsNeedUpdate=geometry.normalsNeedUpdate;this.colorsNeedUpdate=geometry.colorsNeedUpdate;this.uvsNeedUpdate=geometry.uvsNeedUpdate;this.groupsNeedUpdate=geometry.groupsNeedUpdate;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */var count=0;function GeometryIdCount(){return count++;}function Geometry(){Object.defineProperty(this,'id',{value:GeometryIdCount()});this.uuid=_Math.generateUUID();this.name='';this.type='Geometry';this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// update flags
this.elementsNeedUpdate=false;this.verticesNeedUpdate=false;this.uvsNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.lineDistancesNeedUpdate=false;this.groupsNeedUpdate=false;}Geometry.prototype={constructor:Geometry,isGeometry:true,applyMatrix:function applyMatrix(matrix){var normalMatrix=new Matrix3().getNormalMatrix(matrix);for(var i=0,il=this.vertices.length;i<il;i++){var vertex=this.vertices[i];vertex.applyMatrix4(matrix);}for(var i=0,il=this.faces.length;i<il;i++){var face=this.faces[i];face.normal.applyMatrix3(normalMatrix).normalize();for(var j=0,jl=face.vertexNormals.length;j<jl;j++){face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();}}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}this.verticesNeedUpdate=true;this.normalsNeedUpdate=true;return this;},rotateX:function(){// rotate geometry around world x-axis
var m1;return function rotateX(angle){if(m1===undefined)m1=new Matrix4();m1.makeRotationX(angle);this.applyMatrix(m1);return this;};}(),rotateY:function(){// rotate geometry around world y-axis
var m1;return function rotateY(angle){if(m1===undefined)m1=new Matrix4();m1.makeRotationY(angle);this.applyMatrix(m1);return this;};}(),rotateZ:function(){// rotate geometry around world z-axis
var m1;return function rotateZ(angle){if(m1===undefined)m1=new Matrix4();m1.makeRotationZ(angle);this.applyMatrix(m1);return this;};}(),translate:function(){// translate geometry
var m1;return function translate(x,y,z){if(m1===undefined)m1=new Matrix4();m1.makeTranslation(x,y,z);this.applyMatrix(m1);return this;};}(),scale:function(){// scale geometry
var m1;return function scale(x,y,z){if(m1===undefined)m1=new Matrix4();m1.makeScale(x,y,z);this.applyMatrix(m1);return this;};}(),lookAt:function(){var obj;return function lookAt(vector){if(obj===undefined)obj=new Object3D();obj.lookAt(vector);obj.updateMatrix();this.applyMatrix(obj.matrix);};}(),fromBufferGeometry:function fromBufferGeometry(geometry){var scope=this;var indices=geometry.index!==null?geometry.index.array:undefined;var attributes=geometry.attributes;var positions=attributes.position.array;var normals=attributes.normal!==undefined?attributes.normal.array:undefined;var colors=attributes.color!==undefined?attributes.color.array:undefined;var uvs=attributes.uv!==undefined?attributes.uv.array:undefined;var uvs2=attributes.uv2!==undefined?attributes.uv2.array:undefined;if(uvs2!==undefined)this.faceVertexUvs[1]=[];var tempNormals=[];var tempUVs=[];var tempUVs2=[];for(var i=0,j=0;i<positions.length;i+=3,j+=2){scope.vertices.push(new Vector3(positions[i],positions[i+1],positions[i+2]));if(normals!==undefined){tempNormals.push(new Vector3(normals[i],normals[i+1],normals[i+2]));}if(colors!==undefined){scope.colors.push(new Color(colors[i],colors[i+1],colors[i+2]));}if(uvs!==undefined){tempUVs.push(new Vector2(uvs[j],uvs[j+1]));}if(uvs2!==undefined){tempUVs2.push(new Vector2(uvs2[j],uvs2[j+1]));}}function addFace(a,b,c,materialIndex){var vertexNormals=normals!==undefined?[tempNormals[a].clone(),tempNormals[b].clone(),tempNormals[c].clone()]:[];var vertexColors=colors!==undefined?[scope.colors[a].clone(),scope.colors[b].clone(),scope.colors[c].clone()]:[];var face=new Face3(a,b,c,vertexNormals,vertexColors,materialIndex);scope.faces.push(face);if(uvs!==undefined){scope.faceVertexUvs[0].push([tempUVs[a].clone(),tempUVs[b].clone(),tempUVs[c].clone()]);}if(uvs2!==undefined){scope.faceVertexUvs[1].push([tempUVs2[a].clone(),tempUVs2[b].clone(),tempUVs2[c].clone()]);}}if(indices!==undefined){var groups=geometry.groups;if(groups.length>0){for(var i=0;i<groups.length;i++){var group=groups[i];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){addFace(indices[j],indices[j+1],indices[j+2],group.materialIndex);}}}else{for(var i=0;i<indices.length;i+=3){addFace(indices[i],indices[i+1],indices[i+2]);}}}else{for(var i=0;i<positions.length/3;i+=3){addFace(i,i+1,i+2);}}this.computeFaceNormals();if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}return this;},center:function center(){this.computeBoundingBox();var offset=this.boundingBox.getCenter().negate();this.translate(offset.x,offset.y,offset.z);return offset;},normalize:function normalize(){this.computeBoundingSphere();var center=this.boundingSphere.center;var radius=this.boundingSphere.radius;var s=radius===0?1:1.0/radius;var matrix=new Matrix4();matrix.set(s,0,0,-s*center.x,0,s,0,-s*center.y,0,0,s,-s*center.z,0,0,0,1);this.applyMatrix(matrix);return this;},computeFaceNormals:function computeFaceNormals(){var cb=new Vector3(),ab=new Vector3();for(var f=0,fl=this.faces.length;f<fl;f++){var face=this.faces[f];var vA=this.vertices[face.a];var vB=this.vertices[face.b];var vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);cb.normalize();face.normal.copy(cb);}},computeVertexNormals:function computeVertexNormals(areaWeighted){if(areaWeighted===undefined)areaWeighted=true;var v,vl,f,fl,face,vertices;vertices=new Array(this.vertices.length);for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v]=new Vector3();}if(areaWeighted){// vertex normals weighted by triangle areas
// http://www.iquilezles.org/www/articles/normals/normals.htm
var vA,vB,vC;var cb=new Vector3(),ab=new Vector3();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vA=this.vertices[face.a];vB=this.vertices[face.b];vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);vertices[face.a].add(cb);vertices[face.b].add(cb);vertices[face.c].add(cb);}}else{this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vertices[face.a].add(face.normal);vertices[face.b].add(face.normal);vertices[face.c].add(face.normal);}}for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v].normalize();}for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(vertices[face.a]);vertexNormals[1].copy(vertices[face.b]);vertexNormals[2].copy(vertices[face.c]);}else{vertexNormals[0]=vertices[face.a].clone();vertexNormals[1]=vertices[face.b].clone();vertexNormals[2]=vertices[face.c].clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeFlatVertexNormals:function computeFlatVertexNormals(){var f,fl,face;this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(face.normal);vertexNormals[1].copy(face.normal);vertexNormals[2].copy(face.normal);}else{vertexNormals[0]=face.normal.clone();vertexNormals[1]=face.normal.clone();vertexNormals[2]=face.normal.clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeMorphNormals:function computeMorphNormals(){var i,il,f,fl,face;// save original normals
// - create temp variables on first access
//   otherwise just copy (for faster repeated calls)
for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];if(!face.__originalFaceNormal){face.__originalFaceNormal=face.normal.clone();}else{face.__originalFaceNormal.copy(face.normal);}if(!face.__originalVertexNormals)face.__originalVertexNormals=[];for(i=0,il=face.vertexNormals.length;i<il;i++){if(!face.__originalVertexNormals[i]){face.__originalVertexNormals[i]=face.vertexNormals[i].clone();}else{face.__originalVertexNormals[i].copy(face.vertexNormals[i]);}}}// use temp geometry to compute face and vertex normals for each morph
var tmpGeo=new Geometry();tmpGeo.faces=this.faces;for(i=0,il=this.morphTargets.length;i<il;i++){// create on first access
if(!this.morphNormals[i]){this.morphNormals[i]={};this.morphNormals[i].faceNormals=[];this.morphNormals[i].vertexNormals=[];var dstNormalsFace=this.morphNormals[i].faceNormals;var dstNormalsVertex=this.morphNormals[i].vertexNormals;var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){faceNormal=new Vector3();vertexNormals={a:new Vector3(),b:new Vector3(),c:new Vector3()};dstNormalsFace.push(faceNormal);dstNormalsVertex.push(vertexNormals);}}var morphNormals=this.morphNormals[i];// set vertices to morph target
tmpGeo.vertices=this.morphTargets[i].vertices;// compute morph normals
tmpGeo.computeFaceNormals();tmpGeo.computeVertexNormals();// store morph normals
var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];faceNormal=morphNormals.faceNormals[f];vertexNormals=morphNormals.vertexNormals[f];faceNormal.copy(face.normal);vertexNormals.a.copy(face.vertexNormals[0]);vertexNormals.b.copy(face.vertexNormals[1]);vertexNormals.c.copy(face.vertexNormals[2]);}}// restore original normals
for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];face.normal=face.__originalFaceNormal;face.vertexNormals=face.__originalVertexNormals;}},computeLineDistances:function computeLineDistances(){var d=0;var vertices=this.vertices;for(var i=0,il=vertices.length;i<il;i++){if(i>0){d+=vertices[i].distanceTo(vertices[i-1]);}this.lineDistances[i]=d;}},computeBoundingBox:function computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}this.boundingBox.setFromPoints(this.vertices);},computeBoundingSphere:function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}this.boundingSphere.setFromPoints(this.vertices);},merge:function merge(geometry,matrix,materialIndexOffset){if((geometry&&geometry.isGeometry)===false){console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',geometry);return;}var normalMatrix,vertexOffset=this.vertices.length,vertices1=this.vertices,vertices2=geometry.vertices,faces1=this.faces,faces2=geometry.faces,uvs1=this.faceVertexUvs[0],uvs2=geometry.faceVertexUvs[0],colors1=this.colors,colors2=geometry.colors;if(materialIndexOffset===undefined)materialIndexOffset=0;if(matrix!==undefined){normalMatrix=new Matrix3().getNormalMatrix(matrix);}// vertices
for(var i=0,il=vertices2.length;i<il;i++){var vertex=vertices2[i];var vertexCopy=vertex.clone();if(matrix!==undefined)vertexCopy.applyMatrix4(matrix);vertices1.push(vertexCopy);}// colors
for(var i=0,il=colors2.length;i<il;i++){colors1.push(colors2[i].clone());}// faces
for(i=0,il=faces2.length;i<il;i++){var face=faces2[i],faceCopy,normal,color,faceVertexNormals=face.vertexNormals,faceVertexColors=face.vertexColors;faceCopy=new Face3(face.a+vertexOffset,face.b+vertexOffset,face.c+vertexOffset);faceCopy.normal.copy(face.normal);if(normalMatrix!==undefined){faceCopy.normal.applyMatrix3(normalMatrix).normalize();}for(var j=0,jl=faceVertexNormals.length;j<jl;j++){normal=faceVertexNormals[j].clone();if(normalMatrix!==undefined){normal.applyMatrix3(normalMatrix).normalize();}faceCopy.vertexNormals.push(normal);}faceCopy.color.copy(face.color);for(var j=0,jl=faceVertexColors.length;j<jl;j++){color=faceVertexColors[j];faceCopy.vertexColors.push(color.clone());}faceCopy.materialIndex=face.materialIndex+materialIndexOffset;faces1.push(faceCopy);}// uvs
for(i=0,il=uvs2.length;i<il;i++){var uv=uvs2[i],uvCopy=[];if(uv===undefined){continue;}for(var j=0,jl=uv.length;j<jl;j++){uvCopy.push(uv[j].clone());}uvs1.push(uvCopy);}},mergeMesh:function mergeMesh(mesh){if((mesh&&mesh.isMesh)===false){console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',mesh);return;}mesh.matrixAutoUpdate&&mesh.updateMatrix();this.merge(mesh.geometry,mesh.matrix);},/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */mergeVertices:function mergeVertices(){var verticesMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)
var unique=[],changes=[];var v,key;var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
var precision=Math.pow(10,precisionPoints);var i,il,face;var indices,j,jl;for(i=0,il=this.vertices.length;i<il;i++){v=this.vertices[i];key=Math.round(v.x*precision)+'_'+Math.round(v.y*precision)+'_'+Math.round(v.z*precision);if(verticesMap[key]===undefined){verticesMap[key]=i;unique.push(this.vertices[i]);changes[i]=unique.length-1;}else{//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
changes[i]=changes[verticesMap[key]];}}// if faces are completely degenerate after merging vertices, we
// have to remove them from the geometry.
var faceIndicesToRemove=[];for(i=0,il=this.faces.length;i<il;i++){face=this.faces[i];face.a=changes[face.a];face.b=changes[face.b];face.c=changes[face.c];indices=[face.a,face.b,face.c];// if any duplicate vertices are found in a Face3
// we have to remove the face as nothing can be saved
for(var n=0;n<3;n++){if(indices[n]===indices[(n+1)%3]){faceIndicesToRemove.push(i);break;}}}for(i=faceIndicesToRemove.length-1;i>=0;i--){var idx=faceIndicesToRemove[i];this.faces.splice(idx,1);for(j=0,jl=this.faceVertexUvs.length;j<jl;j++){this.faceVertexUvs[j].splice(idx,1);}}// Use unique set of vertices
var diff=this.vertices.length-unique.length;this.vertices=unique;return diff;},sortFacesByMaterialIndex:function sortFacesByMaterialIndex(){var faces=this.faces;var length=faces.length;// tag faces
for(var i=0;i<length;i++){faces[i]._id=i;}// sort faces
function materialIndexSort(a,b){return a.materialIndex-b.materialIndex;}faces.sort(materialIndexSort);// sort uvs
var uvs1=this.faceVertexUvs[0];var uvs2=this.faceVertexUvs[1];var newUvs1,newUvs2;if(uvs1&&uvs1.length===length)newUvs1=[];if(uvs2&&uvs2.length===length)newUvs2=[];for(var i=0;i<length;i++){var id=faces[i]._id;if(newUvs1)newUvs1.push(uvs1[id]);if(newUvs2)newUvs2.push(uvs2[id]);}if(newUvs1)this.faceVertexUvs[0]=newUvs1;if(newUvs2)this.faceVertexUvs[1]=newUvs2;},toJSON:function toJSON(){var data={metadata:{version:4.4,type:'Geometry',generator:'Geometry.toJSON'}};// standard Geometry serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}var vertices=[];for(var i=0;i<this.vertices.length;i++){var vertex=this.vertices[i];vertices.push(vertex.x,vertex.y,vertex.z);}var faces=[];var normals=[];var normalsHash={};var colors=[];var colorsHash={};var uvs=[];var uvsHash={};for(var i=0;i<this.faces.length;i++){var face=this.faces[i];var hasMaterial=true;var hasFaceUv=false;// deprecated
var hasFaceVertexUv=this.faceVertexUvs[0][i]!==undefined;var hasFaceNormal=face.normal.length()>0;var hasFaceVertexNormal=face.vertexNormals.length>0;var hasFaceColor=face.color.r!==1||face.color.g!==1||face.color.b!==1;var hasFaceVertexColor=face.vertexColors.length>0;var faceType=0;faceType=setBit(faceType,0,0);// isQuad
faceType=setBit(faceType,1,hasMaterial);faceType=setBit(faceType,2,hasFaceUv);faceType=setBit(faceType,3,hasFaceVertexUv);faceType=setBit(faceType,4,hasFaceNormal);faceType=setBit(faceType,5,hasFaceVertexNormal);faceType=setBit(faceType,6,hasFaceColor);faceType=setBit(faceType,7,hasFaceVertexColor);faces.push(faceType);faces.push(face.a,face.b,face.c);faces.push(face.materialIndex);if(hasFaceVertexUv){var faceVertexUvs=this.faceVertexUvs[0][i];faces.push(getUvIndex(faceVertexUvs[0]),getUvIndex(faceVertexUvs[1]),getUvIndex(faceVertexUvs[2]));}if(hasFaceNormal){faces.push(getNormalIndex(face.normal));}if(hasFaceVertexNormal){var vertexNormals=face.vertexNormals;faces.push(getNormalIndex(vertexNormals[0]),getNormalIndex(vertexNormals[1]),getNormalIndex(vertexNormals[2]));}if(hasFaceColor){faces.push(getColorIndex(face.color));}if(hasFaceVertexColor){var vertexColors=face.vertexColors;faces.push(getColorIndex(vertexColors[0]),getColorIndex(vertexColors[1]),getColorIndex(vertexColors[2]));}}function setBit(value,position,enabled){return enabled?value|1<<position:value&~(1<<position);}function getNormalIndex(normal){var hash=normal.x.toString()+normal.y.toString()+normal.z.toString();if(normalsHash[hash]!==undefined){return normalsHash[hash];}normalsHash[hash]=normals.length/3;normals.push(normal.x,normal.y,normal.z);return normalsHash[hash];}function getColorIndex(color){var hash=color.r.toString()+color.g.toString()+color.b.toString();if(colorsHash[hash]!==undefined){return colorsHash[hash];}colorsHash[hash]=colors.length;colors.push(color.getHex());return colorsHash[hash];}function getUvIndex(uv){var hash=uv.x.toString()+uv.y.toString();if(uvsHash[hash]!==undefined){return uvsHash[hash];}uvsHash[hash]=uvs.length/2;uvs.push(uv.x,uv.y);return uvsHash[hash];}data.data={};data.data.vertices=vertices;data.data.normals=normals;if(colors.length>0)data.data.colors=colors;if(uvs.length>0)data.data.uvs=[uvs];// temporal backward compatibility
data.data.faces=faces;return data;},clone:function clone(){/*
			// Handle primitives

			var parameters = this.parameters;

			if ( parameters !== undefined ) {

				var values = [];

				for ( var key in parameters ) {

					values.push( parameters[ key ] );

				}

				var geometry = Object.create( this.constructor.prototype );
				this.constructor.apply( geometry, values );
				return geometry;

			}

			return new this.constructor().copy( this );
			*/return new Geometry().copy(this);},copy:function copy(source){this.vertices=[];this.faces=[];this.faceVertexUvs=[[]];this.colors=[];var vertices=source.vertices;for(var i=0,il=vertices.length;i<il;i++){this.vertices.push(vertices[i].clone());}var colors=source.colors;for(var i=0,il=colors.length;i<il;i++){this.colors.push(colors[i].clone());}var faces=source.faces;for(var i=0,il=faces.length;i<il;i++){this.faces.push(faces[i].clone());}for(var i=0,il=source.faceVertexUvs.length;i<il;i++){var faceVertexUvs=source.faceVertexUvs[i];if(this.faceVertexUvs[i]===undefined){this.faceVertexUvs[i]=[];}for(var j=0,jl=faceVertexUvs.length;j<jl;j++){var uvs=faceVertexUvs[j],uvsCopy=[];for(var k=0,kl=uvs.length;k<kl;k++){var uv=uvs[k];uvsCopy.push(uv.clone());}this.faceVertexUvs[i].push(uvsCopy);}}return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}};(0,_assign2.default)(Geometry.prototype,EventDispatcher.prototype);/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */function BufferGeometry(){Object.defineProperty(this,'id',{value:GeometryIdCount()});this.uuid=_Math.generateUUID();this.name='';this.type='BufferGeometry';this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;this.drawRange={start:0,count:Infinity};}BufferGeometry.prototype={constructor:BufferGeometry,isBufferGeometry:true,getIndex:function getIndex(){return this.index;},setIndex:function setIndex(index){this.index=index;},addAttribute:function addAttribute(name,attribute){if((attribute&&attribute.isBufferAttribute)===false&&(attribute&&attribute.isInterleavedBufferAttribute)===false){console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');this.addAttribute(name,new BufferAttribute(arguments[1],arguments[2]));return;}if(name==='index'){console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');this.setIndex(attribute);return;}this.attributes[name]=attribute;return this;},getAttribute:function getAttribute(name){return this.attributes[name];},removeAttribute:function removeAttribute(name){delete this.attributes[name];return this;},addGroup:function addGroup(start,count,materialIndex){this.groups.push({start:start,count:count,materialIndex:materialIndex!==undefined?materialIndex:0});},clearGroups:function clearGroups(){this.groups=[];},setDrawRange:function setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count;},applyMatrix:function applyMatrix(matrix){var position=this.attributes.position;if(position!==undefined){matrix.applyToBufferAttribute(position);position.needsUpdate=true;}var normal=this.attributes.normal;if(normal!==undefined){var normalMatrix=new Matrix3().getNormalMatrix(matrix);normalMatrix.applyToBufferAttribute(normal);normal.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;},rotateX:function(){// rotate geometry around world x-axis
var m1;return function rotateX(angle){if(m1===undefined)m1=new Matrix4();m1.makeRotationX(angle);this.applyMatrix(m1);return this;};}(),rotateY:function(){// rotate geometry around world y-axis
var m1;return function rotateY(angle){if(m1===undefined)m1=new Matrix4();m1.makeRotationY(angle);this.applyMatrix(m1);return this;};}(),rotateZ:function(){// rotate geometry around world z-axis
var m1;return function rotateZ(angle){if(m1===undefined)m1=new Matrix4();m1.makeRotationZ(angle);this.applyMatrix(m1);return this;};}(),translate:function(){// translate geometry
var m1;return function translate(x,y,z){if(m1===undefined)m1=new Matrix4();m1.makeTranslation(x,y,z);this.applyMatrix(m1);return this;};}(),scale:function(){// scale geometry
var m1;return function scale(x,y,z){if(m1===undefined)m1=new Matrix4();m1.makeScale(x,y,z);this.applyMatrix(m1);return this;};}(),lookAt:function(){var obj;return function lookAt(vector){if(obj===undefined)obj=new Object3D();obj.lookAt(vector);obj.updateMatrix();this.applyMatrix(obj.matrix);};}(),center:function center(){this.computeBoundingBox();var offset=this.boundingBox.getCenter().negate();this.translate(offset.x,offset.y,offset.z);return offset;},setFromObject:function setFromObject(object){// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
var geometry=object.geometry;if(object.isPoints||object.isLine){var positions=new Float32BufferAttribute(geometry.vertices.length*3,3);var colors=new Float32BufferAttribute(geometry.colors.length*3,3);this.addAttribute('position',positions.copyVector3sArray(geometry.vertices));this.addAttribute('color',colors.copyColorsArray(geometry.colors));if(geometry.lineDistances&&geometry.lineDistances.length===geometry.vertices.length){var lineDistances=new Float32BufferAttribute(geometry.lineDistances.length,1);this.addAttribute('lineDistance',lineDistances.copyArray(geometry.lineDistances));}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}}else if(object.isMesh){if(geometry&&geometry.isGeometry){this.fromGeometry(geometry);}}return this;},updateFromObject:function updateFromObject(object){var geometry=object.geometry;if(object.isMesh){var direct=geometry.__directGeometry;if(geometry.elementsNeedUpdate===true){direct=undefined;geometry.elementsNeedUpdate=false;}if(direct===undefined){return this.fromGeometry(geometry);}direct.verticesNeedUpdate=geometry.verticesNeedUpdate;direct.normalsNeedUpdate=geometry.normalsNeedUpdate;direct.colorsNeedUpdate=geometry.colorsNeedUpdate;direct.uvsNeedUpdate=geometry.uvsNeedUpdate;direct.groupsNeedUpdate=geometry.groupsNeedUpdate;geometry.verticesNeedUpdate=false;geometry.normalsNeedUpdate=false;geometry.colorsNeedUpdate=false;geometry.uvsNeedUpdate=false;geometry.groupsNeedUpdate=false;geometry=direct;}var attribute;if(geometry.verticesNeedUpdate===true){attribute=this.attributes.position;if(attribute!==undefined){attribute.copyVector3sArray(geometry.vertices);attribute.needsUpdate=true;}geometry.verticesNeedUpdate=false;}if(geometry.normalsNeedUpdate===true){attribute=this.attributes.normal;if(attribute!==undefined){attribute.copyVector3sArray(geometry.normals);attribute.needsUpdate=true;}geometry.normalsNeedUpdate=false;}if(geometry.colorsNeedUpdate===true){attribute=this.attributes.color;if(attribute!==undefined){attribute.copyColorsArray(geometry.colors);attribute.needsUpdate=true;}geometry.colorsNeedUpdate=false;}if(geometry.uvsNeedUpdate){attribute=this.attributes.uv;if(attribute!==undefined){attribute.copyVector2sArray(geometry.uvs);attribute.needsUpdate=true;}geometry.uvsNeedUpdate=false;}if(geometry.lineDistancesNeedUpdate){attribute=this.attributes.lineDistance;if(attribute!==undefined){attribute.copyArray(geometry.lineDistances);attribute.needsUpdate=true;}geometry.lineDistancesNeedUpdate=false;}if(geometry.groupsNeedUpdate){geometry.computeGroups(object.geometry);this.groups=geometry.groups;geometry.groupsNeedUpdate=false;}return this;},fromGeometry:function fromGeometry(geometry){geometry.__directGeometry=new DirectGeometry().fromGeometry(geometry);return this.fromDirectGeometry(geometry.__directGeometry);},fromDirectGeometry:function fromDirectGeometry(geometry){var positions=new Float32Array(geometry.vertices.length*3);this.addAttribute('position',new BufferAttribute(positions,3).copyVector3sArray(geometry.vertices));if(geometry.normals.length>0){var normals=new Float32Array(geometry.normals.length*3);this.addAttribute('normal',new BufferAttribute(normals,3).copyVector3sArray(geometry.normals));}if(geometry.colors.length>0){var colors=new Float32Array(geometry.colors.length*3);this.addAttribute('color',new BufferAttribute(colors,3).copyColorsArray(geometry.colors));}if(geometry.uvs.length>0){var uvs=new Float32Array(geometry.uvs.length*2);this.addAttribute('uv',new BufferAttribute(uvs,2).copyVector2sArray(geometry.uvs));}if(geometry.uvs2.length>0){var uvs2=new Float32Array(geometry.uvs2.length*2);this.addAttribute('uv2',new BufferAttribute(uvs2,2).copyVector2sArray(geometry.uvs2));}if(geometry.indices.length>0){var TypeArray=geometry.vertices.length>65535?Uint32Array:Uint16Array;var indices=new TypeArray(geometry.indices.length*3);this.setIndex(new BufferAttribute(indices,1).copyIndicesArray(geometry.indices));}// groups
this.groups=geometry.groups;// morphs
for(var name in geometry.morphTargets){var array=[];var morphTargets=geometry.morphTargets[name];for(var i=0,l=morphTargets.length;i<l;i++){var morphTarget=morphTargets[i];var attribute=new Float32BufferAttribute(morphTarget.length*3,3);array.push(attribute.copyVector3sArray(morphTarget));}this.morphAttributes[name]=array;}// skinning
if(geometry.skinIndices.length>0){var skinIndices=new Float32BufferAttribute(geometry.skinIndices.length*4,4);this.addAttribute('skinIndex',skinIndices.copyVector4sArray(geometry.skinIndices));}if(geometry.skinWeights.length>0){var skinWeights=new Float32BufferAttribute(geometry.skinWeights.length*4,4);this.addAttribute('skinWeight',skinWeights.copyVector4sArray(geometry.skinWeights));}//
if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}return this;},computeBoundingBox:function computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}var position=this.attributes.position;if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);}else{this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}},computeBoundingSphere:function(){var box=new Box3();var vector=new Vector3();return function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}var position=this.attributes.position;if(position){var center=this.boundingSphere.center;box.setFromBufferAttribute(position);box.getCenter(center);// hoping to find a boundingSphere with a radius smaller than the
// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
var maxRadiusSq=0;for(var i=0,il=position.count;i<il;i++){vector.x=position.getX(i);vector.y=position.getY(i);vector.z=position.getZ(i);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(vector));}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}};}(),computeFaceNormals:function computeFaceNormals(){// backwards compatibility
},computeVertexNormals:function computeVertexNormals(){var index=this.index;var attributes=this.attributes;var groups=this.groups;if(attributes.position){var positions=attributes.position.array;if(attributes.normal===undefined){this.addAttribute('normal',new BufferAttribute(new Float32Array(positions.length),3));}else{// reset existing normals to zero
var array=attributes.normal.array;for(var i=0,il=array.length;i<il;i++){array[i]=0;}}var normals=attributes.normal.array;var vA,vB,vC;var pA=new Vector3(),pB=new Vector3(),pC=new Vector3();var cb=new Vector3(),ab=new Vector3();// indexed elements
if(index){var indices=index.array;if(groups.length===0){this.addGroup(0,indices.length);}for(var j=0,jl=groups.length;j<jl;++j){var group=groups[j];var start=group.start;var count=group.count;for(var i=start,il=start+count;i<il;i+=3){vA=indices[i+0]*3;vB=indices[i+1]*3;vC=indices[i+2]*3;pA.fromArray(positions,vA);pB.fromArray(positions,vB);pC.fromArray(positions,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[vA]+=cb.x;normals[vA+1]+=cb.y;normals[vA+2]+=cb.z;normals[vB]+=cb.x;normals[vB+1]+=cb.y;normals[vB+2]+=cb.z;normals[vC]+=cb.x;normals[vC+1]+=cb.y;normals[vC+2]+=cb.z;}}}else{// non-indexed elements (unconnected triangle soup)
for(var i=0,il=positions.length;i<il;i+=9){pA.fromArray(positions,i);pB.fromArray(positions,i+3);pC.fromArray(positions,i+6);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[i]=cb.x;normals[i+1]=cb.y;normals[i+2]=cb.z;normals[i+3]=cb.x;normals[i+4]=cb.y;normals[i+5]=cb.z;normals[i+6]=cb.x;normals[i+7]=cb.y;normals[i+8]=cb.z;}}this.normalizeNormals();attributes.normal.needsUpdate=true;}},merge:function merge(geometry,offset){if((geometry&&geometry.isBufferGeometry)===false){console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);return;}if(offset===undefined)offset=0;var attributes=this.attributes;for(var key in attributes){if(geometry.attributes[key]===undefined)continue;var attribute1=attributes[key];var attributeArray1=attribute1.array;var attribute2=geometry.attributes[key];var attributeArray2=attribute2.array;var attributeSize=attribute2.itemSize;for(var i=0,j=attributeSize*offset;i<attributeArray2.length;i++,j++){attributeArray1[j]=attributeArray2[i];}}return this;},normalizeNormals:function normalizeNormals(){var normals=this.attributes.normal.array;var x,y,z,n;for(var i=0,il=normals.length;i<il;i+=3){x=normals[i];y=normals[i+1];z=normals[i+2];n=1.0/Math.sqrt(x*x+y*y+z*z);normals[i]*=n;normals[i+1]*=n;normals[i+2]*=n;}},toNonIndexed:function toNonIndexed(){if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');return this;}var geometry2=new BufferGeometry();var indices=this.index.array;var attributes=this.attributes;for(var name in attributes){var attribute=attributes[name];var array=attribute.array;var itemSize=attribute.itemSize;var array2=new array.constructor(indices.length*itemSize);var index=0,index2=0;for(var i=0,l=indices.length;i<l;i++){index=indices[i]*itemSize;for(var j=0;j<itemSize;j++){array2[index2++]=array[index++];}}geometry2.addAttribute(name,new BufferAttribute(array2,itemSize));}return geometry2;},toJSON:function toJSON(){var data={metadata:{version:4.4,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}data.data={attributes:{}};var index=this.index;if(index!==null){var array=Array.prototype.slice.call(index.array);data.data.index={type:index.array.constructor.name,array:array};}var attributes=this.attributes;for(var key in attributes){var attribute=attributes[key];var array=Array.prototype.slice.call(attribute.array);data.data.attributes[key]={itemSize:attribute.itemSize,type:attribute.array.constructor.name,array:array,normalized:attribute.normalized};}var groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse((0,_stringify2.default)(groups));}var boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;},clone:function clone(){/*
			// Handle primitives

			var parameters = this.parameters;

			if ( parameters !== undefined ) {

				var values = [];

				for ( var key in parameters ) {

					values.push( parameters[ key ] );

				}

				var geometry = Object.create( this.constructor.prototype );
				this.constructor.apply( geometry, values );
				return geometry;

			}

			return new this.constructor().copy( this );
			*/return new BufferGeometry().copy(this);},copy:function copy(source){var name,i,l;// reset
this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// name
this.name=source.name;// index
var index=source.index;if(index!==null){this.setIndex(index.clone());}// attributes
var attributes=source.attributes;for(name in attributes){var attribute=attributes[name];this.addAttribute(name,attribute.clone());}// morph attributes
var morphAttributes=source.morphAttributes;for(name in morphAttributes){var array=[];var morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
for(i=0,l=morphAttribute.length;i<l;i++){array.push(morphAttribute[i].clone());}this.morphAttributes[name]=array;}// groups
var groups=source.groups;for(i=0,l=groups.length;i<l;i++){var group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}};BufferGeometry.MaxIndex=65535;(0,_assign2.default)(BufferGeometry.prototype,EventDispatcher.prototype);/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */function Mesh(geometry,material){Object3D.call(this);this.type='Mesh';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new MeshBasicMaterial({color:Math.random()*0xffffff});this.drawMode=TrianglesDrawMode;this.updateMorphTargets();}Mesh.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:Mesh,isMesh:true,setDrawMode:function setDrawMode(value){this.drawMode=value;},copy:function copy(source){Object3D.prototype.copy.call(this,source);this.drawMode=source.drawMode;return this;},updateMorphTargets:function updateMorphTargets(){var morphTargets=this.geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var m=0,ml=morphTargets.length;m<ml;m++){this.morphTargetInfluences.push(0);this.morphTargetDictionary[morphTargets[m].name]=m;}}},raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();var vA=new Vector3();var vB=new Vector3();var vC=new Vector3();var tempA=new Vector3();var tempB=new Vector3();var tempC=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();var barycoord=new Vector3();var intersectionPoint=new Vector3();var intersectionPointWorld=new Vector3();function uvIntersection(point,p1,p2,p3,uv1,uv2,uv3){Triangle.barycoordFromPoint(point,p1,p2,p3,barycoord);uv1.multiplyScalar(barycoord.x);uv2.multiplyScalar(barycoord.y);uv3.multiplyScalar(barycoord.z);uv1.add(uv2).add(uv3);return uv1.clone();}function checkIntersection(object,raycaster,ray,pA,pB,pC,point){var intersect;var material=object.material;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else{intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);}if(intersect===null)return null;intersectionPointWorld.copy(point);intersectionPointWorld.applyMatrix4(object.matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return{distance:distance,point:intersectionPointWorld.clone(),object:object};}function checkBufferGeometryIntersection(object,raycaster,ray,position,uv,a,b,c){vA.fromBufferAttribute(position,a);vB.fromBufferAttribute(position,b);vC.fromBufferAttribute(position,c);var intersection=checkIntersection(object,raycaster,ray,vA,vB,vC,intersectionPoint);if(intersection){if(uv){uvA.fromBufferAttribute(uv,a);uvB.fromBufferAttribute(uv,b);uvC.fromBufferAttribute(uv,c);intersection.uv=uvIntersection(intersectionPoint,vA,vB,vC,uvA,uvB,uvC);}intersection.face=new Face3(a,b,c,Triangle.normal(vA,vB,vC));intersection.faceIndex=a;}return intersection;}return function raycast(raycaster,intersects){var geometry=this.geometry;var material=this.material;var matrixWorld=this.matrixWorld;if(material===undefined)return;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);// Check boundingBox before continuing
if(geometry.boundingBox!==null){if(ray.intersectsBox(geometry.boundingBox)===false)return;}var intersection;if(geometry.isBufferGeometry){var a,b,c;var index=geometry.index;var position=geometry.attributes.position;var uv=geometry.attributes.uv;var i,l;if(index!==null){// indexed buffer geometry
for(i=0,l=index.count;i<l;i+=3){a=index.getX(i);b=index.getX(i+1);c=index.getX(i+2);intersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in indices buffer semantics
intersects.push(intersection);}}}else{// non-indexed buffer geometry
for(i=0,l=position.count;i<l;i+=3){a=i;b=i+1;c=i+2;intersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);if(intersection){intersection.index=a;// triangle number in positions buffer semantics
intersects.push(intersection);}}}}else if(geometry.isGeometry){var fvA,fvB,fvC;var isFaceMaterial=material&&material.isMultiMaterial;var materials=isFaceMaterial===true?material.materials:null;var vertices=geometry.vertices;var faces=geometry.faces;var uvs;var faceVertexUvs=geometry.faceVertexUvs[0];if(faceVertexUvs.length>0)uvs=faceVertexUvs;for(var f=0,fl=faces.length;f<fl;f++){var face=faces[f];var faceMaterial=isFaceMaterial===true?materials[face.materialIndex]:material;if(faceMaterial===undefined)continue;fvA=vertices[face.a];fvB=vertices[face.b];fvC=vertices[face.c];if(faceMaterial.morphTargets===true){var morphTargets=geometry.morphTargets;var morphInfluences=this.morphTargetInfluences;vA.set(0,0,0);vB.set(0,0,0);vC.set(0,0,0);for(var t=0,tl=morphTargets.length;t<tl;t++){var influence=morphInfluences[t];if(influence===0)continue;var targets=morphTargets[t].vertices;vA.addScaledVector(tempA.subVectors(targets[face.a],fvA),influence);vB.addScaledVector(tempB.subVectors(targets[face.b],fvB),influence);vC.addScaledVector(tempC.subVectors(targets[face.c],fvC),influence);}vA.add(fvA);vB.add(fvB);vC.add(fvC);fvA=vA;fvB=vB;fvC=vC;}intersection=checkIntersection(this,raycaster,ray,fvA,fvB,fvC,intersectionPoint);if(intersection){if(uvs){var uvs_f=uvs[f];uvA.copy(uvs_f[0]);uvB.copy(uvs_f[1]);uvC.copy(uvs_f[2]);intersection.uv=uvIntersection(intersectionPoint,fvA,fvB,fvC,uvA,uvB,uvC);}intersection.face=face;intersection.faceIndex=f;intersects.push(intersection);}}}};}(),clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */function BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){BufferGeometry.call(this);this.type='BoxBufferGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};var scope=this;// segments
widthSegments=Math.floor(widthSegments)||1;heightSegments=Math.floor(heightSegments)||1;depthSegments=Math.floor(depthSegments)||1;// these are used to calculate buffer length
var vertexCount=calculateVertexCount(widthSegments,heightSegments,depthSegments);var indexCount=calculateIndexCount(widthSegments,heightSegments,depthSegments);// buffers
var indices=new(indexCount>65535?Uint32Array:Uint16Array)(indexCount);var vertices=new Float32Array(vertexCount*3);var normals=new Float32Array(vertexCount*3);var uvs=new Float32Array(vertexCount*2);// offset variables
var vertexBufferOffset=0;var uvBufferOffset=0;var indexBufferOffset=0;var numberOfVertices=0;// group variables
var groupStart=0;// build each side of the box geometry
buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
// build geometry
this.setIndex(new BufferAttribute(indices,1));this.addAttribute('position',new BufferAttribute(vertices,3));this.addAttribute('normal',new BufferAttribute(normals,3));this.addAttribute('uv',new BufferAttribute(uvs,2));// helper functions
function calculateVertexCount(w,h,d){var vertices=0;// calculate the amount of vertices for each side (plane)
vertices+=(w+1)*(h+1)*2;// xy
vertices+=(w+1)*(d+1)*2;// xz
vertices+=(d+1)*(h+1)*2;// zy
return vertices;}function calculateIndexCount(w,h,d){var index=0;// calculate the amount of squares for each side
index+=w*h*2;// xy
index+=w*d*2;// xz
index+=d*h*2;// zy
return index*6;// two triangles per square => six vertices per square
}function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){var segmentWidth=width/gridX;var segmentHeight=height/gridY;var widthHalf=width/2;var heightHalf=height/2;var depthHalf=depth/2;var gridX1=gridX+1;var gridY1=gridY+1;var vertexCounter=0;var groupCount=0;var vector=new Vector3();// generate vertices, normals and uvs
for(var iy=0;iy<gridY1;iy++){var y=iy*segmentHeight-heightHalf;for(var ix=0;ix<gridX1;ix++){var x=ix*segmentWidth-widthHalf;// set values to correct vector component
vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
vertices[vertexBufferOffset]=vector.x;vertices[vertexBufferOffset+1]=vector.y;vertices[vertexBufferOffset+2]=vector.z;// set values to correct vector component
vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
normals[vertexBufferOffset]=vector.x;normals[vertexBufferOffset+1]=vector.y;normals[vertexBufferOffset+2]=vector.z;// uvs
uvs[uvBufferOffset]=ix/gridX;uvs[uvBufferOffset+1]=1-iy/gridY;// update offsets and counters
vertexBufferOffset+=3;uvBufferOffset+=2;vertexCounter+=1;}}// 1. you need three indices to draw a single face
// 2. a single segment consists of two faces
// 3. so we need to generate six (2*3) indices per segment
for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){// indices
var a=numberOfVertices+ix+gridX1*iy;var b=numberOfVertices+ix+gridX1*(iy+1);var c=numberOfVertices+(ix+1)+gridX1*(iy+1);var d=numberOfVertices+(ix+1)+gridX1*iy;// face one
indices[indexBufferOffset]=a;indices[indexBufferOffset+1]=b;indices[indexBufferOffset+2]=d;// face two
indices[indexBufferOffset+3]=b;indices[indexBufferOffset+4]=c;indices[indexBufferOffset+5]=d;// update offsets and counters
indexBufferOffset+=6;groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
groupStart+=groupCount;// update total number of vertices
numberOfVertices+=vertexCounter;}}BoxBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);BoxBufferGeometry.prototype.constructor=BoxBufferGeometry;/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */function PlaneBufferGeometry(width,height,widthSegments,heightSegments){BufferGeometry.call(this);this.type='PlaneBufferGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};var width_half=width/2;var height_half=height/2;var gridX=Math.floor(widthSegments)||1;var gridY=Math.floor(heightSegments)||1;var gridX1=gridX+1;var gridY1=gridY+1;var segment_width=width/gridX;var segment_height=height/gridY;var vertices=new Float32Array(gridX1*gridY1*3);var normals=new Float32Array(gridX1*gridY1*3);var uvs=new Float32Array(gridX1*gridY1*2);var offset=0;var offset2=0;for(var iy=0;iy<gridY1;iy++){var y=iy*segment_height-height_half;for(var ix=0;ix<gridX1;ix++){var x=ix*segment_width-width_half;vertices[offset]=x;vertices[offset+1]=-y;normals[offset+2]=1;uvs[offset2]=ix/gridX;uvs[offset2+1]=1-iy/gridY;offset+=3;offset2+=2;}}offset=0;var indices=new(vertices.length/3>65535?Uint32Array:Uint16Array)(gridX*gridY*6);for(var iy=0;iy<gridY;iy++){for(var ix=0;ix<gridX;ix++){var a=ix+gridX1*iy;var b=ix+gridX1*(iy+1);var c=ix+1+gridX1*(iy+1);var d=ix+1+gridX1*iy;indices[offset]=a;indices[offset+1]=b;indices[offset+2]=d;indices[offset+3]=b;indices[offset+4]=c;indices[offset+5]=d;offset+=6;}}this.setIndex(new BufferAttribute(indices,1));this.addAttribute('position',new BufferAttribute(vertices,3));this.addAttribute('normal',new BufferAttribute(normals,3));this.addAttribute('uv',new BufferAttribute(uvs,2));}PlaneBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);PlaneBufferGeometry.prototype.constructor=PlaneBufferGeometry;/**
	 * @author Ben Houston / bhouston / http://clara.io
	 *
	 */function MaterialMap(name,uvChannel,uvTransform,texelTransform){this.name=name||"unnamed";this.texture=null;this.uvChannel=uvChannel||0;this.uvTransform=uvTransform||false;this.uvOffset=new Vector2(0,0);this.uvRepeat=new Vector2(1.0,1.0);//this.uvRotation = 0;  - not implemented because offset/repeat fix in a vec4 uniform, rotation doesn't.
this.texelTransform=uvTransform||false;this.texelScale=1.0;this.texelOffset=0.0;this.texelInvert=false;}MaterialMap.prototype={constructor:MaterialMap,copy:function copy(source){this.name=source.name;this.texture=source.texture;this.uvChannel=source.uvChannel;this.uvTransform=source.uvTransform;this.uvOffset=source.uvOffset;this.uvRepeat=source.uvRepeat;//this.uvRotation = source.uvRotation;
this.texelTransform=source.texelTransform;this.texelScale=source.texelScale;this.texelOffset=source.texelOffset;this.texelInvert=source.texelInvert;return this;},// bakes all the input texel parameters into just two.
getFlattenedTexelTransform:function getFlattenedTexelTransform(optionalTexelTransform){var texelTransform=optionalTexelTransform||{};if(this.texelInvert){texelTransform.texelScale=-this.texelScale;texelTransform.texelOffset=this.texelScale+this.texelOffset;}else{texelTransform.texelScale=this.texelScale;texelTransform.texelOffset=this.texelOffset;}return texelTransform;}};MaterialMap.SupportedMapNames=['map','lightMap','aoMap','emissiveMap','specularMap','bumpMap','normalMap','roughnessMap','metalnessMap','alphaMap','displacementMap','falloffMap','falloffAlphaMap','anisotropyMap','anisotropyRotationMap'];MaterialMap.SupportedMapSlotNames=[];MaterialMap.SupportedMapUVNames=[];MaterialMap.SupportedMapTexelNames=[];for(var i=0;i<MaterialMap.SupportedMapNames.length;i++){var name=MaterialMap.SupportedMapNames[i];MaterialMap.SupportedMapSlotNames.push(name+'Slot');MaterialMap.SupportedMapUVNames.push(name+'UVTransformParams');MaterialMap.SupportedMapTexelNames.push(name+'TexelTransformParams');}/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/function Camera(){Object3D.call(this);this.type='Camera';this.matrixWorldInverse=new Matrix4();this.projectionMatrix=new Matrix4();}Camera.prototype=(0,_create2.default)(Object3D.prototype);Camera.prototype.constructor=Camera;Camera.prototype.isCamera=true;Camera.prototype.getWorldDirection=function(){var quaternion=new Quaternion();return function getWorldDirection(optionalTarget){var result=optionalTarget||new Vector3();this.getWorldQuaternion(quaternion);return result.set(0,0,-1).applyQuaternion(quaternion);};}();Camera.prototype.lookAt=function(){// This routine does not support cameras with rotated and/or translated parent(s)
var m1=new Matrix4();return function lookAt(vector){m1.lookAt(this.position,vector,this.up);this.quaternion.setFromRotationMatrix(m1);};}();Camera.prototype.clone=function(){return new this.constructor().copy(this);};Camera.prototype.copy=function(source){Object3D.prototype.copy.call(this,source);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);return this;};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */function PerspectiveCamera(fov,aspect,near,far){Camera.call(this);this.type='PerspectiveCamera';this.fov=fov!==undefined?fov:50;this.zoom=1;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.focus=10;this.aspect=aspect!==undefined?aspect:1;this.view=null;this.filmGauge=35;// width of the film (default in millimeters)
this.filmOffset=0;// horizontal film offset (same unit as gauge)
this.updateProjectionMatrix();}PerspectiveCamera.prototype=(0,_assign2.default)((0,_create2.default)(Camera.prototype),{constructor:PerspectiveCamera,isPerspectiveCamera:true,copy:function copy(source){Camera.prototype.copy.call(this,source);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:(0,_assign2.default)({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;},/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */setFocalLength:function setFocalLength(focalLength){// see http://www.bobatkins.com/photography/technical/field_of_view.html
var vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=_Math.RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();},/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */getFocalLength:function getFocalLength(){var vExtentSlope=Math.tan(_Math.DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;},getEffectiveFOV:function getEffectiveFOV(){return _Math.RAD2DEG*2*Math.atan(Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom);},getFilmWidth:function getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
return this.filmGauge*Math.min(this.aspect,1);},getFilmHeight:function getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
return this.filmGauge/Math.max(this.aspect,1);},/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */setViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){if(!fullWidth){this.view=null;return;}this.aspect=fullWidth/fullHeight;this.view={fullWidth:fullWidth,fullHeight:fullHeight,offsetX:x,offsetY:y,width:width,height:height};this.updateProjectionMatrix();},clearViewOffset:function clearViewOffset(){this.view=null;this.updateProjectionMatrix();},updateProjectionMatrix:function updateProjectionMatrix(){var near=this.near,top=near*Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom,height=2*top,width=this.aspect*height,left=-0.5*width,view=this.view;if(view!==null){var fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}var skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=(0,_assign2.default)({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}});/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */function OrthographicCamera(left,right,top,bottom,near,far){Camera.call(this);this.type='OrthographicCamera';this.zoom=1;this.view=null;this.left=left;this.right=right;this.top=top;this.bottom=bottom;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.updateProjectionMatrix();}OrthographicCamera.prototype=(0,_assign2.default)((0,_create2.default)(Camera.prototype),{constructor:OrthographicCamera,isOrthographicCamera:true,copy:function copy(source){Camera.prototype.copy.call(this,source);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:(0,_assign2.default)({},source.view);return this;},setViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){this.view={fullWidth:fullWidth,fullHeight:fullHeight,offsetX:x,offsetY:y,width:width,height:height};this.updateProjectionMatrix();},clearViewOffset:function clearViewOffset(){this.view=null;this.updateProjectionMatrix();},updateProjectionMatrix:function updateProjectionMatrix(){var dx=(this.right-this.left)/(2*this.zoom);var dy=(this.top-this.bottom)/(2*this.zoom);var cx=(this.right+this.left)/2;var cy=(this.top+this.bottom)/2;var left=cx-dx;var right=cx+dx;var top=cy+dy;var bottom=cy-dy;if(this.view!==null){var zoomW=this.zoom/(this.view.width/this.view.fullWidth);var zoomH=this.zoom/(this.view.height/this.view.fullHeight);var scaleW=(this.right-this.left)/this.view.width;var scaleH=(this.top-this.bottom)/this.view.height;left+=scaleW*(this.view.offsetX/zoomW);right=left+scaleW*(this.view.width/zoomW);top-=scaleH*(this.view.offsetY/zoomH);bottom=top-scaleH*(this.view.height/zoomH);}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=(0,_assign2.default)({},this.view);return data;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLIndexedBufferRenderer(gl,extensions,infoRender){var mode;function setMode(value){mode=value;}var type,size;function setIndex(index){if(index.array instanceof Uint32Array&&extensions.get('OES_element_index_uint')){type=gl.UNSIGNED_INT;size=4;}else if(index.array instanceof Uint16Array){type=gl.UNSIGNED_SHORT;size=2;}else{type=gl.UNSIGNED_BYTE;size=1;}}function render(start,count){gl.drawElements(mode,count,type,start*size);infoRender.calls++;infoRender.vertices+=count;if(mode===gl.TRIANGLES)infoRender.faces+=count/3;}function renderInstances(geometry,start,count){var extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}extension.drawElementsInstancedANGLE(mode,count,type,start*size,geometry.maxInstancedCount);infoRender.calls++;infoRender.vertices+=count*geometry.maxInstancedCount;if(mode===gl.TRIANGLES)infoRender.faces+=geometry.maxInstancedCount*count/3;}return{setMode:setMode,setIndex:setIndex,render:render,renderInstances:renderInstances};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLBufferRenderer(gl,extensions,infoRender){var mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);infoRender.calls++;infoRender.vertices+=count;if(mode===gl.TRIANGLES)infoRender.faces+=count/3;}function renderInstances(geometry){var extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}var position=geometry.attributes.position;var count=0;if(position.isInterleavedBufferAttribute){count=position.data.count;extension.drawArraysInstancedANGLE(mode,0,count,geometry.maxInstancedCount);}else{count=position.count;extension.drawArraysInstancedANGLE(mode,0,count,geometry.maxInstancedCount);}infoRender.calls++;infoRender.vertices+=count*geometry.maxInstancedCount;if(mode===gl.TRIANGLES)infoRender.faces+=geometry.maxInstancedCount*count/3;}return{setMode:setMode,render:render,renderInstances:renderInstances};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLLights(){var lights={};return{get:function get(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new Vector3(),color:new Color(),shadow:false,shadowBias:0,shadowRadius:1,shadowSpreadAngle:0,shadowMapSize:new Vector2(),shadowCameraParams:new Vector3()};break;case'SpotLight':uniforms={position:new Vector3(),direction:new Vector3(),color:new Color(),distance:0,coneCos:0,penumbraCos:0,decay:0,shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2(),shadowCameraParams:new Vector3()};break;case'PointLight':uniforms={position:new Vector3(),color:new Color(),distance:0,decay:0,shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'HemisphereLight':uniforms={direction:new Vector3(),skyColor:new Color(),groundColor:new Color()};break;case'RectAreaLight':uniforms={color:new Color(),position:new Vector3(),halfWidth:new Vector3(),halfHeight:new Vector3()// TODO (abelnation): set RectAreaLight shadow uniforms
};break;}lights[light.id]=uniforms;return uniforms;}};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function addLineNumbers(string){var lines=string.split('\n');for(var i=0;i<lines.length;i++){lines[i]=i+1+': '+lines[i];}return lines.join('\n');}function WebGLShader(gl,type,string){var shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);if(gl.getShaderParameter(shader,gl.COMPILE_STATUS)===false){console.error('THREE.WebGLShader: Shader couldn\'t compile.',gl.getShaderInfoLog(shader),addLineNumbers(string));}if(gl.getShaderInfoLog(shader)!==''){console.warn('THREE.WebGLShader: gl.getShaderInfoLog()',type===gl.VERTEX_SHADER?'vertex':'fragment',gl.getShaderInfoLog(shader),addLineNumbers(string));}// --enable-privileged-webgl-extension
// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
return shader;}/**
	 * @author mrdoob / http://mrdoob.com/
	 */var programIdCount=0;function getEncodingComponents(encoding){switch(encoding){case LinearEncoding:return['Linear','( value )'];case sRGBEncoding:return['sRGB','( value )'];case RGBEEncoding:return['RGBE','( value )'];case RGBM7Encoding:return['RGBM','( value, 7.0 )'];case RGBM16Encoding:return['RGBM','( value, 16.0 )'];case RGBDEncoding:return['RGBD','( value, 256.0 )'];case GammaEncoding:return['Gamma','( value, float( GAMMA_FACTOR ) )'];default:throw new Error('unsupported encoding: '+encoding);}}function getTexelDecodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return"vec4 "+functionName+"( vec4 value ) { return "+components[0]+"ToLinear"+components[1]+"; }";}function getTexelEncodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return"vec4 "+functionName+"( vec4 value ) { return LinearTo"+components[0]+components[1]+"; }";}function getTexelTransformFunction(mapName,map){if(!map||!map.texelTransform){return"vec4 "+mapName+"TexelTransform( vec4 value ) { return value; }\n";}var transform=map.getFlattenedTexelTransform();var template=ShaderChunk['slot_texel_transform_template'];var result=template.replace(/\$SLOT_NAME\$/g,mapName);return result;}function getUVFunction(mapName,map,isVertexShader){var uvVariableName=isVertexShader?"uv":"vUv";if(map&&map.uvChannel>0){uvVariableName+=map.uvChannel+1;}if(!map||!map.uvTransform){return"vec2 "+mapName+"UV() { return "+uvVariableName+"; }\n";}var transform=map.getFlattenedTexelTransform();var template=ShaderChunk['slot_uv_transform_template'];var result=template.replace(/\$SLOT_NAME\$/g,mapName);result=result.replace(/\$UV_VAR_NAME\$/g,uvVariableName);return result;}function getToneMappingFunction(functionName,toneMapping){var toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName="Linear";break;case ReinhardToneMapping:toneMappingName="Reinhard";break;case Uncharted2ToneMapping:toneMappingName="Uncharted2";break;case CineonToneMapping:toneMappingName="OptimizedCineon";break;default:throw new Error('unsupported toneMapping: '+toneMapping);}return"vec3 "+functionName+"( vec3 color ) { return "+toneMappingName+"ToneMapping( color ); }";}function generateExtensions(extensions,parameters,rendererExtensions){extensions=extensions||{};var chunks=[extensions.derivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.normalMap||parameters.flatShading?'#extension GL_OES_standard_derivatives : enable':'',(extensions.fragDepth||parameters.logarithmicDepthBuffer)&&rendererExtensions.get('EXT_frag_depth')?'#extension GL_EXT_frag_depth : enable':'',extensions.drawBuffers&&rendererExtensions.get('WEBGL_draw_buffers')?'#extension GL_EXT_draw_buffers : require':'',(extensions.shaderTextureLOD||parameters.envMap)&&rendererExtensions.get('EXT_shader_texture_lod')?'#extension GL_EXT_shader_texture_lod : enable':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){var chunks=[];for(var name in defines){var value=defines[name];if(value===false)continue;chunks.push('#define '+name+' '+value);}return chunks.join('\n');}function fetchAttributeLocations(gl,program,identifiers){var attributes={};var n=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(var i=0;i<n;i++){var info=gl.getActiveAttrib(program,i);var name=info.name;// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
attributes[name]=gl.getAttribLocation(program,name);}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights);}function parseIncludes(string){var pattern=/#include +<([\w\d.]+)>/g;function replace(match,include){var replace=ShaderChunk[include];if(replace===undefined){throw new Error('Can not resolve #include <'+include+'>');}return parseIncludes(replace);}return string.replace(pattern,replace);}function unrollLoops(string){var pattern=/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;function replace(match,start,end,snippet){var unroll='';for(var i=parseInt(start);i<parseInt(end);i++){unroll+=snippet.replace(/\[ i \]/g,'[ '+i+' ]');}return unroll;}return string.replace(pattern,replace);}function WebGLProgram(renderer,code,material,parameters){var gl=renderer.context;var extensions=material.extensions;var defines=material.defines;var vertexShader=material.__webglShader.vertexShader;var fragmentShader=material.__webglShader.fragmentShader;var shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCSSSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCSS';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}var envMapTypeDefine='ENVMAP_TYPE_CUBE';var envMapModeDefine='ENVMAP_MODE_REFLECTION';var envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';if(parameters.envMap){switch(material.envMap.mapping){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:case CubeUVRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;case EquirectangularReflectionMapping:case EquirectangularRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_EQUIREC';break;case SphericalReflectionMapping:envMapTypeDefine='ENVMAP_TYPE_SPHERE';break;}switch(material.envMap.mapping){case CubeRefractionMapping:case EquirectangularRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}switch(material.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}var gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;// console.log( 'building new program ' );
//
var customExtensions=generateExtensions(extensions,parameters,renderer.extensions);var customDefines=generateDefines(defines);//
var program=gl.createProgram();var prefixVertex,prefixFragment;if(material.isRawShaderMaterial){prefixVertex=[customDefines,'\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,customDefines,'\n'].filter(filterEmptyLine).join('\n');}else{prefixVertex=['precision '+parameters.precision+' float;','precision '+parameters.precision+' int;','#define SHADER_NAME '+material.__webglShader.name,customDefines,parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'','#define GAMMA_FACTOR '+gammaFactorDefine,'#define MAX_BONES '+parameters.maxBones,parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.falloffMap&&parameters.falloff?'#define USE_FALLOFFMAP':'',parameters.falloffAlphaMap&&parameters.falloff?'#define USE_FALLOFFALPHAMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.anisotropy?"#define ANISOTROPY":"",parameters.skinning?'#define USE_SKINNING':'',parameters.useVertexTexture?'#define BONE_TEXTURE':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'','#define NUM_CLIPPING_PLANES '+parameters.numClippingPlanes,parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&renderer.extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'',parameters.oit?'#define USE_OIT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_COLOR','	attribute vec3 color;','#endif','#ifdef ANISOTROPY',' attribute vec4 tangent;','#endif','#ifdef USE_MORPHTARGETS','	attribute vec3 morphTarget0;','	attribute vec3 morphTarget1;','	attribute vec3 morphTarget2;','	attribute vec3 morphTarget3;','	#ifdef USE_MORPHNORMALS','		attribute vec3 morphNormal0;','		attribute vec3 morphNormal1;','		attribute vec3 morphNormal2;','		attribute vec3 morphNormal3;','	#else','		attribute vec3 morphTarget4;','		attribute vec3 morphTarget5;','		attribute vec3 morphTarget6;','		attribute vec3 morphTarget7;','	#endif','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,'precision '+parameters.precision+' float;','precision '+parameters.precision+' int;','#define SHADER_NAME '+material.__webglShader.name,customDefines,parameters.alphaTest?'#define ALPHATEST '+parameters.alphaTest:'',parameters.falloff?'#define FALLOFF':'',parameters.falloffMap&&parameters.falloff?'#define USE_FALLOFFMAP':'',parameters.falloffAlphaMap&&parameters.falloff?'#define USE_FALLOFFALPHAMAP':'',//parameters.flatShading ? '#define FLAT_SHADED' : '',
'#define GAMMA_FACTOR '+gammaFactorDefine,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.anisotropy?"#define ANISOTROPY":"",parameters.anisotropyMap?"#define USE_ANISOTROPYMAP":"",parameters.anisotropy&&parameters.anisotropyRotation?"#define ANISOTROPYROTATION":"",parameters.anisotropy&&parameters.anisotropyRotationMap?"#define USE_ANISOTROPYROTATIONMAP":"",parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'','#define NUM_CLIPPING_PLANES '+parameters.numClippingPlanes,'#define UNION_CLIPPING_PLANES '+(parameters.numClippingPlanes-parameters.numClipIntersection),parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":'',parameters.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&renderer.extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'',parameters.outputEncoding||parameters.mapEncoding||parameters.envMapEncoding||parameters.falloffMapEncoding||parameters.emissiveMapEncoding?ShaderChunk['encodings_pars_fragment']:'',// this code is required here because it is used by the various encoding/decoding function defined below
parameters.mapEncoding?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',parameters.envMapEncoding?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',parameters.emissiveMapEncoding?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',parameters.falloffMapEncoding?getTexelDecodingFunction('falloffMapTexelToLinear',parameters.falloffMapEncoding):'',parameters.outputEncoding?getTexelEncodingFunction("linearToOutputTexel",parameters.outputEncoding):'',parameters.depthPacking?"#define DEPTH_PACKING "+material.depthPacking:'',parameters.envMap&&renderer.extensions.get('EXT_shader_texture_lod')?'#define TEXTURE_LOD_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;',parameters.toneMapping!==NoToneMapping?"#define TONE_MAPPING":'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
parameters.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",parameters.toneMapping):'',parameters.depthPacking?"#define DEPTH_PACKING "+material.depthPacking:'',parameters.oit?'#define USE_OIT':'','\n'].filter(filterEmptyLine).join('\n');var supportedMapNames=MaterialMap.SupportedMapNames;var mapUVChannelsCode="";var mapTexelTransformCode="";var mapUvChannels={};for(var i=0;i<supportedMapNames.length;i++){var mapName=supportedMapNames[i];var map=material[mapName+'Slot'];if(material[mapName]||map&&map.texture){if(map&&!mapUvChannels[map.uvChannel])mapUvChannels[map.uvChannel]=true;mapTexelTransformCode+=getTexelTransformFunction(mapName,map);mapUVChannelsCode+="uniform sampler2D "+mapName+";\n";mapUVChannelsCode+=getUVFunction(mapName,map,false);}}if((0,_keys2.default)(mapUvChannels).length>0){var mapUVPrefix="";mapUVPrefix+="#define TEXTURE_SLOTS\n";for(var uvChannel in mapUvChannels){uvChannel=parseInt(uvChannel);var uvChannelName="vUv";if(uvChannel>0)uvChannelName+=''+(uvChannel+1);mapUVPrefix+="varying vec2 "+uvChannelName+";\n";}prefixFragment+=mapUVPrefix+mapUVChannelsCode;}prefixFragment+=mapTexelTransformCode;}vertexShader=parseIncludes(vertexShader,parameters);vertexShader=replaceLightNums(vertexShader,parameters);fragmentShader=parseIncludes(fragmentShader,parameters);fragmentShader=replaceLightNums(fragmentShader,parameters);if(!material.isShaderMaterial){vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);}var vertexGlsl=prefixVertex+vertexShader;var fragmentGlsl=prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
// console.log( '*FRAGMENT*', fragmentGlsl );
var glVertexShader=WebGLShader(gl,gl.VERTEX_SHADER,vertexGlsl);var glFragmentShader=WebGLShader(gl,gl.FRAGMENT_SHADER,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
if(material.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,material.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);var programLog=gl.getProgramInfoLog(program);var vertexLog=gl.getShaderInfoLog(glVertexShader);var fragmentLog=gl.getShaderInfoLog(glFragmentShader);var runnable=true;var haveDiagnostics=true;// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
if(gl.getProgramParameter(program,gl.LINK_STATUS)===false){runnable=false;var debugShaderExtension=gl.getExtension('WEBGL_debug_shaders');if(debugShaderExtension){console.log('**VERTEX**',vertexGlsl,"----------------------------------------------------------",gl.getExtension('WEBGL_debug_shaders').getTranslatedShaderSource(glVertexShader));console.log('**FRAGMENT**',fragmentGlsl,"----------------------------------------------------------",gl.getExtension('WEBGL_debug_shaders').getTranslatedShaderSource(glFragmentShader));}console.error('THREE.WebGLProgram: shader error: ',gl.getError(),'gl.VALIDATE_STATUS',gl.getProgramParameter(program,gl.VALIDATE_STATUS),'gl.getProgramInfoLog',programLog,vertexLog,fragmentLog);}else if(programLog!==''){console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){this.diagnostics={runnable:runnable,material:material,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}// clean up
gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);// set up caching for uniform locations
var cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){cachedUniforms=new WebGLUniforms(gl,program,renderer);}return cachedUniforms;};// set up caching for attribute locations
var cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){cachedAttributes=fetchAttributeLocations(gl,program);}return cachedAttributes;};// free resource
this.destroy=function(){gl.deleteProgram(program);this.program=undefined;};// DEPRECATED
(0,_defineProperties2.default)(this,{uniforms:{get:function get(){console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');return this.getUniforms();}},attributes:{get:function get(){console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');return this.getAttributes();}}});//
this.id=programIdCount++;this.code=code;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLPrograms(renderer,capabilities){var programs=[];var shaderIDs={MeshDepthMaterial:'depth',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'phong',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',MeshCubeMaterial:'cubeEnv',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points'};var parameterNames=["precision","supportsVertexTextures","map","mapEncoding","envMap","envMapMode","envMapEncoding","lightMap","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","fog","useFog","fogExp","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","shadowMapEnabled","shadowMapType","toneMapping",'physicallyCorrectLights',"alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking",'falloff','falloffMap','falloffAlphaMap'];var supportedMaps=MaterialMap.SupportedMapNames;for(var i=0;i<supportedMaps.length;i++){var name=supportedMaps[i];parameterNames.push(name);parameterNames.push(name+'UVChannel');parameterNames.push(name+'UVTransform');parameterNames.push(name+'TexelTransform');}function allocateBones(object){if(capabilities.floatVertexTextures&&object&&object.skeleton&&object.skeleton.useVertexTexture){return 1024;}else{// default for when object is not specified
// ( for example when prebuilding shader to be used with multiple objects )
//
//  - leave some extra space for other uniforms
//  - limit here is ANGLE's 254 max uniform vectors
//    (up to 54 should be safe)
var nVertexUniforms=capabilities.maxVertexUniforms;var nVertexMatrices=Math.floor((nVertexUniforms-20)/4);var maxBones=nVertexMatrices;if(object!==undefined&&object&&object.isSkinnedMesh){maxBones=Math.min(object.skeleton.bones.length,maxBones);if(maxBones<object.skeleton.bones.length){console.warn('WebGLRenderer: too many bones - '+object.skeleton.bones.length+', this GPU supports just '+maxBones+' (try OpenGL instead of ANGLE)');}}return maxBones;}}function getTextureEncodingFromMap(map,gammaOverrideLinear){var encoding;if(!map){encoding=LinearEncoding;}else if(map.isTexture){encoding=map.encoding;}else if(map.isWebGLRenderTarget){console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");encoding=map.texture.encoding;}// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
if(encoding===LinearEncoding&&gammaOverrideLinear){encoding=GammaEncoding;}return encoding;}this.getParameters=function(material,lights,fog,nClipPlanes,nClipIntersection,object){var shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
// (not to blow over maxLights budget)
var maxBones=allocateBones(object);var precision=renderer.getPrecision();if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}var currentRenderTarget=renderer.getCurrentRenderTarget();var parameters={shaderID:shaderID,precision:precision,supportsVertexTextures:capabilities.vertexTextures,outputEncoding:getTextureEncodingFromMap(!currentRenderTarget?null:currentRenderTarget.texture,renderer.gammaOutput),mapEncoding:getTextureEncodingFromMap(material.map,renderer.gammaInput),envMap:!!material.envMap,envMapMode:material.envMap&&material.envMap.mapping,envMapEncoding:getTextureEncodingFromMap(material.envMap,renderer.gammaInput),envMapCubeUV:!!material.envMap&&(material.envMap.mapping===CubeUVReflectionMapping||material.envMap.mapping===CubeUVRefractionMapping),emissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap,renderer.gammaInput),falloff:material.falloff,falloffMapEncoding:getTextureEncodingFromMap(material.falloffMap,renderer.gammaInput),gradientMap:!!material.gradientMap,combine:material.combine,anisotropy:material.anisotropy!==undefined&&material.anisotropy!==0||!!material.anisotropyMap,anisotropyMap:!!material.anisotropyMap,anisotropyRotation:material.anisotropyRotation!==undefined&&material.anisotropyRotation!==0||!!material.anisotropyRotationMap,anisotropyRotationMap:!!material.anisotropyRotationMap,vertexColors:material.vertexColors,fog:!!fog,useFog:material.fog,fogExp:fog&&fog.isFogExp2,flatShading:material.shading===FlatShading,sizeAttenuation:material.sizeAttenuation,logarithmicDepthBuffer:capabilities.logarithmicDepthBuffer,skinning:material.skinning,maxBones:maxBones,useVertexTexture:capabilities.floatVertexTextures&&object&&object.skeleton&&object.skeleton.useVertexTexture,morphTargets:material.morphTargets,morphNormals:material.morphNormals,maxMorphTargets:renderer.maxMorphTargets,maxMorphNormals:renderer.maxMorphNormals,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numClippingPlanes:nClipPlanes,numClipIntersection:nClipIntersection,shadowMapEnabled:renderer.shadowMap.enabled&&object.receiveShadow&&lights.shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:renderer.toneMapping,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,alphaTest:material.alphaTest,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,depthPacking:material.depthPacking!==undefined?material.depthPacking:false,oit:renderer.transparency===OrderIndependentTransperancy};var supportedMapNames=MaterialMap.SupportedMapNames;for(var i=0;i<supportedMapNames.length;i++){var mapName=supportedMapNames[i];var mapSlotName=MaterialMap.SupportedMapSlotNames[i];// backwards compatibility
parameters[mapName]=!!material[mapName];// new functional for slot-based maps
var map=material[mapSlotName];parameters[mapName+"UVChannel"]=map!==undefined?map.uvChannel:0;parameters[mapName+"UVTransform"]=map!==undefined?map.uvTransform:false;parameters[mapName+"TexelTransform"]=map!==undefined?map.texelTransform:false;}return parameters;};this.getProgramCode=function(material,parameters){var array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else{array.push(material.fragmentShader);array.push(material.vertexShader);}if(material.defines!==undefined){for(var name in material.defines){array.push(name);array.push(material.defines[name]);}}for(var i=0;i<parameterNames.length;i++){array.push(parameters[parameterNames[i]]);}return array.join();};this.acquireProgram=function(material,parameters,code){var program;// Check if code has been already compiled
for(var p=0,pl=programs.length;p<pl;p++){var programInfo=programs[p];if(programInfo.code===code){program=programInfo;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,code,material,parameters);programs.push(program);}return program;};this.releaseProgram=function(program){if(--program.usedTimes===0){// Remove from unordered set
var i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();// Free WebGL resources
program.destroy();}};// Exposed for resource monitoring & error feedback via renderer.info:
this.programs=programs;}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLGeometries(gl,properties,info){var geometries={};function onGeometryDispose(event){var geometry=event.target;var buffergeometry=geometries[geometry.id];if(buffergeometry.index!==null){deleteAttribute(buffergeometry.index);}deleteAttributes(buffergeometry.attributes);geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];// TODO
var property=properties.get(geometry);if(property.wireframe){deleteAttribute(property.wireframe);}properties.delete(geometry);var bufferproperty=properties.get(buffergeometry);if(bufferproperty.wireframe){deleteAttribute(bufferproperty.wireframe);}properties.delete(buffergeometry);//
info.memory.geometries--;}function getAttributeBuffer(attribute){if(attribute.isInterleavedBufferAttribute){return properties.get(attribute.data).__webglBuffer;}return properties.get(attribute).__webglBuffer;}function deleteAttribute(attribute){var buffer=getAttributeBuffer(attribute);if(buffer!==undefined){gl.deleteBuffer(buffer);removeAttributeBuffer(attribute);}}function deleteAttributes(attributes){for(var name in attributes){deleteAttribute(attributes[name]);}}function removeAttributeBuffer(attribute){if(attribute.isInterleavedBufferAttribute){properties.delete(attribute.data);}else{properties.delete(attribute);}}return{get:function get(object){var geometry=object.geometry;if(geometries[geometry.id]!==undefined){return geometries[geometry.id];}geometry.addEventListener('dispose',onGeometryDispose);var buffergeometry;if(geometry.isBufferGeometry){buffergeometry=geometry;}else if(geometry.isGeometry){if(geometry._bufferGeometry===undefined){geometry._bufferGeometry=new BufferGeometry().setFromObject(object);}buffergeometry=geometry._bufferGeometry;}geometries[geometry.id]=buffergeometry;info.memory.geometries++;return buffergeometry;}};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLObjects(gl,properties,info){var geometries=new WebGLGeometries(gl,properties,info);//
function update(object){// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
var geometry=geometries.get(object);if(object.geometry.isGeometry){geometry.updateFromObject(object);}var index=geometry.index;var attributes=geometry.attributes;if(index!==null){updateAttribute(index,gl.ELEMENT_ARRAY_BUFFER);}for(var name in attributes){updateAttribute(attributes[name],gl.ARRAY_BUFFER);}// morph targets
var morphAttributes=geometry.morphAttributes;for(var name in morphAttributes){var array=morphAttributes[name];for(var i=0,l=array.length;i<l;i++){updateAttribute(array[i],gl.ARRAY_BUFFER);}}return geometry;}function updateAttribute(attribute,bufferType){var data=attribute.isInterleavedBufferAttribute?attribute.data:attribute;var attributeProperties=properties.get(data);if(attributeProperties.__webglBuffer===undefined){createBuffer(attributeProperties,data,bufferType);}else if(attributeProperties.version!==data.version){updateBuffer(attributeProperties,data,bufferType);}}function createBuffer(attributeProperties,data,bufferType){attributeProperties.__webglBuffer=gl.createBuffer();gl.bindBuffer(bufferType,attributeProperties.__webglBuffer);var usage=data.dynamic?gl.DYNAMIC_DRAW:gl.STATIC_DRAW;gl.bufferData(bufferType,data.array,usage);var type=gl.FLOAT;var array=data.array;if(array instanceof Float32Array){type=gl.FLOAT;}else if(array instanceof Float64Array){console.warn("Unsupported data buffer format: Float64Array");}else if(array instanceof Uint16Array){type=gl.UNSIGNED_SHORT;}else if(array instanceof Int16Array){type=gl.SHORT;}else if(array instanceof Uint32Array){type=gl.UNSIGNED_INT;}else if(array instanceof Int32Array){type=gl.INT;}else if(array instanceof Int8Array){type=gl.BYTE;}else if(array instanceof Uint8Array){type=gl.UNSIGNED_BYTE;}attributeProperties.bytesPerElement=array.BYTES_PER_ELEMENT;attributeProperties.type=type;attributeProperties.version=data.version;data.onUploadCallback();}function updateBuffer(attributeProperties,data,bufferType){gl.bindBuffer(bufferType,attributeProperties.__webglBuffer);if(data.dynamic===false){gl.bufferData(bufferType,data.array,gl.STATIC_DRAW);}else if(data.updateRange.count===-1){// Not using update ranges
gl.bufferSubData(bufferType,0,data.array);}else if(data.updateRange.count===0){console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');}else{gl.bufferSubData(bufferType,data.updateRange.offset*data.array.BYTES_PER_ELEMENT,data.array.subarray(data.updateRange.offset,data.updateRange.offset+data.updateRange.count));data.updateRange.count=0;// reset range
}attributeProperties.version=data.version;}function getAttributeBuffer(attribute){if(attribute.isInterleavedBufferAttribute){return properties.get(attribute.data).__webglBuffer;}return properties.get(attribute).__webglBuffer;}function getAttributeProperties(attribute){if(attribute.isInterleavedBufferAttribute){return properties.get(attribute.data);}return properties.get(attribute);}function getWireframeAttribute(geometry){var property=properties.get(geometry);if(property.wireframe!==undefined){return property.wireframe;}var indices=[];var index=geometry.index;var attributes=geometry.attributes;var position=attributes.position;// console.time( 'wireframe' );
if(index!==null){var edges={};var array=index.array;for(var i=0,l=array.length;i<l;i+=3){var a=array[i+0];var b=array[i+1];var c=array[i+2];indices.push(a,b,b,c,c,a);}}else{var array=attributes.position.array;for(var i=0,l=array.length/3-1;i<l;i+=3){var a=i+0;var b=i+1;var c=i+2;indices.push(a,b,b,c,c,a);}}// console.timeEnd( 'wireframe' );
var TypeArray=position.count>65535?Uint32Array:Uint16Array;var attribute=new BufferAttribute(new TypeArray(indices),1);updateAttribute(attribute,gl.ELEMENT_ARRAY_BUFFER);property.wireframe=attribute;return attribute;}return{getAttributeBuffer:getAttributeBuffer,getAttributeProperties:getAttributeProperties,getWireframeAttribute:getWireframeAttribute,update:update};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLTextures(_gl,extensions,state,properties,capabilities,paramThreeToGL,info){var _infoMemory=info.memory;var _isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&_gl instanceof WebGL2RenderingContext;//
function clampToMaxSize(image,maxSize){if(image.width>maxSize||image.height>maxSize){// Warning: Scaling through the canvas will only work with images that use
// premultiplied alpha.
var scale=maxSize/Math.max(image.width,image.height);var canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=Math.floor(image.width*scale);canvas.height=Math.floor(image.height*scale);var context=canvas.getContext('2d');context.drawImage(image,0,0,image.width,image.height,0,0,canvas.width,canvas.height);console.warn('THREE.WebGLRenderer: image is too big ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);return canvas;}return image;}function isPowerOfTwo(image){return _Math.isPowerOfTwo(image.width)&&_Math.isPowerOfTwo(image.height);}function makePowerOfTwo(image){if(image instanceof HTMLImageElement||image instanceof HTMLCanvasElement){var canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=_Math.nearestPowerOfTwo(image.width);canvas.height=_Math.nearestPowerOfTwo(image.height);var context=canvas.getContext('2d');context.drawImage(image,0,0,canvas.width,canvas.height);console.warn('THREE.WebGLRenderer: image is not power of two ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);return canvas;}return image;}function textureNeedsPowerOfTwo(texture){return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}// Fallback filters for non-power-of-2 textures
function filterFallback(f){if(f===NearestFilter||f===NearestMipMapNearestFilter||f===NearestMipMapLinearFilter){return _gl.NEAREST;}return _gl.LINEAR;}//
function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);_infoMemory.textures--;}function onRenderTargetDispose(event){var renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);_infoMemory.textures--;}//
function deallocateTexture(texture){var textureProperties=properties.get(texture);if(texture.image&&textureProperties.__image__webglTextureCube){// cube texture
_gl.deleteTexture(textureProperties.__image__webglTextureCube);}else{// 2D texture
if(textureProperties.__webglInit===undefined)return;_gl.deleteTexture(textureProperties.__webglTexture);}// remove all webgl properties
properties.delete(texture);}function deallocateRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);if(!renderTarget)return;if(textureProperties.__webglTexture!==undefined){_gl.deleteTexture(textureProperties.__webglTexture);}if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();}if(renderTarget.isWebGLRenderTargetCube){for(var i=0;i<6;i++){_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);}}else{_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);}properties.delete(renderTarget.texture);properties.delete(renderTarget);}//
var textureUpdateUndefinedWarning=false;var textureUpdateIncompleteWarning=false;function setTexture2D(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){var image=texture.image;if(image===undefined){if(!textureUpdateUndefinedWarning){console.trace('THREE.WebGLRenderer: Texture marked for update but image is undefined',texture);textureUpdateUndefinedWarning=true;}}else if(image.complete===false){if(!textureUpdateIncompleteWarning){console.trace('THREE.WebGLRenderer: Texture marked for update but image is incomplete',texture);textureUpdateIncompleteWarning=true;}}else{uploadTexture(textureProperties,texture,slot);return;}}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);}function setTextureCube(texture,slot){var textureProperties=properties.get(texture);if(texture.image.length===6){if(texture.version>0&&textureProperties.__version!==texture.version){if(!textureProperties.__image__webglTextureCube){texture.addEventListener('dispose',onTextureDispose);textureProperties.__image__webglTextureCube=_gl.createTexture();_infoMemory.textures++;}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);var isCompressed=texture&&texture.isCompressedTexture;var isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;var cubeImage=[];for(var i=0;i<6;i++){if(!isCompressed&&!isDataTexture){cubeImage[i]=clampToMaxSize(texture.image[i],capabilities.maxCubemapSize);}else{cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];}}var image=cubeImage[0],isPowerOfTwoImage=isPowerOfTwo(image),glFormat=paramThreeToGL(texture.format),glType=paramThreeToGL(texture.type);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture,isPowerOfTwoImage);for(var i=0;i<6;i++){if(!isCompressed){if(isDataTexture){state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);}else{state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,glFormat,glType,cubeImage[i]);}}else{var mipmap,mipmaps=cubeImage[i].mipmaps;for(var j=0,jl=mipmaps.length;j<jl;j++){mipmap=mipmaps[j];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");}}else{state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}if(texture.generateMipmaps&&isPowerOfTwoImage){_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}else{state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);}}}function setTextureCubeDynamic(texture,slot){state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,properties.get(texture).__webglTexture);}function setTextureParameters(textureType,texture,isPowerOfTwoImage){var extension;if(isPowerOfTwoImage){_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,paramThreeToGL(texture.wrapS));_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,paramThreeToGL(texture.wrapT));_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,paramThreeToGL(texture.magFilter));_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,paramThreeToGL(texture.minFilter));}else{_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,_gl.CLAMP_TO_EDGE);_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,_gl.CLAMP_TO_EDGE);if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',texture);}_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterFallback(texture.magFilter));_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterFallback(texture.minFilter));if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',texture);}}extension=extensions.get('EXT_texture_filter_anisotropic');if(extension){if(texture.type===FloatType&&extensions.get('OES_texture_float_linear')===null)return;if(texture.type===HalfFloatType&&extensions.get('OES_texture_half_float_linear')===null)return;if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function uploadTexture(textureProperties,texture,slot){if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);textureProperties.__webglTexture=_gl.createTexture();_infoMemory.textures++;}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);var image=clampToMaxSize(texture.image,capabilities.maxTextureSize);if(textureNeedsPowerOfTwo(texture)&&isPowerOfTwo(image)===false){image=makePowerOfTwo(image);}var isPowerOfTwoImage=isPowerOfTwo(image),glFormat=paramThreeToGL(texture.format),glType=paramThreeToGL(texture.type);setTextureParameters(_gl.TEXTURE_2D,texture,isPowerOfTwoImage);var mipmap,mipmaps=texture.mipmaps;if(texture.isDepthTexture){// populate depth texture with dummy data
var internalFormat=_gl.DEPTH_COMPONENT;if(texture.type===FloatType){if(!_isWebGL2)throw new Error('Float Depth Texture only supported in WebGL2.0');internalFormat=_gl.DEPTH_COMPONENT32F;}else if(_isWebGL2){// WebGL 2.0 requires signed internalformat for glTexImage2D
internalFormat=_gl.DEPTH_COMPONENT16;}if(texture.format===DepthFormat&&internalFormat===_gl.DEPTH_COMPONENT){// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');texture.type=UnsignedShortType;glType=paramThreeToGL(texture.type);}}// Depth stencil textures need the DEPTH_STENCIL internal format
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.format===DepthStencilFormat){internalFormat=_gl.DEPTH_STENCIL;// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedInt248Type){console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');texture.type=UnsignedInt248Type;glType=paramThreeToGL(texture.type);}}state.texImage2D(_gl.TEXTURE_2D,0,internalFormat,image.width,image.height,0,glFormat,glType,null);}else if(texture.isDataTexture){// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(mipmaps.length>0&&isPowerOfTwoImage){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}texture.generateMipmaps=false;}else{state.texImage2D(_gl.TEXTURE_2D,0,glFormat,image.width,image.height,0,glFormat,glType,image.data);}}else if(texture.isCompressedTexture){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){state.compressedTexImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");}}else{state.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}else{// regular Texture (image, video, canvas)
// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(mipmaps.length>0&&isPowerOfTwoImage){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(_gl.TEXTURE_2D,i,glFormat,glFormat,glType,mipmap);}texture.generateMipmaps=false;}else{state.texImage2D(_gl.TEXTURE_2D,0,glFormat,glFormat,glType,image);}}if(texture.generateMipmaps&&isPowerOfTwoImage)_gl.generateMipmap(_gl.TEXTURE_2D);textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}// Render targets
// Setup storage for target texture and bind it to correct framebuffer
function setupFrameBufferTexture(framebuffer,renderTarget,attachment,textureTarget){var glFormat=paramThreeToGL(renderTarget.texture.format);var glType=paramThreeToGL(renderTarget.texture.type);state.texImage2D(textureTarget,0,glFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,attachment,textureTarget,properties.get(renderTarget.texture).__webglTexture,0);_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
function setupRenderBufferStorage(renderbuffer,renderTarget){_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_COMPONENT16,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_STENCIL,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);}else{// FIXME: We don't support !depth !stencil
_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.RGBA4,renderTarget.width,renderTarget.height);}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
function setupDepthTexture(framebuffer,renderTarget){var isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;if(isCube)throw new Error('Depth Texture with cube render targets is not supported!');_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}// upload an empty depth texture with framebuffer size
if(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);var webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;if(renderTarget.depthTexture.format===DepthFormat){_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}else if(renderTarget.depthTexture.format===DepthStencilFormat){_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}else{throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
function setupDepthRenderbuffer(renderTarget){var renderTargetProperties=properties.get(renderTarget);var isCube=renderTarget.isWebGLRenderTargetCube===true;if(renderTarget.depthTexture){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else{if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(var i=0;i<6;i++){_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[i]);renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget);}}else{_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget);}}_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Set up GL resources for the render target
function setupRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);textureProperties.__webglTexture=_gl.createTexture();_infoMemory.textures++;var isCube=renderTarget.isWebGLRenderTargetCube===true;var isTargetPowerOfTwo=isPowerOfTwo(renderTarget);// Setup framebuffer
if(isCube){renderTargetProperties.__webglFramebuffer=[];for(var i=0;i<6;i++){renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();}}else{renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();}// Setup color buffer
if(isCube){state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_CUBE_MAP,renderTarget.texture,isTargetPowerOfTwo);for(var i=0;i<6;i++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i);}if(renderTarget.texture.generateMipmaps&&isTargetPowerOfTwo)_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);state.bindTexture(_gl.TEXTURE_CUBE_MAP,null);}else{state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_2D,renderTarget.texture,isTargetPowerOfTwo);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D);if(renderTarget.texture.generateMipmaps&&isTargetPowerOfTwo)_gl.generateMipmap(_gl.TEXTURE_2D);state.bindTexture(_gl.TEXTURE_2D,null);}// Setup depth and stencil buffers
if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){var texture=renderTarget.texture;if(texture.generateMipmaps&&isPowerOfTwo(renderTarget)&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){var target=renderTarget&&renderTarget.isWebGLRenderTargetCube?_gl.TEXTURE_CUBE_MAP:_gl.TEXTURE_2D;var webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture);_gl.generateMipmap(target);state.bindTexture(target,null);}}this.setTexture2D=setTexture2D;this.setTextureCube=setTextureCube;this.setTextureCubeDynamic=setTextureCubeDynamic;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;}/**
	 * @author fordacious / fordacious.github.io
	 */function WebGLProperties(){var properties={};return{get:function get(object){var uuid=object.uuid;var map=properties[uuid];if(map===undefined){map={};properties[uuid]=map;}return map;},delete:function _delete(object){delete properties[object.uuid];},clear:function clear(){properties={};}};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLState(gl,extensions,paramThreeToGL){function ColorBuffer(){var locked=false;var color=new Vector4();var currentColorMask=null;var currentColorClear=new Vector4();return{setMask:function setMask(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function reset(){locked=false;currentColorMask=null;currentColorClear.set(0,0,0,1);}};}function DepthBuffer(){var locked=false;var currentDepthMask=null;var currentDepthFunc=null;var currentDepthClear=null;return{setTest:function setTest(depthTest){if(depthTest){enable(gl.DEPTH_TEST);}else{disable(gl.DEPTH_TEST);}},setMask:function setMask(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function setFunc(depthFunc){if(currentDepthFunc!==depthFunc){if(depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(gl.NEVER);break;case AlwaysDepth:gl.depthFunc(gl.ALWAYS);break;case LessDepth:gl.depthFunc(gl.LESS);break;case LessEqualDepth:gl.depthFunc(gl.LEQUAL);break;case EqualDepth:gl.depthFunc(gl.EQUAL);break;case GreaterEqualDepth:gl.depthFunc(gl.GEQUAL);break;case GreaterDepth:gl.depthFunc(gl.GREATER);break;case NotEqualDepth:gl.depthFunc(gl.NOTEQUAL);break;default:gl.depthFunc(gl.LEQUAL);}}else{gl.depthFunc(gl.LEQUAL);}currentDepthFunc=depthFunc;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(depth){if(currentDepthClear!==depth){gl.clearDepth(depth);currentDepthClear=depth;}},reset:function reset(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;}};}function StencilBuffer(){var locked=false;var currentStencilMask=null;var currentStencilFunc=null;var currentStencilRef=null;var currentStencilFuncMask=null;var currentStencilFail=null;var currentStencilZFail=null;var currentStencilZPass=null;var currentStencilClear=null;return{setTest:function setTest(stencilTest){if(stencilTest){enable(gl.STENCIL_TEST);}else{disable(gl.STENCIL_TEST);}},setMask:function setMask(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function setFunc(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function setOp(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function reset(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
var colorBuffer=new ColorBuffer();var depthBuffer=new DepthBuffer();var stencilBuffer=new StencilBuffer();var maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);var newAttributes=new Uint8Array(maxVertexAttributes);var enabledAttributes=new Uint8Array(maxVertexAttributes);var attributeDivisors=new Uint8Array(maxVertexAttributes);var capabilities={};var compressedTextureFormats=null;var currentBlending=null;var currentBlendEquation=null;var currentBlendSrc=null;var currentBlendDst=null;var currentBlendEquationAlpha=null;var currentBlendSrcAlpha=null;var currentBlendDstAlpha=null;var currentPremultipledAlpha=false;var currentFlipSided=null;var currentCullFace=null;var currentLineWidth=null;var currentPolygonOffsetFactor=null;var currentPolygonOffsetUnits=null;var currentScissorTest=null;var maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);var version=parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);var lineWidthAvailable=parseFloat(version)>=1.0;var currentTextureSlot=null;var currentBoundTextures={};var currentScissor=new Vector4();var currentViewport=new Vector4();function createTexture(type,target,count){var data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
var texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(type,gl.TEXTURE_MAG_FILTER,gl.NEAREST);for(var i=0;i<count;i++){gl.texImage2D(target+i,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,data);}return texture;}var emptyTextures={};emptyTextures[gl.TEXTURE_2D]=createTexture(gl.TEXTURE_2D,gl.TEXTURE_2D,1);emptyTextures[gl.TEXTURE_CUBE_MAP]=createTexture(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_CUBE_MAP_POSITIVE_X,6);//
function init(){colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(gl.DEPTH_TEST);setDepthFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(gl.CULL_FACE);enable(gl.BLEND);setBlending(NormalBlending);}function initAttributes(){for(var i=0,l=newAttributes.length;i<l;i++){newAttributes[i]=0;}}function enableAttribute(attribute){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==0){var extension=extensions.get('ANGLE_instanced_arrays');extension.vertexAttribDivisorANGLE(attribute,0);attributeDivisors[attribute]=0;}}function enableAttributeAndDivisor(attribute,meshPerAttribute,extension){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){extension.vertexAttribDivisorANGLE(attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){for(var i=0,l=enabledAttributes.length;i!==l;++i){if(enabledAttributes[i]!==newAttributes[i]){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}}function enable(id){if(capabilities[id]!==true){gl.enable(id);capabilities[id]=true;}}function disable(id){if(capabilities[id]!==false){gl.disable(id);capabilities[id]=false;}}function getCompressedTextureFormats(){if(compressedTextureFormats===null){compressedTextureFormats=[];if(extensions.get('WEBGL_compressed_texture_pvrtc')||extensions.get('WEBGL_compressed_texture_s3tc')||extensions.get('WEBGL_compressed_texture_etc1')){var formats=gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);for(var i=0;i<formats.length;i++){compressedTextureFormats.push(formats[i]);}}}return compressedTextureFormats;}function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(blending!==NoBlending){enable(gl.BLEND);}else{disable(gl.BLEND);}if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(blending===AdditiveBlending){if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ONE,gl.ONE,gl.ONE,gl.ONE);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.SRC_ALPHA,gl.ONE);}}else if(blending===SubtractiveBlending){if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ZERO,gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ZERO,gl.ONE_MINUS_SRC_COLOR);}}else if(blending===MultiplyBlending){if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ZERO,gl.SRC_COLOR,gl.ZERO,gl.SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ZERO,gl.SRC_COLOR);}}else{if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE_MINUS_DST_ALPHA,gl.ONE);}else{gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}}currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}if(blending===CustomBlending){blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(paramThreeToGL(blendEquation),paramThreeToGL(blendEquationAlpha));currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;//console.log("setting custom blend state", blendEquation, blendEquationAlpha );
}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(paramThreeToGL(blendSrc),paramThreeToGL(blendDst),paramThreeToGL(blendSrcAlpha),paramThreeToGL(blendDstAlpha));//console.log("setting custom blend state", blendSrc, blendDst, blendSrcAlpha, blendDstAlpha );
currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}}else{currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;}}// TODO Deprecate
function setColorWrite(colorWrite){colorBuffer.setMask(colorWrite);}function setDepthTest(depthTest){depthBuffer.setTest(depthTest);}function setDepthWrite(depthWrite){depthBuffer.setMask(depthWrite);}function setDepthFunc(depthFunc){depthBuffer.setFunc(depthFunc);}function setStencilTest(stencilTest){stencilBuffer.setTest(stencilTest);}function setStencilWrite(stencilWrite){stencilBuffer.setMask(stencilWrite);}function setStencilFunc(stencilFunc,stencilRef,stencilMask){stencilBuffer.setFunc(stencilFunc,stencilRef,stencilMask);}function setStencilOp(stencilFail,stencilZFail,stencilZPass){stencilBuffer.setOp(stencilFail,stencilZFail,stencilZPass);}//
function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(gl.CW);}else{gl.frontFace(gl.CCW);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(gl.CULL_FACE);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(gl.BACK);}else if(cullFace===CullFaceFront){gl.cullFace(gl.FRONT);}else{gl.cullFace(gl.FRONT_AND_BACK);}}}else{disable(gl.CULL_FACE);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(gl.POLYGON_OFFSET_FILL);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else{disable(gl.POLYGON_OFFSET_FILL);}}function getScissorTest(){return currentScissorTest;}function setScissorTest(scissorTest){currentScissorTest=scissorTest;if(scissorTest){enable(gl.SCISSOR_TEST);}else{disable(gl.SCISSOR_TEST);}}// texture
function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=gl.TEXTURE0+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture){if(currentTextureSlot===null){activeTexture();}var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[currentTextureSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error(error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error(error);}}//
function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}//
function reset(){for(var i=0;i<enabledAttributes.length;i++){if(enabledAttributes[i]===1){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}capabilities={};compressedTextureFormats=null;currentTextureSlot=null;currentBoundTextures={};currentBlending=null;currentFlipSided=null;currentCullFace=null;colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return{buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},init:init,initAttributes:initAttributes,enableAttribute:enableAttribute,enableAttributeAndDivisor:enableAttributeAndDivisor,disableUnusedAttributes:disableUnusedAttributes,enable:enable,disable:disable,getCompressedTextureFormats:getCompressedTextureFormats,setBlending:setBlending,setColorWrite:setColorWrite,setDepthTest:setDepthTest,setDepthWrite:setDepthWrite,setDepthFunc:setDepthFunc,setStencilTest:setStencilTest,setStencilWrite:setStencilWrite,setStencilFunc:setStencilFunc,setStencilOp:setStencilOp,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,getScissorTest:getScissorTest,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,scissor:scissor,viewport:viewport,reset:reset};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLCapabilities(gl,extensions,parameters){var maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;var extension=extensions.get('EXT_texture_filter_anisotropic');if(extension!==null){maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else{maxAnisotropy=0;}return maxAnisotropy;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){return'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){return'mediump';}}return'lowp';}var precision=parameters.precision!==undefined?parameters.precision:'highp';var maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}var logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true&&!!extensions.get('EXT_frag_depth');var maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);var maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);var maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);var maxCubemapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);var maxAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);var maxVertexUniforms=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);var maxVaryings=gl.getParameter(gl.MAX_VARYING_VECTORS);var maxFragmentUniforms=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);var vertexTextures=maxVertexTextures>0;var floatFragmentTextures=!!extensions.get('OES_texture_float');var floatVertexTextures=vertexTextures&&floatFragmentTextures;return{getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,floatFragmentTextures:floatFragmentTextures,floatVertexTextures:floatVertexTextures};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLExtensions(gl){var extensions={};return{get:function get(name){if(extensions[name]!==undefined){return extensions[name];}var extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;case'WEBGL_compressed_texture_etc1':extension=gl.getExtension('WEBGL_compressed_texture_etc1');break;default:extension=gl.getExtension(name);}if(extension===null){console.warn('THREE.WebGLRenderer: '+name+' extension not supported.');}extensions[name]=extension;return extension;}};}/**
	 * @author tschw
	 */function WebGLClipping(){var scope=this,globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false,plane=new Plane(),viewNormalMatrix=new Matrix3(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping,camera){var enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
// run another frame in order to reset the state:
numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;resetGlobalState();};this.setState=function(planes,clipIntersection,clipShadows,camera,cache,fromCache){if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
if(renderingShadows){// there's no global clipping
projectPlanes(null);}else{resetGlobalState();}}else{var nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4,dstArray=cache.clippingState||null;uniform.value=dstArray;// ensure unique state
dstArray=projectPlanes(planes,camera,lGlobal,fromCache);for(var i=0;i!==lGlobal;++i){dstArray[i]=globalState[i];}cache.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){var nPlanes=planes!==null?planes.length:0,dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){var flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(var i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;return dstArray;}}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Scene(){Object3D.call(this);this.type='Scene';this.background=null;this.fog=null;this.overrideMaterial=null;this.autoUpdate=true;// checked by the renderer
}Scene.prototype=(0,_create2.default)(Object3D.prototype);Scene.prototype.constructor=Scene;Scene.prototype.copy=function(source,recursive){Object3D.prototype.copy.call(this,source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.fog!==null)this.fog=source.fog.clone();if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.autoUpdate=source.autoUpdate;this.matrixAutoUpdate=source.matrixAutoUpdate;return this;};Scene.prototype.toJSON=function(meta){var data=Object3D.prototype.toJSON.call(this,meta);if(this.background!==null)data.object.background=this.background.toJSON(meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();return data;};/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */function WebGLRenderer(parameters){console.log('THREE.WebGLRenderer',REVISION);parameters=parameters||{};var _canvas=parameters.canvas!==undefined?parameters.canvas:document.createElementNS('http://www.w3.org/1999/xhtml','canvas'),_context=parameters.context!==undefined?parameters.context:null,_alpha=parameters.alpha!==undefined?parameters.alpha:false,_depth=parameters.depth!==undefined?parameters.depth:true,_stencil=parameters.stencil!==undefined?parameters.stencil:true,_antialias=parameters.antialias!==undefined?parameters.antialias:false,_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false;var lights=[];this.opaqueObjects=[];var opaqueObjectsLastIndex=-1;this.transparentObjects=[];var transparentObjectsLastIndex=-1;var morphInfluences=new Float32Array(8);var sprites=[];var lensFlares=[];var passScene=null,passCamera=null,passQuad=null;// public properties
this.domElement=_canvas;this.context=null;// clearing
this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
this.sortObjects=true;// user-defined clipping
this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
this.gammaFactor=2.0;// for backwards compatibility
this.gammaInput=false;this.gammaOutput=false;// physical lights
this.physicallyCorrectLights=false;// tone mapping
this.toneMapping=LinearToneMapping;this.toneMappingExposure=1.0;this.toneMappingWhitePoint=1.0;// dither
this.ditherScale=1.0;// morphs
this.maxMorphTargets=8;this.maxMorphNormals=4;// flags
this.autoScaleCubemaps=true;this.autoResizeTextures=false;// internal properties
var _this=this,// internal state cache
_currentProgram=null,_currentRenderTarget=null,_currentFramebuffer=null,_currentMaterialId=-1,_currentGeometryProgram='',_currentCamera=null,_currentScissor=new Vector4(),_currentScissorTest=null,_currentViewport=new Vector4(),//
_usedTextureUnits=0,//
_clearColor=new Color(0x000000),_clearAlpha=0,_width=_canvas.width,_height=_canvas.height,_pixelRatio=1,_scissor=new Vector4(0,0,_width,_height),_scissorTest=false,_viewport=new Vector4(0,0,_width,_height),// frustum
_frustum=new Frustum(),// clipping
_clipping=new WebGLClipping(),_clippingEnabled=false,_localClippingEnabled=false,_sphere=new Sphere(),// camera matrices cache
_projScreenMatrix=new Matrix4(),_vector3=new Vector3(),_matrix4=new Matrix4(),_matrix42=new Matrix4(),// light arrays cache
_lights={hash:'',ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],shadows:[]},// info
_infoRender={calls:0,vertices:0,faces:0,points:0};this.info={render:_infoRender,memory:{geometries:0,textures:0},programs:null};// initialize
var _gl;try{var attributes={alpha:_alpha,depth:_depth,stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer};_gl=_context||_canvas.getContext('webgl',attributes)||_canvas.getContext('experimental-webgl',attributes);if(_gl===null){if(_canvas.getContext('webgl')!==null){throw'Error creating WebGL context with your selected attributes.';}else{throw'Error creating WebGL context.';}}// Some experimental-webgl implementations do not have getShaderPrecisionFormat
if(_gl.getShaderPrecisionFormat===undefined){_gl.getShaderPrecisionFormat=function(){return{'rangeMin':1,'rangeMax':1,'precision':1};};}_canvas.addEventListener('webglcontextlost',onContextLost,false);}catch(error){console.error('THREE.WebGLRenderer: '+error);}var extensions=new WebGLExtensions(_gl);this.transparency=PaintersTransperancy;this.oitMode=2;// 0: accumlation pass, 1: revealage pass, 2: none
extensions.get('WEBGL_depth_texture');extensions.get('OES_texture_float');extensions.get('OES_texture_float_linear');extensions.get('OES_texture_half_float');extensions.get('OES_texture_half_float_linear');extensions.get('OES_standard_derivatives');extensions.get('ANGLE_instanced_arrays');if(extensions.get('OES_element_index_uint')){BufferGeometry.MaxIndex=4294967296;}var capabilities=new WebGLCapabilities(_gl,extensions,parameters);var state=new WebGLState(_gl,extensions,paramThreeToGL);var properties=new WebGLProperties();var textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,paramThreeToGL,this.info);var objects=new WebGLObjects(_gl,properties,this.info);var programCache=new WebGLPrograms(this,capabilities);var lightCache=new WebGLLights();this.info.programs=programCache.programs;var bufferRenderer=new WebGLBufferRenderer(_gl,extensions,_infoRender);var indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,_infoRender);//
var backgroundCamera=new OrthographicCamera(-1,1,1,-1,0,1);var backgroundCamera2=new PerspectiveCamera();var backgroundPlaneMesh=new Mesh(new PlaneBufferGeometry(2,2),new MeshBasicMaterial({depthTest:false,depthWrite:false,fog:false}));var backgroundBoxShader=ShaderLib['cube'];var backgroundBoxMesh=new Mesh(new BoxBufferGeometry(5,5,5),new ShaderMaterial({uniforms:backgroundBoxShader.uniforms,vertexShader:backgroundBoxShader.vertexShader,fragmentShader:backgroundBoxShader.fragmentShader,side:BackSide,depthTest:false,depthWrite:false,fog:false}));//
function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}function setDefaultGLState(){state.init();state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);}function resetGLState(){_currentProgram=null;_currentCamera=null;_currentGeometryProgram='';_currentMaterialId=-1;state.reset();}setDefaultGLState();this.context=_gl;this.capabilities=capabilities;this.extensions=extensions;this.properties=properties;this.state=state;// shadow map
var shadowMap=new WebGLShadowMap(this,_lights,objects,capabilities);this.shadowMap=shadowMap;// Plugins
var spritePlugin=new SpritePlugin(this,sprites);var lensFlarePlugin=new LensFlarePlugin(this,lensFlares);// API
this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){extensions.get('WEBGL_lose_context').loseContext();};this.getMaxAnisotropy=function(){return capabilities.getMaxAnisotropy();};this.getPrecision=function(){return capabilities.precision;};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_viewport.z,_viewport.w,false);};this.getSize=function(){return{width:_width,height:_height};};this.setSize=function(width,height,updateStyle){_width=width;_height=height;_canvas.width=width*_pixelRatio;_canvas.height=height*_pixelRatio;if(updateStyle!==false){_canvas.style.width=width+'px';_canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.setViewport=function(x,y,width,height){state.viewport(_viewport.set(x,y,width,height));};this.setScissor=function(x,y,width,height){state.scissor(_scissor.set(x,y,width,height));};this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean);};// Clearing
this.getClearColor=function(){return _clearColor;};this.setClearColor=function(color,alpha){_clearColor.set(color);_clearAlpha=alpha!==undefined?alpha:1;state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);};this.getClearAlpha=function(){return _clearAlpha;};this.setClearAlpha=function(alpha){_clearAlpha=alpha;state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);};this.clear=function(color,depth,stencil){var bits=0;if(color===undefined||color)bits|=_gl.COLOR_BUFFER_BIT;if(depth===undefined||depth)bits|=_gl.DEPTH_BUFFER_BIT;if(stencil===undefined||stencil)bits|=_gl.STENCIL_BUFFER_BIT;_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};this.clearTarget=function(renderTarget,color,depth,stencil){this.setRenderTarget(renderTarget);this.clear(color,depth,stencil);};// Reset
this.resetGLState=resetGLState;this.dispose=function(){this.transparentObjects=[];transparentObjectsLastIndex=-1;this.opaqueObjects=[];opaqueObjectsLastIndex=-1;_canvas.removeEventListener('webglcontextlost',onContextLost,false);};// Events
function onContextLost(event){event.preventDefault();resetGLState();setDefaultGLState();properties.clear();}function onMaterialDispose(event){var material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
function deallocateMaterial(material){releaseMaterialProgramReference(material);properties.delete(material);}function releaseMaterialProgramReference(material){var programInfo=properties.get(material).program;material.program=undefined;if(programInfo!==undefined){programCache.releaseProgram(programInfo);}}// Buffer rendering
this.renderBufferImmediate=function(object,program,material){state.initAttributes();var buffers=properties.get(object);if(object.hasPositions&&!buffers.position)buffers.position=_gl.createBuffer();if(object.hasNormals&&!buffers.normal)buffers.normal=_gl.createBuffer();if(object.hasUvs&&!buffers.uv)buffers.uv=_gl.createBuffer();if(object.hasColors&&!buffers.color)buffers.color=_gl.createBuffer();var attributes=program.getAttributes();if(object.hasPositions){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.position);_gl.bufferData(_gl.ARRAY_BUFFER,object.positionArray,_gl.DYNAMIC_DRAW);state.enableAttribute(attributes.position);_gl.vertexAttribPointer(attributes.position,3,_gl.FLOAT,false,0,0);}if(object.hasNormals){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.normal);if(!material.isMeshPhongMaterial&&!material.isMeshStandardMaterial&&!material.isMeshNormalMaterial&&material.shading===FlatShading){for(var i=0,l=object.count*3;i<l;i+=9){var array=object.normalArray;var nx=(array[i+0]+array[i+3]+array[i+6])/3;var ny=(array[i+1]+array[i+4]+array[i+7])/3;var nz=(array[i+2]+array[i+5]+array[i+8])/3;array[i+0]=nx;array[i+1]=ny;array[i+2]=nz;array[i+3]=nx;array[i+4]=ny;array[i+5]=nz;array[i+6]=nx;array[i+7]=ny;array[i+8]=nz;}}_gl.bufferData(_gl.ARRAY_BUFFER,object.normalArray,_gl.DYNAMIC_DRAW);state.enableAttribute(attributes.normal);_gl.vertexAttribPointer(attributes.normal,3,_gl.FLOAT,false,0,0);}if(object.hasUvs&&material.map){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.uv);_gl.bufferData(_gl.ARRAY_BUFFER,object.uvArray,_gl.DYNAMIC_DRAW);state.enableAttribute(attributes.uv);_gl.vertexAttribPointer(attributes.uv,2,_gl.FLOAT,false,0,0);}if(object.hasColors&&material.vertexColors!==NoColors){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.color);_gl.bufferData(_gl.ARRAY_BUFFER,object.colorArray,_gl.DYNAMIC_DRAW);state.enableAttribute(attributes.color);_gl.vertexAttribPointer(attributes.color,3,_gl.FLOAT,false,0,0);}state.disableUnusedAttributes();_gl.drawArrays(_gl.TRIANGLES,0,object.count);object.count=0;};this.renderBufferDirect=function(camera,fog,geometry,material,object,group){setMaterial(material);var program=setProgram(camera,fog,material,object);var updateBuffers=false;var geometryProgram=geometry.id+'_'+program.id+'_'+material.wireframe;if(geometryProgram!==_currentGeometryProgram){_currentGeometryProgram=geometryProgram;updateBuffers=true;}// morph targets
var morphTargetInfluences=object.morphTargetInfluences;if(morphTargetInfluences!==undefined){var activeInfluences=[];for(var i=0,l=morphTargetInfluences.length;i<l;i++){var influence=morphTargetInfluences[i];activeInfluences.push([influence,i]);}activeInfluences.sort(absNumericalSort);if(activeInfluences.length>8){activeInfluences.length=8;}var morphAttributes=geometry.morphAttributes;for(var i=0,l=activeInfluences.length;i<l;i++){var influence=activeInfluences[i];morphInfluences[i]=influence[0];if(influence[0]!==0){var index=influence[1];if(material.morphTargets===true&&morphAttributes.position)geometry.addAttribute('morphTarget'+i,morphAttributes.position[index]);if(material.morphNormals===true&&morphAttributes.normal)geometry.addAttribute('morphNormal'+i,morphAttributes.normal[index]);}else{if(material.morphTargets===true)geometry.removeAttribute('morphTarget'+i);if(material.morphNormals===true)geometry.removeAttribute('morphNormal'+i);}}for(var i=activeInfluences.length,il=morphInfluences.length;i<il;i++){morphInfluences[i]=0.0;}program.getUniforms().setValue(_gl,'morphTargetInfluences',morphInfluences);updateBuffers=true;}//
var index=geometry.index;var position=geometry.attributes.position;var rangeFactor=1;if(material.wireframe===true){index=objects.getWireframeAttribute(geometry);rangeFactor=2;}var renderer;if(index!==null){renderer=indexedBufferRenderer;renderer.setIndex(index);}else{renderer=bufferRenderer;}if(updateBuffers){setupVertexAttributes(material,program,geometry);if(index!==null){_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,objects.getAttributeBuffer(index));}}//
var dataCount=0;if(index!==null){dataCount=index.count;}else if(position!==undefined){dataCount=position.count;}var rangeStart=geometry.drawRange.start*rangeFactor;var rangeCount=geometry.drawRange.count*rangeFactor;var groupStart=group!==null?group.start*rangeFactor:0;var groupCount=group!==null?group.count*rangeFactor:Infinity;var drawStart=Math.max(rangeStart,groupStart);var drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;var drawCount=Math.max(0,drawEnd-drawStart+1);if(drawCount===0)return;//
if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(_gl.LINES);}else{switch(object.drawMode){case TrianglesDrawMode:renderer.setMode(_gl.TRIANGLES);break;case TriangleStripDrawMode:renderer.setMode(_gl.TRIANGLE_STRIP);break;case TriangleFanDrawMode:renderer.setMode(_gl.TRIANGLE_FAN);break;}}}else if(object.isLine){var lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(_gl.LINES);}else{renderer.setMode(_gl.LINE_STRIP);}}else if(object.isPoints){renderer.setMode(_gl.POINTS);}if(geometry&&geometry.isInstancedBufferGeometry){if(geometry.maxInstancedCount>0){renderer.renderInstances(geometry,drawStart,drawCount);}}else{renderer.render(drawStart,drawCount);}};function setupVertexAttributes(material,program,geometry,startIndex){var extension;if(geometry&&geometry.isInstancedBufferGeometry){extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}if(startIndex===undefined)startIndex=0;state.initAttributes();var geometryAttributes=geometry.attributes;var programAttributes=program.getAttributes();var materialDefaultAttributeValues=material.defaultAttributeValues;for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute>=0){var geometryAttribute=geometryAttributes[name];if(geometryAttribute!==undefined){var normalized=geometryAttribute.normalized;var size=geometryAttribute.itemSize;var attributeProperties=objects.getAttributeProperties(geometryAttribute);var buffer=attributeProperties.__webglBuffer;var type=attributeProperties.type;var bytesPerElement=attributeProperties.bytesPerElement;if(geometryAttribute.isInterleavedBufferAttribute){var data=geometryAttribute.data;var stride=data.stride;var offset=geometryAttribute.offset;if(data&&data.isInstancedInterleavedBuffer){state.enableAttributeAndDivisor(programAttribute,data.meshPerAttribute,extension);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=data.meshPerAttribute*data.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,stride*bytesPerElement,(startIndex*stride+offset)*bytesPerElement);}else{if(geometryAttribute.isInstancedBufferAttribute){state.enableAttributeAndDivisor(programAttribute,geometryAttribute.meshPerAttribute,extension);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,0,startIndex*size*bytesPerElement);}}else if(materialDefaultAttributeValues!==undefined){var value=materialDefaultAttributeValues[name];if(value!==undefined){switch(value.length){case 2:_gl.vertexAttrib2fv(programAttribute,value);break;case 3:_gl.vertexAttrib3fv(programAttribute,value);break;case 4:_gl.vertexAttrib4fv(programAttribute,value);break;default:_gl.vertexAttrib1fv(programAttribute,value);}}}}}state.disableUnusedAttributes();}// Sorting
function absNumericalSort(a,b){return Math.abs(b[0])-Math.abs(a[0]);}function painterSortStable(a,b){if(a.object.renderOrder!==b.object.renderOrder){return a.object.renderOrder-b.object.renderOrder;}else if(a.material.program&&b.material.program&&a.material.program!==b.material.program){return a.material.program.id-b.material.program.id;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else{return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.object.renderOrder!==b.object.renderOrder){return a.object.renderOrder-b.object.renderOrder;}if(a.z!==b.z){return b.z-a.z;}else{return a.id-b.id;}}// Rendering
this.renderOverride=function(overrideMaterial,scene,camera,renderTarget,forceClear,onlyTransparent,onlyOpaque){scene.overrideMaterial=overrideMaterial;this.render(scene,camera,renderTarget,forceClear,onlyTransparent,onlyOpaque);scene.overrideMaterial=null;};this.renderPass=function(passMaterial,renderTarget,forceClear){if(passScene===null){passCamera=new OrthographicCamera(-1,1,1,-1,0,1);passQuad=new Mesh(new PlaneBufferGeometry(2,2),null);passScene=new Scene();passScene.add(passQuad);}passQuad.material=passMaterial;this.render(passScene,passCamera,renderTarget,forceClear);passQuad.material=null;};this.render=function(scene,camera,renderTarget,forceClear,visibilityFunc){if(camera!==undefined&&camera.isCamera!==true){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}// reset caching for this frame
_currentGeometryProgram='';_currentMaterialId=-1;_currentCamera=null;// update scene graph
if(scene.autoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
if(camera.parent===null)camera.updateMatrixWorld();camera.matrixWorldInverse.getInverse(camera.matrixWorld);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromMatrix(_projScreenMatrix);lights.length=0;opaqueObjectsLastIndex=-1;transparentObjectsLastIndex=-1;sprites.length=0;lensFlares.length=0;_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=_clipping.init(this.clippingPlanes,_localClippingEnabled,camera);this.projectObject(scene,camera);this.opaqueObjects.length=opaqueObjectsLastIndex+1;this.transparentObjects.length=transparentObjectsLastIndex+1;if(_this.sortObjects===true){this.opaqueObjects.sort(painterSortStable);if(this.transparency===PaintersTransperancy)this.transparentObjects.sort(reversePainterSortStable);}//
if(_clippingEnabled)_clipping.beginShadows();setupShadows(lights);shadowMap.render(scene,camera);setupLights(lights,camera);if(_clippingEnabled)_clipping.endShadows();//
_infoRender.calls=0;_infoRender.vertices=0;_infoRender.faces=0;_infoRender.points=0;if(renderTarget===undefined){renderTarget=null;}//console.log( "render() renderTarget: ", renderTarget );
this.setRenderTarget(renderTarget);//
var background=scene.background;background=null;if(background===null){state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);}else if(background&&background.isColor){state.buffers.color.setClear(background.r,background.g,background.b,1,_premultipliedAlpha);forceClear=true;}if(this.autoClear||forceClear){this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil);}if(background&&background.isCubeTexture){backgroundCamera2.projectionMatrix.copy(camera.projectionMatrix);backgroundCamera2.matrixWorld.extractRotation(camera.matrixWorld);backgroundCamera2.matrixWorldInverse.getInverse(backgroundCamera2.matrixWorld);backgroundBoxMesh.material.uniforms["tCube"].value=background;backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundCamera2.matrixWorldInverse,backgroundBoxMesh.matrixWorld);objects.update(backgroundBoxMesh);_this.renderBufferDirect(backgroundCamera2,null,backgroundBoxMesh.geometry,backgroundBoxMesh.material,backgroundBoxMesh,null);}else if(background&&background.isTexture){backgroundPlaneMesh.material.map=background;objects.update(backgroundPlaneMesh);_this.renderBufferDirect(backgroundCamera,null,backgroundPlaneMesh.geometry,backgroundPlaneMesh.material,backgroundPlaneMesh,null);}//
if(scene.overrideMaterial){var overrideMaterial=scene.overrideMaterial;renderObjects(this.opaqueObjects,scene,camera,overrideMaterial,visibilityFunc);renderObjects(this.transparentObjects,scene,camera,overrideMaterial,visibilityFunc);}else{// opaque pass (front-to-back order)
state.setBlending(NoBlending);// transparent pass (back-to-front order)
if(this.transparency===PaintersTransperancy){renderObjects(this.opaqueObjects,scene,camera,overrideMaterial,visibilityFunc);renderObjects(this.transparentObjects,scene,camera,overrideMaterial,visibilityFunc);}}// custom render plugins (post pass)
spritePlugin.render(scene,camera);lensFlarePlugin.render(scene,camera,_currentViewport);// Generate mipmap if we're using any kind of mipmap filtering
if(renderTarget){textures.updateRenderTargetMipmap(renderTarget);}// Ensure depth buffer writing is enabled so it can be cleared on next render
state.setDepthTest(true);state.setDepthWrite(true);state.setColorWrite(true);// _gl.finish();
};function pushRenderItem(object,geometry,material,z,group){var array,index;// allocate the next position in the appropriate array
if(material.transparent){array=_this.transparentObjects;index=++transparentObjectsLastIndex;}else{array=_this.opaqueObjects;index=++opaqueObjectsLastIndex;}// recycle existing render item or grow the array
var renderItem=array[index];if(renderItem!==undefined){renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.z=_vector3.z;renderItem.group=group;}else{renderItem={id:object.id,object:object,geometry:geometry,material:material,z:_vector3.z,group:group};// assert( index === array.length );
array.push(renderItem);}}// TODO Duplicated code (Frustum)
function isObjectViewable(object){var geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return isSphereViewable(_sphere);}function isSpriteViewable(sprite){_sphere.center.set(0,0,0);_sphere.radius=0.7071067811865476;_sphere.applyMatrix4(sprite.matrixWorld);return isSphereViewable(_sphere);}function isSphereViewable(sphere){if(!_frustum.intersectsSphere(sphere))return false;var numPlanes=_clipping.numPlanes;if(numPlanes===0)return true;var planes=_this.clippingPlanes,center=sphere.center,negRad=-sphere.radius,i=0;do{// out when deeper than radius in the negative halfspace
if(planes[i].distanceToPoint(center)<negRad)return false;}while(++i!==numPlanes);return true;}this.projectObject=function(object,camera){if(object.visible===false)return;var visible=(object.layers.mask&camera.layers.mask)!==0;if(visible){if(object.isLight){lights.push(object);}else if(object.isSprite){if(object.frustumCulled===false||isSpriteViewable(object)===true){sprites.push(object);}}else if(object.isLensFlare){lensFlares.push(object);}else if(object.isImmediateRenderObject){if(_this.sortObjects===true){_vector3.setFromMatrixPosition(object.matrixWorld);_vector3.applyMatrix4(_projScreenMatrix);}pushRenderItem(object,null,object.material,_vector3.z,null);}else if(object.isMesh||object.isLine||object.isPoints){if(object.isSkinnedMesh){object.skeleton.update();}if(object.frustumCulled===false||isObjectViewable(object)===true){var material=object.material;if(material.visible===true){if(_this.sortObjects===true){_vector3.setFromMatrixPosition(object.matrixWorld);_vector3.applyMatrix4(_projScreenMatrix);}var geometry=objects.update(object);if(material.isMultiMaterial){var groups=geometry.groups;var materials=material.materials;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];var groupMaterial=materials[group.materialIndex];if(groupMaterial.visible===true){pushRenderItem(object,geometry,groupMaterial,_vector3.z,group);}}}else{pushRenderItem(object,geometry,material,_vector3.z,null);}}}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){this.projectObject(children[i],camera);}};function renderObjects(renderList,scene,camera,overrideMaterial,visibilityFunc){for(var i=0,l=renderList.length;i<l;i++){var renderItem=renderList[i];var object=renderItem.object;if(visibilityFunc&&object&&!visibilityFunc(object))continue;var geometry=renderItem.geometry;var material=overrideMaterial===undefined?renderItem.material:overrideMaterial;var group=renderItem.group;object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);object.onBeforeRender(_this,scene,camera,geometry,material,group);if(object.isImmediateRenderObject){setMaterial(material);var program=setProgram(camera,scene.fog,material,object);_currentGeometryProgram='';object.render(function(object){_this.renderBufferImmediate(object,program,material);});}else{_this.renderBufferDirect(camera,scene.fog,geometry,material,object,group);}object.onAfterRender(_this,scene,camera,geometry,material,group);}}function initMaterial(material,fog,object){var materialProperties=properties.get(material);var parameters=programCache.getParameters(material,_lights,fog,_clipping.numPlanes,_clipping.numIntersection,object);var code=programCache.getProgramCode(material,parameters);var program=materialProperties.program;var programChange=true;if(program===undefined){// new material
material.addEventListener('dispose',onMaterialDispose);}else if(program.code!==code){// changed glsl or parameters
releaseMaterialProgramReference(material);}else if(parameters.shaderID!==undefined){// same glsl and uniform list
return;}else{// only rebuild uniform list
programChange=false;}if(programChange){if(parameters.shaderID){var shader=ShaderLib[parameters.shaderID];materialProperties.__webglShader={name:material.type,uniforms:UniformsUtils.clone(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader};}else{materialProperties.__webglShader={name:material.type,uniforms:material.uniforms,vertexShader:material.vertexShader,fragmentShader:material.fragmentShader};}material.__webglShader=materialProperties.__webglShader;program=programCache.acquireProgram(material,parameters,code);materialProperties.program=program;material.program=program;}var attributes=program.getAttributes();if(material.morphTargets){material.numSupportedMorphTargets=0;for(var i=0;i<_this.maxMorphTargets;i++){if(attributes['morphTarget'+i]>=0){material.numSupportedMorphTargets++;}}}if(material.morphNormals){material.numSupportedMorphNormals=0;for(var i=0;i<_this.maxMorphNormals;i++){if(attributes['morphNormal'+i]>=0){material.numSupportedMorphNormals++;}}}var uniforms=materialProperties.__webglShader.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){materialProperties.numClippingPlanes=_clipping.numPlanes;materialProperties.numIntersection=_clipping.numIntersection;uniforms.clippingPlanes=_clipping.uniform;}materialProperties.fog=fog;// store the light setup it was created for
materialProperties.lightsHash=_lights.hash;if(material.lights){// wire up the material to this renderer's lighting state
uniforms.ambientLightColor.value=_lights.ambient;uniforms.directionalLights.value=_lights.directional;uniforms.spotLights.value=_lights.spot;uniforms.rectAreaLights.value=_lights.rectArea;uniforms.pointLights.value=_lights.point;uniforms.hemisphereLights.value=_lights.hemi;uniforms.directionalShadowMap.value=_lights.directionalShadowMap;uniforms.directionalShadowMatrix.value=_lights.directionalShadowMatrix;uniforms.spotShadowMap.value=_lights.spotShadowMap;uniforms.spotShadowMatrix.value=_lights.spotShadowMatrix;uniforms.pointShadowMap.value=_lights.pointShadowMap;uniforms.pointShadowMatrix.value=_lights.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
}var progUniforms=materialProperties.program.getUniforms(),uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);materialProperties.uniformsList=uniformsList;}function setMaterial(material){material.side===DoubleSide?state.disable(_gl.CULL_FACE):state.enable(_gl.CULL_FACE);state.setFlipSided(material.side===BackSide);material.transparent===true?state.setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha):state.setBlending(NoBlending);state.setDepthFunc(material.depthFunc);state.setDepthTest(material.depthTest);state.setDepthWrite(material.depthWrite);state.setColorWrite(material.colorWrite);state.setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);}function setProgram(camera,fog,material,object){_usedTextureUnits=0;var materialProperties=properties.get(material);if(_clippingEnabled){if(_localClippingEnabled||camera!==_currentCamera){var useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
// object instead of the material, once it becomes feasible
// (#8465, #8379)
_clipping.setState(material.clippingPlanes,material.clipIntersection,material.clipShadows,camera,materialProperties,useCache);}}if(material.needsUpdate===false){if(materialProperties.program===undefined){material.needsUpdate=true;}else if(material.fog&&materialProperties.fog!==fog){material.needsUpdate=true;}else if(material.lights&&materialProperties.lightsHash!==_lights.hash){material.needsUpdate=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==_clipping.numPlanes||materialProperties.numIntersection!==_clipping.numIntersection)){material.needsUpdate=true;}}if(material.needsUpdate){initMaterial(material,fog,object);material.needsUpdate=false;}var refreshProgram=false;var refreshMaterial=false;var refreshLights=false;var program=materialProperties.program,p_uniforms=program.getUniforms(),m_uniforms=materialProperties.__webglShader.uniforms;if(program.id!==_currentProgram){_gl.useProgram(program.program);_currentProgram=program.id;refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||camera!==_currentCamera){p_uniforms.set(_gl,camera,'projectionMatrix');if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}if(camera!==_currentCamera){_currentCamera=camera;// lighting uniforms depend on the camera so enforce an update
// now, in case this material supports lights - or later, when
// the next material that does gets activated:
refreshMaterial=true;// set to true on material change
refreshLights=true;// remains set until update done
}// load material specific uniforms
// (shader material also gets them for the sake of genericity)
if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.envMap){var uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}}if(material.isMeshPhongMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.skinning){p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);}p_uniforms.set(_gl,_this,'toneMappingExposure');p_uniforms.set(_gl,_this,'toneMappingWhitePoint');p_uniforms.set(_gl,_this,'ditherScale');}p_uniforms.set(_gl,_this,'oitMode');// skinning uniforms must be set even if material didn't change
// auto-setting of texture unit for bone texture must go before other textures
// not sure why, but otherwise weird things happen
if(material.skinning){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');var skeleton=object.skeleton;if(skeleton){if(capabilities.floatVertexTextures&&skeleton.useVertexTexture){p_uniforms.set(_gl,skeleton,'boneTexture');p_uniforms.set(_gl,skeleton,'boneTextureWidth');p_uniforms.set(_gl,skeleton,'boneTextureHeight');}else{p_uniforms.setOptional(_gl,skeleton,'boneMatrices');}}}if(refreshMaterial){if(material.lights){// the current material requires lighting info
// note: all lighting uniforms are always set correctly
// they simply reference the renderer's state for their
// values
//
// use the current material's .needsUpdate flags to set
// the GL state when required
markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
if(fog&&material.fog){refreshUniformsFog(m_uniforms,fog);}if(material.isMeshBasicMaterial||material.isMeshLambertMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isMeshDepthMaterial||material.isMeshNormalMaterial||material.isMeshCubeMaterial){refreshUniformsCommon(m_uniforms,material);}// refresh single material specific uniforms
if(material.isLineBasicMaterial){refreshUniformsLine(m_uniforms,material);}else if(material.isLineDashedMaterial){refreshUniformsLine(m_uniforms,material);refreshUniformsDash(m_uniforms,material);}else if(material.isPointsMaterial){refreshUniformsPoints(m_uniforms,material);}else if(material.isMeshCubeMaterial){refreshUniformsCube(m_uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsLambert(m_uniforms,material);}else if(material.isMeshToonMaterial){refreshUniformsToon(m_uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsPhong(m_uniforms,material);}else if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(m_uniforms,material);}else if(material.isMeshStandardMaterial){refreshUniformsStandard(m_uniforms,material);}else if(material.isMeshDepthMaterial){if(material.displacementMap){m_uniforms.displacementMap.value=material.displacementMap;m_uniforms.displacementScale.value=material.displacementScale;m_uniforms.displacementBias.value=material.displacementBias;}}else if(material.isMeshNormalMaterial){refreshUniformsNormal(m_uniforms,material);}// RectAreaLight Texture
// TODO (mrdoob): Find a nicer implementation
if(m_uniforms.ltcMat!==undefined)m_uniforms.ltcMat.value=UniformsLib.LTC_MAT_TEXTURE;if(m_uniforms.ltcMag!==undefined)m_uniforms.ltcMag.value=UniformsLib.LTC_MAG_TEXTURE;WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,_this);}// common matrices
p_uniforms.set(_gl,object,'modelViewMatrix');p_uniforms.set(_gl,object,'normalMatrix');p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);p_uniforms.setValue(_gl,'modelMatrixInverse',object.matrixWorldInverse);return program;}// Uniforms (refresh uniforms objects)
var texelTransform={texelScale:0,texelOffset:0};function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;uniforms.diffuse.value=material.color;if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}var supportedMapNames=MaterialMap.SupportedMapNames;var supportedMapSlotNames=MaterialMap.SupportedMapSlotNames;var supportedMapUVNames=MaterialMap.SupportedMapUVNames;var supportedMapTexelNames=MaterialMap.SupportedMapTexelNames;if(!material.usedSlots||material.usedSlotsVersion!=material.version){material.usedSlots=[];for(var i=0,il=supportedMapNames.length;i<il;i++){var mapName=supportedMapNames[i];var mapSlotName=supportedMapSlotNames[i];var map=material[mapSlotName];material.usedSlots.push({index:i,mapUniform:uniforms[mapName],uvUniform:uniforms[supportedMapUVNames[i]],texelUniform:uniforms[supportedMapTexelNames[i]]});}material.usedSlotsVersion=material.version;}for(var j=0,jl=material.usedSlots.length;j<jl;j++){var usedSlots=material.usedSlots[j];var i=usedSlots.index;var mapName=supportedMapNames[i];var mapSlotName=supportedMapSlotNames[i];var map=material[mapSlotName];if(map){usedSlots.mapUniform.value=map.texture;if(map.texture){if(map.uvTransform){var value=usedSlots.uvUniform.value;value.set(map.uvRepeat.x,map.uvRepeat.y,map.uvOffset.x,map.uvOffset.y);}if(map.texelTransform){texelTransform=map.getFlattenedTexelTransform(texelTransform);usedSlots.texelUniform.value.set(texelTransform.texelScale,texelTransform.texelOffset);}}}else if(material[mapName]){uniforms[mapName].value=material[mapName];}}//uniforms.map.value = material.map;
//uniforms.specularMap.value = material.specularMap;
//uniforms.alphaMap.value = material.alphaMap;
if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;}if(material.aoMap){//uniforms.aoMap.value = material.aoMap;
uniforms.aoMapIntensity.value=material.aoMapIntensity;}// uv repeat and offset setting priorities
// 1. color map
// 2. specular map
// 3. normal map
// 4. bump map
// 5. alpha map
// 6. emissive map
var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.specularMap){uvScaleMap=material.specularMap;}else if(material.displacementMap){uvScaleMap=material.displacementMap;}else if(material.normalMap){uvScaleMap=material.normalMap;}else if(material.bumpMap){uvScaleMap=material.bumpMap;}else if(material.roughnessMap){uvScaleMap=material.roughnessMap;}else if(material.metalnessMap){uvScaleMap=material.metalnessMap;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}else if(material.emissiveMap){uvScaleMap=material.emissiveMap;}if(uvScaleMap!==undefined){// backwards compatibility
if(uvScaleMap.isWebGLRenderTarget){uvScaleMap=uvScaleMap.texture;}var offset=uvScaleMap.offset;var repeat=uvScaleMap.repeat;uniforms.offsetRepeat.value.set(offset.x,offset.y,repeat.x,repeat.y);}uniforms.envMap.value=material.envMap;if(material.envMapIntensity){//uniforms.envMap.value = material.envMap; // part of uniforms common
uniforms.envMapIntensity.value=material.envMapIntensity;}// don't flip CubeTexture envMaps, flip everything else:
//  WebGLRenderTargetCube will be flipped for backwards compatibility
//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
uniforms.flipEnvMap.value=!(material.envMap&&material.envMap.isCubeTexture)?1:-1;uniforms.reflectivity.value=material.reflectivity;uniforms.refractionRatio.value=material.refractionRatio;}function refreshUniformsCube(uniforms,material){uniforms.roughness.value=material.roughness;uniforms.opacity.value=material.opacity;uniforms.envMapIntensity.value=material.envMapIntensity;}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value=material.color;uniforms.opacity.value=material.opacity;}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material){uniforms.diffuse.value=material.color;uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*_pixelRatio;uniforms.scale.value=_height*0.5;uniforms.map.value=material.map;if(material.map!==null){var offset=material.map.offset;var repeat=material.map.repeat;uniforms.offsetRepeat.value.set(offset.x,offset.y,repeat.x,repeat.y);}}function refreshUniformsFog(uniforms,fog){uniforms.fogColor.value=fog.color;if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshUniformsLambert(uniforms,material){if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value=material.specular;uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsToon(uniforms,material){refreshUniformsPhong(uniforms,material);if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}}function refreshUniformsStandard(uniforms,material){uniforms.roughness.value=material.roughness;uniforms.metalness.value=material.metalness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;}if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}if(material.envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material){uniforms.falloffDiffuse.value=material.falloffColor;if(material.falloffMap){uniforms.falloffMap.value=material.falloffMap;}uniforms.falloffOpacity.value=material.falloffOpacity;if(material.falloffAlphaMap){uniforms.falloffAlphaMap.value=material.falloffAlphaMap;}uniforms.anisotropy.value=material.anisotropy;if(material.anisotropyMap){uniforms.anisotropyMap.value=material.anisotropyMap;}uniforms.anisotropyRotation.value=material.anisotropyRotation;if(material.anisotropyRotationMap){uniforms.anisotropyRotationMap.value=material.anisotropyRotationMap;}uniforms.clearCoat.value=material.clearCoat;uniforms.clearCoatRoughness.value=material.clearCoatRoughness;refreshUniformsStandard(uniforms,material);}function refreshUniformsNormal(uniforms,material){if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}// Lighting
function setupShadows(lights){var lightShadowsLength=0;for(var i=0,l=lights.length;i<l;i++){var light=lights[i];if(light.castShadow){_lights.shadows[lightShadowsLength++]=light;}}_lights.shadows.length=lightShadowsLength;}function setupLights(lights,camera){var l,ll,light,r=0,g=0,b=0,color,intensity,distance,shadowMap,viewMatrix=camera.matrixWorldInverse,directionalLength=0,pointLength=0,spotLength=0,rectAreaLength=0,hemiLength=0;for(l=0,ll=lights.length;l<ll;l++){light=lights[l];color=light.color;intensity=light.intensity;distance=light.distance;shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity;g+=color.g*intensity;b+=color.b*intensity;}else if(light.isDirectionalLight){var uniforms=lightCache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.direction.setFromMatrixPosition(light.matrixWorld);_vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(_vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.shadow=light.castShadow;if(light.castShadow){uniforms.shadowBias=light.shadow.bias;uniforms.spreadAngle=light.shadow.spreadAngle;uniforms.shadowMapSize=light.shadow.mapSize;uniforms.shadowCameraParams.x=Math.abs(light.shadow.camera.right-light.shadow.camera.left);uniforms.shadowCameraParams.y=light.shadow.camera.near;uniforms.shadowCameraParams.z=light.shadow.camera.far;}_lights.directionalShadowMap[directionalLength]=shadowMap;_lights.directionalShadowMatrix[directionalLength]=light.shadow.matrix;_lights.directional[directionalLength++]=uniforms;}else if(light.isSpotLight){var uniforms=lightCache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.distance=distance;uniforms.direction.setFromMatrixPosition(light.matrixWorld);_vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(_vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.distance===0?0.0:light.decay;uniforms.shadow=light.castShadow;if(light.castShadow){uniforms.shadowBias=light.shadow.bias;uniforms.shadowRadius=light.shadow.radius;uniforms.shadowMapSize=light.shadow.mapSize;uniforms.shadowCameraParams.x=_Math.DEG2RAD*light.shadow.camera.fov;uniforms.shadowCameraParams.y=light.shadow.camera.near;uniforms.shadowCameraParams.z=light.shadow.camera.far;}_lights.spotShadowMap[spotLength]=shadowMap;_lights.spotShadowMatrix[spotLength]=light.shadow.matrix;_lights.spot[spotLength++]=uniforms;}else if(light.isRectAreaLight){var uniforms=lightCache.get(light);// (a) intensity controls irradiance of entire light
uniforms.color.copy(color).multiplyScalar(intensity/(light.width*light.height));// (b) intensity controls the radiance per light area
// uniforms.color.copy( color ).multiplyScalar( intensity );
uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
_matrix42.identity();_matrix4.copy(light.matrixWorld);_matrix4.premultiply(viewMatrix);_matrix42.extractRotation(_matrix4);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);uniforms.halfWidth.applyMatrix4(_matrix42);uniforms.halfHeight.applyMatrix4(_matrix42);// TODO (abelnation): RectAreaLight distance?
// uniforms.distance = distance;
_lights.rectArea[rectAreaLength++]=uniforms;}else if(light.isPointLight){var uniforms=lightCache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.distance=light.distance;uniforms.decay=light.distance===0?0.0:light.decay;uniforms.shadow=light.castShadow;if(light.castShadow){uniforms.shadowBias=light.shadow.bias;uniforms.shadowRadius=light.shadow.radius;uniforms.shadowMapSize=light.shadow.mapSize;}_lights.pointShadowMap[pointLength]=shadowMap;if(_lights.pointShadowMatrix[pointLength]===undefined){_lights.pointShadowMatrix[pointLength]=new Matrix4();}// for point lights we set the shadow matrix to be a translation-only matrix
// equal to inverse of the light's position
_vector3.setFromMatrixPosition(light.matrixWorld).negate();_lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3);_lights.point[pointLength++]=uniforms;}else if(light.isHemisphereLight){var uniforms=lightCache.get(light);uniforms.direction.setFromMatrixPosition(light.matrixWorld);uniforms.direction.transformDirection(viewMatrix);uniforms.direction.normalize();uniforms.skyColor.copy(light.color).multiplyScalar(intensity);uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);_lights.hemi[hemiLength++]=uniforms;}}_lights.ambient[0]=r;_lights.ambient[1]=g;_lights.ambient[2]=b;_lights.directional.length=directionalLength;_lights.spot.length=spotLength;_lights.rectArea.length=rectAreaLength;_lights.point.length=pointLength;_lights.hemi.length=hemiLength;// TODO (sam-g-steel) why aren't we using join
_lights.hash=directionalLength+','+pointLength+','+spotLength+','+rectAreaLength+','+hemiLength+','+_lights.shadows.length;}// GL state setting
this.setFaceCulling=function(cullFace,frontFaceDirection){state.setCullFace(cullFace);state.setFlipSided(frontFaceDirection===FrontFaceDirectionCW);};// Textures
function allocTextureUnit(){var textureUnit=_usedTextureUnits;if(textureUnit>=capabilities.maxTextures){console.warn('WebGLRenderer: trying to use '+textureUnit+' texture units while this GPU supports only '+capabilities.maxTextures);}_usedTextureUnits+=1;return textureUnit;}this.allocTextureUnit=allocTextureUnit;// this.setTexture2D = setTexture2D;
this.setTexture2D=function(){var warned=false;// backwards compatibility: peel texture.texture
return function setTexture2D(texture,slot){if(texture&&texture.isWebGLRenderTarget){if(!warned){console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.",texture);warned=true;}texture=texture.texture;}textures.setTexture2D(texture,slot);};}();this.setTexture=function(){var warned=false;return function setTexture(texture,slot){if(!warned){console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");warned=true;}textures.setTexture2D(texture,slot);};}();this.setTextureCube=function(){var warned=false;return function setTextureCube(texture,slot){// backwards compatibility: peel texture.texture
if(texture&&texture.isWebGLRenderTargetCube){if(!warned){console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.",texture);warned=true;}texture=texture.texture;}// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
// TODO: unify these code paths
if(texture&&texture.isCubeTexture||Array.isArray(texture.image)&&texture.image.length===6){// CompressedTexture can have Array in image :/
// this function alone should take care of cube textures
textures.setTextureCube(texture,slot);}else{// assumed: texture property of THREE.WebGLRenderTargetCube
textures.setTextureCubeDynamic(texture,slot);}};}();this.getCurrentRenderTarget=function(){return _currentRenderTarget;};this.setRenderTarget=function(renderTarget){_currentRenderTarget=renderTarget;if(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}var isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;var framebuffer;if(renderTarget){var renderTargetProperties=properties.get(renderTarget);if(isCube){framebuffer=renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];}else{framebuffer=renderTargetProperties.__webglFramebuffer;}_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;_currentViewport.copy(renderTarget.viewport);}else{framebuffer=null;_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);_currentScissorTest=_scissorTest;_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);}if(_currentFramebuffer!==framebuffer){_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);_currentFramebuffer=framebuffer;}state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);state.viewport(_currentViewport);if(isCube){var textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+renderTarget.activeCubeFace,textureProperties.__webglTexture,renderTarget.activeMipMapLevel);}};this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer){if((renderTarget&&renderTarget.isWebGLRenderTarget)===false){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}var framebuffer=properties.get(renderTarget).__webglFramebuffer;if(framebuffer){var restore=false;if(framebuffer!==_currentFramebuffer){_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);restore=true;}try{var texture=renderTarget.texture;var textureFormat=texture.format;var textureType=texture.type;if(textureFormat!==RGBAFormat&&paramThreeToGL(textureFormat)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}if(textureType!==UnsignedByteType&&paramThreeToGL(textureType)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE)&&// IE11, Edge and Chrome Mac < 52 (#9513)
!(textureType===FloatType&&(extensions.get('OES_texture_float')||extensions.get('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
!(textureType===HalfFloatType&&extensions.get('EXT_color_buffer_half_float'))){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}if(_gl.checkFramebufferStatus(_gl.FRAMEBUFFER)===_gl.FRAMEBUFFER_COMPLETE){// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,paramThreeToGL(textureFormat),paramThreeToGL(textureType),buffer);}}else{console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');}}finally{if(restore){_gl.bindFramebuffer(_gl.FRAMEBUFFER,_currentFramebuffer);}}}};// MaterialMap three.js constants to WebGL constants
function paramThreeToGL(p){var extension;if(p===RepeatWrapping)return _gl.REPEAT;if(p===ClampToEdgeWrapping)return _gl.CLAMP_TO_EDGE;if(p===MirroredRepeatWrapping)return _gl.MIRRORED_REPEAT;if(p===NearestFilter)return _gl.NEAREST;if(p===NearestMipMapNearestFilter)return _gl.NEAREST_MIPMAP_NEAREST;if(p===NearestMipMapLinearFilter)return _gl.NEAREST_MIPMAP_LINEAR;if(p===LinearFilter)return _gl.LINEAR;if(p===LinearMipMapNearestFilter)return _gl.LINEAR_MIPMAP_NEAREST;if(p===LinearMipMapLinearFilter)return _gl.LINEAR_MIPMAP_LINEAR;if(p===UnsignedByteType)return _gl.UNSIGNED_BYTE;if(p===UnsignedShort4444Type)return _gl.UNSIGNED_SHORT_4_4_4_4;if(p===UnsignedShort5551Type)return _gl.UNSIGNED_SHORT_5_5_5_1;if(p===UnsignedShort565Type)return _gl.UNSIGNED_SHORT_5_6_5;if(p===ByteType)return _gl.BYTE;if(p===ShortType)return _gl.SHORT;if(p===UnsignedShortType)return _gl.UNSIGNED_SHORT;if(p===IntType)return _gl.INT;if(p===UnsignedIntType)return _gl.UNSIGNED_INT;if(p===FloatType)return _gl.FLOAT;if(p===HalfFloatType){extension=extensions.get('OES_texture_half_float');if(extension!==null)return extension.HALF_FLOAT_OES;}if(p===AlphaFormat)return _gl.ALPHA;if(p===RGBFormat)return _gl.RGB;if(p===RGBAFormat)return _gl.RGBA;if(p===LuminanceFormat)return _gl.LUMINANCE;if(p===LuminanceAlphaFormat)return _gl.LUMINANCE_ALPHA;if(p===DepthFormat)return _gl.DEPTH_COMPONENT;if(p===DepthStencilFormat)return _gl.DEPTH_STENCIL;if(p===AddEquation)return _gl.FUNC_ADD;if(p===SubtractEquation)return _gl.FUNC_SUBTRACT;if(p===ReverseSubtractEquation)return _gl.FUNC_REVERSE_SUBTRACT;if(p===ZeroFactor)return _gl.ZERO;if(p===OneFactor)return _gl.ONE;if(p===SrcColorFactor)return _gl.SRC_COLOR;if(p===OneMinusSrcColorFactor)return _gl.ONE_MINUS_SRC_COLOR;if(p===SrcAlphaFactor)return _gl.SRC_ALPHA;if(p===OneMinusSrcAlphaFactor)return _gl.ONE_MINUS_SRC_ALPHA;if(p===DstAlphaFactor)return _gl.DST_ALPHA;if(p===OneMinusDstAlphaFactor)return _gl.ONE_MINUS_DST_ALPHA;if(p===DstColorFactor)return _gl.DST_COLOR;if(p===OneMinusDstColorFactor)return _gl.ONE_MINUS_DST_COLOR;if(p===SrcAlphaSaturateFactor)return _gl.SRC_ALPHA_SATURATE;if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}}if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}}if(p===RGB_ETC1_Format){extension=extensions.get('WEBGL_compressed_texture_etc1');if(extension!==null)return extension.COMPRESSED_RGB_ETC1_WEBGL;}if(p===MinEquation||p===MaxEquation){extension=extensions.get('EXT_blend_minmax');if(extension!==null){if(p===MinEquation)return extension.MIN_EXT;if(p===MaxEquation)return extension.MAX_EXT;}}if(p===UnsignedInt248Type){extension=extensions.get('WEBGL_depth_texture');if(extension!==null)return extension.UNSIGNED_INT_24_8_WEBGL;}return 0;}}/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function FogExp2(color,density){this.name='';this.color=new Color(color);this.density=density!==undefined?density:0.00025;}FogExp2.prototype.isFogExp2=true;FogExp2.prototype.clone=function(){return new FogExp2(this.color.getHex(),this.density);};FogExp2.prototype.toJSON=function(meta){return{type:'FogExp2',color:this.color.getHex(),density:this.density};};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function Fog(color,near,far){this.name='';this.color=new Color(color);this.near=near!==undefined?near:1;this.far=far!==undefined?far:1000;}Fog.prototype.isFog=true;Fog.prototype.clone=function(){return new Fog(this.color.getHex(),this.near,this.far);};Fog.prototype.toJSON=function(meta){return{type:'Fog',color:this.color.getHex(),near:this.near,far:this.far};};/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */function LensFlare(texture,size,distance,blending,color){Object3D.call(this);this.lensFlares=[];this.positionScreen=new Vector3();this.customUpdateCallback=undefined;if(texture!==undefined){this.add(texture,size,distance,blending,color);}}LensFlare.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:LensFlare,isLensFlare:true,copy:function copy(source){Object3D.prototype.copy.call(this,source);this.positionScreen.copy(source.positionScreen);this.customUpdateCallback=source.customUpdateCallback;for(var i=0,l=source.lensFlares.length;i<l;i++){this.lensFlares.push(source.lensFlares[i]);}return this;},add:function add(texture,size,distance,blending,color,opacity){if(size===undefined)size=-1;if(distance===undefined)distance=0;if(opacity===undefined)opacity=1;if(color===undefined)color=new Color(0xffffff);if(blending===undefined)blending=NormalBlending;distance=Math.min(distance,Math.max(0,distance));this.lensFlares.push({texture:texture,// THREE.Texture
size:size,// size in pixels (-1 = use texture.width)
distance:distance,// distance (0-1) from light source (0=at light source)
x:0,y:0,z:0,// screen position (-1 => 1) z = 0 is in front z = 1 is back
scale:1,// scale
rotation:0,// rotation
opacity:opacity,// opacity
color:color,// color
blending:blending// blending
});},/*
		 * Update lens flares update positions on all flares based on the screen position
		 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
		 */updateLensFlares:function updateLensFlares(){var f,fl=this.lensFlares.length;var flare;var vecX=-this.positionScreen.x*2;var vecY=-this.positionScreen.y*2;for(f=0;f<fl;f++){flare=this.lensFlares[f];flare.x=this.positionScreen.x+vecX*flare.distance;flare.y=this.positionScreen.y+vecY*flare.distance;flare.wantedRotation=flare.x*Math.PI*0.25;flare.rotation+=(flare.wantedRotation-flare.rotation)*0.25;}}});/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2()
	 * }
	 */function SpriteMaterial(parameters){Material.call(this);this.type='SpriteMaterial';this.color=new Color(0xffffff);this.map=null;this.rotation=0;this.fog=false;this.lights=false;this.setValues(parameters);}SpriteMaterial.prototype=(0,_create2.default)(Material.prototype);SpriteMaterial.prototype.constructor=SpriteMaterial;SpriteMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.rotation=source.rotation;return this;};/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */function Sprite(material){Object3D.call(this);this.type='Sprite';this.material=material!==undefined?material:new SpriteMaterial();}Sprite.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:Sprite,isSprite:true,raycast:function(){var matrixPosition=new Vector3();return function raycast(raycaster,intersects){matrixPosition.setFromMatrixPosition(this.matrixWorld);var distanceSq=raycaster.ray.distanceSqToPoint(matrixPosition);var guessSizeSq=this.scale.x*this.scale.y/4;if(distanceSq>guessSizeSq){return;}intersects.push({distance:Math.sqrt(distanceSq),point:this.position,face:null,object:this});};}(),clone:function clone(){return new this.constructor(this.material).copy(this);}});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */function LOD(){Object3D.call(this);this.type='LOD';(0,_defineProperties2.default)(this,{levels:{enumerable:true,value:[]}});}LOD.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:LOD,copy:function copy(source){Object3D.prototype.copy.call(this,source,false);var levels=source.levels;for(var i=0,l=levels.length;i<l;i++){var level=levels[i];this.addLevel(level.object.clone(),level.distance);}return this;},addLevel:function addLevel(object,distance){if(distance===undefined)distance=0;distance=Math.abs(distance);var levels=this.levels;for(var l=0;l<levels.length;l++){if(distance<levels[l].distance){break;}}levels.splice(l,0,{distance:distance,object:object});this.add(object);},getObjectForDistance:function getObjectForDistance(distance){var levels=this.levels;for(var i=1,l=levels.length;i<l;i++){if(distance<levels[i].distance){break;}}return levels[i-1].object;},raycast:function(){var matrixPosition=new Vector3();return function raycast(raycaster,intersects){matrixPosition.setFromMatrixPosition(this.matrixWorld);var distance=raycaster.ray.origin.distanceTo(matrixPosition);this.getObjectForDistance(distance).raycast(raycaster,intersects);};}(),update:function(){var v1=new Vector3();var v2=new Vector3();return function update(camera){var levels=this.levels;if(levels.length>1){v1.setFromMatrixPosition(camera.matrixWorld);v2.setFromMatrixPosition(this.matrixWorld);var distance=v1.distanceTo(v2);levels[0].object.visible=true;for(var i=1,l=levels.length;i<l;i++){if(distance>=levels[i].distance){levels[i-1].object.visible=false;levels[i].object.visible=true;}else{break;}}for(;i<l;i++){levels[i].object.visible=false;}}};}(),toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.levels=[];var levels=this.levels;for(var i=0,l=levels.length;i<l;i++){var level=levels[i];data.object.levels.push({object:level.object.uuid,distance:level.distance});}return data;}});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */function Skeleton(bones,boneInverses,useVertexTexture){this.useVertexTexture=useVertexTexture!==undefined?useVertexTexture:true;this.identityMatrix=new Matrix4();// copy the bone array
bones=bones||[];this.bones=bones.slice(0);// create a bone texture or an array of floats
if(this.useVertexTexture){// layout (1 matrix = 4 pixels)
//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
var size=Math.sqrt(this.bones.length*4);// 4 pixels needed for 1 matrix
size=_Math.nextPowerOfTwo(Math.ceil(size));size=Math.max(size,4);this.boneTextureWidth=size;this.boneTextureHeight=size;this.boneMatrices=new Float32Array(this.boneTextureWidth*this.boneTextureHeight*4);// 4 floats per RGBA pixel
this.boneTexture=new DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,RGBAFormat,FloatType);}else{this.boneMatrices=new Float32Array(16*this.bones.length);}// use the supplied bone inverses or calculate the inverses
if(boneInverses===undefined){this.calculateInverses();}else{if(this.bones.length===boneInverses.length){this.boneInverses=boneInverses.slice(0);}else{console.warn('THREE.Skeleton bonInverses is the wrong length.');this.boneInverses=[];for(var b=0,bl=this.bones.length;b<bl;b++){this.boneInverses.push(new Matrix4());}}}}(0,_assign2.default)(Skeleton.prototype,{calculateInverses:function calculateInverses(){this.boneInverses=[];for(var b=0,bl=this.bones.length;b<bl;b++){var inverse=new Matrix4();if(this.bones[b]){inverse.getInverse(this.bones[b].matrixWorld);}this.boneInverses.push(inverse);}},pose:function pose(){var bone;// recover the bind-time world matrices
for(var b=0,bl=this.bones.length;b<bl;b++){bone=this.bones[b];if(bone){bone.matrixWorld.getInverse(this.boneInverses[b]);}}// compute the local matrices, positions, rotations and scales
for(var b=0,bl=this.bones.length;b<bl;b++){bone=this.bones[b];if(bone){if(bone.parent&&bone.parent.isBone){bone.matrix.getInverse(bone.parent.matrixWorld);bone.matrix.multiply(bone.matrixWorld);}else{bone.matrix.copy(bone.matrixWorld);}bone.matrix.decompose(bone.position,bone.quaternion,bone.scale);}}},update:function(){var offsetMatrix=new Matrix4();return function update(){// flatten bone matrices to array
for(var b=0,bl=this.bones.length;b<bl;b++){// compute the offset between the current and the original transform
var matrix=this.bones[b]?this.bones[b].matrixWorld:this.identityMatrix;offsetMatrix.multiplyMatrices(matrix,this.boneInverses[b]);offsetMatrix.toArray(this.boneMatrices,b*16);}if(this.useVertexTexture){this.boneTexture.needsUpdate=true;}};}(),clone:function clone(){return new Skeleton(this.bones,this.boneInverses,this.useVertexTexture);}});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */function Bone(){Object3D.call(this);this.type='Bone';}Bone.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:Bone,isBone:true});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */function SkinnedMesh(geometry,material,useVertexTexture){Mesh.call(this,geometry,material);this.type='SkinnedMesh';this.bindMode="attached";this.bindMatrix=new Matrix4();this.bindMatrixInverse=new Matrix4();// init bones
// TODO: remove bone creation as there is no reason (other than
// convenience) for THREE.SkinnedMesh to do this.
var bones=[];if(this.geometry&&this.geometry.bones!==undefined){var bone,gbone;for(var b=0,bl=this.geometry.bones.length;b<bl;++b){gbone=this.geometry.bones[b];bone=new Bone();bones.push(bone);bone.name=gbone.name;bone.position.fromArray(gbone.pos);bone.quaternion.fromArray(gbone.rotq);if(gbone.scl!==undefined)bone.scale.fromArray(gbone.scl);}for(var b=0,bl=this.geometry.bones.length;b<bl;++b){gbone=this.geometry.bones[b];if(gbone.parent!==-1&&gbone.parent!==null&&bones[gbone.parent]!==undefined){bones[gbone.parent].add(bones[b]);}else{this.add(bones[b]);}}}this.normalizeSkinWeights();this.updateMatrixWorld(true);this.bind(new Skeleton(bones,undefined,useVertexTexture),this.matrixWorld);}SkinnedMesh.prototype=(0,_assign2.default)((0,_create2.default)(Mesh.prototype),{constructor:SkinnedMesh,isSkinnedMesh:true,bind:function bind(skeleton,bindMatrix){this.skeleton=skeleton;if(bindMatrix===undefined){this.updateMatrixWorld(true);this.skeleton.calculateInverses();bindMatrix=this.matrixWorld;}this.bindMatrix.copy(bindMatrix);this.bindMatrixInverse.getInverse(bindMatrix);},pose:function pose(){this.skeleton.pose();},normalizeSkinWeights:function normalizeSkinWeights(){if(this.geometry&&this.geometry.isGeometry){for(var i=0;i<this.geometry.skinWeights.length;i++){var sw=this.geometry.skinWeights[i];var scale=1.0/sw.lengthManhattan();if(scale!==Infinity){sw.multiplyScalar(scale);}else{sw.set(1,0,0,0);// do something reasonable
}}}else if(this.geometry&&this.geometry.isBufferGeometry){var vec=new Vector4();var skinWeight=this.geometry.attributes.skinWeight;for(var i=0;i<skinWeight.count;i++){vec.x=skinWeight.getX(i);vec.y=skinWeight.getY(i);vec.z=skinWeight.getZ(i);vec.w=skinWeight.getW(i);var scale=1.0/vec.lengthManhattan();if(scale!==Infinity){vec.multiplyScalar(scale);}else{vec.set(1,0,0,0);// do something reasonable
}skinWeight.setXYZW(i,vec.x,vec.y,vec.z,vec.w);}}},updateMatrixWorld:function updateMatrixWorld(force){Mesh.prototype.updateMatrixWorld.call(this,true);if(this.bindMode==="attached"){this.bindMatrixInverse.getInverse(this.matrixWorld);}else if(this.bindMode==="detached"){this.bindMatrixInverse.getInverse(this.bindMatrix);}else{console.warn('THREE.SkinnedMesh unrecognized bindMode: '+this.bindMode);}},clone:function clone(){return new this.constructor(this.geometry,this.material,this.skeleton.useVertexTexture).copy(this);}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */function LineBasicMaterial(parameters){Material.call(this);this.type='LineBasicMaterial';this.color=new Color(0xffffff);this.linewidth=1;this.linecap='round';this.linejoin='round';this.lights=false;this.setValues(parameters);}LineBasicMaterial.prototype=(0,_create2.default)(Material.prototype);LineBasicMaterial.prototype.constructor=LineBasicMaterial;LineBasicMaterial.prototype.isLineBasicMaterial=true;LineBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.linewidth=source.linewidth;this.linecap=source.linecap;this.linejoin=source.linejoin;return this;};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Line(geometry,material,mode){if(mode===1){console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');return new LineSegments(geometry,material);}Object3D.call(this);this.type='Line';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new LineBasicMaterial({color:Math.random()*0xffffff});}Line.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:Line,isLine:true,raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();return function raycast(raycaster,intersects){var precision=raycaster.linePrecision;var precisionSq=precision*precision;var geometry=this.geometry;var matrixWorld=this.matrixWorld;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var vStart=new Vector3();var vEnd=new Vector3();var interSegment=new Vector3();var interRay=new Vector3();var step=this&&this.isLineSegments?2:1;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,l=indices.length-1;i<l;i+=step){var a=indices[i];var b=indices[i+1];vStart.fromArray(positions,a*3);vEnd.fromArray(positions,b*3);var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}else{for(var i=0,l=positions.length/3-1;i<l;i+=step){vStart.fromArray(positions,3*i);vEnd.fromArray(positions,3*i+3);var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}}else if(geometry.isGeometry){var vertices=geometry.vertices;var nbVertices=vertices.length;for(var i=0;i<nbVertices-1;i+=step){var distSq=ray.distanceSqToSegment(vertices[i],vertices[i+1],interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}};}(),clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function LineSegments(geometry,material){Line.call(this,geometry,material);this.type='LineSegments';}LineSegments.prototype=(0,_assign2.default)((0,_create2.default)(Line.prototype),{constructor:LineSegments,isLineSegments:true});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */function PointsMaterial(parameters){Material.call(this);this.type='PointsMaterial';this.color=new Color(0xffffff);this.map=null;this.size=1;this.sizeAttenuation=true;this.lights=false;this.setValues(parameters);}PointsMaterial.prototype=(0,_create2.default)(Material.prototype);PointsMaterial.prototype.constructor=PointsMaterial;PointsMaterial.prototype.isPointsMaterial=true;PointsMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.size=source.size;this.sizeAttenuation=source.sizeAttenuation;return this;};/**
	 * @author alteredq / http://alteredqualia.com/
	 */function Points(geometry,material){Object3D.call(this);this.type='Points';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new PointsMaterial({color:Math.random()*0xffffff});}Points.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:Points,isPoints:true,raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();return function raycast(raycaster,intersects){var object=this;var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Points.threshold;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;var position=new Vector3();function testPoint(point,index){var rayPointDistanceSq=ray.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){var intersectPoint=ray.closestPointToPoint(point);intersectPoint.applyMatrix4(matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint.clone(),index:index,face:null,object:object});}}if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,il=indices.length;i<il;i++){var a=indices[i];position.fromArray(positions,a*3);testPoint(position,a);}}else{for(var i=0,l=positions.length/3;i<l;i++){position.fromArray(positions,i*3);testPoint(position,i);}}}else{var vertices=geometry.vertices;for(var i=0,l=vertices.length;i<l;i++){testPoint(vertices[i],i);}}};}(),clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Group(){Object3D.call(this);this.type='Group';}Group.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:Group});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function VideoTexture(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){Texture.call(this,video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.generateMipmaps=false;var scope=this;function update(){requestAnimationFrame(update);if(video.readyState>=video.HAVE_CURRENT_DATA){scope.needsUpdate=true;}}update();}VideoTexture.prototype=(0,_create2.default)(Texture.prototype);VideoTexture.prototype.constructor=VideoTexture;/**
	 * @author alteredq / http://alteredqualia.com/
	 */function CompressedTexture(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={width:width,height:height};this.mipmaps=mipmaps;// no flipping for cube textures
// (also flipping doesn't work for compressed textures )
this.flipY=false;// can't generate mipmaps for compressed textures
// mips must be embedded in DDS files
this.generateMipmaps=false;}CompressedTexture.prototype=(0,_create2.default)(Texture.prototype);CompressedTexture.prototype.constructor=CompressedTexture;CompressedTexture.prototype.isCompressedTexture=true;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function CanvasTexture(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){Texture.call(this,canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.needsUpdate=true;}CanvasTexture.prototype=(0,_create2.default)(Texture.prototype);CanvasTexture.prototype.constructor=CanvasTexture;/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */function DepthTexture(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){format=format!==undefined?format:DepthFormat;if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}if(type===undefined&&format===DepthFormat)type=UnsignedShortType;if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.image={width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.flipY=false;this.generateMipmaps=false;}DepthTexture.prototype=(0,_create2.default)(Texture.prototype);DepthTexture.prototype.constructor=DepthTexture;DepthTexture.prototype.isDepthTexture=true;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WireframeGeometry(geometry){BufferGeometry.call(this);var edge=[0,0],hash={};function sortFunction(a,b){return a-b;}var keys=['a','b','c'];if(geometry&&geometry.isGeometry){var vertices=geometry.vertices;var faces=geometry.faces;var numEdges=0;// allocate maximal size
var edges=new Uint32Array(6*faces.length);for(var i=0,l=faces.length;i<l;i++){var face=faces[i];for(var j=0;j<3;j++){edge[0]=face[keys[j]];edge[1]=face[keys[(j+1)%3]];edge.sort(sortFunction);var key=edge.toString();if(hash[key]===undefined){edges[2*numEdges]=edge[0];edges[2*numEdges+1]=edge[1];hash[key]=true;numEdges++;}}}var coords=new Float32Array(numEdges*2*3);for(var i=0,l=numEdges;i<l;i++){for(var j=0;j<2;j++){var vertex=vertices[edges[2*i+j]];var index=6*i+3*j;coords[index+0]=vertex.x;coords[index+1]=vertex.y;coords[index+2]=vertex.z;}}this.addAttribute('position',new BufferAttribute(coords,3));}else if(geometry&&geometry.isBufferGeometry){if(geometry.index!==null){// Indexed BufferGeometry
var indices=geometry.index.array;var vertices=geometry.attributes.position;var groups=geometry.groups;var numEdges=0;if(groups.length===0){geometry.addGroup(0,indices.length);}// allocate maximal size
var edges=new Uint32Array(2*indices.length);for(var o=0,ol=groups.length;o<ol;++o){var group=groups[o];var start=group.start;var count=group.count;for(var i=start,il=start+count;i<il;i+=3){for(var j=0;j<3;j++){edge[0]=indices[i+j];edge[1]=indices[i+(j+1)%3];edge.sort(sortFunction);var key=edge.toString();if(hash[key]===undefined){edges[2*numEdges]=edge[0];edges[2*numEdges+1]=edge[1];hash[key]=true;numEdges++;}}}}var coords=new Float32Array(numEdges*2*3);for(var i=0,l=numEdges;i<l;i++){for(var j=0;j<2;j++){var index=6*i+3*j;var index2=edges[2*i+j];coords[index+0]=vertices.getX(index2);coords[index+1]=vertices.getY(index2);coords[index+2]=vertices.getZ(index2);}}this.addAttribute('position',new BufferAttribute(coords,3));}else{// non-indexed BufferGeometry
var vertices=geometry.attributes.position.array;var numEdges=vertices.length/3;var numTris=numEdges/3;var coords=new Float32Array(numEdges*2*3);for(var i=0,l=numTris;i<l;i++){for(var j=0;j<3;j++){var index=18*i+6*j;var index1=9*i+3*j;coords[index+0]=vertices[index1];coords[index+1]=vertices[index1+1];coords[index+2]=vertices[index1+2];var index2=9*i+3*((j+1)%3);coords[index+3]=vertices[index2];coords[index+4]=vertices[index2+1];coords[index+5]=vertices[index2+2];}}this.addAttribute('position',new BufferAttribute(coords,3));}}}WireframeGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);WireframeGeometry.prototype.constructor=WireframeGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */function ParametricBufferGeometry(func,slices,stacks){BufferGeometry.call(this);this.type='ParametricBufferGeometry';this.parameters={func:func,slices:slices,stacks:stacks};// generate vertices and uvs
var vertices=[];var uvs=[];var i,j,p;var u,v;var sliceCount=slices+1;for(i=0;i<=stacks;i++){v=i/stacks;for(j=0;j<=slices;j++){u=j/slices;p=func(u,v);vertices.push(p.x,p.y,p.z);uvs.push(u,v);}}// generate indices
var indices=[];var a,b,c,d;for(i=0;i<stacks;i++){for(j=0;j<slices;j++){a=i*sliceCount+j;b=i*sliceCount+j+1;c=(i+1)*sliceCount+j+1;d=(i+1)*sliceCount+j;// faces one and two
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(new(indices.length>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1));this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// generate normals
this.computeVertexNormals();}ParametricBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);ParametricBufferGeometry.prototype.constructor=ParametricBufferGeometry;/**
	 * @author zz85 / https://github.com/zz85
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */function ParametricGeometry(func,slices,stacks){Geometry.call(this);this.type='ParametricGeometry';this.parameters={func:func,slices:slices,stacks:stacks};this.fromBufferGeometry(new ParametricBufferGeometry(func,slices,stacks));this.mergeVertices();}ParametricGeometry.prototype=(0,_create2.default)(Geometry.prototype);ParametricGeometry.prototype.constructor=ParametricGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */function PolyhedronBufferGeometry(vertices,indices,radius,detail){BufferGeometry.call(this);this.type='PolyhedronBufferGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};radius=radius||1;detail=detail||0;// default buffer data
var vertexBuffer=[];var uvBuffer=[];// the subdivision creates the vertex buffer data
subdivide(detail);// all vertices should lie on a conceptual sphere with a given radius
appplyRadius(radius);// finally, create the uv data
generateUVs();// build non-indexed geometry
this.addAttribute('position',new Float32BufferAttribute(vertexBuffer,3));this.addAttribute('normal',new Float32BufferAttribute(vertexBuffer.slice(),3));this.addAttribute('uv',new Float32BufferAttribute(uvBuffer,2));this.normalizeNormals();this.boundingSphere=new Sphere(new Vector3(),radius);// helper functions
function subdivide(detail){var a=new Vector3();var b=new Vector3();var c=new Vector3();// iterate over all faces and apply a subdivison with the given detail value
for(var i=0;i<indices.length;i+=3){// get the vertices of the face
getVertexByIndex(indices[i+0],a);getVertexByIndex(indices[i+1],b);getVertexByIndex(indices[i+2],c);// perform subdivision
subdivideFace(a,b,c,detail);}}function subdivideFace(a,b,c,detail){var cols=Math.pow(2,detail);// we use this multidimensional array as a data structure for creating the subdivision
var v=[];var i,j;// construct all of the vertices for this subdivision
for(i=0;i<=cols;i++){v[i]=[];var aj=a.clone().lerp(c,i/cols);var bj=b.clone().lerp(c,i/cols);var rows=cols-i;for(j=0;j<=rows;j++){if(j===0&&i===cols){v[i][j]=aj;}else{v[i][j]=aj.clone().lerp(bj,j/rows);}}}// construct all of the faces
for(i=0;i<cols;i++){for(j=0;j<2*(cols-i)-1;j++){var k=Math.floor(j/2);if(j%2===0){pushVertex(v[i][k+1]);pushVertex(v[i+1][k]);pushVertex(v[i][k]);}else{pushVertex(v[i][k+1]);pushVertex(v[i+1][k+1]);pushVertex(v[i+1][k]);}}}}function appplyRadius(radius){var vertex=new Vector3();// iterate over the entire buffer and apply the radius to each vertex
for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];vertex.normalize().multiplyScalar(radius);vertexBuffer[i+0]=vertex.x;vertexBuffer[i+1]=vertex.y;vertexBuffer[i+2]=vertex.z;}}function generateUVs(){var vertex=new Vector3();for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];var u=azimuth(vertex)/2/Math.PI+0.5;var v=inclination(vertex)/Math.PI+0.5;uvBuffer.push(u,1-v);}correctUVs();correctSeam();}function correctSeam(){// handle case when face straddles the seam, see #3269
for(var i=0;i<uvBuffer.length;i+=6){// uv data of a single face
var x0=uvBuffer[i+0];var x1=uvBuffer[i+2];var x2=uvBuffer[i+4];var max=Math.max(x0,x1,x2);var min=Math.min(x0,x1,x2);// 0.9 is somewhat arbitrary
if(max>0.9&&min<0.1){if(x0<0.2)uvBuffer[i+0]+=1;if(x1<0.2)uvBuffer[i+2]+=1;if(x2<0.2)uvBuffer[i+4]+=1;}}}function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z);}function getVertexByIndex(index,vertex){var stride=index*3;vertex.x=vertices[stride+0];vertex.y=vertices[stride+1];vertex.z=vertices[stride+2];}function correctUVs(){var a=new Vector3();var b=new Vector3();var c=new Vector3();var centroid=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();for(var i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){a.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);b.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);c.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]);uvA.set(uvBuffer[j+0],uvBuffer[j+1]);uvB.set(uvBuffer[j+2],uvBuffer[j+3]);uvC.set(uvBuffer[j+4],uvBuffer[j+5]);centroid.copy(a).add(b).add(c).divideScalar(3);var azi=azimuth(centroid);correctUV(uvA,j+0,a,azi);correctUV(uvB,j+2,b,azi);correctUV(uvC,j+4,c,azi);}}function correctUV(uv,stride,vector,azimuth){if(azimuth<0&&uv.x===1){uvBuffer[stride]=uv.x-1;}if(vector.x===0&&vector.z===0){uvBuffer[stride]=azimuth/2/Math.PI+0.5;}}// Angle around the Y axis, counter-clockwise when looking from above.
function azimuth(vector){return Math.atan2(vector.z,-vector.x);}// Angle above the XZ plane.
function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z));}}PolyhedronBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);PolyhedronBufferGeometry.prototype.constructor=PolyhedronBufferGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */function TetrahedronBufferGeometry(radius,detail){var vertices=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1];var indices=[2,1,0,0,3,2,1,3,0,2,3,1];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='TetrahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}TetrahedronBufferGeometry.prototype=(0,_create2.default)(PolyhedronBufferGeometry.prototype);TetrahedronBufferGeometry.prototype.constructor=TetrahedronBufferGeometry;/**
	 * @author timothypratley / https://github.com/timothypratley
	 */function TetrahedronGeometry(radius,detail){Geometry.call(this);this.type='TetrahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new TetrahedronBufferGeometry(radius,detail));this.mergeVertices();}TetrahedronGeometry.prototype=(0,_create2.default)(Geometry.prototype);TetrahedronGeometry.prototype.constructor=TetrahedronGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */function OctahedronBufferGeometry(radius,detail){var vertices=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1];var indices=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='OctahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}OctahedronBufferGeometry.prototype=(0,_create2.default)(PolyhedronBufferGeometry.prototype);OctahedronBufferGeometry.prototype.constructor=OctahedronBufferGeometry;/**
	 * @author timothypratley / https://github.com/timothypratley
	 */function OctahedronGeometry(radius,detail){Geometry.call(this);this.type='OctahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new OctahedronBufferGeometry(radius,detail));this.mergeVertices();}OctahedronGeometry.prototype=(0,_create2.default)(Geometry.prototype);OctahedronGeometry.prototype.constructor=OctahedronGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */function IcosahedronBufferGeometry(radius,detail){var t=(1+Math.sqrt(5))/2;var vertices=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1];var indices=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='IcosahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}IcosahedronBufferGeometry.prototype=(0,_create2.default)(PolyhedronBufferGeometry.prototype);IcosahedronBufferGeometry.prototype.constructor=IcosahedronBufferGeometry;/**
	 * @author timothypratley / https://github.com/timothypratley
	 */function IcosahedronGeometry(radius,detail){Geometry.call(this);this.type='IcosahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new IcosahedronBufferGeometry(radius,detail));this.mergeVertices();}IcosahedronGeometry.prototype=(0,_create2.default)(Geometry.prototype);IcosahedronGeometry.prototype.constructor=IcosahedronGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */function DodecahedronBufferGeometry(radius,detail){var t=(1+Math.sqrt(5))/2;var r=1/t;var vertices=[// (1, 1, 1)
-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,// (0, 1/, )
0,-r,-t,0,-r,t,0,r,-t,0,r,t,// (1/, , 0)
-r,-t,0,-r,t,0,r,-t,0,r,t,0,// (, 0, 1/)
-t,0,-r,t,0,-r,-t,0,r,t,0,r];var indices=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='DodecahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}DodecahedronBufferGeometry.prototype=(0,_create2.default)(PolyhedronBufferGeometry.prototype);DodecahedronBufferGeometry.prototype.constructor=DodecahedronBufferGeometry;/**
	 * @author Abe Pazos / https://hamoid.com
	 */function DodecahedronGeometry(radius,detail){Geometry.call(this);this.type='DodecahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new DodecahedronBufferGeometry(radius,detail));this.mergeVertices();}DodecahedronGeometry.prototype=(0,_create2.default)(Geometry.prototype);DodecahedronGeometry.prototype.constructor=DodecahedronGeometry;/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/function PolyhedronGeometry(vertices,indices,radius,detail){Geometry.call(this);this.type='PolyhedronGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices,indices,radius,detail));this.mergeVertices();}PolyhedronGeometry.prototype=(0,_create2.default)(Geometry.prototype);PolyhedronGeometry.prototype.constructor=PolyhedronGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Creates a tube which extrudes along a 3d spline.
	 *
	 */function TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed){BufferGeometry.call(this);this.type='TubeBufferGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};tubularSegments=tubularSegments||64;radius=radius||1;radialSegments=radialSegments||8;closed=closed||false;var frames=path.computeFrenetFrames(tubularSegments,closed);// expose internals
this.tangents=frames.tangents;this.normals=frames.normals;this.binormals=frames.binormals;// helper variables
var vertex=new Vector3();var normal=new Vector3();var uv=new Vector2();var i,j;// buffer
var vertices=[];var normals=[];var uvs=[];var indices=[];// create buffer data
generateBufferData();// build geometry
this.setIndex(new(indices.length>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1));this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// functions
function generateBufferData(){for(i=0;i<tubularSegments;i++){generateSegment(i);}// if the geometry is not closed, generate the last row of vertices and normals
// at the regular position on the given path
//
// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
generateSegment(closed===false?tubularSegments:0);// uvs are generated in a separate function.
// this makes it easy compute correct values for closed geometries
generateUVs();// finally create faces
generateIndices();}function generateSegment(i){// we use getPointAt to sample evenly distributed points from the given path
var P=path.getPointAt(i/tubularSegments);// retrieve corresponding normal and binormal
var N=frames.normals[i];var B=frames.binormals[i];// generate normals and vertices for the current segment
for(j=0;j<=radialSegments;j++){var v=j/radialSegments*Math.PI*2;var sin=Math.sin(v);var cos=-Math.cos(v);// normal
normal.x=cos*N.x+sin*B.x;normal.y=cos*N.y+sin*B.y;normal.z=cos*N.z+sin*B.z;normal.normalize();normals.push(normal.x,normal.y,normal.z);// vertex
vertex.x=P.x+radius*normal.x;vertex.y=P.y+radius*normal.y;vertex.z=P.z+radius*normal.z;vertices.push(vertex.x,vertex.y,vertex.z);}}function generateIndices(){for(j=1;j<=tubularSegments;j++){for(i=1;i<=radialSegments;i++){var a=(radialSegments+1)*(j-1)+(i-1);var b=(radialSegments+1)*j+(i-1);var c=(radialSegments+1)*j+i;var d=(radialSegments+1)*(j-1)+i;// faces
indices.push(a,b,d);indices.push(b,c,d);}}}function generateUVs(){for(i=0;i<=tubularSegments;i++){for(j=0;j<=radialSegments;j++){uv.x=i/tubularSegments;uv.y=j/radialSegments;uvs.push(uv.x,uv.y);}}}}TubeBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);TubeBufferGeometry.prototype.constructor=TubeBufferGeometry;/**
	 * @author oosmoxiecode / https://github.com/oosmoxiecode
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Creates a tube which extrudes along a 3d spline.
	 */function TubeGeometry(path,tubularSegments,radius,radialSegments,closed,taper){Geometry.call(this);this.type='TubeGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};if(taper!==undefined)console.warn('THREE.TubeGeometry: taper has been removed.');var bufferGeometry=new TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed);// expose internals
this.tangents=bufferGeometry.tangents;this.normals=bufferGeometry.normals;this.binormals=bufferGeometry.binormals;// create geometry
this.fromBufferGeometry(bufferGeometry);this.mergeVertices();}TubeGeometry.prototype=(0,_create2.default)(Geometry.prototype);TubeGeometry.prototype.constructor=TubeGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * see: http://www.blackpawn.com/texts/pqtorus/
	 */function TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q){BufferGeometry.call(this);this.type='TorusKnotBufferGeometry';this.parameters={radius:radius,tube:tube,tubularSegments:tubularSegments,radialSegments:radialSegments,p:p,q:q};radius=radius||100;tube=tube||40;tubularSegments=Math.floor(tubularSegments)||64;radialSegments=Math.floor(radialSegments)||8;p=p||2;q=q||3;// used to calculate buffer length
var vertexCount=(radialSegments+1)*(tubularSegments+1);var indexCount=radialSegments*tubularSegments*2*3;// buffers
var indices=new BufferAttribute(new(indexCount>65535?Uint32Array:Uint16Array)(indexCount),1);var vertices=new BufferAttribute(new Float32Array(vertexCount*3),3);var normals=new BufferAttribute(new Float32Array(vertexCount*3),3);var uvs=new BufferAttribute(new Float32Array(vertexCount*2),2);// helper variables
var i,j,index=0,indexOffset=0;var vertex=new Vector3();var normal=new Vector3();var uv=new Vector2();var P1=new Vector3();var P2=new Vector3();var B=new Vector3();var T=new Vector3();var N=new Vector3();// generate vertices, normals and uvs
for(i=0;i<=tubularSegments;++i){// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
var u=i/tubularSegments*p*Math.PI*2;// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
calculatePositionOnCurve(u,p,q,radius,P1);calculatePositionOnCurve(u+0.01,p,q,radius,P2);// calculate orthonormal basis
T.subVectors(P2,P1);N.addVectors(P2,P1);B.crossVectors(T,N);N.crossVectors(B,T);// normalize B, N. T can be ignored, we don't use it
B.normalize();N.normalize();for(j=0;j<=radialSegments;++j){// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
var v=j/radialSegments*Math.PI*2;var cx=-tube*Math.cos(v);var cy=tube*Math.sin(v);// now calculate the final vertex position.
// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
vertex.x=P1.x+(cx*N.x+cy*B.x);vertex.y=P1.y+(cx*N.y+cy*B.y);vertex.z=P1.z+(cx*N.z+cy*B.z);// vertex
vertices.setXYZ(index,vertex.x,vertex.y,vertex.z);// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
normal.subVectors(vertex,P1).normalize();normals.setXYZ(index,normal.x,normal.y,normal.z);// uv
uv.x=i/tubularSegments;uv.y=j/radialSegments;uvs.setXY(index,uv.x,uv.y);// increase index
index++;}}// generate indices
for(j=1;j<=tubularSegments;j++){for(i=1;i<=radialSegments;i++){// indices
var a=(radialSegments+1)*(j-1)+(i-1);var b=(radialSegments+1)*j+(i-1);var c=(radialSegments+1)*j+i;var d=(radialSegments+1)*(j-1)+i;// face one
indices.setX(indexOffset,a);indexOffset++;indices.setX(indexOffset,b);indexOffset++;indices.setX(indexOffset,d);indexOffset++;// face two
indices.setX(indexOffset,b);indexOffset++;indices.setX(indexOffset,c);indexOffset++;indices.setX(indexOffset,d);indexOffset++;}}// build geometry
this.setIndex(indices);this.addAttribute('position',vertices);this.addAttribute('normal',normals);this.addAttribute('uv',uvs);// this function calculates the current position on the torus curve
function calculatePositionOnCurve(u,p,q,radius,position){var cu=Math.cos(u);var su=Math.sin(u);var quOverP=q/p*u;var cs=Math.cos(quOverP);position.x=radius*(2+cs)*0.5*cu;position.y=radius*(2+cs)*su*0.5;position.z=radius*Math.sin(quOverP)*0.5;}}TorusKnotBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);TorusKnotBufferGeometry.prototype.constructor=TorusKnotBufferGeometry;/**
	 * @author oosmoxiecode
	 */function TorusKnotGeometry(radius,tube,tubularSegments,radialSegments,p,q,heightScale){Geometry.call(this);this.type='TorusKnotGeometry';this.parameters={radius:radius,tube:tube,tubularSegments:tubularSegments,radialSegments:radialSegments,p:p,q:q};if(heightScale!==undefined)console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');this.fromBufferGeometry(new TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q));this.mergeVertices();}TorusKnotGeometry.prototype=(0,_create2.default)(Geometry.prototype);TorusKnotGeometry.prototype.constructor=TorusKnotGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */function TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc){BufferGeometry.call(this);this.type='TorusBufferGeometry';this.parameters={radius:radius,tube:tube,radialSegments:radialSegments,tubularSegments:tubularSegments,arc:arc};radius=radius||100;tube=tube||40;radialSegments=Math.floor(radialSegments)||8;tubularSegments=Math.floor(tubularSegments)||6;arc=arc||Math.PI*2;// used to calculate buffer length
var vertexCount=(radialSegments+1)*(tubularSegments+1);var indexCount=radialSegments*tubularSegments*2*3;// buffers
var indices=new(indexCount>65535?Uint32Array:Uint16Array)(indexCount);var vertices=new Float32Array(vertexCount*3);var normals=new Float32Array(vertexCount*3);var uvs=new Float32Array(vertexCount*2);// offset variables
var vertexBufferOffset=0;var uvBufferOffset=0;var indexBufferOffset=0;// helper variables
var center=new Vector3();var vertex=new Vector3();var normal=new Vector3();var j,i;// generate vertices, normals and uvs
for(j=0;j<=radialSegments;j++){for(i=0;i<=tubularSegments;i++){var u=i/tubularSegments*arc;var v=j/radialSegments*Math.PI*2;// vertex
vertex.x=(radius+tube*Math.cos(v))*Math.cos(u);vertex.y=(radius+tube*Math.cos(v))*Math.sin(u);vertex.z=tube*Math.sin(v);vertices[vertexBufferOffset]=vertex.x;vertices[vertexBufferOffset+1]=vertex.y;vertices[vertexBufferOffset+2]=vertex.z;// this vector is used to calculate the normal
center.x=radius*Math.cos(u);center.y=radius*Math.sin(u);// normal
normal.subVectors(vertex,center).normalize();normals[vertexBufferOffset]=normal.x;normals[vertexBufferOffset+1]=normal.y;normals[vertexBufferOffset+2]=normal.z;// uv
uvs[uvBufferOffset]=i/tubularSegments;uvs[uvBufferOffset+1]=j/radialSegments;// update offsets
vertexBufferOffset+=3;uvBufferOffset+=2;}}// generate indices
for(j=1;j<=radialSegments;j++){for(i=1;i<=tubularSegments;i++){// indices
var a=(tubularSegments+1)*j+i-1;var b=(tubularSegments+1)*(j-1)+i-1;var c=(tubularSegments+1)*(j-1)+i;var d=(tubularSegments+1)*j+i;// face one
indices[indexBufferOffset]=a;indices[indexBufferOffset+1]=b;indices[indexBufferOffset+2]=d;// face two
indices[indexBufferOffset+3]=b;indices[indexBufferOffset+4]=c;indices[indexBufferOffset+5]=d;// update offset
indexBufferOffset+=6;}}// build geometry
this.setIndex(new BufferAttribute(indices,1));this.addAttribute('position',new BufferAttribute(vertices,3));this.addAttribute('normal',new BufferAttribute(normals,3));this.addAttribute('uv',new BufferAttribute(uvs,2));}TorusBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);TorusBufferGeometry.prototype.constructor=TorusBufferGeometry;/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */function TorusGeometry(radius,tube,radialSegments,tubularSegments,arc){Geometry.call(this);this.type='TorusGeometry';this.parameters={radius:radius,tube:tube,radialSegments:radialSegments,tubularSegments:tubularSegments,arc:arc};this.fromBufferGeometry(new TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc));}TorusGeometry.prototype=(0,_create2.default)(Geometry.prototype);TorusGeometry.prototype.constructor=TorusGeometry;/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */var ShapeUtils={// calculate area of the contour polygon
area:function area(contour){var n=contour.length;var a=0.0;for(var p=n-1,q=0;q<n;p=q++){a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;}return a*0.5;},triangulate:function(){/**
			 * This code is a quick port of code written in C++ which was submitted to
			 * flipcode.com by John W. Ratcliff  // July 22, 2000
			 * See original code and more information here:
			 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
			 *
			 * ported to actionscript by Zevan Rosser
			 * www.actionsnippet.com
			 *
			 * ported to javascript by Joshua Koo
			 * http://www.lab4games.net/zz85/blog
			 *
			 */function snip(contour,u,v,w,n,verts){var p;var ax,ay,bx,by;var cx,cy,px,py;ax=contour[verts[u]].x;ay=contour[verts[u]].y;bx=contour[verts[v]].x;by=contour[verts[v]].y;cx=contour[verts[w]].x;cy=contour[verts[w]].y;if((bx-ax)*(cy-ay)-(by-ay)*(cx-ax)<=0)return false;var aX,aY,bX,bY,cX,cY;var apx,apy,bpx,bpy,cpx,cpy;var cCROSSap,bCROSScp,aCROSSbp;aX=cx-bx;aY=cy-by;bX=ax-cx;bY=ay-cy;cX=bx-ax;cY=by-ay;for(p=0;p<n;p++){px=contour[verts[p]].x;py=contour[verts[p]].y;if(px===ax&&py===ay||px===bx&&py===by||px===cx&&py===cy)continue;apx=px-ax;apy=py-ay;bpx=px-bx;bpy=py-by;cpx=px-cx;cpy=py-cy;// see if p is inside triangle abc
aCROSSbp=aX*bpy-aY*bpx;cCROSSap=cX*apy-cY*apx;bCROSScp=bX*cpy-bY*cpx;if(aCROSSbp>=-_epsilon2.default&&bCROSScp>=-_epsilon2.default&&cCROSSap>=-_epsilon2.default)return false;}return true;}// takes in an contour array and returns
return function triangulate(contour,indices){var n=contour.length;if(n<3)return null;var result=[],verts=[],vertIndices=[];/* we want a counter-clockwise polygon in verts */var u,v,w;if(ShapeUtils.area(contour)>0.0){for(v=0;v<n;v++){verts[v]=v;}}else{for(v=0;v<n;v++){verts[v]=n-1-v;}}var nv=n;/*  remove nv - 2 vertices, creating 1 triangle every time */var count=2*nv;/* error detection */for(v=nv-1;nv>2;){/* if we loop, it is probably a non-simple polygon */if(count--<=0){//** Triangulate: ERROR - probable bad polygon!
//throw ( "Warning, unable to triangulate polygon!" );
//return null;
// Sometimes warning is fine, especially polygons are triangulated in reverse.
console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');if(indices)return vertIndices;return result;}/* three consecutive vertices in current polygon, <u,v,w> */u=v;if(nv<=u)u=0;/* previous */v=u+1;if(nv<=v)v=0;/* new v    */w=v+1;if(nv<=w)w=0;/* next     */if(snip(contour,u,v,w,nv,verts)){var a,b,c,s,t;/* true names of the vertices */a=verts[u];b=verts[v];c=verts[w];/* output Triangle */result.push([contour[a],contour[b],contour[c]]);vertIndices.push([verts[u],verts[v],verts[w]]);/* remove v from the remaining polygon */for(s=v,t=v+1;t<nv;s++,t++){verts[s]=verts[t];}nv--;/* reset error detection counter */count=2*nv;}}if(indices)return vertIndices;return result;};}(),triangulateShape:function triangulateShape(contour,holes){function removeDupEndPts(points){var l=points.length;if(l>2&&points[l-1].equals(points[0])){points.pop();}}removeDupEndPts(contour);holes.forEach(removeDupEndPts);function point_in_segment_2D_colin(inSegPt1,inSegPt2,inOtherPt){// inOtherPt needs to be collinear to the inSegment
if(inSegPt1.x!==inSegPt2.x){if(inSegPt1.x<inSegPt2.x){return inSegPt1.x<=inOtherPt.x&&inOtherPt.x<=inSegPt2.x;}else{return inSegPt2.x<=inOtherPt.x&&inOtherPt.x<=inSegPt1.x;}}else{if(inSegPt1.y<inSegPt2.y){return inSegPt1.y<=inOtherPt.y&&inOtherPt.y<=inSegPt2.y;}else{return inSegPt2.y<=inOtherPt.y&&inOtherPt.y<=inSegPt1.y;}}}function intersect_segments_2D(inSeg1Pt1,inSeg1Pt2,inSeg2Pt1,inSeg2Pt2,inExcludeAdjacentSegs){var seg1dx=inSeg1Pt2.x-inSeg1Pt1.x,seg1dy=inSeg1Pt2.y-inSeg1Pt1.y;var seg2dx=inSeg2Pt2.x-inSeg2Pt1.x,seg2dy=inSeg2Pt2.y-inSeg2Pt1.y;var seg1seg2dx=inSeg1Pt1.x-inSeg2Pt1.x;var seg1seg2dy=inSeg1Pt1.y-inSeg2Pt1.y;var limit=seg1dy*seg2dx-seg1dx*seg2dy;var perpSeg1=seg1dy*seg1seg2dx-seg1dx*seg1seg2dy;if(Math.abs(limit)>_epsilon2.default){// not parallel
var perpSeg2;if(limit>0){if(perpSeg1<0||perpSeg1>limit)return[];perpSeg2=seg2dy*seg1seg2dx-seg2dx*seg1seg2dy;if(perpSeg2<0||perpSeg2>limit)return[];}else{if(perpSeg1>0||perpSeg1<limit)return[];perpSeg2=seg2dy*seg1seg2dx-seg2dx*seg1seg2dy;if(perpSeg2>0||perpSeg2<limit)return[];}// i.e. to reduce rounding errors
// intersection at endpoint of segment#1?
if(perpSeg2===0){if(inExcludeAdjacentSegs&&(perpSeg1===0||perpSeg1===limit))return[];return[inSeg1Pt1];}if(perpSeg2===limit){if(inExcludeAdjacentSegs&&(perpSeg1===0||perpSeg1===limit))return[];return[inSeg1Pt2];}// intersection at endpoint of segment#2?
if(perpSeg1===0)return[inSeg2Pt1];if(perpSeg1===limit)return[inSeg2Pt2];// return real intersection point
var factorSeg1=perpSeg2/limit;return[{x:inSeg1Pt1.x+factorSeg1*seg1dx,y:inSeg1Pt1.y+factorSeg1*seg1dy}];}else{// parallel or collinear
if(perpSeg1!==0||seg2dy*seg1seg2dx!==seg2dx*seg1seg2dy)return[];// they are collinear or degenerate
var seg1Pt=seg1dx===0&&seg1dy===0;// segment1 is just a point?
var seg2Pt=seg2dx===0&&seg2dy===0;// segment2 is just a point?
// both segments are points
if(seg1Pt&&seg2Pt){if(inSeg1Pt1.x!==inSeg2Pt1.x||inSeg1Pt1.y!==inSeg2Pt1.y)return[];// they are distinct  points
return[inSeg1Pt1];// they are the same point
}// segment#1  is a single point
if(seg1Pt){if(!point_in_segment_2D_colin(inSeg2Pt1,inSeg2Pt2,inSeg1Pt1))return[];// but not in segment#2
return[inSeg1Pt1];}// segment#2  is a single point
if(seg2Pt){if(!point_in_segment_2D_colin(inSeg1Pt1,inSeg1Pt2,inSeg2Pt1))return[];// but not in segment#1
return[inSeg2Pt1];}// they are collinear segments, which might overlap
var seg1min,seg1max,seg1minVal,seg1maxVal;var seg2min,seg2max,seg2minVal,seg2maxVal;if(seg1dx!==0){// the segments are NOT on a vertical line
if(inSeg1Pt1.x<inSeg1Pt2.x){seg1min=inSeg1Pt1;seg1minVal=inSeg1Pt1.x;seg1max=inSeg1Pt2;seg1maxVal=inSeg1Pt2.x;}else{seg1min=inSeg1Pt2;seg1minVal=inSeg1Pt2.x;seg1max=inSeg1Pt1;seg1maxVal=inSeg1Pt1.x;}if(inSeg2Pt1.x<inSeg2Pt2.x){seg2min=inSeg2Pt1;seg2minVal=inSeg2Pt1.x;seg2max=inSeg2Pt2;seg2maxVal=inSeg2Pt2.x;}else{seg2min=inSeg2Pt2;seg2minVal=inSeg2Pt2.x;seg2max=inSeg2Pt1;seg2maxVal=inSeg2Pt1.x;}}else{// the segments are on a vertical line
if(inSeg1Pt1.y<inSeg1Pt2.y){seg1min=inSeg1Pt1;seg1minVal=inSeg1Pt1.y;seg1max=inSeg1Pt2;seg1maxVal=inSeg1Pt2.y;}else{seg1min=inSeg1Pt2;seg1minVal=inSeg1Pt2.y;seg1max=inSeg1Pt1;seg1maxVal=inSeg1Pt1.y;}if(inSeg2Pt1.y<inSeg2Pt2.y){seg2min=inSeg2Pt1;seg2minVal=inSeg2Pt1.y;seg2max=inSeg2Pt2;seg2maxVal=inSeg2Pt2.y;}else{seg2min=inSeg2Pt2;seg2minVal=inSeg2Pt2.y;seg2max=inSeg2Pt1;seg2maxVal=inSeg2Pt1.y;}}if(seg1minVal<=seg2minVal){if(seg1maxVal<seg2minVal)return[];if(seg1maxVal===seg2minVal){if(inExcludeAdjacentSegs)return[];return[seg2min];}if(seg1maxVal<=seg2maxVal)return[seg2min,seg1max];return[seg2min,seg2max];}else{if(seg1minVal>seg2maxVal)return[];if(seg1minVal===seg2maxVal){if(inExcludeAdjacentSegs)return[];return[seg1min];}if(seg1maxVal<=seg2maxVal)return[seg1min,seg1max];return[seg1min,seg2max];}}}function isPointInsideAngle(inVertex,inLegFromPt,inLegToPt,inOtherPt){// The order of legs is important
// translation of all points, so that Vertex is at (0,0)
var legFromPtX=inLegFromPt.x-inVertex.x,legFromPtY=inLegFromPt.y-inVertex.y;var legToPtX=inLegToPt.x-inVertex.x,legToPtY=inLegToPt.y-inVertex.y;var otherPtX=inOtherPt.x-inVertex.x,otherPtY=inOtherPt.y-inVertex.y;// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
var from2toAngle=legFromPtX*legToPtY-legFromPtY*legToPtX;var from2otherAngle=legFromPtX*otherPtY-legFromPtY*otherPtX;if(Math.abs(from2toAngle)>_epsilon2.default){// angle != 180 deg.
var other2toAngle=otherPtX*legToPtY-otherPtY*legToPtX;// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
if(from2toAngle>0){// main angle < 180 deg.
return from2otherAngle>=0&&other2toAngle>=0;}else{// main angle > 180 deg.
return from2otherAngle>=0||other2toAngle>=0;}}else{// angle == 180 deg.
// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
return from2otherAngle>0;}}function removeHoles(contour,holes){var shape=contour.concat();// work on this shape
var hole;function isCutLineInsideAngles(inShapeIdx,inHoleIdx){// Check if hole point lies within angle around shape point
var lastShapeIdx=shape.length-1;var prevShapeIdx=inShapeIdx-1;if(prevShapeIdx<0)prevShapeIdx=lastShapeIdx;var nextShapeIdx=inShapeIdx+1;if(nextShapeIdx>lastShapeIdx)nextShapeIdx=0;var insideAngle=isPointInsideAngle(shape[inShapeIdx],shape[prevShapeIdx],shape[nextShapeIdx],hole[inHoleIdx]);if(!insideAngle){// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
return false;}// Check if shape point lies within angle around hole point
var lastHoleIdx=hole.length-1;var prevHoleIdx=inHoleIdx-1;if(prevHoleIdx<0)prevHoleIdx=lastHoleIdx;var nextHoleIdx=inHoleIdx+1;if(nextHoleIdx>lastHoleIdx)nextHoleIdx=0;insideAngle=isPointInsideAngle(hole[inHoleIdx],hole[prevHoleIdx],hole[nextHoleIdx],shape[inShapeIdx]);if(!insideAngle){// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
return false;}return true;}function intersectsShapeEdge(inShapePt,inHolePt){// checks for intersections with shape edges
var sIdx,nextIdx,intersection;for(sIdx=0;sIdx<shape.length;sIdx++){nextIdx=sIdx+1;nextIdx%=shape.length;intersection=intersect_segments_2D(inShapePt,inHolePt,shape[sIdx],shape[nextIdx],true);if(intersection.length>0)return true;}return false;}var indepHoles=[];function intersectsHoleEdge(inShapePt,inHolePt){// checks for intersections with hole edges
var ihIdx,chkHole,hIdx,nextIdx,intersection;for(ihIdx=0;ihIdx<indepHoles.length;ihIdx++){chkHole=holes[indepHoles[ihIdx]];for(hIdx=0;hIdx<chkHole.length;hIdx++){nextIdx=hIdx+1;nextIdx%=chkHole.length;intersection=intersect_segments_2D(inShapePt,inHolePt,chkHole[hIdx],chkHole[nextIdx],true);if(intersection.length>0)return true;}}return false;}var holeIndex,shapeIndex,shapePt,holePt,holeIdx,cutKey,failedCuts=[],tmpShape1,tmpShape2,tmpHole1,tmpHole2;for(var h=0,hl=holes.length;h<hl;h++){indepHoles.push(h);}var minShapeIndex=0;var counter=indepHoles.length*2;while(indepHoles.length>0){counter--;if(counter<0){console.log("Infinite Loop! Holes left:"+indepHoles.length+", Probably Hole outside Shape!");break;}// search for shape-vertex and hole-vertex,
// which can be connected without intersections
for(shapeIndex=minShapeIndex;shapeIndex<shape.length;shapeIndex++){shapePt=shape[shapeIndex];holeIndex=-1;// search for hole which can be reached without intersections
for(var h=0;h<indepHoles.length;h++){holeIdx=indepHoles[h];// prevent multiple checks
cutKey=shapePt.x+":"+shapePt.y+":"+holeIdx;if(failedCuts[cutKey]!==undefined)continue;hole=holes[holeIdx];for(var h2=0;h2<hole.length;h2++){holePt=hole[h2];if(!isCutLineInsideAngles(shapeIndex,h2))continue;if(intersectsShapeEdge(shapePt,holePt))continue;if(intersectsHoleEdge(shapePt,holePt))continue;holeIndex=h2;indepHoles.splice(h,1);tmpShape1=shape.slice(0,shapeIndex+1);tmpShape2=shape.slice(shapeIndex);tmpHole1=hole.slice(holeIndex);tmpHole2=hole.slice(0,holeIndex+1);shape=tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);minShapeIndex=shapeIndex;// Debug only, to show the selected cuts
// glob_CutLines.push( [ shapePt, holePt ] );
break;}if(holeIndex>=0)break;// hole-vertex found
failedCuts[cutKey]=true;// remember failure
}if(holeIndex>=0)break;// hole-vertex found
}}return shape;/* shape with no holes */}var i,il,f,face,key,index,allPointsMap={};// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
var allpoints=contour.concat();for(var h=0,hl=holes.length;h<hl;h++){Array.prototype.push.apply(allpoints,holes[h]);}//console.log( "allpoints",allpoints, allpoints.length );
// prepare all points map
for(i=0,il=allpoints.length;i<il;i++){key=allpoints[i].x+":"+allpoints[i].y;if(allPointsMap[key]!==undefined){console.warn("THREE.ShapeUtils: Duplicate point",key,i);}allPointsMap[key]=i;}// remove holes by cutting paths to holes and adding them to the shape
var shapeWithoutHoles=removeHoles(contour,holes);var triangles=ShapeUtils.triangulate(shapeWithoutHoles,false);// True returns indices for points of spooled shape
//console.log( "triangles",triangles, triangles.length );
// check all face vertices against all points map
for(i=0,il=triangles.length;i<il;i++){face=triangles[i];for(f=0;f<3;f++){key=face[f].x+":"+face[f].y;index=allPointsMap[key];if(index!==undefined){face[f]=index;}}}return triangles.concat();},isClockWise:function isClockWise(pts){return ShapeUtils.area(pts)<0;}};/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *  frames: <Object> // containing arrays of tangents, normals, binormals
	 *
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/function ExtrudeGeometry(shapes,options){if(typeof shapes==="undefined"){shapes=[];return;}Geometry.call(this);this.type='ExtrudeGeometry';shapes=Array.isArray(shapes)?shapes:[shapes];this.addShapeList(shapes,options);this.computeFaceNormals();// can't really use automatic vertex normals
// as then front and back sides get smoothed too
// should do separate smoothing just for sides
//this.computeVertexNormals();
//console.log( "took", ( Date.now() - startTime ) );
}ExtrudeGeometry.prototype=(0,_create2.default)(Geometry.prototype);ExtrudeGeometry.prototype.constructor=ExtrudeGeometry;ExtrudeGeometry.prototype.addShapeList=function(shapes,options){var sl=shapes.length;for(var s=0;s<sl;s++){var shape=shapes[s];this.addShape(shape,options);}};ExtrudeGeometry.prototype.addShape=function(shape,options){var amount=options.amount!==undefined?options.amount:100;var bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:6;// 10
var bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-2;// 8
var bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;var bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;// false
var curveSegments=options.curveSegments!==undefined?options.curveSegments:12;var steps=options.steps!==undefined?options.steps:1;var extrudePath=options.extrudePath;var extrudePts,extrudeByPath=false;// Use default WorldUVGenerator if no UV generators are specified.
var uvgen=options.UVGenerator!==undefined?options.UVGenerator:ExtrudeGeometry.WorldUVGenerator;var splineTube,binormal,normal,position2;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps);extrudeByPath=true;bevelEnabled=false;// bevels not supported for path extrusion
// SETUP TNB variables
// TODO1 - have a .isClosed in spline?
splineTube=options.frames!==undefined?options.frames:extrudePath.computeFrenetFrames(steps,false);// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
binormal=new Vector3();normal=new Vector3();position2=new Vector3();}// Safeguards if bevels are not enabled
if(!bevelEnabled){bevelSegments=0;bevelThickness=0;bevelSize=0;}// Variables initialization
var ahole,h,hl;// looping of holes
var scope=this;var shapesOffset=this.vertices.length;var shapePoints=shape.extractPoints(curveSegments);var vertices=shapePoints.shape;var holes=shapePoints.holes;var reverse=!ShapeUtils.isClockWise(vertices);if(reverse){vertices=vertices.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];if(ShapeUtils.isClockWise(ahole)){holes[h]=ahole.reverse();}}reverse=false;// If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
}var faces=ShapeUtils.triangulateShape(vertices,holes);/* Vertices */var contour=vertices;// vertices has all points but contour has only points of circumference
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];vertices=vertices.concat(ahole);}function scalePt2(pt,vec,size){if(!vec)console.error("THREE.ExtrudeGeometry: vec does not exist");return vec.clone().multiplyScalar(size).add(pt);}var b,bs,t,z,vert,vlen=vertices.length,face,flen=faces.length;// Find directions for point movement
function getBevelVec(inPt,inPrev,inNext){// computes for inPt the corresponding point inPt' on a new contour
//   shifted by 1 unit (length of normalized vector) to the left
// if we walk along contour clockwise, this new contour is outside the old one
//
// inPt' is the intersection of the two lines parallel to the two
//  adjacent edges of inPt at a distance of 1 unit on the left side.
var v_trans_x,v_trans_y,shrink_by=1;// resulting translation vector for inPt
// good reading for geometry algorithms (here: line-line intersection)
// http://geomalgorithms.com/a05-_intersect-1.html
var v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y;var v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y;var v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;// check for collinear edges
var collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>_epsilon2.default){// not collinear
// length of vectors for normalizing
var v_prev_len=Math.sqrt(v_prev_lensq);var v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);// shift adjacent points by unit vectors to the left
var ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;var ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;var ptNextShift_x=inNext.x-v_next_y/v_next_len;var ptNextShift_y=inNext.y+v_next_x/v_next_len;// scaling factor for v_prev to intersection point
var sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-(ptNextShift_y-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);// vector from inPt to intersection point
v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;// Don't normalize!, otherwise sharp corners become ugly
//  but prevent crazy spikes
var v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2){return new Vector2(v_trans_x,v_trans_y);}else{shrink_by=Math.sqrt(v_trans_lensq/2);}}else{// handle special case of collinear edges
var direction_eq=false;// assumes: opposite
if(v_prev_x>_epsilon2.default){if(v_next_x>_epsilon2.default){direction_eq=true;}}else{if(v_prev_x<-_epsilon2.default){if(v_next_x<-_epsilon2.default){direction_eq=true;}}else{if((0,_sign2.default)(v_prev_y)===(0,_sign2.default)(v_next_y)){direction_eq=true;}}}if(direction_eq){// console.log("Warning: lines are a straight sequence");
v_trans_x=-v_prev_y;v_trans_y=v_prev_x;shrink_by=Math.sqrt(v_prev_lensq);}else{// console.log("Warning: lines are a straight spike");
v_trans_x=v_prev_x;v_trans_y=v_prev_y;shrink_by=Math.sqrt(v_prev_lensq/2);}}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);}var contourMovements=[];for(var i=0,il=contour.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
// console.log('i,j,k', i, j , k)
contourMovements[i]=getBevelVec(contour[i],contour[j],contour[k]);}var holesMovements=[],oneHoleMovements,verticesMovements=contourMovements.concat();for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=[];for(i=0,il=ahole.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
oneHoleMovements[i]=getBevelVec(ahole[i],ahole[j],ahole[k]);}holesMovements.push(oneHoleMovements);verticesMovements=verticesMovements.concat(oneHoleMovements);}// Loop bevelSegments, 1 for the front, 1 for the back
for(b=0;b<bevelSegments;b++){//for ( b = bevelSegments; b > 0; b -- ) {
t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2);// contract shape
for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,-z);}// expand holes
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);v(vert.x,vert.y,-z);}}}bs=bevelSize;// Back facing vertices
for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,0);}else{// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);position2.copy(extrudePts[0]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}// Add stepped vertices...
// Including front facing vertices
var s;for(s=1;s<=steps;s++){for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,amount/steps*s);}else{// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);position2.copy(extrudePts[s]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}}// Add bevel segments planes
//for ( b = 1; b <= bevelSegments; b ++ ) {
for(b=bevelSegments-1;b>=0;b--){t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2);// contract shape
for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,amount+z);}// expand holes
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);if(!extrudeByPath){v(vert.x,vert.y,amount+z);}else{v(vert.x,vert.y+extrudePts[steps-1].y,extrudePts[steps-1].x+z);}}}}/* Faces */// Top and bottom faces
buildLidFaces();// Sides faces
buildSideFaces();/////  Internal functions
function buildLidFaces(){if(bevelEnabled){var layer=0;// steps + 1
var offset=vlen*layer;// Bottom faces
for(i=0;i<flen;i++){face=faces[i];f3(face[2]+offset,face[1]+offset,face[0]+offset);}layer=steps+bevelSegments*2;offset=vlen*layer;// Top faces
for(i=0;i<flen;i++){face=faces[i];f3(face[0]+offset,face[1]+offset,face[2]+offset);}}else{// Bottom faces
for(i=0;i<flen;i++){face=faces[i];f3(face[2],face[1],face[0]);}// Top faces
for(i=0;i<flen;i++){face=faces[i];f3(face[0]+vlen*steps,face[1]+vlen*steps,face[2]+vlen*steps);}}}// Create faces for the z-sides of the shape
function buildSideFaces(){var layeroffset=0;sidewalls(contour,layeroffset);layeroffset+=contour.length;for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];sidewalls(ahole,layeroffset);//, true
layeroffset+=ahole.length;}}function sidewalls(contour,layeroffset){var j,k;i=contour.length;while(--i>=0){j=i;k=i-1;if(k<0)k=contour.length-1;//console.log('b', i,j, i-1, k,vertices.length);
var s=0,sl=steps+bevelSegments*2;for(s=0;s<sl;s++){var slen1=vlen*s;var slen2=vlen*(s+1);var a=layeroffset+j+slen1,b=layeroffset+k+slen1,c=layeroffset+k+slen2,d=layeroffset+j+slen2;f4(a,b,c,d,contour,s,sl,j,k);}}}function v(x,y,z){scope.vertices.push(new Vector3(x,y,z));}function f3(a,b,c){a+=shapesOffset;b+=shapesOffset;c+=shapesOffset;scope.faces.push(new Face3(a,b,c,null,null,0));var uvs=uvgen.generateTopUV(scope,a,b,c);scope.faceVertexUvs[0].push(uvs);}function f4(a,b,c,d,wallContour,stepIndex,stepsLength,contourIndex1,contourIndex2){a+=shapesOffset;b+=shapesOffset;c+=shapesOffset;d+=shapesOffset;scope.faces.push(new Face3(a,b,d,null,null,1));scope.faces.push(new Face3(b,c,d,null,null,1));var uvs=uvgen.generateSideWallUV(scope,a,b,c,d);scope.faceVertexUvs[0].push([uvs[0],uvs[1],uvs[3]]);scope.faceVertexUvs[0].push([uvs[1],uvs[2],uvs[3]]);}};ExtrudeGeometry.WorldUVGenerator={generateTopUV:function generateTopUV(geometry,indexA,indexB,indexC){var vertices=geometry.vertices;var a=vertices[indexA];var b=vertices[indexB];var c=vertices[indexC];return[new Vector2(a.x,a.y),new Vector2(b.x,b.y),new Vector2(c.x,c.y)];},generateSideWallUV:function generateSideWallUV(geometry,indexA,indexB,indexC,indexD){var vertices=geometry.vertices;var a=vertices[indexA];var b=vertices[indexB];var c=vertices[indexC];var d=vertices[indexD];if(Math.abs(a.y-b.y)<0.01){return[new Vector2(a.x,1-a.z),new Vector2(b.x,1-b.z),new Vector2(c.x,1-c.z),new Vector2(d.x,1-d.z)];}else{return[new Vector2(a.y,1-a.z),new Vector2(b.y,1-b.z),new Vector2(c.y,1-c.z),new Vector2(d.y,1-d.z)];}}};/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */function TextGeometry(text,parameters){parameters=parameters||{};var font=parameters.font;if((font&&font.isFont)===false){console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');return new Geometry();}var shapes=font.generateShapes(text,parameters.size,parameters.curveSegments);// translate parameters to ExtrudeGeometry API
parameters.amount=parameters.height!==undefined?parameters.height:50;// defaults
if(parameters.bevelThickness===undefined)parameters.bevelThickness=10;if(parameters.bevelSize===undefined)parameters.bevelSize=8;if(parameters.bevelEnabled===undefined)parameters.bevelEnabled=false;ExtrudeGeometry.call(this,shapes,parameters);this.type='TextGeometry';}TextGeometry.prototype=(0,_create2.default)(ExtrudeGeometry.prototype);TextGeometry.prototype.constructor=TextGeometry;/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * based on THREE.SphereGeometry
	 */function SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){BufferGeometry.call(this);this.type='SphereBufferGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||50;widthSegments=Math.max(3,Math.floor(widthSegments)||8);heightSegments=Math.max(2,Math.floor(heightSegments)||6);phiStart=phiStart!==undefined?phiStart:0;phiLength=phiLength!==undefined?phiLength:Math.PI*2;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI;var thetaEnd=thetaStart+thetaLength;var vertexCount=(widthSegments+1)*(heightSegments+1);var positions=new BufferAttribute(new Float32Array(vertexCount*3),3);var normals=new BufferAttribute(new Float32Array(vertexCount*3),3);var uvs=new BufferAttribute(new Float32Array(vertexCount*2),2);var index=0,vertices=[],normal=new Vector3();for(var y=0;y<=heightSegments;y++){var verticesRow=[];var v=y/heightSegments;for(var x=0;x<=widthSegments;x++){var u=x/widthSegments;var px=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);var py=radius*Math.cos(thetaStart+v*thetaLength);var pz=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);normal.set(px,py,pz).normalize();positions.setXYZ(index,px,py,pz);normals.setXYZ(index,normal.x,normal.y,normal.z);uvs.setXY(index,u,1-v);verticesRow.push(index);index++;}vertices.push(verticesRow);}var indices=[];for(var y=0;y<heightSegments;y++){for(var x=0;x<widthSegments;x++){var v1=vertices[y][x+1];var v2=vertices[y][x];var v3=vertices[y+1][x];var v4=vertices[y+1][x+1];if(y!==0||thetaStart>0)indices.push(v1,v2,v4);if(y!==heightSegments-1||thetaEnd<Math.PI)indices.push(v2,v3,v4);}}this.setIndex(new(positions.count>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1));this.addAttribute('position',positions);this.addAttribute('normal',normals);this.addAttribute('uv',uvs);this.boundingSphere=new Sphere(new Vector3(),radius);}SphereBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);SphereBufferGeometry.prototype.constructor=SphereBufferGeometry;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function SphereGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){Geometry.call(this);this.type='SphereGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength));}SphereGeometry.prototype=(0,_create2.default)(Geometry.prototype);SphereGeometry.prototype.constructor=SphereGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */function RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){BufferGeometry.call(this);this.type='RingBufferGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};innerRadius=innerRadius||20;outerRadius=outerRadius||50;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;thetaSegments=thetaSegments!==undefined?Math.max(3,thetaSegments):8;phiSegments=phiSegments!==undefined?Math.max(1,phiSegments):1;// these are used to calculate buffer length
var vertexCount=(thetaSegments+1)*(phiSegments+1);var indexCount=thetaSegments*phiSegments*2*3;// buffers
var indices=new BufferAttribute(new(indexCount>65535?Uint32Array:Uint16Array)(indexCount),1);var vertices=new BufferAttribute(new Float32Array(vertexCount*3),3);var normals=new BufferAttribute(new Float32Array(vertexCount*3),3);var uvs=new BufferAttribute(new Float32Array(vertexCount*2),2);// some helper variables
var index=0,indexOffset=0,segment;var radius=innerRadius;var radiusStep=(outerRadius-innerRadius)/phiSegments;var vertex=new Vector3();var uv=new Vector2();var j,i;// generate vertices, normals and uvs
// values are generate from the inside of the ring to the outside
for(j=0;j<=phiSegments;j++){for(i=0;i<=thetaSegments;i++){segment=thetaStart+i/thetaSegments*thetaLength;// vertex
vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.setXYZ(index,vertex.x,vertex.y,vertex.z);// normal
normals.setXYZ(index,0,0,1);// uv
uv.x=(vertex.x/outerRadius+1)/2;uv.y=(vertex.y/outerRadius+1)/2;uvs.setXY(index,uv.x,uv.y);// increase index
index++;}// increase the radius for next row of vertices
radius+=radiusStep;}// generate indices
for(j=0;j<phiSegments;j++){var thetaSegmentLevel=j*(thetaSegments+1);for(i=0;i<thetaSegments;i++){segment=i+thetaSegmentLevel;// indices
var a=segment;var b=segment+thetaSegments+1;var c=segment+thetaSegments+2;var d=segment+1;// face one
indices.setX(indexOffset,a);indexOffset++;indices.setX(indexOffset,b);indexOffset++;indices.setX(indexOffset,c);indexOffset++;// face two
indices.setX(indexOffset,a);indexOffset++;indices.setX(indexOffset,c);indexOffset++;indices.setX(indexOffset,d);indexOffset++;}}// build geometry
this.setIndex(indices);this.addAttribute('position',vertices);this.addAttribute('normal',normals);this.addAttribute('uv',uvs);}RingBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);RingBufferGeometry.prototype.constructor=RingBufferGeometry;/**
	 * @author Kaleb Murphy
	 */function RingGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){Geometry.call(this);this.type='RingGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength));}RingGeometry.prototype=(0,_create2.default)(Geometry.prototype);RingGeometry.prototype.constructor=RingGeometry;/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */function PlaneGeometry(width,height,widthSegments,heightSegments){Geometry.call(this);this.type='PlaneGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};this.fromBufferGeometry(new PlaneBufferGeometry(width,height,widthSegments,heightSegments));}PlaneGeometry.prototype=(0,_create2.default)(Geometry.prototype);PlaneGeometry.prototype.constructor=PlaneGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2PI) range of the lathed section
//    2PI is a closed lathe, less than 2PI is a portion.
function LatheBufferGeometry(points,segments,phiStart,phiLength){BufferGeometry.call(this);this.type='LatheBufferGeometry';this.parameters={points:points,segments:segments,phiStart:phiStart,phiLength:phiLength};segments=Math.floor(segments)||12;phiStart=phiStart||0;phiLength=phiLength||Math.PI*2;// clamp phiLength so it's in range of [ 0, 2PI ]
phiLength=_Math.clamp(phiLength,0,Math.PI*2);// these are used to calculate buffer length
var vertexCount=(segments+1)*points.length;var indexCount=segments*points.length*2*3;// buffers
var indices=new BufferAttribute(new(indexCount>65535?Uint32Array:Uint16Array)(indexCount),1);var vertices=new BufferAttribute(new Float32Array(vertexCount*3),3);var uvs=new BufferAttribute(new Float32Array(vertexCount*2),2);// helper variables
var index=0,indexOffset=0,base;var inverseSegments=1.0/segments;var vertex=new Vector3();var uv=new Vector2();var i,j;// generate vertices and uvs
for(i=0;i<=segments;i++){var phi=phiStart+i*inverseSegments*phiLength;var sin=Math.sin(phi);var cos=Math.cos(phi);for(j=0;j<=points.length-1;j++){// vertex
vertex.x=points[j].x*sin;vertex.y=points[j].y;vertex.z=points[j].x*cos;vertices.setXYZ(index,vertex.x,vertex.y,vertex.z);// uv
uv.x=i/segments;uv.y=j/(points.length-1);uvs.setXY(index,uv.x,uv.y);// increase index
index++;}}// generate indices
for(i=0;i<segments;i++){for(j=0;j<points.length-1;j++){base=j+i*points.length;// indices
var a=base;var b=base+points.length;var c=base+points.length+1;var d=base+1;// face one
indices.setX(indexOffset,a);indexOffset++;indices.setX(indexOffset,b);indexOffset++;indices.setX(indexOffset,d);indexOffset++;// face two
indices.setX(indexOffset,b);indexOffset++;indices.setX(indexOffset,c);indexOffset++;indices.setX(indexOffset,d);indexOffset++;}}// build geometry
this.setIndex(indices);this.addAttribute('position',vertices);this.addAttribute('uv',uvs);// generate normals
this.computeVertexNormals();// if the geometry is closed, we need to average the normals along the seam.
// because the corresponding vertices are identical (but still have different UVs).
if(phiLength===Math.PI*2){var normals=this.attributes.normal.array;var n1=new Vector3();var n2=new Vector3();var n=new Vector3();// this is the buffer offset for the last line of vertices
base=segments*points.length*3;for(i=0,j=0;i<points.length;i++,j+=3){// select the normal of the vertex in the first line
n1.x=normals[j+0];n1.y=normals[j+1];n1.z=normals[j+2];// select the normal of the vertex in the last line
n2.x=normals[base+j+0];n2.y=normals[base+j+1];n2.z=normals[base+j+2];// average normals
n.addVectors(n1,n2).normalize();// assign the new values to both normals
normals[j+0]=normals[base+j+0]=n.x;normals[j+1]=normals[base+j+1]=n.y;normals[j+2]=normals[base+j+2]=n.z;}// next row
}}LatheBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);LatheBufferGeometry.prototype.constructor=LatheBufferGeometry;/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 */// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2PI) range of the lathed section
//    2PI is a closed lathe, less than 2PI is a portion.
function LatheGeometry(points,segments,phiStart,phiLength){Geometry.call(this);this.type='LatheGeometry';this.parameters={points:points,segments:segments,phiStart:phiStart,phiLength:phiLength};this.fromBufferGeometry(new LatheBufferGeometry(points,segments,phiStart,phiLength));this.mergeVertices();}LatheGeometry.prototype=(0,_create2.default)(Geometry.prototype);LatheGeometry.prototype.constructor=LatheGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Creates a one-sided polygonal geometry from one or more shapes.
	 *
	 **/function ShapeBufferGeometry(shapes,curveSegments){BufferGeometry.call(this);this.type='ShapeBufferGeometry';this.parameters={shapes:shapes,curveSegments:curveSegments};curveSegments=curveSegments||12;var vertices=[];var normals=[];var uvs=[];var indices=[];var groupStart=0;var groupCount=0;// allow single and array values for "shapes" parameter
if(Array.isArray(shapes)===false){addShape(shapes);}else{for(var i=0;i<shapes.length;i++){addShape(shapes[i]);this.addGroup(groupStart,groupCount,i);// enables MultiMaterial support
groupStart+=groupCount;groupCount=0;}}// build geometry
this.setIndex(new(indices.length>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1));this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// helper functions
function addShape(shape){var i,l,shapeHole;var indexOffset=vertices.length/3;var points=shape.extractPoints(curveSegments);var shapeVertices=points.shape;var shapeHoles=points.holes;// check direction of vertices
if(ShapeUtils.isClockWise(shapeVertices)===false){shapeVertices=shapeVertices.reverse();// also check if holes are in the opposite direction
for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];if(ShapeUtils.isClockWise(shapeHole)===true){shapeHoles[i]=shapeHole.reverse();}}}var faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);// join vertices of inner and outer paths to a single array
for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];shapeVertices=shapeVertices.concat(shapeHole);}// vertices, normals, uvs
for(i=0,l=shapeVertices.length;i<l;i++){var vertex=shapeVertices[i];vertices.push(vertex.x,vertex.y,0);normals.push(0,0,1);uvs.push(vertex.x,vertex.y);// world uvs
}// incides
for(i=0,l=faces.length;i<l;i++){var face=faces[i];var a=face[0]+indexOffset;var b=face[1]+indexOffset;var c=face[2]+indexOffset;indices.push(a,b,c);groupCount+=3;}}}ShapeBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);ShapeBufferGeometry.prototype.constructor=ShapeBufferGeometry;/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape.
	 *
	 **/function ShapeGeometry(shapes,curveSegments){Geometry.call(this);this.type='ShapeGeometry';if((typeof curveSegments==='undefined'?'undefined':(0,_typeof3.default)(curveSegments))==='object'){console.warn('THREE.ShapeGeometry: Options parameter has been removed.');curveSegments=curveSegments.curveSegments;}this.parameters={shapes:shapes,curveSegments:curveSegments};this.fromBufferGeometry(new ShapeBufferGeometry(shapes,curveSegments));this.mergeVertices();}ShapeGeometry.prototype=(0,_create2.default)(Geometry.prototype);ShapeGeometry.prototype.constructor=ShapeGeometry;/**
	 * @author WestLangley / http://github.com/WestLangley
	 */function EdgesGeometry(geometry,thresholdAngle){BufferGeometry.call(this);thresholdAngle=thresholdAngle!==undefined?thresholdAngle:1;var thresholdDot=Math.cos(_Math.DEG2RAD*thresholdAngle);var edge=[0,0],hash={};function sortFunction(a,b){return a-b;}var keys=['a','b','c'];var geometry2;if(geometry.isBufferGeometry){geometry2=new Geometry();geometry2.fromBufferGeometry(geometry);}else{geometry2=geometry.clone();}geometry2.mergeVertices();geometry2.computeFaceNormals();var vertices=geometry2.vertices;var faces=geometry2.faces;for(var i=0,l=faces.length;i<l;i++){var face=faces[i];for(var j=0;j<3;j++){edge[0]=face[keys[j]];edge[1]=face[keys[(j+1)%3]];edge.sort(sortFunction);var key=edge.toString();if(hash[key]===undefined){hash[key]={vert1:edge[0],vert2:edge[1],face1:i,face2:undefined};}else{hash[key].face2=i;}}}var coords=[];for(var key in hash){var h=hash[key];// An edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
if(h.face2===undefined||faces[h.face1].normal.dot(faces[h.face2].normal)<=thresholdDot){var vertex=vertices[h.vert1];coords.push(vertex.x);coords.push(vertex.y);coords.push(vertex.z);vertex=vertices[h.vert2];coords.push(vertex.x);coords.push(vertex.y);coords.push(vertex.z);}}this.addAttribute('position',new Float32BufferAttribute(coords,3));}EdgesGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);EdgesGeometry.prototype.constructor=EdgesGeometry;/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */function CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){BufferGeometry.call(this);this.type='CylinderBufferGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};var scope=this;radiusTop=radiusTop!==undefined?radiusTop:20;radiusBottom=radiusBottom!==undefined?radiusBottom:20;height=height!==undefined?height:100;radialSegments=Math.floor(radialSegments)||8;heightSegments=Math.floor(heightSegments)||1;openEnded=openEnded!==undefined?openEnded:false;thetaStart=thetaStart!==undefined?thetaStart:0.0;thetaLength=thetaLength!==undefined?thetaLength:2.0*Math.PI;// used to calculate buffer length
var nbCap=0;if(openEnded===false){if(radiusTop>0)nbCap++;if(radiusBottom>0)nbCap++;}var vertexCount=calculateVertexCount();var indexCount=calculateIndexCount();// buffers
var indices=new BufferAttribute(new(indexCount>65535?Uint32Array:Uint16Array)(indexCount),1);var vertices=new BufferAttribute(new Float32Array(vertexCount*3),3);var normals=new BufferAttribute(new Float32Array(vertexCount*3),3);var uvs=new BufferAttribute(new Float32Array(vertexCount*2),2);// helper variables
var index=0,indexOffset=0,indexArray=[],halfHeight=height/2;// group variables
var groupStart=0;// generate geometry
generateTorso();if(openEnded===false){if(radiusTop>0)generateCap(true);if(radiusBottom>0)generateCap(false);}// build geometry
this.setIndex(indices);this.addAttribute('position',vertices);this.addAttribute('normal',normals);this.addAttribute('uv',uvs);// helper functions
function calculateVertexCount(){var count=(radialSegments+1)*(heightSegments+1);if(openEnded===false){count+=(radialSegments+1)*nbCap+radialSegments*nbCap;}return count;}function calculateIndexCount(){var count=radialSegments*heightSegments*2*3;if(openEnded===false){count+=radialSegments*nbCap*3;}return count;}function generateTorso(){var x,y;var normal=new Vector3();var vertex=new Vector3();var groupCount=0;// this will be used to calculate the normal
var slope=(radiusBottom-radiusTop)/height;// generate vertices, normals and uvs
for(y=0;y<=heightSegments;y++){var indexRow=[];var v=y/heightSegments;// calculate the radius of the current row
var radius=v*(radiusBottom-radiusTop)+radiusTop;for(x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);// vertex
vertex.x=radius*sinTheta;vertex.y=-v*height+halfHeight;vertex.z=radius*cosTheta;vertices.setXYZ(index,vertex.x,vertex.y,vertex.z);// normal
normal.set(sinTheta,slope,cosTheta).normalize();normals.setXYZ(index,normal.x,normal.y,normal.z);// uv
uvs.setXY(index,u,1-v);// save index of vertex in respective row
indexRow.push(index);// increase index
index++;}// now save vertices of the row in our index array
indexArray.push(indexRow);}// generate indices
for(x=0;x<radialSegments;x++){for(y=0;y<heightSegments;y++){// we use the index array to access the correct indices
var i1=indexArray[y][x];var i2=indexArray[y+1][x];var i3=indexArray[y+1][x+1];var i4=indexArray[y][x+1];// face one
indices.setX(indexOffset,i1);indexOffset++;indices.setX(indexOffset,i2);indexOffset++;indices.setX(indexOffset,i4);indexOffset++;// face two
indices.setX(indexOffset,i2);indexOffset++;indices.setX(indexOffset,i3);indexOffset++;indices.setX(indexOffset,i4);indexOffset++;// update counters
groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,0);// calculate new start value for groups
groupStart+=groupCount;}function generateCap(top){var x,centerIndexStart,centerIndexEnd;var uv=new Vector2();var vertex=new Vector3();var groupCount=0;var radius=top===true?radiusTop:radiusBottom;var sign=top===true?1:-1;// save the index of the first center vertex
centerIndexStart=index;// first we generate the center vertex data of the cap.
// because the geometry needs one set of uvs per face,
// we must generate a center vertex per face/segment
for(x=1;x<=radialSegments;x++){// vertex
vertices.setXYZ(index,0,halfHeight*sign,0);// normal
normals.setXYZ(index,0,sign,0);// uv
uv.x=0.5;uv.y=0.5;uvs.setXY(index,uv.x,uv.y);// increase index
index++;}// save the index of the last center vertex
centerIndexEnd=index;// now we generate the surrounding vertices, normals and uvs
for(x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var cosTheta=Math.cos(theta);var sinTheta=Math.sin(theta);// vertex
vertex.x=radius*sinTheta;vertex.y=halfHeight*sign;vertex.z=radius*cosTheta;vertices.setXYZ(index,vertex.x,vertex.y,vertex.z);// normal
normals.setXYZ(index,0,sign,0);// uv
uv.x=cosTheta*0.5+0.5;uv.y=sinTheta*0.5*sign+0.5;uvs.setXY(index,uv.x,uv.y);// increase index
index++;}// generate indices
for(x=0;x<radialSegments;x++){var c=centerIndexStart+x;var i=centerIndexEnd+x;if(top===true){// face top
indices.setX(indexOffset,i);indexOffset++;indices.setX(indexOffset,i+1);indexOffset++;indices.setX(indexOffset,c);indexOffset++;}else{// face bottom
indices.setX(indexOffset,i+1);indexOffset++;indices.setX(indexOffset,i);indexOffset++;indices.setX(indexOffset,c);indexOffset++;}// update counters
groupCount+=3;}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,top===true?1:2);// calculate new start value for groups
groupStart+=groupCount;}}CylinderBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);CylinderBufferGeometry.prototype.constructor=CylinderBufferGeometry;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function CylinderGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){Geometry.call(this);this.type='CylinderGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength));this.mergeVertices();}CylinderGeometry.prototype=(0,_create2.default)(Geometry.prototype);CylinderGeometry.prototype.constructor=CylinderGeometry;/**
	 * @author abelnation / http://github.com/abelnation
	 */function ConeGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){CylinderGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}ConeGeometry.prototype=(0,_create2.default)(CylinderGeometry.prototype);ConeGeometry.prototype.constructor=ConeGeometry;/**
	 * @author: abelnation / http://github.com/abelnation
	 */function ConeBufferGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){CylinderBufferGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeBufferGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}ConeBufferGeometry.prototype=(0,_create2.default)(CylinderBufferGeometry.prototype);ConeBufferGeometry.prototype.constructor=ConeBufferGeometry;/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function CircleBufferGeometry(radius,segments,thetaStart,thetaLength){BufferGeometry.call(this);this.type='CircleBufferGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||50;segments=segments!==undefined?Math.max(3,segments):8;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;var vertices=segments+2;var positions=new Float32Array(vertices*3);var normals=new Float32Array(vertices*3);var uvs=new Float32Array(vertices*2);// center data is already zero, but need to set a few extras
normals[2]=1.0;uvs[0]=0.5;uvs[1]=0.5;for(var s=0,i=3,ii=2;s<=segments;s++,i+=3,ii+=2){var segment=thetaStart+s/segments*thetaLength;positions[i]=radius*Math.cos(segment);positions[i+1]=radius*Math.sin(segment);normals[i+2]=1;// normal z
uvs[ii]=(positions[i]/radius+1)/2;uvs[ii+1]=(positions[i+1]/radius+1)/2;}var indices=[];for(var i=1;i<=segments;i++){indices.push(i,i+1,0);}this.setIndex(new BufferAttribute(new Uint16Array(indices),1));this.addAttribute('position',new BufferAttribute(positions,3));this.addAttribute('normal',new BufferAttribute(normals,3));this.addAttribute('uv',new BufferAttribute(uvs,2));this.boundingSphere=new Sphere(new Vector3(),radius);}CircleBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);CircleBufferGeometry.prototype.constructor=CircleBufferGeometry;/**
	 * @author hughes
	 */function CircleGeometry(radius,segments,thetaStart,thetaLength){Geometry.call(this);this.type='CircleGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new CircleBufferGeometry(radius,segments,thetaStart,thetaLength));}CircleGeometry.prototype=(0,_create2.default)(Geometry.prototype);CircleGeometry.prototype.constructor=CircleGeometry;/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */function BoxGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){Geometry.call(this);this.type='BoxGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};this.fromBufferGeometry(new BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments));this.mergeVertices();}BoxGeometry.prototype=(0,_create2.default)(Geometry.prototype);BoxGeometry.prototype.constructor=BoxGeometry;var Geometries=(0,_freeze2.default)({WireframeGeometry:WireframeGeometry,ParametricGeometry:ParametricGeometry,ParametricBufferGeometry:ParametricBufferGeometry,TetrahedronGeometry:TetrahedronGeometry,TetrahedronBufferGeometry:TetrahedronBufferGeometry,OctahedronGeometry:OctahedronGeometry,OctahedronBufferGeometry:OctahedronBufferGeometry,IcosahedronGeometry:IcosahedronGeometry,IcosahedronBufferGeometry:IcosahedronBufferGeometry,DodecahedronGeometry:DodecahedronGeometry,DodecahedronBufferGeometry:DodecahedronBufferGeometry,PolyhedronGeometry:PolyhedronGeometry,PolyhedronBufferGeometry:PolyhedronBufferGeometry,TubeGeometry:TubeGeometry,TubeBufferGeometry:TubeBufferGeometry,TorusKnotGeometry:TorusKnotGeometry,TorusKnotBufferGeometry:TorusKnotBufferGeometry,TorusGeometry:TorusGeometry,TorusBufferGeometry:TorusBufferGeometry,TextGeometry:TextGeometry,SphereBufferGeometry:SphereBufferGeometry,SphereGeometry:SphereGeometry,RingGeometry:RingGeometry,RingBufferGeometry:RingBufferGeometry,PlaneBufferGeometry:PlaneBufferGeometry,PlaneGeometry:PlaneGeometry,LatheGeometry:LatheGeometry,LatheBufferGeometry:LatheBufferGeometry,ShapeGeometry:ShapeGeometry,ShapeBufferGeometry:ShapeBufferGeometry,ExtrudeGeometry:ExtrudeGeometry,EdgesGeometry:EdgesGeometry,ConeGeometry:ConeGeometry,ConeBufferGeometry:ConeBufferGeometry,CylinderGeometry:CylinderGeometry,CylinderBufferGeometry:CylinderBufferGeometry,CircleBufferGeometry:CircleBufferGeometry,CircleGeometry:CircleGeometry,BoxBufferGeometry:BoxBufferGeometry,BoxGeometry:BoxGeometry});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function ShadowMaterial(){ShaderMaterial.call(this,{uniforms:UniformsUtils.merge([UniformsLib$1.lights,{opacity:{value:1.0}}]),vertexShader:ShaderChunk['shadow_vert'],fragmentShader:ShaderChunk['shadow_frag']});this.lights=true;this.transparent=true;(0,_defineProperties2.default)(this,{opacity:{enumerable:true,get:function get(){return this.uniforms.opacity.value;},set:function set(value){this.uniforms.opacity.value=value;}}});}ShadowMaterial.prototype=(0,_create2.default)(ShaderMaterial.prototype);ShadowMaterial.prototype.constructor=ShadowMaterial;ShadowMaterial.prototype.isShadowMaterial=true;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function RawShaderMaterial(parameters){ShaderMaterial.call(this,parameters);this.type='RawShaderMaterial';}RawShaderMaterial.prototype=(0,_create2.default)(ShaderMaterial.prototype);RawShaderMaterial.prototype.constructor=RawShaderMaterial;RawShaderMaterial.prototype.isRawShaderMaterial=true;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function MultiMaterial(materials){this.uuid=_Math.generateUUID();this.type='MultiMaterial';this.materials=Array.isArray(materials)?materials:[];this.visible=true;}MultiMaterial.prototype={constructor:MultiMaterial,isMultiMaterial:true,toJSON:function toJSON(meta){var output={metadata:{version:4.2,type:'material',generator:'MaterialExporter'},uuid:this.uuid,type:this.type,materials:[]};var materials=this.materials;for(var i=0,l=materials.length;i<l;i++){var material=materials[i].toJSON(meta);delete material.metadata;output.materials.push(material);}output.visible=this.visible;return output;},clone:function clone(){var material=new this.constructor();for(var i=0;i<this.materials.length;i++){material.materials.push(this.materials[i].clone());}material.visible=this.visible;return material;}};/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Ben Houston / bhouston / http://clara.io
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */function MeshStandardMaterial(parameters){Material.call(this);this.defines={'STANDARD':''};this.type='MeshStandardMaterial';this.color=new Color(0xffffff);// diffuse
//this.map = null;
this.mapSlot=new MaterialMap("map",0,false,false);this.reflectivity=0.5;this.roughness=0.5;//this.roughnessMap = null;
this.roughnessMapSlot=new MaterialMap("roughnessMap",0,false,false);this.metalness=0.5;//this.metalnessMap = null;
this.metalnessMapSlot=new MaterialMap("metalnessMap",0,false,false);this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;//this.emissiveMap = null;
this.emissiveMapSlot=new MaterialMap("emissiveMap",0,false,false);//this.bumpMap = null;
//this.bumpScale = 1;
this.bumpMapSlot=new MaterialMap("bumpMap",0,false,true);//this.normalMap = null;
this.normalScale=new Vector2(1,1);this.normalMapSlot=new MaterialMap("normalMap",0,false,false);//this.displacementMap = null;
//this.displacementScale = 1;
//this.displacementBias = 0;
this.displacementMapSlot=new MaterialMap("displacementMap",0,false,true);//this.lightMap = null;
//this.lightMapIntensity = 1.0;
this.lightMapSlot=new MaterialMap("lightMap",1,false,true);//this.aoMap = null;
this.aoMapIntensity=1.0;this.aoMapSlot=new MaterialMap("aoMap",1,false,true);//this.alphaMap = null;
this.alphaMapSlot=new MaterialMap("alphaMap",0,false,false);this.envMap=null;this.envMapIntensity=1.0;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshStandardMaterial.prototype=(0,_create2.default)(Material.prototype);MeshStandardMaterial.prototype.constructor=MeshStandardMaterial;MeshStandardMaterial.prototype.isMeshStandardMaterial=true;var closure$1=function(){var propertyMappings={"map":{get:function get(){return this.mapSlot.texture;},set:function set(value){this.mapSlot.texture=value;}},"lightMap":{get:function get(){return this.lightMapSlot.texture;},set:function set(value){this.lightMapSlot.texture=value;}},"lightMapIntensity":{get:function get(){return this.lightMapSlot.texelScale;},set:function set(value){this.lightMapSlot.texelTransform=true;this.lightMapSlot.texelScale=value;}},"aoMap":{get:function get(){return this.aoMapSlot.texture;},set:function set(value){this.aoMapSlot.texture=value;}},"emissiveMap":{get:function get(){return this.emissiveMapSlot.texture;},set:function set(value){this.emissiveMapSlot.texture=value;}},"bumpMap":{get:function get(){return this.bumpMapSlot.texture;},set:function set(value){this.bumpMapSlot.texture=value;}},"bumpScale":{get:function get(){return this.bumpMapSlot.texelScale;},set:function set(value){this.bumpMapSlot.texelTransform=true;this.bumpMapSlot.texelScale=value;}},"normalMap":{get:function get(){return this.normalMapSlot.texture;},set:function set(value){this.normalMapSlot.texture=value;}},"displacementMap":{get:function get(){return this.displacementMapSlot.texture;},set:function set(value){this.displacementMapSlot.texture=value;}},"displacementScale":{get:function get(){return this.displacementMapSlot.texelScale;},set:function set(value){this.displacementMapSlot.texelTransform=true;this.displacementMapSlot.texelScale=value;}},"displacementBias":{get:function get(){return this.displacementMapSlot.texelOffset;},set:function set(value){this.displacementMapSlot.texelTransform=true;this.displacementMapSlot.texelOffset=value;}},"roughnessMap":{get:function get(){return this.roughnessMapSlot.texture;},set:function set(value){this.roughnessMapSlot.texture=value;}},"metalnessMap":{get:function get(){return this.metalnessMapSlot.texture;},set:function set(value){this.metalnessMapSlot.texture=value;}},"alphaMap":{get:function get(){return this.alphaMapSlot.texture;},set:function set(value){this.alphaMapSlot.texture=value;}}};for(var propertyName in propertyMappings){(0,_defineProperty2.default)(MeshStandardMaterial.prototype,propertyName,propertyMappings[propertyName]);}}();MeshStandardMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.defines={'STANDARD':''};this.color.copy(source.color);this.mapSlot.copy(source.mapSlot);this.reflectivity=source.reflectivity;this.roughness=source.roughness;this.roughnessMapSlot.copy(source.roughnessMapSlot);this.metalness=source.metalness;this.metalnessMapSlot.copy(source.metalnessMapSlot);this.lightMapSlot.copy(source.lightMapSlot);this.aoMapIntensity=source.aoMapIntensity;this.aoMapSlot.copy(source.aoMapSlot);this.emissive.copy(source.emissive);this.emissiveIntensity=source.emissiveIntensity;this.emissiveMapSlot.copy(source.emissiveMapSlot);this.bumpMapSlot.copy(source.bumpMapSlot);this.normalScale.copy(source.normalScale);this.normalMapSlot.copy(source.normalMapSlot);this.displacementMapSlot.copy(source.displacementMapSlot);this.alphaMapSlot.copy(source.alphaMapSlot);this.envMap=source.envMap;this.envMapIntensity=source.envMapIntensity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 * }
	 */function MeshPhysicalMaterial(parameters){MeshStandardMaterial.call(this);this.defines={'PHYSICAL':''};this.type='MeshPhysicalMaterial';this.reflectivity=0.5;// maps to F0 = 0.04
this.falloff=false;this.falloffColor=new Color(0xffffff);this.falloffMapSlot=new MaterialMap("falloffMap",0,false,false);this.falloffOpacity=1.0;this.falloffAlphaMapSlot=new MaterialMap("falloffAlphaMap",0,false,false);this.clearCoat=0.0;this.clearCoatRoughness=0.0;this.anisotropy=0.0;// valid range is [-1,1].-1 is max vertical elongation, 0 is normal, +1 is max horizontal elongation
this.anisotropyMapSlot=new MaterialMap("anisotropyMap",0,false,false);// only R is read and considered to be anisotropy.  To get negative values, use texture brightness, gain
this.anisotropyRotation=0.0;// converted to radias via multiplication by 2*PI.  Thus the range [ 0 - 1 ] maps to radian [0, PI].
this.anisotropyRotationMapSlot=new MaterialMap("anisotropyRotationMap",0,false,false);// only R is read and considered to be anisotropyRotation.
this.setValues(parameters);}MeshPhysicalMaterial.prototype=(0,_create2.default)(MeshStandardMaterial.prototype);MeshPhysicalMaterial.prototype.constructor=MeshPhysicalMaterial;MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=true;var closure=function(){var propertyMappings={"falloffMap":{get:function get(){return this.falloffMapSlot.texture;},set:function set(value){this.falloffMapSlot.texture=value;}},"falloffAlphaMap":{get:function get(){return this.falloffAlphaMapSlot.texture;},set:function set(value){this.falloffAlphaMapSlot.texture=value;}},"anisotropyMap":{get:function get(){return this.anisotropyMapSlot.texture;},set:function set(value){this.anisotropyMapSlot.texture=value;}},"anisotropyRotationMap":{get:function get(){return this.anisotropyRotationMapSlot.texture;},set:function set(value){this.anisotropyRotationMapSlot.texture=value;}}};for(var propertyName in propertyMappings){(0,_defineProperty2.default)(MeshPhysicalMaterial.prototype,propertyName,propertyMappings[propertyName]);}}();MeshPhysicalMaterial.prototype.copy=function(source){MeshStandardMaterial.prototype.copy.call(this,source);this.defines={'PHYSICAL':''};this.reflectivity=source.reflectivity;this.falloff=source.falloff;this.falloffColor.copy(source.falloffColor);this.falloffMapSlot.copy(source.falloffMapSlot);this.falloffOpacity=source.falloffOpacity;this.falloffAlphaMapSlot.copy(source.falloffAlphaMapSlot);this.clearCoat=source.clearCoat;this.clearCoatRoughness=source.clearCoatRoughness;this.anisotropy=source.anisotropy;this.anisotropyMapSlot=source.anisotropyMapSlot;this.anisotropyRotation=source.anisotropyRotation;this.anisotropyRotationMapSlot=source.anisotropyRotationMapSlot;return this;};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */function MeshPhongMaterial(parameters){Material.call(this);this.type='MeshPhongMaterial';this.color=new Color(0xffffff);// diffuse
this.specular=new Color(0x111111);this.shininess=30;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshPhongMaterial.prototype=(0,_create2.default)(Material.prototype);MeshPhongMaterial.prototype.constructor=MeshPhongMaterial;MeshPhongMaterial.prototype.isMeshPhongMaterial=true;MeshPhongMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
	 * @author takahirox / http://github.com/takahirox
	 *
	 * parameters = {
	 *  gradientMap: new THREE.Texture( <Image> )
	 * }
	 */function MeshToonMaterial(parameters){MeshPhongMaterial.call(this);this.defines={'TOON':''};this.type='MeshToonMaterial';this.gradientMap=null;this.setValues(parameters);}MeshToonMaterial.prototype=(0,_create2.default)(MeshPhongMaterial.prototype);MeshToonMaterial.prototype.constructor=MeshToonMaterial;MeshToonMaterial.prototype.isMeshToonMaterial=true;MeshToonMaterial.prototype.copy=function(source){MeshPhongMaterial.prototype.copy.call(this,source);this.gradientMap=source.gradientMap;return this;};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */function MeshNormalMaterial(parameters){Material.call(this,parameters);this.type='MeshNormalMaterial';this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.lights=false;this.skinning=false;this.morphTargets=false;this.morphNormals=false;// default normal is facing the camera.
this.clearColor=new Color(0.5,0.5,1.0);this.clearAlpha=1.0;this.setValues(parameters);}MeshNormalMaterial.prototype=(0,_create2.default)(Material.prototype);MeshNormalMaterial.prototype.constructor=MeshNormalMaterial;MeshNormalMaterial.prototype.isMeshNormalMaterial=true;MeshNormalMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.clearColor=source.clearColor;this.clearAlpha=source.clearAlpha;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */function MeshLambertMaterial(parameters){Material.call(this);this.type='MeshLambertMaterial';this.color=new Color(0xffffff);// diffuse
this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshLambertMaterial.prototype=(0,_create2.default)(Material.prototype);MeshLambertMaterial.prototype.constructor=MeshLambertMaterial;MeshLambertMaterial.prototype.isMeshLambertMaterial=true;MeshLambertMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
	 * @author bhouston / https://clara.io
	 *
	 * parameters = {
	 *
	 * }
	 */function MeshCubeMaterial(parameters){Material.call(this);this.type='MeshCubeMaterial';this.envMap=null;this.envMapIntensity=1.0;this.roughness=0.0;this.depthTest=false;this.depthWrite=false;this.side=BackSide;this.lights=false;this.setValues(parameters);}MeshCubeMaterial.prototype=(0,_create2.default)(Material.prototype);MeshCubeMaterial.prototype.constructor=MeshCubeMaterial;MeshCubeMaterial.prototype.isMeshCubeMaterial=true;MeshCubeMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.envMap=source.envMap;this.envMapIntensity=source.envMapIntensity;this.roughness=source.roughness;return this;};/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */function LineDashedMaterial(parameters){Material.call(this);this.type='LineDashedMaterial';this.color=new Color(0xffffff);this.linewidth=1;this.scale=1;this.dashSize=3;this.gapSize=1;this.lights=false;this.setValues(parameters);}LineDashedMaterial.prototype=(0,_create2.default)(Material.prototype);LineDashedMaterial.prototype.constructor=LineDashedMaterial;LineDashedMaterial.prototype.isLineDashedMaterial=true;LineDashedMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.linewidth=source.linewidth;this.scale=source.scale;this.dashSize=source.dashSize;this.gapSize=source.gapSize;return this;};var Materials=(0,_freeze2.default)({ShadowMaterial:ShadowMaterial,SpriteMaterial:SpriteMaterial,RawShaderMaterial:RawShaderMaterial,ShaderMaterial:ShaderMaterial,PointsMaterial:PointsMaterial,MultiMaterial:MultiMaterial,MeshPhysicalMaterial:MeshPhysicalMaterial,MeshStandardMaterial:MeshStandardMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshToonMaterial:MeshToonMaterial,MeshNormalMaterial:MeshNormalMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshDepthMaterial:MeshDepthMaterial,MeshBasicMaterial:MeshBasicMaterial,MeshCubeMaterial:MeshCubeMaterial,LineDashedMaterial:LineDashedMaterial,LineBasicMaterial:LineBasicMaterial,MaterialMap:MaterialMap,Material:Material});/**
	 * @author mrdoob / http://mrdoob.com/
	 */var Cache={enabled:false,files:{},add:function add(key,file){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Adding key:', key );
this.files[key]=file;},get:function get(key){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Checking key:', key );
return this.files[key];},remove:function remove(key){delete this.files[key];},clear:function clear(){this.files={};}};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function LoadingManager(onLoad,onProgress,onError){var scope=this;var isLoading=false,itemsLoaded=0,itemsTotal=0;this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(isLoading===false){if(scope.onStart!==undefined){scope.onStart(url,itemsLoaded,itemsTotal);}}isLoading=true;};this.itemEnd=function(url){itemsLoaded++;if(scope.onProgress!==undefined){scope.onProgress(url,itemsLoaded,itemsTotal);}if(itemsLoaded===itemsTotal){isLoading=false;if(scope.onLoad!==undefined){scope.onLoad();}}};this.itemError=function(url){if(scope.onError!==undefined){scope.onError(url);}};}var DefaultLoadingManager=new LoadingManager();/**
	 * @author mrdoob / http://mrdoob.com/
	 */function FileLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}(0,_assign2.default)(FileLoader.prototype,{load:function load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}// Check for data: URI
var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=url.match(dataUriRegex);// Safari can not handle Data URIs through XMLHttpRequest so process manually
if(dataUriRegexResult){var mimeType=dataUriRegexResult[1];var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=window.decodeURIComponent(data);if(isBase64)data=window.atob(data);try{var response;var responseType=(this.responseType||'').toLowerCase();switch(responseType){case'arraybuffer':case'blob':response=new ArrayBuffer(data.length);var view=new Uint8Array(response);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}if(responseType==='blob'){response=new Blob([response],{type:mimeType});}break;case'document':var parser=new DOMParser();response=parser.parseFromString(data,mimeType);break;case'json':response=JSON.parse(data);break;default:// 'text' or other
response=data;break;}// Wait for next browser tick
window.setTimeout(function(){if(onLoad)onLoad(response);scope.manager.itemEnd(url);},0);}catch(error){// Wait for next browser tick
window.setTimeout(function(){if(onError)onError(error);scope.manager.itemError(url);},0);}}else{var request=new XMLHttpRequest();request.open('GET',url,true);request.addEventListener('load',function(event){var response=event.target.response;Cache.add(url,response);if(this.status===200){if(onLoad)onLoad(response);scope.manager.itemEnd(url);}else if(this.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
// e.g. 'file://' or 'data://'. Handle as success.
console.warn('THREE.FileLoader: HTTP Status 0 received.');if(onLoad)onLoad(response);scope.manager.itemEnd(url);}else{if(onError)onError(event);scope.manager.itemError(url);}},false);if(onProgress!==undefined){request.addEventListener('progress',function(event){onProgress(event);},false);}request.addEventListener('error',function(event){if(onError)onError(event);scope.manager.itemError(url);},false);if(this.responseType!==undefined)request.responseType=this.responseType;if(this.withCredentials!==undefined)request.withCredentials=this.withCredentials;if(request.overrideMimeType)request.overrideMimeType(this.mimeType!==undefined?this.mimeType:'text/plain');request.send(null);}scope.manager.itemStart(url);return request;},setPath:function setPath(value){this.path=value;return this;},setResponseType:function setResponseType(value){this.responseType=value;return this;},setWithCredentials:function setWithCredentials(value){this.withCredentials=value;return this;},setMimeType:function setMimeType(value){this.mimeType=value;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */function CompressedTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;// override in sub classes
this._parser=null;}(0,_assign2.default)(CompressedTextureLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var images=[];var texture=new CompressedTexture();texture.image=images;var loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType('arraybuffer');function loadTexture(i){loader.load(url[i],function(buffer){var texDatas=scope._parser(buffer,true);images[i]={width:texDatas.width,height:texDatas.height,format:texDatas.format,mipmaps:texDatas.mipmaps};loaded+=1;if(loaded===6){if(texDatas.mipmapCount===1)texture.minFilter=LinearFilter;texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);}},onProgress,onError);}if(Array.isArray(url)){var loaded=0;for(var i=0,il=url.length;i<il;++i){loadTexture(i);}}else{// compressed cubemap texture stored in a single DDS file
loader.load(url,function(buffer){var texDatas=scope._parser(buffer,true);if(texDatas.isCubemap){var faces=texDatas.mipmaps.length/texDatas.mipmapCount;for(var f=0;f<faces;f++){images[f]={mipmaps:[]};for(var i=0;i<texDatas.mipmapCount;i++){images[f].mipmaps.push(texDatas.mipmaps[f*texDatas.mipmapCount+i]);images[f].format=texDatas.format;images[f].width=texDatas.width;images[f].height=texDatas.height;}}}else{texture.image.width=texDatas.width;texture.image.height=texDatas.height;texture.mipmaps=texDatas.mipmaps;}if(texDatas.mipmapCount===1){texture.minFilter=LinearFilter;}texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);},onProgress,onError);}return texture;},setPath:function setPath(value){this.path=value;return this;}});/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */function DataTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;// override in sub classes
this._parser=null;}(0,_assign2.default)(DataTextureLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var texture=new DataTexture();var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.load(url,function(buffer){var texData=scope._parser(buffer);if(!texData)return;if(undefined!==texData.image){texture.image=texData.image;}else if(undefined!==texData.data){texture.image.width=texData.width;texture.image.height=texData.height;texture.image.data=texData.data;}texture.wrapS=undefined!==texData.wrapS?texData.wrapS:ClampToEdgeWrapping;texture.wrapT=undefined!==texData.wrapT?texData.wrapT:ClampToEdgeWrapping;texture.magFilter=undefined!==texData.magFilter?texData.magFilter:LinearFilter;texture.minFilter=undefined!==texData.minFilter?texData.minFilter:LinearMipMapLinearFilter;texture.anisotropy=undefined!==texData.anisotropy?texData.anisotropy:1;if(undefined!==texData.format){texture.format=texData.format;}if(undefined!==texData.type){texture.type=texData.type;}if(undefined!==texData.mipmaps){texture.mipmaps=texData.mipmaps;}if(1===texData.mipmapCount){texture.minFilter=LinearFilter;}texture.needsUpdate=true;if(onLoad)onLoad(texture,texData);},onProgress,onError);return texture;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function ImageLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}(0,_assign2.default)(ImageLoader.prototype,{load:function load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var image=document.createElementNS('http://www.w3.org/1999/xhtml','img');image.addEventListener('load',function(){Cache.add(url,this);if(onLoad)onLoad(this);scope.manager.itemEnd(url);},false);/*
			image.addEventListener( 'progress', function ( event ) {

				if ( onProgress ) onProgress( event );

			}, false );
			*/image.addEventListener('error',function(event){if(onError)onError(event);scope.manager.itemError(url);},false);if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;scope.manager.itemStart(url);image.src=url;return image;},setCrossOrigin:function setCrossOrigin(value){this.crossOrigin=value;return this;},setPath:function setPath(value){this.path=value;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function CubeTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}(0,_assign2.default)(CubeTextureLoader.prototype,{load:function load(urls,onLoad,onProgress,onError){var texture=new CubeTexture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);var loaded=0;function loadTexture(i){loader.load(urls[i],function(image){texture.images[i]=image;loaded++;if(loaded===6){texture.needsUpdate=true;if(onLoad)onLoad(texture);}},undefined,onError);}for(var i=0;i<urls.length;++i){loadTexture(i);}return texture;},setCrossOrigin:function setCrossOrigin(value){this.crossOrigin=value;return this;},setPath:function setPath(value){this.path=value;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function TextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}(0,_assign2.default)(TextureLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var texture=new Texture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);loader.load(url,function(image){// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
var isJPEG=url.search(/\.(jpg|jpeg)$/)>0||url.search(/^data\:image\/jpeg/)===0;texture.format=isJPEG?RGBFormat:RGBAFormat;texture.image=image;texture.needsUpdate=true;if(onLoad!==undefined){onLoad(texture);}},onProgress,onError);return texture;},setCrossOrigin:function setCrossOrigin(value){this.crossOrigin=value;return this;},setPath:function setPath(value){this.path=value;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function Light(color,intensity){Object3D.call(this);this.type='Light';this.color=new Color(color);this.intensity=intensity!==undefined?intensity:1;this.receiveShadow=undefined;}Light.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:Light,isLight:true,copy:function copy(source){Object3D.prototype.copy.call(this,source);this.color.copy(source.color);this.intensity=source.intensity;return this;},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();return data;}});/**
	 * @author alteredq / http://alteredqualia.com/
	 */function HemisphereLight(skyColor,groundColor,intensity){Light.call(this,skyColor,intensity);this.type='HemisphereLight';this.castShadow=undefined;this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.groundColor=new Color(groundColor);}HemisphereLight.prototype=(0,_assign2.default)((0,_create2.default)(Light.prototype),{constructor:HemisphereLight,isHemisphereLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.groundColor.copy(source.groundColor);return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 */function LightShadow(camera){this.camera=camera;this.bias=0;this.radius=1;this.mapSize=new Vector2(512,512);this.map=null;this.matrix=new Matrix4();}(0,_assign2.default)(LightShadow.prototype,{copy:function copy(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;},clone:function clone(){return new this.constructor().copy(this);},toJSON:function toJSON(){var object={};if(this.bias!==0)object.bias=this.bias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function SpotLightShadow(){LightShadow.call(this,new PerspectiveCamera());}SpotLightShadow.prototype=(0,_assign2.default)((0,_create2.default)(LightShadow.prototype),{constructor:SpotLightShadow,isSpotLightShadow:true,update:function update(light){var fov=_Math.RAD2DEG*2*light.angle;var aspect=this.mapSize.width/this.mapSize.height;var far=light.distance||500;var camera=this.camera;camera.fov=fov;camera.aspect=aspect;camera.far=far;camera.updateProjectionMatrix();}});/**
	 * @author alteredq / http://alteredqualia.com/
	 */function SpotLight(color,intensity,distance,angle,penumbra,decay){Light.call(this,color,intensity);this.type='SpotLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.autoShadow=false;Object.defineProperty(this,'power',{get:function get(){// intensity = power per solid angle.
// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
return this.intensity*Math.PI;},set:function set(power){// intensity = power per solid angle.
// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
this.intensity=power/Math.PI;}});this.distance=distance!==undefined?distance:0;this.angle=angle!==undefined?angle:Math.PI/3;this.penumbra=penumbra!==undefined?penumbra:0;this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.
this.shadow=new SpotLightShadow();}SpotLight.prototype=(0,_assign2.default)((0,_create2.default)(Light.prototype),{constructor:SpotLight,isSpotLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.distance=source.distance;this.angle=source.angle;this.penumbra=source.penumbra;this.decay=source.decay;this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});// update shadow camera by all visible meshes in the scene
SpotLight.prototype.updateShadow=function(){var box=new Box3();var result=new Box3();return function(scene){if(!scene)return;var position=this.getWorldPosition();var targetPosition=this.target.position;result.makeEmpty();scene.traverseVisible(function(object){if(object.isMesh){var geometry=object.geometry;if(geometry.boundingBox===null){geometry.computeBoundingBox();}if(geometry.boundingBox.isEmpty()===false){box.copy(geometry.boundingBox);object.matrix.compose(object.position,object.quaternion,object.scale);object.updateMatrixWorld(true);box.applyMatrix4(object.matrixWorld);result.union(box);}}});var boundingSphere=result.getBoundingSphere();var vector1=new Vector3().subVectors(targetPosition,position);var vector2=new Vector3().subVectors(boundingSphere.center,position);//If light target is a child of light, get light direction, default direction is (0,0,-1) in clara
if(this.children[0]&&this.children[0].uuid===this.target.uuid){vector1=new Vector3(0,0,-1).applyQuaternion(this.getWorldQuaternion());}var angle=vector1.angleTo(vector2);var distance=boundingSphere.center.distanceTo(position);var far=angle>Math.PI/2?0.1:distance*Math.cos(angle)+boundingSphere.radius;var near=far-boundingSphere.radius*2<0?0.01:far-boundingSphere.radius*2;this.distance=far;this.shadow.camera.far=far;this.shadow.camera.near=near;this.shadow.camera.updateProjectionMatrix();};}();/**
	 * @author mrdoob / http://mrdoob.com/
	 */function PointLight(color,intensity,distance,decay){Light.call(this,color,intensity);this.type='PointLight';Object.defineProperty(this,'power',{get:function get(){// intensity = power per solid angle.
// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
return this.intensity*4*Math.PI;},set:function set(power){// intensity = power per solid angle.
// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
this.intensity=power/(4*Math.PI);}});this.distance=distance!==undefined?distance:0;this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.
this.shadow=new LightShadow(new PerspectiveCamera(90,1,0.5,500));}PointLight.prototype=(0,_assign2.default)((0,_create2.default)(Light.prototype),{constructor:PointLight,isPointLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.distance=source.distance;this.decay=source.decay;this.shadow=source.shadow.clone();return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io
	 */function DirectionalLightShadow(){LightShadow.call(this,new OrthographicCamera());this.spreadAngle=0.0;}DirectionalLightShadow.prototype=(0,_assign2.default)((0,_create2.default)(LightShadow.prototype),{constructor:DirectionalLightShadow,isDirectionalLightShadow:true,copy:function copy(source){LightShadow.prototype.copy.call(this,source);this.spreadAngle=source.spreadAngle;return this;},update:function update(light){this.camera.updateProjectionMatrix();}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function DirectionalLight(color,intensity){Light.call(this,color,intensity);this.type='DirectionalLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.autoShadow=false;this.shadow=new DirectionalLightShadow();}DirectionalLight.prototype=(0,_assign2.default)((0,_create2.default)(Light.prototype),{constructor:DirectionalLight,isDirectionalLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});// update shadow camera by all visible meshes in the scene
DirectionalLight.prototype.updateShadowWithPosition=function(scene){if(!scene)return;var position=this.getWorldPosition();var targetPosition=this.target.position;var box=new Box3();var result=new Box3();result.makeEmpty();scene.traverseVisible(function(object){if(object.isMesh){var geometry=object.geometry;if(geometry.boundingBox===null){geometry.computeBoundingBox();}if(geometry.boundingBox.isEmpty()===false){box.copy(geometry.boundingBox);object.matrix.compose(object.position,object.quaternion,object.scale);object.updateMatrixWorld(true);box.applyMatrix4(object.matrixWorld);result.union(box);}}});var boundingSphere=result.getBoundingSphere();var vector1=new Vector3().subVectors(targetPosition,position);var vector2=new Vector3().subVectors(boundingSphere.center,position);//If light target is a child of light, get light direction, default direction is (0,0,-1) in clara
if(this.children[0]&&this.children[0].uuid===this.target.uuid){vector1=new Vector3(0,0,-1).applyQuaternion(this.getWorldQuaternion());}var angle=vector1.angleTo(vector2);var distance=boundingSphere.center.distanceTo(position);var size=distance*Math.sin(angle)+boundingSphere.radius;var far=angle>Math.PI/2?0:distance*Math.cos(angle)+boundingSphere.radius;var near=far===0||far-boundingSphere.radius*2<0?0.01:far-boundingSphere.radius*2;this.shadow.camera.left=-size;this.shadow.camera.right=size;this.shadow.camera.top=size;this.shadow.camera.bottom=-size;this.shadow.camera.far=far;this.shadow.camera.near=near;this.shadow.camera.updateProjectionMatrix();};//Default ignore directional light's position
DirectionalLight.prototype.updateShadow=function(scene){if(!scene)return;var position=this.position;var targetPosition=this.target.position;var box=new Box3();var result=new Box3();result.makeEmpty();scene.traverseVisible(function(object){if(object.isMesh){var geometry=object.geometry;if(geometry.boundingBox===null){geometry.computeBoundingBox();}if(geometry.boundingBox.isEmpty()===false){box.copy(geometry.boundingBox);object.matrix.compose(object.position,object.quaternion,object.scale);object.updateMatrixWorld(true);box.applyMatrix4(object.matrixWorld);result.union(box);}}});var boundingSphere=result.getBoundingSphere();var dirVec=new Vector3().subVectors(targetPosition,position).normalize();if(this.children[0]&&this.children[0].uuid===this.target.uuid){dirVec=new Vector3(0,0,-1).applyQuaternion(this.quaternion);}var shadowCamPos=boundingSphere.center.clone().sub(dirVec.clone().multiplyScalar(boundingSphere.radius));var size=boundingSphere.radius;var far=2*boundingSphere.radius;var near=0;this.shadow.virtualPosition=new Vector3(shadowCamPos.x,shadowCamPos.y,shadowCamPos.z);this.shadow.camera.left=-size;this.shadow.camera.right=size;this.shadow.camera.top=size;this.shadow.camera.bottom=-size;this.shadow.camera.far=far;this.shadow.camera.near=near;this.shadow.camera.updateProjectionMatrix();};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function AmbientLight(color,intensity){Light.call(this,color,intensity);this.type='AmbientLight';this.castShadow=undefined;}AmbientLight.prototype=(0,_assign2.default)((0,_create2.default)(Light.prototype),{constructor:AmbientLight,isAmbientLight:true});/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */var AnimationUtils={// same as Array.prototype.slice, but also works on typed arrays
arraySlice:function arraySlice(array,from,to){if(AnimationUtils.isTypedArray(array)){return new array.constructor(array.subarray(from,to));}return array.slice(from,to);},// converts an array to a specific type
convertArray:function convertArray(array,type,forceClone){if(!array||// let 'undefined' and 'null' pass
!forceClone&&array.constructor===type)return array;if(typeof type.BYTES_PER_ELEMENT==='number'){return new type(array);// create typed array
}return Array.prototype.slice.call(array);// create Array
},isTypedArray:function isTypedArray(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView);},// returns an array by which times and values can be sorted
getKeyframeOrder:function getKeyframeOrder(times){function compareTime(i,j){return times[i]-times[j];}var n=times.length;var result=new Array(n);for(var i=0;i!==n;++i){result[i]=i;}result.sort(compareTime);return result;},// uses the array previously returned by 'getKeyframeOrder' to sort data
sortedArray:function sortedArray(values,stride,order){var nValues=values.length;var result=new values.constructor(nValues);for(var i=0,dstOffset=0;dstOffset!==nValues;++i){var srcOffset=order[i]*stride;for(var j=0;j!==stride;++j){result[dstOffset++]=values[srcOffset+j];}}return result;},// function for parsing AOS keyframe formats
flattenJSON:function flattenJSON(jsonKeys,times,values,valuePropertyName){var i=1,key=jsonKeys[0];while(key!==undefined&&key[valuePropertyName]===undefined){key=jsonKeys[i++];}if(key===undefined)return;// no data
var value=key[valuePropertyName];if(value===undefined)return;// no data
if(Array.isArray(value)){do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push.apply(values,value);// push all elements
}key=jsonKeys[i++];}while(key!==undefined);}else if(value.toArray!==undefined){// ...assume THREE.Math-ish
do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);value.toArray(values,values.length);}key=jsonKeys[i++];}while(key!==undefined);}else{// otherwise push as-is
do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push(value);}key=jsonKeys[i++];}while(key!==undefined);}}};/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */function Interpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=resultBuffer!==undefined?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;}Interpolant.prototype={constructor:Interpolant,evaluate:function evaluate(t){var pp=this.parameterPositions,i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{var right;linear_scan:{//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
forward_scan:if(!(t<t1)){for(var giveUpAt=i1+2;;){if(t1===undefined){if(t<t0)break forward_scan;// after end
i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t,t0);}if(i1===giveUpAt)break;// this loop
t0=t1;t1=pp[++i1];if(t<t1){// we have arrived at the sought interval
break seek;}}// prepare binary search on the right side of the index
right=pp.length;break linear_scan;}//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
if(!(t>=t0)){// looping?
var t1global=pp[1];if(t<t1global){i1=2;// + 1, using the scan for the details
t0=t1global;}// linear reverse scan
for(var giveUpAt=i1-2;;){if(t0===undefined){// before start
this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(i1===giveUpAt)break;// this loop
t1=t0;t0=pp[--i1-1];if(t>=t0){// we have arrived at the sought interval
break seek;}}// prepare binary search on the left side of the index
right=i1;i1=0;break linear_scan;}// the interval is valid
break validate_interval;}// linear scan
// binary search
while(i1<right){var mid=i1+right>>>1;if(t<pp[mid]){right=mid;}else{i1=mid+1;}}t1=pp[i1];t0=pp[i1-1];// check boundary cases, again
if(t0===undefined){this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(t1===undefined){i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t0,t);}}// seek
this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1);}// validate_interval
return this.interpolate_(i1,t0,t,t1);},settings:null,// optional, subclass-specific settings structure
// Note: The indirection allows central control of many interpolants.
// --- Protected interface
DefaultSettings_:{},getSettings_:function getSettings_(){return this.settings||this.DefaultSettings_;},copySampleValue_:function copySampleValue_(index){// copies a sample value to the result buffer
var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(var i=0;i!==stride;++i){result[i]=values[offset+i];}return result;},// Template methods for derived classes:
interpolate_:function interpolate_(i1,t0,t,t1){throw new Error("call to abstract method");// implementations shall return this.resultBuffer
},intervalChanged_:function intervalChanged_(i1,t0,t1){// empty
}};(0,_assign2.default)(Interpolant.prototype,{beforeStart_://( 0, t, t0 ), returns this.resultBuffer
Interpolant.prototype.copySampleValue_,afterEnd_://( N-1, tN-1, t ), returns this.resultBuffer
Interpolant.prototype.copySampleValue_});/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */function CubicInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);this._weightPrev=-0;this._offsetPrev=-0;this._weightNext=-0;this._offsetNext=-0;}CubicInterpolant.prototype=(0,_assign2.default)((0,_create2.default)(Interpolant.prototype),{constructor:CubicInterpolant,DefaultSettings_:{endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding},intervalChanged_:function intervalChanged_(i1,t0,t1){var pp=this.parameterPositions,iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===undefined){switch(this.getSettings_().endingStart){case ZeroSlopeEnding:// f'(t0) = 0
iPrev=i1;tPrev=2*t0-t1;break;case WrapAroundEnding:// use the other end of the curve
iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:// ZeroCurvatureEnding
// f''(t0) = 0 a.k.a. Natural Spline
iPrev=i1;tPrev=t1;}}if(tNext===undefined){switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:// f'(tN) = 0
iNext=i1;tNext=2*t1-t0;break;case WrapAroundEnding:// use the other end of the curve
iNext=1;tNext=t1+pp[1]-pp[0];break;default:// ZeroCurvatureEnding
// f''(tN) = 0, a.k.a. Natural Spline
iNext=i1-1;tNext=t0;}}var halfDt=(t1-t0)*0.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev);this._weightNext=halfDt/(tNext-t1);this._offsetPrev=iPrev*stride;this._offsetNext=iNext*stride;},interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p;// evaluate polynomials
var sP=-wP*ppp+2*wP*pp-wP*p;var s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;var s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;var sN=wN*ppp-wN*pp;// combine data linearly
for(var i=0;i!==stride;++i){result[i]=sP*values[oP+i]+s0*values[o0+i]+s1*values[o1+i]+sN*values[oN+i];}return result;}});/**
	 * @author tschw
	 */function LinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}LinearInterpolant.prototype=(0,_assign2.default)((0,_create2.default)(Interpolant.prototype),{constructor:LinearInterpolant,interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(var i=0;i!==stride;++i){result[i]=values[offset0+i]*weight0+values[offset1+i]*weight1;}return result;}});/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */function DiscreteInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}DiscreteInterpolant.prototype=(0,_assign2.default)((0,_create2.default)(Interpolant.prototype),{constructor:DiscreteInterpolant,interpolate_:function interpolate_(i1,t0,t,t1){return this.copySampleValue_(i1-1);}});var KeyframeTrackPrototype;KeyframeTrackPrototype={TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodDiscrete:function InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:function InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);},setInterpolation:function setInterpolation(interpolation){var factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break;}if(factoryMethod===undefined){var message="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===undefined){// fall back to default, unless the default itself is messed up
if(interpolation!==this.DefaultInterpolation){this.setInterpolation(this.DefaultInterpolation);}else{throw new Error(message);// fatal, in this case
}}console.warn(message);return;}this.createInterpolant=factoryMethod;},getInterpolation:function getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth;}},getValueSize:function getValueSize(){return this.values.length/this.times.length;},// move all keyframes either forwards or backwards in time
shift:function shift(timeOffset){if(timeOffset!==0.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]+=timeOffset;}}return this;},// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
scale:function scale(timeScale){if(timeScale!==1.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]*=timeScale;}}return this;},// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
trim:function trim(startTime,endTime){var times=this.times,nKeys=times.length,from=0,to=nKeys-1;while(from!==nKeys&&times[from]<startTime){++from;}while(to!==-1&&times[to]>endTime){--to;}++to;// inclusive -> exclusive bound
if(from!==0||to!==nKeys){// empty tracks are forbidden, so keep at least one keyframe
if(from>=to)to=Math.max(to,1),from=to-1;var stride=this.getValueSize();this.times=AnimationUtils.arraySlice(times,from,to);this.values=AnimationUtils.arraySlice(this.values,from*stride,to*stride);}return this;},// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
validate:function validate(){var valid=true;var valueSize=this.getValueSize();if(valueSize-Math.floor(valueSize)!==0){console.error("invalid value size in track",this);valid=false;}var times=this.times,values=this.values,nKeys=times.length;if(nKeys===0){console.error("track is empty",this);valid=false;}var prevTime=null;for(var i=0;i!==nKeys;i++){var currTime=times[i];if(typeof currTime==='number'&&isNaN(currTime)){console.error("time is not a valid number",this,i,currTime);valid=false;break;}if(prevTime!==null&&prevTime>currTime){console.error("out of order keys",this,i,currTime,prevTime);valid=false;break;}prevTime=currTime;}if(values!==undefined){if(AnimationUtils.isTypedArray(values)){for(var i=0,n=values.length;i!==n;++i){var value=values[i];if(isNaN(value)){console.error("value is not a valid number",this,i,value);valid=false;break;}}}}return valid;},// removes equivalent sequential keys as common in morph target sequences
// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
optimize:function optimize(){var times=this.times,values=this.values,stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,writeIndex=1,lastIndex=times.length-1;for(var i=1;i<lastIndex;++i){var keep=false;var time=times[i];var timeNext=times[i+1];// remove adjacent keyframes scheduled at the same time
if(time!==timeNext&&(i!==1||time!==time[0])){if(!smoothInterpolation){// remove unnecessary keyframes same as their neighbors
var offset=i*stride,offsetP=offset-stride,offsetN=offset+stride;for(var j=0;j!==stride;++j){var value=values[offset+j];if(value!==values[offsetP+j]||value!==values[offsetN+j]){keep=true;break;}}}else keep=true;}// in-place compaction
if(keep){if(i!==writeIndex){times[writeIndex]=times[i];var readOffset=i*stride,writeOffset=writeIndex*stride;for(var j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}}++writeIndex;}}// flush last keyframe (compaction looks ahead)
if(lastIndex>0){times[writeIndex]=times[lastIndex];for(var readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}++writeIndex;}if(writeIndex!==times.length){this.times=AnimationUtils.arraySlice(times,0,writeIndex);this.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);}return this;}};function KeyframeTrackConstructor(name,times,values,interpolation){if(name===undefined)throw new Error("track name is undefined");if(times===undefined||times.length===0){throw new Error("no keyframes in track named "+name);}this.name=name;this.times=AnimationUtils.convertArray(times,this.TimeBufferType);this.values=AnimationUtils.convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation);this.validate();this.optimize();}/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function VectorKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}VectorKeyframeTrack.prototype=(0,_assign2.default)((0,_create2.default)(KeyframeTrackPrototype),{constructor:VectorKeyframeTrack,ValueTypeName:'vector'// ValueBufferType is inherited
// DefaultInterpolation is inherited
});/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */function QuaternionLinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}QuaternionLinearInterpolant.prototype=(0,_assign2.default)((0,_create2.default)(Interpolant.prototype),{constructor:QuaternionLinearInterpolant,interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=i1*stride,alpha=(t-t0)/(t1-t0);for(var end=offset+stride;offset!==end;offset+=4){Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);}return result;}});/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function QuaternionKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}QuaternionKeyframeTrack.prototype=(0,_assign2.default)((0,_create2.default)(KeyframeTrackPrototype),{constructor:QuaternionKeyframeTrack,ValueTypeName:'quaternion',// ValueBufferType is inherited
DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:undefined// not yet implemented
});/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function NumberKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}NumberKeyframeTrack.prototype=(0,_assign2.default)((0,_create2.default)(KeyframeTrackPrototype),{constructor:NumberKeyframeTrack,ValueTypeName:'number'// ValueBufferType is inherited
// DefaultInterpolation is inherited
});/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function StringKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}StringKeyframeTrack.prototype=(0,_assign2.default)((0,_create2.default)(KeyframeTrackPrototype),{constructor:StringKeyframeTrack,ValueTypeName:'string',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined});/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function BooleanKeyframeTrack(name,times,values){KeyframeTrackConstructor.call(this,name,times,values);}BooleanKeyframeTrack.prototype=(0,_assign2.default)((0,_create2.default)(KeyframeTrackPrototype),{constructor:BooleanKeyframeTrack,ValueTypeName:'bool',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined// Note: Actually this track could have a optimized / compressed
// representation of a single value and a custom interpolant that
// computes "firstValue ^ isOdd( index )".
});/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function ColorKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}ColorKeyframeTrack.prototype=(0,_assign2.default)((0,_create2.default)(KeyframeTrackPrototype),{constructor:ColorKeyframeTrack,ValueTypeName:'color'// ValueBufferType is inherited
// DefaultInterpolation is inherited
// Note: Very basic implementation and nothing special yet.
// However, this is the place for color space parameterization.
});/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function KeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.apply(this,arguments);}KeyframeTrack.prototype=KeyframeTrackPrototype;KeyframeTrackPrototype.constructor=KeyframeTrack;// Static methods:
(0,_assign2.default)(KeyframeTrack,{// Serialization (in static context, because of constructor invocation
// and automatic invocation of .toJSON):
parse:function parse(json){if(json.type===undefined){throw new Error("track type undefined, can not parse");}var trackType=KeyframeTrack._getTrackTypeForValueTypeName(json.type);if(json.times===undefined){var times=[],values=[];AnimationUtils.flattenJSON(json.keys,times,values,'value');json.times=times;json.values=values;}// derived classes can define a static parse method
if(trackType.parse!==undefined){return trackType.parse(json);}else{// by default, we asssume a constructor compatible with the base
return new trackType(json.name,json.times,json.values,json.interpolation);}},toJSON:function toJSON(track){var trackType=track.constructor;var json;// derived classes can define a static toJSON method
if(trackType.toJSON!==undefined){json=trackType.toJSON(track);}else{// by default, we assume the data can be serialized as-is
json={'name':track.name,'times':AnimationUtils.convertArray(track.times,Array),'values':AnimationUtils.convertArray(track.values,Array)};var interpolation=track.getInterpolation();if(interpolation!==track.DefaultInterpolation){json.interpolation=interpolation;}}json.type=track.ValueTypeName;// mandatory
return json;},_getTrackTypeForValueTypeName:function _getTrackTypeForValueTypeName(typeName){switch(typeName.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack;}throw new Error("Unsupported typeName: "+typeName);}});/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */function AnimationClip(name,duration,tracks){this.name=name;this.tracks=tracks;this.duration=duration!==undefined?duration:-1;this.uuid=_Math.generateUUID();// this means it should figure out its duration by scanning the tracks
if(this.duration<0){this.resetDuration();}this.optimize();}AnimationClip.prototype={constructor:AnimationClip,resetDuration:function resetDuration(){var tracks=this.tracks,duration=0;for(var i=0,n=tracks.length;i!==n;++i){var track=this.tracks[i];duration=Math.max(duration,track.times[track.times.length-1]);}this.duration=duration;},trim:function trim(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].trim(0,this.duration);}return this;},optimize:function optimize(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].optimize();}return this;}};// Static methods:
(0,_assign2.default)(AnimationClip,{parse:function parse(json){var tracks=[],jsonTracks=json.tracks,frameTime=1.0/(json.fps||1.0);for(var i=0,n=jsonTracks.length;i!==n;++i){tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));}return new AnimationClip(json.name,json.duration,tracks);},toJSON:function toJSON(clip){var tracks=[],clipTracks=clip.tracks;var json={'name':clip.name,'duration':clip.duration,'tracks':tracks};for(var i=0,n=clipTracks.length;i!==n;++i){tracks.push(KeyframeTrack.toJSON(clipTracks[i]));}return json;},CreateFromMorphTargetSequence:function CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){var numMorphTargets=morphTargetSequence.length;var tracks=[];for(var i=0;i<numMorphTargets;i++){var times=[];var values=[];times.push((i+numMorphTargets-1)%numMorphTargets,i,(i+1)%numMorphTargets);values.push(0,1,0);var order=AnimationUtils.getKeyframeOrder(times);times=AnimationUtils.sortedArray(times,1,order);values=AnimationUtils.sortedArray(values,1,order);// if there is a key at the first frame, duplicate it as the
// last frame as well for perfect loop.
if(!noLoop&&times[0]===0){times.push(numMorphTargets);values.push(values[0]);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluences['+morphTargetSequence[i].name+']',times,values).scale(1.0/fps));}return new AnimationClip(name,-1,tracks);},findByName:function findByName(objectOrClipArray,name){var clipArray=objectOrClipArray;if(!Array.isArray(objectOrClipArray)){var o=objectOrClipArray;clipArray=o.geometry&&o.geometry.animations||o.animations;}for(var i=0;i<clipArray.length;i++){if(clipArray[i].name===name){return clipArray[i];}}return null;},CreateClipsFromMorphTargetSequences:function CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){var animationToMorphTargets={};// tested with https://regex101.com/ on trick sequences
// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
var pattern=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
// patterns like Walk_001, Walk_002, Run_001, Run_002
for(var i=0,il=morphTargets.length;i<il;i++){var morphTarget=morphTargets[i];var parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){var name=parts[1];var animationMorphTargets=animationToMorphTargets[name];if(!animationMorphTargets){animationToMorphTargets[name]=animationMorphTargets=[];}animationMorphTargets.push(morphTarget);}}var clips=[];for(var name in animationToMorphTargets){clips.push(AnimationClip.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));}return clips;},// parse the animation.hierarchy format
parseAnimation:function parseAnimation(animation,bones){if(!animation){console.error("  no animation in JSONLoader data");return null;}var addNonemptyTrack=function addNonemptyTrack(trackType,trackName,animationKeys,propertyName,destTracks){// only return track if there are actually keys.
if(animationKeys.length!==0){var times=[];var values=[];AnimationUtils.flattenJSON(animationKeys,times,values,propertyName);// empty keys are filtered out, so check again
if(times.length!==0){destTracks.push(new trackType(trackName,times,values));}}};var tracks=[];var clipName=animation.name||'default';// automatic length determination in AnimationClip.
var duration=animation.length||-1;var fps=animation.fps||30;var hierarchyTracks=animation.hierarchy||[];for(var h=0;h<hierarchyTracks.length;h++){var animationKeys=hierarchyTracks[h].keys;// skip empty tracks
if(!animationKeys||animationKeys.length===0)continue;// process morph targets in a way exactly compatible
// with AnimationHandler.init( animation )
if(animationKeys[0].morphTargets){// figure out all morph targets used in this track
var morphTargetNames={};for(var k=0;k<animationKeys.length;k++){if(animationKeys[k].morphTargets){for(var m=0;m<animationKeys[k].morphTargets.length;m++){morphTargetNames[animationKeys[k].morphTargets[m]]=-1;}}}// create a track for each morph target with all zero
// morphTargetInfluences except for the keys in which
// the morphTarget is named.
for(var morphTargetName in morphTargetNames){var times=[];var values=[];for(var m=0;m!==animationKeys[k].morphTargets.length;++m){var animationKey=animationKeys[k];times.push(animationKey.time);values.push(animationKey.morphTarget===morphTargetName?1:0);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));}duration=morphTargetNames.length*(fps||1.0);}else{// ...assume skeletal animation
var boneName='.bones['+bones[h].name+']';addNonemptyTrack(VectorKeyframeTrack,boneName+'.position',animationKeys,'pos',tracks);addNonemptyTrack(QuaternionKeyframeTrack,boneName+'.quaternion',animationKeys,'rot',tracks);addNonemptyTrack(VectorKeyframeTrack,boneName+'.scale',animationKeys,'scl',tracks);}}if(tracks.length===0){return null;}var clip=new AnimationClip(clipName,duration,tracks);return clip;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function MaterialLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.textures={};}(0,_assign2.default)(MaterialLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.load(url,function(text){onLoad(scope.parse(JSON.parse(text)));},onProgress,onError);},setTextures:function setTextures(value){this.textures=value;},parse:function parse(json){var textures=this.textures;function getTexture(name){if(textures[name]===undefined){console.warn('THREE.MaterialLoader: Undefined texture',name);}return textures[name];}var material=new Materials[json.type]();if(json.uuid!==undefined)material.uuid=json.uuid;if(json.name!==undefined)material.name=json.name;if(json.color!==undefined)material.color.setHex(json.color);if(json.roughness!==undefined)material.roughness=json.roughness;if(json.metalness!==undefined)material.metalness=json.metalness;if(json.emissive!==undefined)material.emissive.setHex(json.emissive);if(json.specular!==undefined)material.specular.setHex(json.specular);if(json.shininess!==undefined)material.shininess=json.shininess;if(json.clearCoat!==undefined)material.clearCoat=json.clearCoat;if(json.clearCoatRoughness!==undefined)material.clearCoatRoughness=json.clearCoatRoughness;if(json.uniforms!==undefined)material.uniforms=json.uniforms;if(json.vertexShader!==undefined)material.vertexShader=json.vertexShader;if(json.fragmentShader!==undefined)material.fragmentShader=json.fragmentShader;if(json.vertexColors!==undefined)material.vertexColors=json.vertexColors;if(json.fog!==undefined)material.fog=json.fog;if(json.shading!==undefined)material.shading=json.shading;if(json.blending!==undefined)material.blending=json.blending;if(json.side!==undefined)material.side=json.side;if(json.opacity!==undefined)material.opacity=json.opacity;if(json.transparent!==undefined)material.transparent=json.transparent;if(json.alphaTest!==undefined)material.alphaTest=json.alphaTest;if(json.depthTest!==undefined)material.depthTest=json.depthTest;if(json.depthWrite!==undefined)material.depthWrite=json.depthWrite;if(json.colorWrite!==undefined)material.colorWrite=json.colorWrite;if(json.wireframe!==undefined)material.wireframe=json.wireframe;if(json.wireframeLinewidth!==undefined)material.wireframeLinewidth=json.wireframeLinewidth;if(json.wireframeLinecap!==undefined)material.wireframeLinecap=json.wireframeLinecap;if(json.wireframeLinejoin!==undefined)material.wireframeLinejoin=json.wireframeLinejoin;if(json.skinning!==undefined)material.skinning=json.skinning;if(json.morphTargets!==undefined)material.morphTargets=json.morphTargets;// for PointsMaterial
if(json.size!==undefined)material.size=json.size;if(json.sizeAttenuation!==undefined)material.sizeAttenuation=json.sizeAttenuation;// maps
if(json.map!==undefined)material.map=getTexture(json.map);if(json.alphaMap!==undefined){material.alphaMap=getTexture(json.alphaMap);material.transparent=true;}if(json.bumpMap!==undefined)material.bumpMap=getTexture(json.bumpMap);if(json.bumpScale!==undefined)material.bumpScale=json.bumpScale;if(json.normalMap!==undefined)material.normalMap=getTexture(json.normalMap);if(json.normalScale!==undefined){var normalScale=json.normalScale;if(Array.isArray(normalScale)===false){// Blender exporter used to export a scalar. See #7459
normalScale=[normalScale,normalScale];}material.normalScale=new Vector2().fromArray(normalScale);}if(json.displacementMap!==undefined)material.displacementMap=getTexture(json.displacementMap);if(json.displacementScale!==undefined)material.displacementScale=json.displacementScale;if(json.displacementBias!==undefined)material.displacementBias=json.displacementBias;if(json.roughnessMap!==undefined)material.roughnessMap=getTexture(json.roughnessMap);if(json.metalnessMap!==undefined)material.metalnessMap=getTexture(json.metalnessMap);if(json.emissiveMap!==undefined)material.emissiveMap=getTexture(json.emissiveMap);if(json.emissiveIntensity!==undefined)material.emissiveIntensity=json.emissiveIntensity;if(json.specularMap!==undefined)material.specularMap=getTexture(json.specularMap);if(json.envMap!==undefined)material.envMap=getTexture(json.envMap);if(json.reflectivity!==undefined)material.reflectivity=json.reflectivity;if(json.lightMap!==undefined)material.lightMap=getTexture(json.lightMap);if(json.lightMapIntensity!==undefined)material.lightMapIntensity=json.lightMapIntensity;if(json.aoMap!==undefined)material.aoMap=getTexture(json.aoMap);if(json.aoMapIntensity!==undefined)material.aoMapIntensity=json.aoMapIntensity;if(json.gradientMap!==undefined)material.gradientMap=getTexture(json.gradientMap);// MultiMaterial
if(json.materials!==undefined){for(var i=0,l=json.materials.length;i<l;i++){material.materials.push(this.parse(json.materials[i]));}}return material;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function BufferGeometryLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}(0,_assign2.default)(BufferGeometryLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.load(url,function(text){onLoad(scope.parse(JSON.parse(text)));},onProgress,onError);},parse:function parse(json){var geometry=new BufferGeometry();var index=json.data.index;var TYPED_ARRAYS={'Int8Array':Int8Array,'Uint8Array':Uint8Array,'Uint8ClampedArray':Uint8ClampedArray,'Int16Array':Int16Array,'Uint16Array':Uint16Array,'Int32Array':Int32Array,'Uint32Array':Uint32Array,'Float32Array':Float32Array,'Float64Array':Float64Array};if(index!==undefined){var typedArray=new TYPED_ARRAYS[index.type](index.array);geometry.setIndex(new BufferAttribute(typedArray,1));}var attributes=json.data.attributes;for(var key in attributes){var attribute=attributes[key];var typedArray=new TYPED_ARRAYS[attribute.type](attribute.array);geometry.addAttribute(key,new BufferAttribute(typedArray,attribute.itemSize,attribute.normalized));}var groups=json.data.groups||json.data.drawcalls||json.data.offsets;if(groups!==undefined){for(var i=0,n=groups.length;i!==n;++i){var group=groups[i];geometry.addGroup(group.start,group.count,group.materialIndex);}}var boundingSphere=json.data.boundingSphere;if(boundingSphere!==undefined){var center=new Vector3();if(boundingSphere.center!==undefined){center.fromArray(boundingSphere.center);}geometry.boundingSphere=new Sphere(center,boundingSphere.radius);}return geometry;}});/**
	 * @author alteredq / http://alteredqualia.com/
	 */function Loader(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){};}Loader.prototype={constructor:Loader,crossOrigin:undefined,extractUrlBase:function extractUrlBase(url){var parts=url.split('/');if(parts.length===1)return'./';parts.pop();return parts.join('/')+'/';},initMaterials:function initMaterials(materials,texturePath,crossOrigin){var array=[];for(var i=0;i<materials.length;++i){array[i]=this.createMaterial(materials[i],texturePath,crossOrigin);}return array;},createMaterial:function(){var BlendingMode={NoBlending:NoBlending,NormalBlending:NormalBlending,AdditiveBlending:AdditiveBlending,SubtractiveBlending:SubtractiveBlending,MultiplyBlending:MultiplyBlending,CustomBlending:CustomBlending};var color,textureLoader,materialLoader;return function createMaterial(m,texturePath,crossOrigin){if(color===undefined)color=new Color();if(textureLoader===undefined)textureLoader=new TextureLoader();if(materialLoader===undefined)materialLoader=new MaterialLoader();// convert from old material format
var textures={};function loadTexture(path,repeat,offset,wrap,anisotropy){var fullPath=texturePath+path;var loader=Loader.Handlers.get(fullPath);var texture;if(loader!==null){texture=loader.load(fullPath);}else{textureLoader.setCrossOrigin(crossOrigin);texture=textureLoader.load(fullPath);}if(repeat!==undefined){texture.repeat.fromArray(repeat);if(repeat[0]!==1)texture.wrapS=RepeatWrapping;if(repeat[1]!==1)texture.wrapT=RepeatWrapping;}if(offset!==undefined){texture.offset.fromArray(offset);}if(wrap!==undefined){if(wrap[0]==='repeat')texture.wrapS=RepeatWrapping;if(wrap[0]==='mirror')texture.wrapS=MirroredRepeatWrapping;if(wrap[1]==='repeat')texture.wrapT=RepeatWrapping;if(wrap[1]==='mirror')texture.wrapT=MirroredRepeatWrapping;}if(anisotropy!==undefined){texture.anisotropy=anisotropy;}var uuid=_Math.generateUUID();textures[uuid]=texture;return uuid;}//
var json={uuid:_Math.generateUUID(),type:'MeshLambertMaterial'};for(var name in m){var value=m[name];switch(name){case'DbgColor':case'DbgIndex':case'opticalDensity':case'illumination':break;case'DbgName':json.name=value;break;case'blending':json.blending=BlendingMode[value];break;case'colorAmbient':case'mapAmbient':console.warn('THREE.Loader.createMaterial:',name,'is no longer supported.');break;case'colorDiffuse':json.color=color.fromArray(value).getHex();break;case'colorSpecular':json.specular=color.fromArray(value).getHex();break;case'colorEmissive':json.emissive=color.fromArray(value).getHex();break;case'specularCoef':json.shininess=value;break;case'shading':if(value.toLowerCase()==='basic')json.type='MeshBasicMaterial';if(value.toLowerCase()==='phong')json.type='MeshPhongMaterial';if(value.toLowerCase()==='standard')json.type='MeshStandardMaterial';break;case'mapDiffuse':json.map=loadTexture(value,m.mapDiffuseRepeat,m.mapDiffuseOffset,m.mapDiffuseWrap,m.mapDiffuseAnisotropy);break;case'mapDiffuseRepeat':case'mapDiffuseOffset':case'mapDiffuseWrap':case'mapDiffuseAnisotropy':break;case'mapEmissive':json.emissiveMap=loadTexture(value,m.mapEmissiveRepeat,m.mapEmissiveOffset,m.mapEmissiveWrap,m.mapEmissiveAnisotropy);break;case'mapEmissiveRepeat':case'mapEmissiveOffset':case'mapEmissiveWrap':case'mapEmissiveAnisotropy':break;case'mapLight':json.lightMap=loadTexture(value,m.mapLightRepeat,m.mapLightOffset,m.mapLightWrap,m.mapLightAnisotropy);break;case'mapLightRepeat':case'mapLightOffset':case'mapLightWrap':case'mapLightAnisotropy':break;case'mapAO':json.aoMap=loadTexture(value,m.mapAORepeat,m.mapAOOffset,m.mapAOWrap,m.mapAOAnisotropy);break;case'mapAORepeat':case'mapAOOffset':case'mapAOWrap':case'mapAOAnisotropy':break;case'mapBump':json.bumpMap=loadTexture(value,m.mapBumpRepeat,m.mapBumpOffset,m.mapBumpWrap,m.mapBumpAnisotropy);break;case'mapBumpScale':json.bumpScale=value;break;case'mapBumpRepeat':case'mapBumpOffset':case'mapBumpWrap':case'mapBumpAnisotropy':break;case'mapNormal':json.normalMap=loadTexture(value,m.mapNormalRepeat,m.mapNormalOffset,m.mapNormalWrap,m.mapNormalAnisotropy);break;case'mapNormalFactor':json.normalScale=[value,value];break;case'mapNormalRepeat':case'mapNormalOffset':case'mapNormalWrap':case'mapNormalAnisotropy':break;case'mapSpecular':json.specularMap=loadTexture(value,m.mapSpecularRepeat,m.mapSpecularOffset,m.mapSpecularWrap,m.mapSpecularAnisotropy);break;case'mapSpecularRepeat':case'mapSpecularOffset':case'mapSpecularWrap':case'mapSpecularAnisotropy':break;case'mapMetalness':json.metalnessMap=loadTexture(value,m.mapMetalnessRepeat,m.mapMetalnessOffset,m.mapMetalnessWrap,m.mapMetalnessAnisotropy);break;case'mapMetalnessRepeat':case'mapMetalnessOffset':case'mapMetalnessWrap':case'mapMetalnessAnisotropy':break;case'mapRoughness':json.roughnessMap=loadTexture(value,m.mapRoughnessRepeat,m.mapRoughnessOffset,m.mapRoughnessWrap,m.mapRoughnessAnisotropy);break;case'mapRoughnessRepeat':case'mapRoughnessOffset':case'mapRoughnessWrap':case'mapRoughnessAnisotropy':break;case'mapAlpha':json.alphaMap=loadTexture(value,m.mapAlphaRepeat,m.mapAlphaOffset,m.mapAlphaWrap,m.mapAlphaAnisotropy);break;case'mapAlphaRepeat':case'mapAlphaOffset':case'mapAlphaWrap':case'mapAlphaAnisotropy':break;case'flipSided':json.side=BackSide;break;case'doubleSided':json.side=DoubleSide;break;case'transparency':console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');json.opacity=value;break;case'depthTest':case'depthWrite':case'colorWrite':case'opacity':case'reflectivity':case'transparent':case'visible':case'wireframe':json[name]=value;break;case'vertexColors':if(value===true)json.vertexColors=VertexColors;if(value==='face')json.vertexColors=FaceColors;break;default:console.error('THREE.Loader.createMaterial: Unsupported',name,value);break;}}if(json.type==='MeshBasicMaterial')delete json.emissive;if(json.type!=='MeshPhongMaterial')delete json.specular;if(json.opacity<1)json.transparent=true;materialLoader.setTextures(textures);return materialLoader.parse(json);};}()};Loader.Handlers={handlers:[],add:function add(regex,loader){this.handlers.push(regex,loader);},get:function get(file){var handlers=this.handlers;for(var i=0,l=handlers.length;i<l;i+=2){var regex=handlers[i];var loader=handlers[i+1];if(regex.test(file)){return loader;}}return null;}};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function JSONLoader(manager){if(typeof manager==='boolean'){console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');manager=undefined;}this.manager=manager!==undefined?manager:DefaultLoadingManager;this.withCredentials=false;}(0,_assign2.default)(JSONLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var texturePath=this.texturePath&&typeof this.texturePath==="string"?this.texturePath:Loader.prototype.extractUrlBase(url);var loader=new FileLoader(this.manager);loader.setWithCredentials(this.withCredentials);loader.load(url,function(text){var json=JSON.parse(text);var metadata=json.metadata;if(metadata!==undefined){var type=metadata.type;if(type!==undefined){if(type.toLowerCase()==='object'){console.error('THREE.JSONLoader: '+url+' should be loaded with THREE.ObjectLoader instead.');return;}if(type.toLowerCase()==='scene'){console.error('THREE.JSONLoader: '+url+' should be loaded with THREE.SceneLoader instead.');return;}}}var object=scope.parse(json,texturePath);onLoad(object.geometry,object.materials);},onProgress,onError);},setTexturePath:function setTexturePath(value){this.texturePath=value;},parse:function parse(json,texturePath){var geometry=new Geometry(),scale=json.scale!==undefined?1.0/json.scale:1.0;parseModel(scale);parseSkin();parseMorphing(scale);parseAnimations();geometry.computeFaceNormals();geometry.computeBoundingSphere();function parseModel(scale){function isBitSet(value,position){return value&1<<position;}var i,j,fi,offset,zLength,colorIndex,normalIndex,uvIndex,materialIndex,type,isQuad,hasMaterial,hasFaceVertexUv,hasFaceNormal,hasFaceVertexNormal,hasFaceColor,hasFaceVertexColor,vertex,face,faceA,faceB,hex,normal,uvLayer,uv,u,v,faces=json.faces,vertices=json.vertices,normals=json.normals,colors=json.colors,nUvLayers=0;if(json.uvs!==undefined){// disregard empty arrays
for(i=0;i<json.uvs.length;i++){if(json.uvs[i].length)nUvLayers++;}for(i=0;i<nUvLayers;i++){geometry.faceVertexUvs[i]=[];}}offset=0;zLength=vertices.length;while(offset<zLength){vertex=new Vector3();vertex.x=vertices[offset++]*scale;vertex.y=vertices[offset++]*scale;vertex.z=vertices[offset++]*scale;geometry.vertices.push(vertex);}offset=0;zLength=faces.length;while(offset<zLength){type=faces[offset++];isQuad=isBitSet(type,0);hasMaterial=isBitSet(type,1);hasFaceVertexUv=isBitSet(type,3);hasFaceNormal=isBitSet(type,4);hasFaceVertexNormal=isBitSet(type,5);hasFaceColor=isBitSet(type,6);hasFaceVertexColor=isBitSet(type,7);// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
if(isQuad){faceA=new Face3();faceA.a=faces[offset];faceA.b=faces[offset+1];faceA.c=faces[offset+3];faceB=new Face3();faceB.a=faces[offset+1];faceB.b=faces[offset+2];faceB.c=faces[offset+3];offset+=4;if(hasMaterial){materialIndex=faces[offset++];faceA.materialIndex=materialIndex;faceB.materialIndex=materialIndex;}// to get face <=> uv index correspondence
fi=geometry.faces.length;if(hasFaceVertexUv){for(i=0;i<nUvLayers;i++){uvLayer=json.uvs[i];geometry.faceVertexUvs[i][fi]=[];geometry.faceVertexUvs[i][fi+1]=[];for(j=0;j<4;j++){uvIndex=faces[offset++];u=uvLayer[uvIndex*2];v=uvLayer[uvIndex*2+1];uv=new Vector2(u,v);if(j!==2)geometry.faceVertexUvs[i][fi].push(uv);if(j!==0)geometry.faceVertexUvs[i][fi+1].push(uv);}}}if(hasFaceNormal){normalIndex=faces[offset++]*3;faceA.normal.set(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);faceB.normal.copy(faceA.normal);}if(hasFaceVertexNormal){for(i=0;i<4;i++){normalIndex=faces[offset++]*3;normal=new Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);if(i!==2)faceA.vertexNormals.push(normal);if(i!==0)faceB.vertexNormals.push(normal);}}if(hasFaceColor){colorIndex=faces[offset++];hex=colors[colorIndex];faceA.color.setHex(hex);faceB.color.setHex(hex);}if(hasFaceVertexColor){for(i=0;i<4;i++){colorIndex=faces[offset++];hex=colors[colorIndex];if(i!==2)faceA.vertexColors.push(new Color(hex));if(i!==0)faceB.vertexColors.push(new Color(hex));}}geometry.faces.push(faceA);geometry.faces.push(faceB);}else{face=new Face3();face.a=faces[offset++];face.b=faces[offset++];face.c=faces[offset++];if(hasMaterial){materialIndex=faces[offset++];face.materialIndex=materialIndex;}// to get face <=> uv index correspondence
fi=geometry.faces.length;if(hasFaceVertexUv){for(i=0;i<nUvLayers;i++){uvLayer=json.uvs[i];geometry.faceVertexUvs[i][fi]=[];for(j=0;j<3;j++){uvIndex=faces[offset++];u=uvLayer[uvIndex*2];v=uvLayer[uvIndex*2+1];uv=new Vector2(u,v);geometry.faceVertexUvs[i][fi].push(uv);}}}if(hasFaceNormal){normalIndex=faces[offset++]*3;face.normal.set(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);}if(hasFaceVertexNormal){for(i=0;i<3;i++){normalIndex=faces[offset++]*3;normal=new Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);face.vertexNormals.push(normal);}}if(hasFaceColor){colorIndex=faces[offset++];face.color.setHex(colors[colorIndex]);}if(hasFaceVertexColor){for(i=0;i<3;i++){colorIndex=faces[offset++];face.vertexColors.push(new Color(colors[colorIndex]));}}geometry.faces.push(face);}}}function parseSkin(){var influencesPerVertex=json.influencesPerVertex!==undefined?json.influencesPerVertex:2;if(json.skinWeights){for(var i=0,l=json.skinWeights.length;i<l;i+=influencesPerVertex){var x=json.skinWeights[i];var y=influencesPerVertex>1?json.skinWeights[i+1]:0;var z=influencesPerVertex>2?json.skinWeights[i+2]:0;var w=influencesPerVertex>3?json.skinWeights[i+3]:0;geometry.skinWeights.push(new Vector4(x,y,z,w));}}if(json.skinIndices){for(var i=0,l=json.skinIndices.length;i<l;i+=influencesPerVertex){var a=json.skinIndices[i];var b=influencesPerVertex>1?json.skinIndices[i+1]:0;var c=influencesPerVertex>2?json.skinIndices[i+2]:0;var d=influencesPerVertex>3?json.skinIndices[i+3]:0;geometry.skinIndices.push(new Vector4(a,b,c,d));}}geometry.bones=json.bones;if(geometry.bones&&geometry.bones.length>0&&(geometry.skinWeights.length!==geometry.skinIndices.length||geometry.skinIndices.length!==geometry.vertices.length)){console.warn('When skinning, number of vertices ('+geometry.vertices.length+'), skinIndices ('+geometry.skinIndices.length+'), and skinWeights ('+geometry.skinWeights.length+') should match.');}}function parseMorphing(scale){if(json.morphTargets!==undefined){for(var i=0,l=json.morphTargets.length;i<l;i++){geometry.morphTargets[i]={};geometry.morphTargets[i].name=json.morphTargets[i].name;geometry.morphTargets[i].vertices=[];var dstVertices=geometry.morphTargets[i].vertices;var srcVertices=json.morphTargets[i].vertices;for(var v=0,vl=srcVertices.length;v<vl;v+=3){var vertex=new Vector3();vertex.x=srcVertices[v]*scale;vertex.y=srcVertices[v+1]*scale;vertex.z=srcVertices[v+2]*scale;dstVertices.push(vertex);}}}if(json.morphColors!==undefined&&json.morphColors.length>0){console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');var faces=geometry.faces;var morphColors=json.morphColors[0].colors;for(var i=0,l=faces.length;i<l;i++){faces[i].color.fromArray(morphColors,i*3);}}}function parseAnimations(){var outputAnimations=[];// parse old style Bone/Hierarchy animations
var animations=[];if(json.animation!==undefined){animations.push(json.animation);}if(json.animations!==undefined){if(json.animations.length){animations=animations.concat(json.animations);}else{animations.push(json.animations);}}for(var i=0;i<animations.length;i++){var clip=AnimationClip.parseAnimation(animations[i],geometry.bones);if(clip)outputAnimations.push(clip);}// parse implicit morph animations
if(geometry.morphTargets){// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
var morphAnimationClips=AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets,10);outputAnimations=outputAnimations.concat(morphAnimationClips);}if(outputAnimations.length>0)geometry.animations=outputAnimations;}if(json.materials===undefined||json.materials.length===0){return{geometry:geometry};}else{var materials=Loader.prototype.initMaterials(json.materials,texturePath,this.crossOrigin);return{geometry:geometry,materials:materials};}}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function ObjectLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.texturePath='';}(0,_assign2.default)(ObjectLoader.prototype,{load:function load(url,onLoad,onProgress,onError){if(this.texturePath===''){this.texturePath=url.substring(0,url.lastIndexOf('/')+1);}var scope=this;var loader=new FileLoader(scope.manager);loader.load(url,function(text){var json=null;try{json=JSON.parse(text);}catch(error){console.error('THREE:ObjectLoader: Can\'t parse '+url+'.',error.message);return;}var metadata=json.metadata;if(metadata===undefined||metadata.type===undefined||metadata.type.toLowerCase()==='geometry'){console.error('THREE.ObjectLoader: Can\'t load '+url+'. Use THREE.JSONLoader instead.');return;}scope.parse(json,onLoad);},onProgress,onError);},setTexturePath:function setTexturePath(value){this.texturePath=value;},setCrossOrigin:function setCrossOrigin(value){this.crossOrigin=value;},parse:function parse(json,onLoad){var geometries=this.parseGeometries(json.geometries);var images=this.parseImages(json.images,function(){if(onLoad!==undefined)onLoad(object);});var textures=this.parseTextures(json.textures,images);var materials=this.parseMaterials(json.materials,textures);var object=this.parseObject(json.object,geometries,materials);if(json.animations){object.animations=this.parseAnimations(json.animations);}if(json.images===undefined||json.images.length===0){if(onLoad!==undefined)onLoad(object);}return object;},parseGeometries:function parseGeometries(json){var geometries={};if(json!==undefined){var geometryLoader=new JSONLoader();var bufferGeometryLoader=new BufferGeometryLoader();for(var i=0,l=json.length;i<l;i++){var geometry;var data=json[i];switch(data.type){case'PlaneGeometry':case'PlaneBufferGeometry':geometry=new Geometries[data.type](data.width,data.height,data.widthSegments,data.heightSegments);break;case'BoxGeometry':case'BoxBufferGeometry':case'CubeGeometry':// backwards compatible
geometry=new Geometries[data.type](data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);break;case'CircleGeometry':case'CircleBufferGeometry':geometry=new Geometries[data.type](data.radius,data.segments,data.thetaStart,data.thetaLength);break;case'CylinderGeometry':case'CylinderBufferGeometry':geometry=new Geometries[data.type](data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);break;case'ConeGeometry':case'ConeBufferGeometry':geometry=new Geometries[data.type](data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);break;case'SphereGeometry':case'SphereBufferGeometry':geometry=new Geometries[data.type](data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength);break;case'DodecahedronGeometry':case'IcosahedronGeometry':case'OctahedronGeometry':case'TetrahedronGeometry':geometry=new Geometries[data.type](data.radius,data.detail);break;case'RingGeometry':case'RingBufferGeometry':geometry=new Geometries[data.type](data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength);break;case'TorusGeometry':case'TorusBufferGeometry':geometry=new Geometries[data.type](data.radius,data.tube,data.radialSegments,data.tubularSegments,data.arc);break;case'TorusKnotGeometry':case'TorusKnotBufferGeometry':geometry=new Geometries[data.type](data.radius,data.tube,data.tubularSegments,data.radialSegments,data.p,data.q);break;case'LatheGeometry':case'LatheBufferGeometry':geometry=new Geometries[data.type](data.points,data.segments,data.phiStart,data.phiLength);break;case'BufferGeometry':geometry=bufferGeometryLoader.parse(data);break;case'Geometry':geometry=geometryLoader.parse(data.data,this.texturePath).geometry;break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+data.type+'"');continue;}geometry.uuid=data.uuid;if(data.name!==undefined)geometry.name=data.name;geometries[data.uuid]=geometry;}}return geometries;},parseMaterials:function parseMaterials(json,textures){var materials={};if(json!==undefined){var loader=new MaterialLoader();loader.setTextures(textures);for(var i=0,l=json.length;i<l;i++){var material=loader.parse(json[i]);materials[material.uuid]=material;}}return materials;},parseAnimations:function parseAnimations(json){var animations=[];for(var i=0;i<json.length;i++){var clip=AnimationClip.parse(json[i]);animations.push(clip);}return animations;},parseImages:function parseImages(json,onLoad){var scope=this;var images={};function loadImage(url){scope.manager.itemStart(url);return loader.load(url,function(){scope.manager.itemEnd(url);},undefined,function(){scope.manager.itemError(url);});}if(json!==undefined&&json.length>0){var manager=new LoadingManager(onLoad);var loader=new ImageLoader(manager);loader.setCrossOrigin(this.crossOrigin);for(var i=0,l=json.length;i<l;i++){var image=json[i];var path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url)?image.url:scope.texturePath+image.url;images[image.uuid]=loadImage(path);}}return images;},parseTextures:function parseTextures(json,images){var TextureMapping={UVMapping:UVMapping,CubeReflectionMapping:CubeReflectionMapping,CubeRefractionMapping:CubeRefractionMapping,EquirectangularReflectionMapping:EquirectangularReflectionMapping,EquirectangularRefractionMapping:EquirectangularRefractionMapping,SphericalReflectionMapping:SphericalReflectionMapping,CubeUVReflectionMapping:CubeUVReflectionMapping,CubeUVRefractionMapping:CubeUVRefractionMapping};var TextureWrapping={RepeatWrapping:RepeatWrapping,ClampToEdgeWrapping:ClampToEdgeWrapping,MirroredRepeatWrapping:MirroredRepeatWrapping};var TextureFilter={NearestFilter:NearestFilter,NearestMipMapNearestFilter:NearestMipMapNearestFilter,NearestMipMapLinearFilter:NearestMipMapLinearFilter,LinearFilter:LinearFilter,LinearMipMapNearestFilter:LinearMipMapNearestFilter,LinearMipMapLinearFilter:LinearMipMapLinearFilter};function parseConstant(value,type){if(typeof value==='number')return value;console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',value);return type[value];}var textures={};if(json!==undefined){for(var i=0,l=json.length;i<l;i++){var data=json[i];if(data.image===undefined){console.warn('THREE.ObjectLoader: No "image" specified for',data.uuid);}if(images[data.image]===undefined){console.warn('THREE.ObjectLoader: Undefined image',data.image);}var texture=new Texture(images[data.image]);texture.needsUpdate=true;texture.uuid=data.uuid;if(data.name!==undefined)texture.name=data.name;if(data.mapping!==undefined)texture.mapping=parseConstant(data.mapping,TextureMapping);if(data.offset!==undefined)texture.offset.fromArray(data.offset);if(data.repeat!==undefined)texture.repeat.fromArray(data.repeat);if(data.wrap!==undefined){texture.wrapS=parseConstant(data.wrap[0],TextureWrapping);texture.wrapT=parseConstant(data.wrap[1],TextureWrapping);}if(data.minFilter!==undefined)texture.minFilter=parseConstant(data.minFilter,TextureFilter);if(data.magFilter!==undefined)texture.magFilter=parseConstant(data.magFilter,TextureFilter);if(data.anisotropy!==undefined)texture.anisotropy=data.anisotropy;if(data.flipY!==undefined)texture.flipY=data.flipY;textures[data.uuid]=texture;}}return textures;},parseObject:function(){var matrix=new Matrix4();return function parseObject(data,geometries,materials){var object;function getGeometry(name){if(geometries[name]===undefined){console.warn('THREE.ObjectLoader: Undefined geometry',name);}return geometries[name];}function getMaterial(name){if(name===undefined)return undefined;if(materials[name]===undefined){console.warn('THREE.ObjectLoader: Undefined material',name);}return materials[name];}switch(data.type){case'Scene':object=new Scene();if(data.background!==undefined){if((0,_isInteger2.default)(data.background)){object.background=new Color(data.background);}}if(data.fog!==undefined){if(data.fog.type==='Fog'){object.fog=new Fog(data.fog.color,data.fog.near,data.fog.far);}else if(data.fog.type==='FogExp2'){object.fog=new FogExp2(data.fog.color,data.fog.density);}}break;case'PerspectiveCamera':object=new PerspectiveCamera(data.fov,data.aspect,data.near,data.far);if(data.focus!==undefined)object.focus=data.focus;if(data.zoom!==undefined)object.zoom=data.zoom;if(data.filmGauge!==undefined)object.filmGauge=data.filmGauge;if(data.filmOffset!==undefined)object.filmOffset=data.filmOffset;if(data.view!==undefined)object.view=(0,_assign2.default)({},data.view);break;case'OrthographicCamera':object=new OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far);break;case'AmbientLight':object=new AmbientLight(data.color,data.intensity);break;case'DirectionalLight':object=new DirectionalLight(data.color,data.intensity);break;case'PointLight':object=new PointLight(data.color,data.intensity,data.distance,data.decay);break;case'SpotLight':object=new SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);break;case'HemisphereLight':object=new HemisphereLight(data.color,data.groundColor,data.intensity);break;case'Mesh':var geometry=getGeometry(data.geometry);var material=getMaterial(data.material);if(geometry.bones&&geometry.bones.length>0){object=new SkinnedMesh(geometry,material);}else{object=new Mesh(geometry,material);}break;case'LOD':object=new LOD();break;case'Line':object=new Line(getGeometry(data.geometry),getMaterial(data.material),data.mode);break;case'LineSegments':object=new LineSegments(getGeometry(data.geometry),getMaterial(data.material));break;case'PointCloud':case'Points':object=new Points(getGeometry(data.geometry),getMaterial(data.material));break;case'Sprite':object=new Sprite(getMaterial(data.material));break;case'Group':object=new Group();break;case'SkinnedMesh':console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.');default:object=new Object3D();}object.uuid=data.uuid;if(data.name!==undefined)object.name=data.name;if(data.matrix!==undefined){matrix.fromArray(data.matrix);matrix.decompose(object.position,object.quaternion,object.scale);}else{if(data.position!==undefined)object.position.fromArray(data.position);if(data.rotation!==undefined)object.rotation.fromArray(data.rotation);if(data.quaternion!==undefined)object.quaternion.fromArray(data.quaternion);if(data.scale!==undefined)object.scale.fromArray(data.scale);}if(data.castShadow!==undefined)object.castShadow=data.castShadow;if(data.receiveShadow!==undefined)object.receiveShadow=data.receiveShadow;if(data.shadow){if(data.shadow.bias!==undefined)object.shadow.bias=data.shadow.bias;if(data.shadow.radius!==undefined)object.shadow.radius=data.shadow.radius;if(data.shadow.mapSize!==undefined)object.shadow.mapSize.fromArray(data.shadow.mapSize);if(data.shadow.camera!==undefined)object.shadow.camera=this.parseObject(data.shadow.camera);}if(data.visible!==undefined)object.visible=data.visible;if(data.userData!==undefined)object.userData=data.userData;if(data.children!==undefined){for(var child in data.children){object.add(this.parseObject(data.children[child],geometries,materials));}}if(data.type==='LOD'){var levels=data.levels;for(var l=0;l<levels.length;l++){var level=levels[l];var child=object.getObjectByProperty('uuid',level.object);if(child!==undefined){object.addLevel(child,level.distance);}}}return object;};}()});/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bzier_curve
	 */function CatmullRom(t,p0,p1,p2,p3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;var t2=t*t;var t3=t*t2;return(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;}//
function QuadraticBezierP0(t,p){var k=1-t;return k*k*p;}function QuadraticBezierP1(t,p){return 2*(1-t)*t*p;}function QuadraticBezierP2(t,p){return t*t*p;}function QuadraticBezier(t,p0,p1,p2){return QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+QuadraticBezierP2(t,p2);}//
function CubicBezierP0(t,p){var k=1-t;return k*k*k*p;}function CubicBezierP1(t,p){var k=1-t;return 3*k*k*t*p;}function CubicBezierP2(t,p){return 3*(1-t)*t*t*p;}function CubicBezierP3(t,p){return t*t*t*p;}function CubicBezier(t,p0,p1,p2,p3){return CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+CubicBezierP3(t,p3);}/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTangentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.CatmullRomCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **//**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/function Curve(){}Curve.prototype={constructor:Curve,// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]
getPoint:function getPoint(t){console.warn("THREE.Curve: Warning, getPoint() not implemented!");return null;},// Get point at relative position in curve according to arc length
// - u [0 .. 1]
getPointAt:function getPointAt(u){var t=this.getUtoTmapping(u);return this.getPoint(t);},// Get sequence of points using getPoint( t )
getPoints:function getPoints(divisions){if(!divisions)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPoint(d/divisions));}return points;},// Get sequence of points using getPointAt( u )
getSpacedPoints:function getSpacedPoints(divisions){if(!divisions)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPointAt(d/divisions));}return points;},// Get total curve arc length
getLength:function getLength(){var lengths=this.getLengths();return lengths[lengths.length-1];},// Get list of cumulative segment lengths
getLengths:function getLengths(divisions){if(!divisions)divisions=this.__arcLengthDivisions?this.__arcLengthDivisions:200;if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){//console.log( "cached", this.cacheArcLengths );
return this.cacheArcLengths;}this.needsUpdate=false;var cache=[];var current,last=this.getPoint(0);var p,sum=0;cache.push(0);for(p=1;p<=divisions;p++){current=this.getPoint(p/divisions);sum+=current.distanceTo(last);cache.push(sum);last=current;}this.cacheArcLengths=cache;return cache;// { sums: cache, sum:sum }; Sum is in the last element.
},updateArcLengths:function updateArcLengths(){this.needsUpdate=true;this.getLengths();},// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
getUtoTmapping:function getUtoTmapping(u,distance){var arcLengths=this.getLengths();var i=0,il=arcLengths.length;var targetArcLength;// The targeted u distance value to get
if(distance){targetArcLength=distance;}else{targetArcLength=u*arcLengths[il-1];}//var time = Date.now();
// binary search for the index with largest value smaller than target u distance
var low=0,high=il-1,comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
comparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else{high=i;break;// DONE
}}i=high;//console.log('b' , i, low, high, Date.now()- time);
if(arcLengths[i]===targetArcLength){var t=i/(il-1);return t;}// we could get finer grain at lengths, or use simple interpolation between two points
var lengthBefore=arcLengths[i];var lengthAfter=arcLengths[i+1];var segmentLength=lengthAfter-lengthBefore;// determine where we are between the 'before' and 'after' points
var segmentFraction=(targetArcLength-lengthBefore)/segmentLength;// add that fractional amount to t
var t=(i+segmentFraction)/(il-1);return t;},// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation
getTangent:function getTangent(t){var delta=0.0001;var t1=t-delta;var t2=t+delta;// Capping in case of danger
if(t1<0)t1=0;if(t2>1)t2=1;var pt1=this.getPoint(t1);var pt2=this.getPoint(t2);var vec=pt2.clone().sub(pt1);return vec.normalize();},getTangentAt:function getTangentAt(u){var t=this.getUtoTmapping(u);return this.getTangent(t);},computeFrenetFrames:function computeFrenetFrames(segments,closed){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
var normal=new Vector3();var tangents=[];var normals=[];var binormals=[];var vec=new Vector3();var mat=new Matrix4();var i,u,theta;// compute the tangent vectors for each segment on the curve
for(i=0;i<=segments;i++){u=i/segments;tangents[i]=this.getTangentAt(u);tangents[i].normalize();}// select an initial normal vector perpendicular to the first tangent vector,
// and in the direction of the minimum tangent xyz component
normals[0]=new Vector3();binormals[0]=new Vector3();var min=Number.MAX_VALUE;var tx=Math.abs(tangents[0].x);var ty=Math.abs(tangents[0].y);var tz=Math.abs(tangents[0].z);if(tx<=min){min=tx;normal.set(1,0,0);}if(ty<=min){min=ty;normal.set(0,1,0);}if(tz<=min){normal.set(0,0,1);}vec.crossVectors(tangents[0],normal).normalize();normals[0].crossVectors(tangents[0],vec);binormals[0].crossVectors(tangents[0],normals[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
for(i=1;i<=segments;i++){normals[i]=normals[i-1].clone();binormals[i]=binormals[i-1].clone();vec.crossVectors(tangents[i-1],tangents[i]);if(vec.length()>_epsilon2.default){vec.normalize();theta=Math.acos(_Math.clamp(tangents[i-1].dot(tangents[i]),-1,1));// clamp for floating pt errors
normals[i].applyMatrix4(mat.makeRotationAxis(vec,theta));}binormals[i].crossVectors(tangents[i],normals[i]);}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
if(closed===true){theta=Math.acos(_Math.clamp(normals[0].dot(normals[segments]),-1,1));theta/=segments;if(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){theta=-theta;}for(i=1;i<=segments;i++){// twist a little...
normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i],theta*i));binormals[i].crossVectors(tangents[i],normals[i]);}}return{tangents:tangents,normals:normals,binormals:binormals};}};function LineCurve(v1,v2){this.v1=v1;this.v2=v2;}LineCurve.prototype=(0,_create2.default)(Curve.prototype);LineCurve.prototype.constructor=LineCurve;LineCurve.prototype.isLineCurve=true;LineCurve.prototype.getPoint=function(t){if(t===1){return this.v2.clone();}var point=this.v2.clone().sub(this.v1);point.multiplyScalar(t).add(this.v1);return point;};// Line curve is linear, so we can overwrite default getPointAt
LineCurve.prototype.getPointAt=function(u){return this.getPoint(u);};LineCurve.prototype.getTangent=function(t){var tangent=this.v2.clone().sub(this.v1);return tangent.normalize();};/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **//**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/function CurvePath(){this.curves=[];this.autoClose=false;// Automatically closes the path
}CurvePath.prototype=(0,_assign2.default)((0,_create2.default)(Curve.prototype),{constructor:CurvePath,add:function add(curve){this.curves.push(curve);},closePath:function closePath(){// Add a line curve if start and end of lines are not connected
var startPoint=this.curves[0].getPoint(0);var endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){this.curves.push(new LineCurve(endPoint,startPoint));}},// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:
// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')
getPoint:function getPoint(t){var d=t*this.getLength();var curveLengths=this.getCurveLengths();var i=0;// To think about boundaries points.
while(i<curveLengths.length){if(curveLengths[i]>=d){var diff=curveLengths[i]-d;var curve=this.curves[i];var segmentLength=curve.getLength();var u=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u);}i++;}return null;// loop where sum != 0, sum > d , sum+1 <d
},// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength
getLength:function getLength(){var lens=this.getCurveLengths();return lens[lens.length-1];},// cacheLengths must be recalculated.
updateArcLengths:function updateArcLengths(){this.needsUpdate=true;this.cacheLengths=null;this.getLengths();},// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.
getCurveLengths:function getCurveLengths(){// We use cache values if curves and cache array are same length
if(this.cacheLengths&&this.cacheLengths.length===this.curves.length){return this.cacheLengths;}// Get length of sub-curve
// Push sums into cached array
var lengths=[],sums=0;for(var i=0,l=this.curves.length;i<l;i++){sums+=this.curves[i].getLength();lengths.push(sums);}this.cacheLengths=lengths;return lengths;},getSpacedPoints:function getSpacedPoints(divisions){if(!divisions)divisions=40;var points=[];for(var i=0;i<=divisions;i++){points.push(this.getPoint(i/divisions));}if(this.autoClose){points.push(points[0]);}return points;},getPoints:function getPoints(divisions){divisions=divisions||12;var points=[],last;for(var i=0,curves=this.curves;i<curves.length;i++){var curve=curves[i];var resolution=curve&&curve.isEllipseCurve?divisions*2:curve&&curve.isLineCurve?1:curve&&curve.isSplineCurve?divisions*curve.points.length:divisions;var pts=curve.getPoints(resolution);for(var j=0;j<pts.length;j++){var point=pts[j];if(last&&last.equals(point))continue;// ensures no consecutive points are duplicates
points.push(point);last=point;}}if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){points.push(points[0]);}return points;},/**************************************************************
		 *	Create Geometries Helpers
		 **************************************************************//// Generate geometry from path points (for Line or Points objects)
createPointsGeometry:function createPointsGeometry(divisions){var pts=this.getPoints(divisions);return this.createGeometry(pts);},// Generate geometry from equidistant sampling along the path
createSpacedPointsGeometry:function createSpacedPointsGeometry(divisions){var pts=this.getSpacedPoints(divisions);return this.createGeometry(pts);},createGeometry:function createGeometry(points){var geometry=new Geometry();for(var i=0,l=points.length;i<l;i++){var point=points[i];geometry.vertices.push(new Vector3(point.x,point.y,point.z||0));}return geometry;}});function EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){this.aX=aX;this.aY=aY;this.xRadius=xRadius;this.yRadius=yRadius;this.aStartAngle=aStartAngle;this.aEndAngle=aEndAngle;this.aClockwise=aClockwise;this.aRotation=aRotation||0;}EllipseCurve.prototype=(0,_create2.default)(Curve.prototype);EllipseCurve.prototype.constructor=EllipseCurve;EllipseCurve.prototype.isEllipseCurve=true;EllipseCurve.prototype.getPoint=function(t){var twoPi=Math.PI*2;var deltaAngle=this.aEndAngle-this.aStartAngle;var samePoints=Math.abs(deltaAngle)<_epsilon2.default;// ensures that deltaAngle is 0 .. 2 PI
while(deltaAngle<0){deltaAngle+=twoPi;}while(deltaAngle>twoPi){deltaAngle-=twoPi;}if(deltaAngle<_epsilon2.default){if(samePoints){deltaAngle=0;}else{deltaAngle=twoPi;}}if(this.aClockwise===true&&!samePoints){if(deltaAngle===twoPi){deltaAngle=-twoPi;}else{deltaAngle=deltaAngle-twoPi;}}var angle=this.aStartAngle+t*deltaAngle;var x=this.aX+this.xRadius*Math.cos(angle);var y=this.aY+this.yRadius*Math.sin(angle);if(this.aRotation!==0){var cos=Math.cos(this.aRotation);var sin=Math.sin(this.aRotation);var tx=x-this.aX;var ty=y-this.aY;// Rotate the point about the center of the ellipse.
x=tx*cos-ty*sin+this.aX;y=tx*sin+ty*cos+this.aY;}return new Vector2(x,y);};function SplineCurve(points/* array of Vector2 */){this.points=points===undefined?[]:points;}SplineCurve.prototype=(0,_create2.default)(Curve.prototype);SplineCurve.prototype.constructor=SplineCurve;SplineCurve.prototype.isSplineCurve=true;SplineCurve.prototype.getPoint=function(t){var points=this.points;var point=(points.length-1)*t;var intPoint=Math.floor(point);var weight=point-intPoint;var point0=points[intPoint===0?intPoint:intPoint-1];var point1=points[intPoint];var point2=points[intPoint>points.length-2?points.length-1:intPoint+1];var point3=points[intPoint>points.length-3?points.length-1:intPoint+2];return new Vector2(CatmullRom(weight,point0.x,point1.x,point2.x,point3.x),CatmullRom(weight,point0.y,point1.y,point2.y,point3.y));};function CubicBezierCurve(v0,v1,v2,v3){this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}CubicBezierCurve.prototype=(0,_create2.default)(Curve.prototype);CubicBezierCurve.prototype.constructor=CubicBezierCurve;CubicBezierCurve.prototype.getPoint=function(t){var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;return new Vector2(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y));};function QuadraticBezierCurve(v0,v1,v2){this.v0=v0;this.v1=v1;this.v2=v2;}QuadraticBezierCurve.prototype=(0,_create2.default)(Curve.prototype);QuadraticBezierCurve.prototype.constructor=QuadraticBezierCurve;QuadraticBezierCurve.prototype.getPoint=function(t){var v0=this.v0,v1=this.v1,v2=this.v2;return new Vector2(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y));};var PathPrototype=(0,_assign2.default)((0,_create2.default)(CurvePath.prototype),{fromPoints:function fromPoints(vectors){this.moveTo(vectors[0].x,vectors[0].y);for(var i=1,l=vectors.length;i<l;i++){this.lineTo(vectors[i].x,vectors[i].y);}},moveTo:function moveTo(x,y){this.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?
},lineTo:function lineTo(x,y){var curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));this.curves.push(curve);this.currentPoint.set(x,y);},quadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){var curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);},bezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){var curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);},splineThru:function splineThru(pts/*Array of Vector*/){var npts=[this.currentPoint.clone()].concat(pts);var curve=new SplineCurve(npts);this.curves.push(curve);this.currentPoint.copy(pts[pts.length-1]);},arc:function arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise);},absarc:function absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);},ellipse:function ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);},absellipse:function absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){// if a previous curve is present, attempt to join
var firstPoint=curve.getPoint(0);if(!firstPoint.equals(this.currentPoint)){this.lineTo(firstPoint.x,firstPoint.y);}}this.curves.push(curve);var lastPoint=curve.getPoint(1);this.currentPoint.copy(lastPoint);}});/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 **/function Path(points){CurvePath.call(this);this.currentPoint=new Vector2();if(points){this.fromPoints(points);}}Path.prototype=PathPrototype;PathPrototype.constructor=Path;/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.
function Shape(){Path.apply(this,arguments);this.holes=[];}Shape.prototype=(0,_assign2.default)((0,_create2.default)(PathPrototype),{constructor:Shape,getPointsHoles:function getPointsHoles(divisions){var holesPts=[];for(var i=0,l=this.holes.length;i<l;i++){holesPts[i]=this.holes[i].getPoints(divisions);}return holesPts;},// Get points of shape and holes (keypoints based on segments parameter)
extractAllPoints:function extractAllPoints(divisions){return{shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)};},extractPoints:function extractPoints(divisions){return this.extractAllPoints(divisions);}});/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 **/function ShapePath(){this.subPaths=[];this.currentPath=null;}ShapePath.prototype={moveTo:function moveTo(x,y){this.currentPath=new Path();this.subPaths.push(this.currentPath);this.currentPath.moveTo(x,y);},lineTo:function lineTo(x,y){this.currentPath.lineTo(x,y);},quadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){this.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY);},bezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){this.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY);},splineThru:function splineThru(pts){this.currentPath.splineThru(pts);},toShapes:function toShapes(isCCW,noHoles){function toShapesNoHoles(inSubpaths){var shapes=[];for(var i=0,l=inSubpaths.length;i<l;i++){var tmpPath=inSubpaths[i];var tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);}return shapes;}function isPointInsidePolygon(inPt,inPolygon){var polyLen=inPolygon.length;// inPt on polygon contour => immediate success    or
// toggling of inside/outside at every single! intersection point of an edge
//  with the horizontal line through inPt, left of inPt
//  not counting lowerY endpoints of edges and whole edges on that line
var inside=false;for(var p=polyLen-1,q=0;q<polyLen;p=q++){var edgeLowPt=inPolygon[p];var edgeHighPt=inPolygon[q];var edgeDx=edgeHighPt.x-edgeLowPt.x;var edgeDy=edgeHighPt.y-edgeLowPt.y;if(Math.abs(edgeDy)>_epsilon2.default){// not parallel
if(edgeDy<0){edgeLowPt=inPolygon[q];edgeDx=-edgeDx;edgeHighPt=inPolygon[p];edgeDy=-edgeDy;}if(inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y)continue;if(inPt.y===edgeLowPt.y){if(inPt.x===edgeLowPt.x)return true;// inPt is on contour ?
// continue;				// no intersection or edgeLowPt => doesn't count !!!
}else{var perpEdge=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);if(perpEdge===0)return true;// inPt is on contour ?
if(perpEdge<0)continue;inside=!inside;// true intersection left of inPt
}}else{// parallel or collinear
if(inPt.y!==edgeLowPt.y)continue;// parallel
// edge lies on the same horizontal line as inPt
if(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||edgeLowPt.x<=inPt.x&&inPt.x<=edgeHighPt.x)return true;// inPt: Point on contour !
// continue;
}}return inside;}var isClockWise=ShapeUtils.isClockWise;var subPaths=this.subPaths;if(subPaths.length===0)return[];if(noHoles===true)return toShapesNoHoles(subPaths);var solid,tmpPath,tmpShape,shapes=[];if(subPaths.length===1){tmpPath=subPaths[0];tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);return shapes;}var holesFirst=!isClockWise(subPaths[0].getPoints());holesFirst=isCCW?!holesFirst:holesFirst;// console.log("Holes first", holesFirst);
var betterShapeHoles=[];var newShapes=[];var newShapeHoles=[];var mainIdx=0;var tmpPoints;newShapes[mainIdx]=undefined;newShapeHoles[mainIdx]=[];for(var i=0,l=subPaths.length;i<l;i++){tmpPath=subPaths[i];tmpPoints=tmpPath.getPoints();solid=isClockWise(tmpPoints);solid=isCCW?!solid:solid;if(solid){if(!holesFirst&&newShapes[mainIdx])mainIdx++;newShapes[mainIdx]={s:new Shape(),p:tmpPoints};newShapes[mainIdx].s.curves=tmpPath.curves;if(holesFirst)mainIdx++;newShapeHoles[mainIdx]=[];//console.log('cw', i);
}else{newShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]});//console.log('ccw', i);
}}// only Holes? -> probably all Shapes with wrong orientation
if(!newShapes[0])return toShapesNoHoles(subPaths);if(newShapes.length>1){var ambiguous=false;var toChange=[];for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){betterShapeHoles[sIdx]=[];}for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){var sho=newShapeHoles[sIdx];for(var hIdx=0;hIdx<sho.length;hIdx++){var ho=sho[hIdx];var hole_unassigned=true;for(var s2Idx=0;s2Idx<newShapes.length;s2Idx++){if(isPointInsidePolygon(ho.p,newShapes[s2Idx].p)){if(sIdx!==s2Idx)toChange.push({froms:sIdx,tos:s2Idx,hole:hIdx});if(hole_unassigned){hole_unassigned=false;betterShapeHoles[s2Idx].push(ho);}else{ambiguous=true;}}}if(hole_unassigned){betterShapeHoles[sIdx].push(ho);}}}// console.log("ambiguous: ", ambiguous);
if(toChange.length>0){// console.log("to change: ", toChange);
if(!ambiguous)newShapeHoles=betterShapeHoles;}}var tmpHoles;for(var i=0,il=newShapes.length;i<il;i++){tmpShape=newShapes[i].s;shapes.push(tmpShape);tmpHoles=newShapeHoles[i];for(var j=0,jl=tmpHoles.length;j<jl;j++){tmpShape.holes.push(tmpHoles[j].h);}}//console.log("shape", shapes);
return shapes;}};/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */function Font(data){this.data=data;}(0,_assign2.default)(Font.prototype,{isFont:true,generateShapes:function generateShapes(text,size,divisions){function createPaths(text){var chars=String(text).split('');var scale=size/data.resolution;var offset=0;var paths=[];for(var i=0;i<chars.length;i++){var ret=createPath(chars[i],scale,offset);offset+=ret.offset;paths.push(ret.path);}return paths;}function createPath(c,scale,offset){var glyph=data.glyphs[c]||data.glyphs['?'];if(!glyph)return;var path=new ShapePath();var pts=[];var x,y,cpx,cpy,cpx0,cpy0,cpx1,cpy1,cpx2,cpy2,laste;if(glyph.o){var outline=glyph._cachedOutline||(glyph._cachedOutline=glyph.o.split(' '));for(var i=0,l=outline.length;i<l;){var action=outline[i++];switch(action){case'm':// moveTo
x=outline[i++]*scale+offset;y=outline[i++]*scale;path.moveTo(x,y);break;case'l':// lineTo
x=outline[i++]*scale+offset;y=outline[i++]*scale;path.lineTo(x,y);break;case'q':// quadraticCurveTo
cpx=outline[i++]*scale+offset;cpy=outline[i++]*scale;cpx1=outline[i++]*scale+offset;cpy1=outline[i++]*scale;path.quadraticCurveTo(cpx1,cpy1,cpx,cpy);laste=pts[pts.length-1];if(laste){cpx0=laste.x;cpy0=laste.y;for(var i2=1;i2<=divisions;i2++){var t=i2/divisions;QuadraticBezier(t,cpx0,cpx1,cpx);QuadraticBezier(t,cpy0,cpy1,cpy);}}break;case'b':// bezierCurveTo
cpx=outline[i++]*scale+offset;cpy=outline[i++]*scale;cpx1=outline[i++]*scale+offset;cpy1=outline[i++]*scale;cpx2=outline[i++]*scale+offset;cpy2=outline[i++]*scale;path.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,cpx,cpy);laste=pts[pts.length-1];if(laste){cpx0=laste.x;cpy0=laste.y;for(var i2=1;i2<=divisions;i2++){var t=i2/divisions;CubicBezier(t,cpx0,cpx1,cpx2,cpx);CubicBezier(t,cpy0,cpy1,cpy2,cpy);}}break;}}}return{offset:glyph.ha*scale,path:path};}//
if(size===undefined)size=100;if(divisions===undefined)divisions=4;var data=this.data;var paths=createPaths(text);var shapes=[];for(var p=0,pl=paths.length;p<pl;p++){Array.prototype.push.apply(shapes,paths[p].toShapes());}return shapes;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function FontLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}(0,_assign2.default)(FontLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(this.manager);loader.load(url,function(text){var json;try{json=JSON.parse(text);}catch(e){console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');json=JSON.parse(text.substring(65,text.length-2));}var font=scope.parse(json);if(onLoad)onLoad(font);},onProgress,onError);},parse:function parse(json){return new Font(json);}});var context;var AudioContext={getContext:function getContext(){if(context===undefined){context=new(window.AudioContext||window.webkitAudioContext)();}return context;},setContext:function setContext(value){context=value;}};/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */function AudioLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}(0,_assign2.default)(AudioLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.load(url,function(buffer){var context=AudioContext.getContext();context.decodeAudioData(buffer,function(audioBuffer){onLoad(audioBuffer);});},onProgress,onError);}});/**
	 * @author abelnation / http://github.com/abelnation
	 */function RectAreaLight(color,intensity,width,height){Light.call(this,color,intensity);this.type='RectAreaLight';this.position.set(0,1,0);this.updateMatrix();this.width=width!==undefined?width:10;this.height=height!==undefined?height:10;// TODO (abelnation): distance/decay
// TODO (abelnation): update method for RectAreaLight to update transform to lookat target
// TODO (abelnation): shadows
// this.shadow = new THREE.RectAreaLightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );
}// TODO (abelnation): RectAreaLight update when light shape is changed
RectAreaLight.prototype=(0,_assign2.default)((0,_create2.default)(Light.prototype),{constructor:RectAreaLight,isRectAreaLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.width=source.width;this.height=source.height;// this.shadow = source.shadow.clone();
return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function StereoCamera(){this.type='StereoCamera';this.aspect=1;this.eyeSep=0.064;this.cameraL=new PerspectiveCamera();this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=false;this.cameraR=new PerspectiveCamera();this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=false;}(0,_assign2.default)(StereoCamera.prototype,{update:function(){var instance,focus,fov,aspect,near,far,zoom;var eyeRight=new Matrix4();var eyeLeft=new Matrix4();return function update(camera){var needsUpdate=instance!==this||focus!==camera.focus||fov!==camera.fov||aspect!==camera.aspect*this.aspect||near!==camera.near||far!==camera.far||zoom!==camera.zoom;if(needsUpdate){instance=this;focus=camera.focus;fov=camera.fov;aspect=camera.aspect*this.aspect;near=camera.near;far=camera.far;zoom=camera.zoom;// Off-axis stereoscopic effect based on
// http://paulbourke.net/stereographics/stereorender/
var projectionMatrix=camera.projectionMatrix.clone();var eyeSep=this.eyeSep/2;var eyeSepOnProjection=eyeSep*near/focus;var ymax=near*Math.tan(_Math.DEG2RAD*fov*0.5)/zoom;var xmin,xmax;// translate xOffset
eyeLeft.elements[12]=-eyeSep;eyeRight.elements[12]=eyeSep;// for left eye
xmin=-ymax*aspect+eyeSepOnProjection;xmax=ymax*aspect+eyeSepOnProjection;projectionMatrix.elements[0]=2*near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraL.projectionMatrix.copy(projectionMatrix);// for right eye
xmin=-ymax*aspect-eyeSepOnProjection;xmax=ymax*aspect-eyeSepOnProjection;projectionMatrix.elements[0]=2*near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraR.projectionMatrix.copy(projectionMatrix);}this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);};}()});/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */function CubeCamera(near,far,cubeResolution){Object3D.call(this);this.type='CubeCamera';var fov=90,aspect=1;var cameraPX=new PerspectiveCamera(fov,aspect,near,far);cameraPX.up.set(0,-1,0);cameraPX.lookAt(new Vector3(1,0,0));this.add(cameraPX);var cameraNX=new PerspectiveCamera(fov,aspect,near,far);cameraNX.up.set(0,-1,0);cameraNX.lookAt(new Vector3(-1,0,0));this.add(cameraNX);var cameraPY=new PerspectiveCamera(fov,aspect,near,far);cameraPY.up.set(0,0,1);cameraPY.lookAt(new Vector3(0,1,0));this.add(cameraPY);var cameraNY=new PerspectiveCamera(fov,aspect,near,far);cameraNY.up.set(0,0,-1);cameraNY.lookAt(new Vector3(0,-1,0));this.add(cameraNY);var cameraPZ=new PerspectiveCamera(fov,aspect,near,far);cameraPZ.up.set(0,-1,0);cameraPZ.lookAt(new Vector3(0,0,1));this.add(cameraPZ);var cameraNZ=new PerspectiveCamera(fov,aspect,near,far);cameraNZ.up.set(0,-1,0);cameraNZ.lookAt(new Vector3(0,0,-1));this.add(cameraNZ);var options={format:RGBFormat,magFilter:LinearFilter,minFilter:LinearFilter,name:"cubeCamera"};this.renderTarget=new WebGLRenderTargetCube(cubeResolution,cubeResolution,options);this.updateCubeMap=function(renderer,scene){if(this.parent===null)this.updateMatrixWorld();var renderTarget=this.renderTarget;var generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=false;renderTarget.activeCubeFace=0;renderer.render(scene,cameraPX,renderTarget);renderTarget.activeCubeFace=1;renderer.render(scene,cameraNX,renderTarget);renderTarget.activeCubeFace=2;renderer.render(scene,cameraPY,renderTarget);renderTarget.activeCubeFace=3;renderer.render(scene,cameraNY,renderTarget);renderTarget.activeCubeFace=4;renderer.render(scene,cameraPZ,renderTarget);renderTarget.texture.generateMipmaps=generateMipmaps;renderTarget.activeCubeFace=5;renderer.render(scene,cameraNZ,renderTarget);renderer.setRenderTarget(null);};}CubeCamera.prototype=(0,_create2.default)(Object3D.prototype);CubeCamera.prototype.constructor=CubeCamera;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function AudioListener(){Object3D.call(this);this.type='AudioListener';this.context=AudioContext.getContext();this.gain=this.context.createGain();this.gain.connect(this.context.destination);this.filter=null;}AudioListener.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:AudioListener,getInput:function getInput(){return this.gain;},removeFilter:function removeFilter(){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);this.gain.connect(this.context.destination);this.filter=null;}},getFilter:function getFilter(){return this.filter;},setFilter:function setFilter(value){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);}else{this.gain.disconnect(this.context.destination);}this.filter=value;this.gain.connect(this.filter);this.filter.connect(this.context.destination);},getMasterVolume:function getMasterVolume(){return this.gain.gain.value;},setMasterVolume:function setMasterVolume(value){this.gain.gain.value=value;},updateMatrixWorld:function(){var position=new Vector3();var quaternion=new Quaternion();var scale=new Vector3();var orientation=new Vector3();return function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);var listener=this.context.listener;var up=this.up;this.matrixWorld.decompose(position,quaternion,scale);orientation.set(0,0,-1).applyQuaternion(quaternion);if(listener.positionX){listener.positionX.setValueAtTime(position.x,this.context.currentTime);listener.positionY.setValueAtTime(position.y,this.context.currentTime);listener.positionZ.setValueAtTime(position.z,this.context.currentTime);listener.forwardX.setValueAtTime(orientation.x,this.context.currentTime);listener.forwardY.setValueAtTime(orientation.y,this.context.currentTime);listener.forwardZ.setValueAtTime(orientation.z,this.context.currentTime);listener.upX.setValueAtTime(up.x,this.context.currentTime);listener.upY.setValueAtTime(up.y,this.context.currentTime);listener.upZ.setValueAtTime(up.z,this.context.currentTime);}else{listener.setPosition(position.x,position.y,position.z);listener.setOrientation(orientation.x,orientation.y,orientation.z,up.x,up.y,up.z);}};}()});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */function Audio(listener){Object3D.call(this);this.type='Audio';this.context=listener.context;this.gain=this.context.createGain();this.gain.connect(listener.getInput());this.autoplay=false;this.buffer=null;this.loop=false;this.startTime=0;this.playbackRate=1;this.isPlaying=false;this.hasPlaybackControl=true;this.sourceType='empty';this.filters=[];}Audio.prototype=(0,_assign2.default)((0,_create2.default)(Object3D.prototype),{constructor:Audio,getOutput:function getOutput(){return this.gain;},setNodeSource:function setNodeSource(audioNode){this.hasPlaybackControl=false;this.sourceType='audioNode';this.source=audioNode;this.connect();return this;},setBuffer:function setBuffer(audioBuffer){this.buffer=audioBuffer;this.sourceType='buffer';if(this.autoplay)this.play();return this;},play:function play(){if(this.isPlaying===true){console.warn('THREE.Audio: Audio is already playing.');return;}if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}var source=this.context.createBufferSource();source.buffer=this.buffer;source.loop=this.loop;source.onended=this.onEnded.bind(this);source.playbackRate.setValueAtTime(this.playbackRate,this.startTime);source.start(0,this.startTime);this.isPlaying=true;this.source=source;return this.connect();},pause:function pause(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.source.stop();this.startTime=this.context.currentTime;this.isPlaying=false;return this;},stop:function stop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.source.stop();this.startTime=0;this.isPlaying=false;return this;},connect:function connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var i=1,l=this.filters.length;i<l;i++){this.filters[i-1].connect(this.filters[i]);}this.filters[this.filters.length-1].connect(this.getOutput());}else{this.source.connect(this.getOutput());}return this;},disconnect:function disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var i=1,l=this.filters.length;i<l;i++){this.filters[i-1].disconnect(this.filters[i]);}this.filters[this.filters.length-1].disconnect(this.getOutput());}else{this.source.disconnect(this.getOutput());}return this;},getFilters:function getFilters(){return this.filters;},setFilters:function setFilters(value){if(!value)value=[];if(this.isPlaying===true){this.disconnect();this.filters=value;this.connect();}else{this.filters=value;}return this;},getFilter:function getFilter(){return this.getFilters()[0];},setFilter:function setFilter(filter){return this.setFilters(filter?[filter]:[]);},setPlaybackRate:function setPlaybackRate(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.playbackRate=value;if(this.isPlaying===true){this.source.playbackRate.setValueAtTime(this.playbackRate,this.context.currentTime);}return this;},getPlaybackRate:function getPlaybackRate(){return this.playbackRate;},onEnded:function onEnded(){this.isPlaying=false;},getLoop:function getLoop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return false;}return this.loop;},setLoop:function setLoop(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.loop=value;if(this.isPlaying===true){this.source.loop=this.loop;}return this;},getVolume:function getVolume(){return this.gain.gain.value;},setVolume:function setVolume(value){this.gain.gain.value=value;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function PositionalAudio(listener){Audio.call(this,listener);this.panner=this.context.createPanner();this.panner.connect(this.gain);}PositionalAudio.prototype=(0,_assign2.default)((0,_create2.default)(Audio.prototype),{constructor:PositionalAudio,getOutput:function getOutput(){return this.panner;},getRefDistance:function getRefDistance(){return this.panner.refDistance;},setRefDistance:function setRefDistance(value){this.panner.refDistance=value;},getRolloffFactor:function getRolloffFactor(){return this.panner.rolloffFactor;},setRolloffFactor:function setRolloffFactor(value){this.panner.rolloffFactor=value;},getDistanceModel:function getDistanceModel(){return this.panner.distanceModel;},setDistanceModel:function setDistanceModel(value){this.panner.distanceModel=value;},getMaxDistance:function getMaxDistance(){return this.panner.maxDistance;},setMaxDistance:function setMaxDistance(value){this.panner.maxDistance=value;},updateMatrixWorld:function(){var position=new Vector3();return function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);position.setFromMatrixPosition(this.matrixWorld);this.panner.setPosition(position.x,position.y,position.z);};}()});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function AudioAnalyser(audio,fftSize){this.analyser=audio.context.createAnalyser();this.analyser.fftSize=fftSize!==undefined?fftSize:2048;this.data=new Uint8Array(this.analyser.frequencyBinCount);audio.getOutput().connect(this.analyser);}(0,_assign2.default)(AudioAnalyser.prototype,{getFrequencyData:function getFrequencyData(){this.analyser.getByteFrequencyData(this.data);return this.data;},getAverageFrequency:function getAverageFrequency(){var value=0,data=this.getFrequencyData();for(var i=0;i<data.length;i++){value+=data[i];}return value/data.length;}});/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function PropertyMixer(binding,typeName,valueSize){this.binding=binding;this.valueSize=valueSize;var bufferType=Float64Array,mixFunction;switch(typeName){case'quaternion':mixFunction=this._slerp;break;case'string':case'bool':bufferType=Array;mixFunction=this._select;break;default:mixFunction=this._lerp;}this.buffer=new bufferType(valueSize*4);// layout: [ incoming | accu0 | accu1 | orig ]
//
// interpolators can use .buffer as their .result
// the data then goes to 'incoming'
//
// 'accu0' and 'accu1' are used frame-interleaved for
// the cumulative result and are compared to detect
// changes
//
// 'orig' stores the original state of the property
this._mixBufferRegion=mixFunction;this.cumulativeWeight=0;this.useCount=0;this.referenceCount=0;}PropertyMixer.prototype={constructor:PropertyMixer,// accumulate data in the 'incoming' region into 'accu<i>'
accumulate:function accumulate(accuIndex,weight){// note: happily accumulating nothing when weight = 0, the caller knows
// the weight and shouldn't have made the call in the first place
var buffer=this.buffer,stride=this.valueSize,offset=accuIndex*stride+stride,currentWeight=this.cumulativeWeight;if(currentWeight===0){// accuN := incoming * weight
for(var i=0;i!==stride;++i){buffer[offset+i]=buffer[i];}currentWeight=weight;}else{// accuN := accuN + incoming * weight
currentWeight+=weight;var mix=weight/currentWeight;this._mixBufferRegion(buffer,offset,0,mix,stride);}this.cumulativeWeight=currentWeight;},// apply the state of 'accu<i>' to the binding when accus differ
apply:function apply(accuIndex){var stride=this.valueSize,buffer=this.buffer,offset=accuIndex*stride+stride,weight=this.cumulativeWeight,binding=this.binding;this.cumulativeWeight=0;if(weight<1){// accuN := accuN + original * ( 1 - cumulativeWeight )
var originalValueOffset=stride*3;this._mixBufferRegion(buffer,offset,originalValueOffset,1-weight,stride);}for(var i=stride,e=stride+stride;i!==e;++i){if(buffer[i]!==buffer[i+stride]){// value has changed -> update scene graph
binding.setValue(buffer,offset);break;}}},// remember the state of the bound property and copy it to both accus
saveOriginalState:function saveOriginalState(){var binding=this.binding;var buffer=this.buffer,stride=this.valueSize,originalValueOffset=stride*3;binding.getValue(buffer,originalValueOffset);// accu[0..1] := orig -- initially detect changes against the original
for(var i=stride,e=originalValueOffset;i!==e;++i){buffer[i]=buffer[originalValueOffset+i%stride];}this.cumulativeWeight=0;},// apply the state previously taken via 'saveOriginalState' to the binding
restoreOriginalState:function restoreOriginalState(){var originalValueOffset=this.valueSize*3;this.binding.setValue(this.buffer,originalValueOffset);},// mix functions
_select:function _select(buffer,dstOffset,srcOffset,t,stride){if(t>=0.5){for(var i=0;i!==stride;++i){buffer[dstOffset+i]=buffer[srcOffset+i];}}},_slerp:function _slerp(buffer,dstOffset,srcOffset,t,stride){Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t);},_lerp:function _lerp(buffer,dstOffset,srcOffset,t,stride){var s=1-t;for(var i=0;i!==stride;++i){var j=dstOffset+i;buffer[j]=buffer[j]*s+buffer[srcOffset+i]*t;}}};/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function PropertyBinding(rootNode,path,parsedPath){this.path=path;this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path);this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName)||rootNode;this.rootNode=rootNode;}PropertyBinding.prototype={constructor:PropertyBinding,getValue:function getValue_unbound(targetArray,offset){this.bind();this.getValue(targetArray,offset);// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
},setValue:function getValue_unbound(sourceArray,offset){this.bind();this.setValue(sourceArray,offset);},// create getter / setter pair for a property in the scene graph
bind:function bind(){var targetObject=this.node,parsedPath=this.parsedPath,objectName=parsedPath.objectName,propertyName=parsedPath.propertyName,propertyIndex=parsedPath.propertyIndex;if(!targetObject){targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName)||this.rootNode;this.node=targetObject;}// set fail state so we can just 'return' on error
this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;// ensure there is a value node
if(!targetObject){console.error("  trying to update node for track: "+this.path+" but it wasn't found.");return;}if(objectName){var objectIndex=parsedPath.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
switch(objectName){case'materials':if(!targetObject.material){console.error('  can not bind to material as node does not have a material',this);return;}if(!targetObject.material.materials){console.error('  can not bind to material.materials as node.material does not have a materials array',this);return;}targetObject=targetObject.material.materials;break;case'bones':if(!targetObject.skeleton){console.error('  can not bind to bones as node does not have a skeleton',this);return;}// potential future optimization: skip this if propertyIndex is already an integer
// and convert the integer string to a true integer.
targetObject=targetObject.skeleton.bones;// support resolving morphTarget names into indices.
for(var i=0;i<targetObject.length;i++){if(targetObject[i].name===objectIndex){objectIndex=i;break;}}break;default:if(targetObject[objectName]===undefined){console.error('  can not bind to objectName of node, undefined',this);return;}targetObject=targetObject[objectName];}if(objectIndex!==undefined){if(targetObject[objectIndex]===undefined){console.error("  trying to bind to objectIndex of objectName, but is undefined:",this,targetObject);return;}targetObject=targetObject[objectIndex];}}// resolve property
var nodeProperty=targetObject[propertyName];if(nodeProperty===undefined){var nodeName=parsedPath.nodeName;console.error("  trying to update property for track: "+nodeName+'.'+propertyName+" but it wasn't found.",targetObject);return;}// determine versioning scheme
var versioning=this.Versioning.None;if(targetObject.needsUpdate!==undefined){// material
versioning=this.Versioning.NeedsUpdate;this.targetObject=targetObject;}else if(targetObject.matrixWorldNeedsUpdate!==undefined){// node transform
versioning=this.Versioning.MatrixWorldNeedsUpdate;this.targetObject=targetObject;}// determine how the property gets bound
var bindingType=this.BindingType.Direct;if(propertyIndex!==undefined){// access a sub element of the property array (only primitives are supported right now)
if(propertyName==="morphTargetInfluences"){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
// support resolving morphTarget names into indices.
if(!targetObject.geometry){console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry',this);return;}if(!targetObject.geometry.morphTargets){console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets',this);return;}for(var i=0;i<this.node.geometry.morphTargets.length;i++){if(targetObject.geometry.morphTargets[i].name===propertyIndex){propertyIndex=i;break;}}}bindingType=this.BindingType.ArrayElement;this.resolvedProperty=nodeProperty;this.propertyIndex=propertyIndex;}else if(nodeProperty.fromArray!==undefined&&nodeProperty.toArray!==undefined){// must use copy for Object3D.Euler/Quaternion
bindingType=this.BindingType.HasFromToArray;this.resolvedProperty=nodeProperty;}else if(nodeProperty.length!==undefined){bindingType=this.BindingType.EntireArray;this.resolvedProperty=nodeProperty;}else{this.propertyName=propertyName;}// select getter / setter
this.getValue=this.GetterByBindingType[bindingType];this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning];},unbind:function unbind(){this.node=null;// back to the prototype version of getValue / setValue
// note: avoiding to mutate the shape of 'this' via 'delete'
this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}};(0,_assign2.default)(PropertyBinding.prototype,{// prototype, continued
// these are used to "bind" a nonexistent property
_getValue_unavailable:function _getValue_unavailable(){},_setValue_unavailable:function _setValue_unavailable(){},// initial state of these methods that calls 'bind'
_getValue_unbound:PropertyBinding.prototype.getValue,_setValue_unbound:PropertyBinding.prototype.setValue,BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function getValue_direct(buffer,offset){buffer[offset]=this.node[this.propertyName];},function getValue_array(buffer,offset){var source=this.resolvedProperty;for(var i=0,n=source.length;i!==n;++i){buffer[offset++]=source[i];}},function getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex];},function getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset);}],SetterByBindingTypeAndVersioning:[[// Direct
function setValue_direct(buffer,offset){this.node[this.propertyName]=buffer[offset];},function setValue_direct_setNeedsUpdate(buffer,offset){this.node[this.propertyName]=buffer[offset];this.targetObject.needsUpdate=true;},function setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){this.node[this.propertyName]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}],[// EntireArray
function setValue_array(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}},function setValue_array_setNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.needsUpdate=true;},function setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.matrixWorldNeedsUpdate=true;}],[// ArrayElement
function setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];},function setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.needsUpdate=true;},function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}],[// HasToFromArray
function setValue_fromArray(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);},function setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.needsUpdate=true;},function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.matrixWorldNeedsUpdate=true;}]]});PropertyBinding.Composite=function(targetGroup,path,optionalParsedPath){var parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);this._targetGroup=targetGroup;this._bindings=targetGroup.subscribe_(path,parsedPath);};PropertyBinding.Composite.prototype={constructor:PropertyBinding.Composite,getValue:function getValue(array,offset){this.bind();// bind all binding
var firstValidIndex=this._targetGroup.nCachedObjects_,binding=this._bindings[firstValidIndex];// and only call .getValue on the first
if(binding!==undefined)binding.getValue(array,offset);},setValue:function setValue(array,offset){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].setValue(array,offset);}},bind:function bind(){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].bind();}},unbind:function unbind(){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].unbind();}}};PropertyBinding.create=function(root,path,parsedPath){if(!(root&&root.isAnimationObjectGroup)){return new PropertyBinding(root,path,parsedPath);}else{return new PropertyBinding.Composite(root,path,parsedPath);}};PropertyBinding.parseTrackName=function(trackName){// matches strings in the form of:
//    nodeName.property
//    nodeName.property[accessor]
//    nodeName.material.property[accessor]
//    uuid.property[accessor]
//    uuid.objectName[objectIndex].propertyName[propertyIndex]
//    parentName/nodeName.property
//    parentName/parentName/nodeName.property[index]
//    .bone[Armature.DEF_cog].position
//    scene:helium_balloon_model:helium_balloon_model.position
// created and tested via https://regex101.com/#javascript
var re=/^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/;var matches=re.exec(trackName);if(!matches){throw new Error("cannot parse trackName at all: "+trackName);}var results={// directoryName: matches[ 1 ], // (tschw) currently unused
nodeName:matches[2],// allowed to be null, specified root node.
objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],propertyIndex:matches[6]// allowed to be null, specifies that the whole property is set.
};if(results.propertyName===null||results.propertyName.length===0){throw new Error("can not parse propertyName from trackName: "+trackName);}return results;};PropertyBinding.findNode=function(root,nodeName){if(!nodeName||nodeName===""||nodeName==="root"||nodeName==="."||nodeName===-1||nodeName===root.name||nodeName===root.uuid){return root;}// search into skeleton bones.
if(root.skeleton){var searchSkeleton=function searchSkeleton(skeleton){for(var i=0;i<skeleton.bones.length;i++){var bone=skeleton.bones[i];if(bone.name===nodeName){return bone;}}return null;};var bone=searchSkeleton(root.skeleton);if(bone){return bone;}}// search into node subtree.
if(root.children){var searchNodeSubtree=function searchNodeSubtree(children){for(var i=0;i<children.length;i++){var childNode=children[i];if(childNode.name===nodeName||childNode.uuid===nodeName){return childNode;}var result=searchNodeSubtree(childNode.children);if(result)return result;}return null;};var subTreeNode=searchNodeSubtree(root.children);if(subTreeNode){return subTreeNode;}}return null;};/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */function AnimationObjectGroup(var_args){this.uuid=_Math.generateUUID();// cached objects followed by the active ones
this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;// threshold
// note: read by PropertyBinding.Composite
var indices={};this._indicesByUUID=indices;// for bookkeeping
for(var i=0,n=arguments.length;i!==n;++i){indices[arguments[i].uuid]=i;}this._paths=[];// inside: string
this._parsedPaths=[];// inside: { we don't care, here }
this._bindings=[];// inside: Array< PropertyBinding >
this._bindingsIndicesByPath={};// inside: indices in these arrays
var scope=this;this.stats={objects:{get total(){return scope._objects.length;},get inUse(){return this.total-scope.nCachedObjects_;}},get bindingsPerObject(){return scope._bindings.length;}};}AnimationObjectGroup.prototype={constructor:AnimationObjectGroup,isAnimationObjectGroup:true,add:function add(var_args){var objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid],knownObject=undefined;if(index===undefined){// unknown object -> add it to the ACTIVE region
index=nObjects++;indicesByUUID[uuid]=index;objects.push(object);// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){bindings[j].push(new PropertyBinding(object,paths[j],parsedPaths[j]));}}else if(index<nCachedObjects){knownObject=objects[index];// move existing object to the ACTIVE region
var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex];indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;indicesByUUID[uuid]=firstActiveIndex;objects[firstActiveIndex]=object;// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],binding=bindingsForPath[index];bindingsForPath[index]=lastCached;if(binding===undefined){// since we do not bother to create new bindings
// for objects that are cached, the binding may
// or may not exist
binding=new PropertyBinding(object,paths[j],parsedPaths[j]);}bindingsForPath[firstActiveIndex]=binding;}}else if(objects[index]!==knownObject){console.error("Different objects with the same UUID "+"detected. Clean the caches or recreate your "+"infrastructure when reloading scenes...");}// else the object is already where we want it to be
}// for arguments
this.nCachedObjects_=nCachedObjects;},remove:function remove(var_args){var objects=this._objects,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined&&index>=nCachedObjects){// move existing object into the CACHED region
var lastCachedIndex=nCachedObjects++,firstActiveObject=objects[lastCachedIndex];indicesByUUID[firstActiveObject.uuid]=index;objects[index]=firstActiveObject;indicesByUUID[uuid]=lastCachedIndex;objects[lastCachedIndex]=object;// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],firstActive=bindingsForPath[lastCachedIndex],binding=bindingsForPath[index];bindingsForPath[index]=firstActive;bindingsForPath[lastCachedIndex]=binding;}}}// for arguments
this.nCachedObjects_=nCachedObjects;},// remove & forget
uncache:function uncache(var_args){var objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined){delete indicesByUUID[uuid];if(index<nCachedObjects){// object is cached, shrink the CACHED region
var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex],lastIndex=--nObjects,lastObject=objects[lastIndex];// last cached object takes this object's place
indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;// last object goes to the activated slot and pop
indicesByUUID[lastObject.uuid]=firstActiveIndex;objects[firstActiveIndex]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],last=bindingsForPath[lastIndex];bindingsForPath[index]=lastCached;bindingsForPath[firstActiveIndex]=last;bindingsForPath.pop();}}else{// object is active, just swap with the last and pop
var lastIndex=--nObjects,lastObject=objects[lastIndex];indicesByUUID[lastObject.uuid]=index;objects[index]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j];bindingsForPath[index]=bindingsForPath[lastIndex];bindingsForPath.pop();}}// cached or active
}// if object is known
}// for arguments
this.nCachedObjects_=nCachedObjects;},// Internal interface used by befriended PropertyBinding.Composite:
subscribe_:function subscribe_(path,parsedPath){// returns an array of bindings for the given path that is changed
// according to the contained objects in the group
var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path],bindings=this._bindings;if(index!==undefined)return bindings[index];var paths=this._paths,parsedPaths=this._parsedPaths,objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,bindingsForPath=new Array(nObjects);index=bindings.length;indicesByPath[path]=index;paths.push(path);parsedPaths.push(parsedPath);bindings.push(bindingsForPath);for(var i=nCachedObjects,n=objects.length;i!==n;++i){var object=objects[i];bindingsForPath[i]=new PropertyBinding(object,path,parsedPath);}return bindingsForPath;},unsubscribe_:function unsubscribe_(path){// tells the group to forget about a property path and no longer
// update the array previously obtained with 'subscribe_'
var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path];if(index!==undefined){var paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,lastBindingsIndex=bindings.length-1,lastBindings=bindings[lastBindingsIndex],lastBindingsPath=path[lastBindingsIndex];indicesByPath[lastBindingsPath]=index;bindings[index]=lastBindings;bindings.pop();parsedPaths[index]=parsedPaths[lastBindingsIndex];parsedPaths.pop();paths[index]=paths[lastBindingsIndex];paths.pop();}}};/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */function AnimationAction(mixer,clip,localRoot){this._mixer=mixer;this._clip=clip;this._localRoot=localRoot||null;var tracks=clip.tracks,nTracks=tracks.length,interpolants=new Array(nTracks);var interpolantSettings={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(var i=0;i!==nTracks;++i){var interpolant=tracks[i].createInterpolant(null);interpolants[i]=interpolant;interpolant.settings=interpolantSettings;}this._interpolantSettings=interpolantSettings;this._interpolants=interpolants;// bound by the mixer
// inside: PropertyMixer (managed by the mixer)
this._propertyBindings=new Array(nTracks);this._cacheIndex=null;// for the memory manager
this._byClipCacheIndex=null;// for the memory manager
this._timeScaleInterpolant=null;this._weightInterpolant=null;this.loop=LoopRepeat;this._loopCount=-1;// global mixer time when the action is to be started
// it's set back to 'null' upon start of the action
this._startTime=null;// scaled local time of the action
// gets clamped or wrapped to 0..clip.duration according to loop
this.time=0;this.timeScale=1;this._effectiveTimeScale=1;this.weight=1;this._effectiveWeight=1;this.repetitions=Infinity;// no. of repetitions when looping
this.paused=false;// false -> zero effective time scale
this.enabled=true;// true -> zero effective weight
this.clampWhenFinished=false;// keep feeding the last frame?
this.zeroSlopeAtStart=true;// for smooth interpolation w/o separate
this.zeroSlopeAtEnd=true;// clips for start, loop and end
}AnimationAction.prototype={constructor:AnimationAction,// State & Scheduling
play:function play(){this._mixer._activateAction(this);return this;},stop:function stop(){this._mixer._deactivateAction(this);return this.reset();},reset:function reset(){this.paused=false;this.enabled=true;this.time=0;// restart clip
this._loopCount=-1;// forget previous loops
this._startTime=null;// forget scheduling
return this.stopFading().stopWarping();},isRunning:function isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this);},// return true when play has been called
isScheduled:function isScheduled(){return this._mixer._isActiveAction(this);},startAt:function startAt(time){this._startTime=time;return this;},setLoop:function setLoop(mode,repetitions){this.loop=mode;this.repetitions=repetitions;return this;},// Weight
// set the weight stopping any scheduled fading
// although .enabled = false yields an effective weight of zero, this
// method does *not* change .enabled, because it would be confusing
setEffectiveWeight:function setEffectiveWeight(weight){this.weight=weight;// note: same logic as when updated at runtime
this._effectiveWeight=this.enabled?weight:0;return this.stopFading();},// return the weight considering fading and .enabled
getEffectiveWeight:function getEffectiveWeight(){return this._effectiveWeight;},fadeIn:function fadeIn(duration){return this._scheduleFading(duration,0,1);},fadeOut:function fadeOut(duration){return this._scheduleFading(duration,1,0);},crossFadeFrom:function crossFadeFrom(fadeOutAction,duration,warp){fadeOutAction.fadeOut(duration);this.fadeIn(duration);if(warp){var fadeInDuration=this._clip.duration,fadeOutDuration=fadeOutAction._clip.duration,startEndRatio=fadeOutDuration/fadeInDuration,endStartRatio=fadeInDuration/fadeOutDuration;fadeOutAction.warp(1.0,startEndRatio,duration);this.warp(endStartRatio,1.0,duration);}return this;},crossFadeTo:function crossFadeTo(fadeInAction,duration,warp){return fadeInAction.crossFadeFrom(this,duration,warp);},stopFading:function stopFading(){var weightInterpolant=this._weightInterpolant;if(weightInterpolant!==null){this._weightInterpolant=null;this._mixer._takeBackControlInterpolant(weightInterpolant);}return this;},// Time Scale Control
// set the weight stopping any scheduled warping
// although .paused = true yields an effective time scale of zero, this
// method does *not* change .paused, because it would be confusing
setEffectiveTimeScale:function setEffectiveTimeScale(timeScale){this.timeScale=timeScale;this._effectiveTimeScale=this.paused?0:timeScale;return this.stopWarping();},// return the time scale considering warping and .paused
getEffectiveTimeScale:function getEffectiveTimeScale(){return this._effectiveTimeScale;},setDuration:function setDuration(duration){this.timeScale=this._clip.duration/duration;return this.stopWarping();},syncWith:function syncWith(action){this.time=action.time;this.timeScale=action.timeScale;return this.stopWarping();},halt:function halt(duration){return this.warp(this._effectiveTimeScale,0,duration);},warp:function warp(startTimeScale,endTimeScale,duration){var mixer=this._mixer,now=mixer.time,interpolant=this._timeScaleInterpolant,timeScale=this.timeScale;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._timeScaleInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;times[1]=now+duration;values[0]=startTimeScale/timeScale;values[1]=endTimeScale/timeScale;return this;},stopWarping:function stopWarping(){var timeScaleInterpolant=this._timeScaleInterpolant;if(timeScaleInterpolant!==null){this._timeScaleInterpolant=null;this._mixer._takeBackControlInterpolant(timeScaleInterpolant);}return this;},// Object Accessors
getMixer:function getMixer(){return this._mixer;},getClip:function getClip(){return this._clip;},getRoot:function getRoot(){return this._localRoot||this._mixer._root;},// Interna
_update:function _update(time,deltaTime,timeDirection,accuIndex){// called by the mixer
var startTime=this._startTime;if(startTime!==null){// check for scheduled start of action
var timeRunning=(time-startTime)*timeDirection;if(timeRunning<0||timeDirection===0){return;// yet to come / don't decide when delta = 0
}// start
this._startTime=null;// unschedule
deltaTime=timeDirection*timeRunning;}// apply time scale and advance time
deltaTime*=this._updateTimeScale(time);var clipTime=this._updateTime(deltaTime);// note: _updateTime may disable the action resulting in
// an effective weight of 0
var weight=this._updateWeight(time);if(weight>0){var interpolants=this._interpolants;var propertyMixers=this._propertyBindings;for(var j=0,m=interpolants.length;j!==m;++j){interpolants[j].evaluate(clipTime);propertyMixers[j].accumulate(accuIndex,weight);}}},_updateWeight:function _updateWeight(time){var weight=0;if(this.enabled){weight=this.weight;var interpolant=this._weightInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];weight*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopFading();if(interpolantValue===0){// faded out, disable
this.enabled=false;}}}}this._effectiveWeight=weight;return weight;},_updateTimeScale:function _updateTimeScale(time){var timeScale=0;if(!this.paused){timeScale=this.timeScale;var interpolant=this._timeScaleInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];timeScale*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopWarping();if(timeScale===0){// motion has halted, pause
this.paused=true;}else{// warp done - apply final time scale
this.timeScale=timeScale;}}}}this._effectiveTimeScale=timeScale;return timeScale;},_updateTime:function _updateTime(deltaTime){var time=this.time+deltaTime;if(deltaTime===0)return time;var duration=this._clip.duration,loop=this.loop,loopCount=this._loopCount;if(loop===LoopOnce){if(loopCount===-1){// just started
this._loopCount=0;this._setEndings(true,true,false);}handle_stop:{if(time>=duration){time=duration;}else if(time<0){time=0;}else break handle_stop;if(this.clampWhenFinished)this.paused=true;else this.enabled=false;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime<0?-1:1});}}else{// repetitive Repeat or PingPong
var pingPong=loop===LoopPingPong;if(loopCount===-1){// just started
if(deltaTime>=0){loopCount=0;this._setEndings(true,this.repetitions===0,pingPong);}else{// when looping in reverse direction, the initial
// transition through zero counts as a repetition,
// so leave loopCount at -1
this._setEndings(this.repetitions===0,true,pingPong);}}if(time>=duration||time<0){// wrap around
var loopDelta=Math.floor(time/duration);// signed
time-=duration*loopDelta;loopCount+=Math.abs(loopDelta);var pending=this.repetitions-loopCount;if(pending<0){// have to stop (switch state, clamp time, fire event)
if(this.clampWhenFinished)this.paused=true;else this.enabled=false;time=deltaTime>0?duration:0;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime>0?1:-1});}else{// keep running
if(pending===0){// entering the last round
var atStart=deltaTime<0;this._setEndings(atStart,!atStart,pingPong);}else{this._setEndings(false,false,pingPong);}this._loopCount=loopCount;this._mixer.dispatchEvent({type:'loop',action:this,loopDelta:loopDelta});}}if(pingPong&&(loopCount&1)===1){// invert time for the "pong round"
this.time=time;return duration-time;}}this.time=time;return time;},_setEndings:function _setEndings(atStart,atEnd,pingPong){var settings=this._interpolantSettings;if(pingPong){settings.endingStart=ZeroSlopeEnding;settings.endingEnd=ZeroSlopeEnding;}else{// assuming for LoopOnce atStart == atEnd == true
if(atStart){settings.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingStart=WrapAroundEnding;}if(atEnd){settings.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingEnd=WrapAroundEnding;}}},_scheduleFading:function _scheduleFading(duration,weightNow,weightThen){var mixer=this._mixer,now=mixer.time,interpolant=this._weightInterpolant;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._weightInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;values[0]=weightNow;times[1]=now+duration;values[1]=weightThen;return this;}};/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function AnimationMixer(root){this._root=root;this._initMemoryManager();this._accuIndex=0;this.time=0;this.timeScale=1.0;}AnimationMixer.prototype={constructor:AnimationMixer,// return an action for a clip optionally using a custom root target
// object (this method allocates a lot of dynamic memory in case a
// previously unknown clip/root combination is specified)
clipAction:function clipAction(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject!==null?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid],prototypeAction=null;if(actionsForClip!==undefined){var existingAction=actionsForClip.actionByRoot[rootUuid];if(existingAction!==undefined){return existingAction;}// we know the clip, so we don't have to parse all
// the bindings again but can just copy
prototypeAction=actionsForClip.knownActions[0];// also, take the clip from the prototype action
if(clipObject===null)clipObject=prototypeAction._clip;}// clip must be known when specified via string
if(clipObject===null)return null;// allocate all resources required to run it
var newAction=new AnimationAction(this,clipObject,optionalRoot);this._bindAction(newAction,prototypeAction);// and make the action known to the memory manager
this._addInactiveAction(newAction,clipUuid,rootUuid);return newAction;},// get an existing action
existingAction:function existingAction(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];if(actionsForClip!==undefined){return actionsForClip.actionByRoot[rootUuid]||null;}return null;},// deactivates all previously scheduled actions
stopAllAction:function stopAllAction(){var actions=this._actions,nActions=this._nActiveActions,bindings=this._bindings,nBindings=this._nActiveBindings;this._nActiveActions=0;this._nActiveBindings=0;for(var i=0;i!==nActions;++i){actions[i].reset();}for(var i=0;i!==nBindings;++i){bindings[i].useCount=0;}return this;},// advance the time and update apply the animation
update:function update(deltaTime){deltaTime*=this.timeScale;var actions=this._actions,nActions=this._nActiveActions,time=this.time+=deltaTime,timeDirection=(0,_sign2.default)(deltaTime),accuIndex=this._accuIndex^=1;// run active actions
for(var i=0;i!==nActions;++i){var action=actions[i];if(action.enabled){action._update(time,deltaTime,timeDirection,accuIndex);}}// update scene graph
var bindings=this._bindings,nBindings=this._nActiveBindings;for(var i=0;i!==nBindings;++i){bindings[i].apply(accuIndex);}return this;},// return this mixer's root target object
getRoot:function getRoot(){return this._root;},// free all resources specific to a particular clip
uncacheClip:function uncacheClip(clip){var actions=this._actions,clipUuid=clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip!==undefined){// note: just calling _removeInactiveAction would mess up the
// iteration state and also require updating the state we can
// just throw away
var actionsToRemove=actionsForClip.knownActions;for(var i=0,n=actionsToRemove.length;i!==n;++i){var action=actionsToRemove[i];this._deactivateAction(action);var cacheIndex=action._cacheIndex,lastInactiveAction=actions[actions.length-1];action._cacheIndex=null;action._byClipCacheIndex=null;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();this._removeInactiveBindingsForAction(action);}delete actionsByClip[clipUuid];}},// free all resources specific to a particular root target object
uncacheRoot:function uncacheRoot(root){var rootUuid=root.uuid,actionsByClip=this._actionsByClip;for(var clipUuid in actionsByClip){var actionByRoot=actionsByClip[clipUuid].actionByRoot,action=actionByRoot[rootUuid];if(action!==undefined){this._deactivateAction(action);this._removeInactiveAction(action);}}var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid];if(bindingByName!==undefined){for(var trackName in bindingByName){var binding=bindingByName[trackName];binding.restoreOriginalState();this._removeInactiveBinding(binding);}}},// remove a targeted clip from the cache
uncacheAction:function uncacheAction(clip,optionalRoot){var action=this.existingAction(clip,optionalRoot);if(action!==null){this._deactivateAction(action);this._removeInactiveAction(action);}}};// Implementation details:
(0,_assign2.default)(AnimationMixer.prototype,{_bindAction:function _bindAction(action,prototypeAction){var root=action._localRoot||this._root,tracks=action._clip.tracks,nTracks=tracks.length,bindings=action._propertyBindings,interpolants=action._interpolants,rootUuid=root.uuid,bindingsByRoot=this._bindingsByRootAndName,bindingsByName=bindingsByRoot[rootUuid];if(bindingsByName===undefined){bindingsByName={};bindingsByRoot[rootUuid]=bindingsByName;}for(var i=0;i!==nTracks;++i){var track=tracks[i],trackName=track.name,binding=bindingsByName[trackName];if(binding!==undefined){bindings[i]=binding;}else{binding=bindings[i];if(binding!==undefined){// existing binding, make sure the cache knows
if(binding._cacheIndex===null){++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);}continue;}var path=prototypeAction&&prototypeAction._propertyBindings[i].binding.parsedPath;binding=new PropertyMixer(PropertyBinding.create(root,trackName,path),track.ValueTypeName,track.getValueSize());++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);bindings[i]=binding;}interpolants[i].resultBuffer=binding.buffer;}},_activateAction:function _activateAction(action){if(!this._isActiveAction(action)){if(action._cacheIndex===null){// this action has been forgotten by the cache, but the user
// appears to be still using it -> rebind
var rootUuid=(action._localRoot||this._root).uuid,clipUuid=action._clip.uuid,actionsForClip=this._actionsByClip[clipUuid];this._bindAction(action,actionsForClip&&actionsForClip.knownActions[0]);this._addInactiveAction(action,clipUuid,rootUuid);}var bindings=action._propertyBindings;// increment reference counts / sort out state
for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(binding.useCount++===0){this._lendBinding(binding);binding.saveOriginalState();}}this._lendAction(action);}},_deactivateAction:function _deactivateAction(action){if(this._isActiveAction(action)){var bindings=action._propertyBindings;// decrement reference counts / sort out state
for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(--binding.useCount===0){binding.restoreOriginalState();this._takeBackBinding(binding);}}this._takeBackAction(action);}},// Memory manager
_initMemoryManager:function _initMemoryManager(){this._actions=[];// 'nActiveActions' followed by inactive ones
this._nActiveActions=0;this._actionsByClip={};// inside:
// {
// 		knownActions: Array< AnimationAction >	- used as prototypes
// 		actionByRoot: AnimationAction			- lookup
// }
this._bindings=[];// 'nActiveBindings' followed by inactive ones
this._nActiveBindings=0;this._bindingsByRootAndName={};// inside: MaterialMap< name, PropertyMixer >
this._controlInterpolants=[];// same game as above
this._nActiveControlInterpolants=0;var scope=this;this.stats={actions:{get total(){return scope._actions.length;},get inUse(){return scope._nActiveActions;}},bindings:{get total(){return scope._bindings.length;},get inUse(){return scope._nActiveBindings;}},controlInterpolants:{get total(){return scope._controlInterpolants.length;},get inUse(){return scope._nActiveControlInterpolants;}}};},// Memory management for AnimationAction objects
_isActiveAction:function _isActiveAction(action){var index=action._cacheIndex;return index!==null&&index<this._nActiveActions;},_addInactiveAction:function _addInactiveAction(action,clipUuid,rootUuid){var actions=this._actions,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip===undefined){actionsForClip={knownActions:[action],actionByRoot:{}};action._byClipCacheIndex=0;actionsByClip[clipUuid]=actionsForClip;}else{var knownActions=actionsForClip.knownActions;action._byClipCacheIndex=knownActions.length;knownActions.push(action);}action._cacheIndex=actions.length;actions.push(action);actionsForClip.actionByRoot[rootUuid]=action;},_removeInactiveAction:function _removeInactiveAction(action){var actions=this._actions,lastInactiveAction=actions[actions.length-1],cacheIndex=action._cacheIndex;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();action._cacheIndex=null;var clipUuid=action._clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid],knownActionsForClip=actionsForClip.knownActions,lastKnownAction=knownActionsForClip[knownActionsForClip.length-1],byClipCacheIndex=action._byClipCacheIndex;lastKnownAction._byClipCacheIndex=byClipCacheIndex;knownActionsForClip[byClipCacheIndex]=lastKnownAction;knownActionsForClip.pop();action._byClipCacheIndex=null;var actionByRoot=actionsForClip.actionByRoot,rootUuid=(actions._localRoot||this._root).uuid;delete actionByRoot[rootUuid];if(knownActionsForClip.length===0){delete actionsByClip[clipUuid];}this._removeInactiveBindingsForAction(action);},_removeInactiveBindingsForAction:function _removeInactiveBindingsForAction(action){var bindings=action._propertyBindings;for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(--binding.referenceCount===0){this._removeInactiveBinding(binding);}}},_lendAction:function _lendAction(action){// [ active actions |  inactive actions  ]
// [  active actions >| inactive actions ]
//                 s        a
//                  <-swap->
//                 a        s
var actions=this._actions,prevIndex=action._cacheIndex,lastActiveIndex=this._nActiveActions++,firstInactiveAction=actions[lastActiveIndex];action._cacheIndex=lastActiveIndex;actions[lastActiveIndex]=action;firstInactiveAction._cacheIndex=prevIndex;actions[prevIndex]=firstInactiveAction;},_takeBackAction:function _takeBackAction(action){// [  active actions  | inactive actions ]
// [ active actions |< inactive actions  ]
//        a        s
//         <-swap->
//        s        a
var actions=this._actions,prevIndex=action._cacheIndex,firstInactiveIndex=--this._nActiveActions,lastActiveAction=actions[firstInactiveIndex];action._cacheIndex=firstInactiveIndex;actions[firstInactiveIndex]=action;lastActiveAction._cacheIndex=prevIndex;actions[prevIndex]=lastActiveAction;},// Memory management for PropertyMixer objects
_addInactiveBinding:function _addInactiveBinding(binding,rootUuid,trackName){var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],bindings=this._bindings;if(bindingByName===undefined){bindingByName={};bindingsByRoot[rootUuid]=bindingByName;}bindingByName[trackName]=binding;binding._cacheIndex=bindings.length;bindings.push(binding);},_removeInactiveBinding:function _removeInactiveBinding(binding){var bindings=this._bindings,propBinding=binding.binding,rootUuid=propBinding.rootNode.uuid,trackName=propBinding.path,bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],lastInactiveBinding=bindings[bindings.length-1],cacheIndex=binding._cacheIndex;lastInactiveBinding._cacheIndex=cacheIndex;bindings[cacheIndex]=lastInactiveBinding;bindings.pop();delete bindingByName[trackName];remove_empty_map:{for(var _ in bindingByName){break remove_empty_map;}delete bindingsByRoot[rootUuid];}},_lendBinding:function _lendBinding(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,lastActiveIndex=this._nActiveBindings++,firstInactiveBinding=bindings[lastActiveIndex];binding._cacheIndex=lastActiveIndex;bindings[lastActiveIndex]=binding;firstInactiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=firstInactiveBinding;},_takeBackBinding:function _takeBackBinding(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,firstInactiveIndex=--this._nActiveBindings,lastActiveBinding=bindings[firstInactiveIndex];binding._cacheIndex=firstInactiveIndex;bindings[firstInactiveIndex]=binding;lastActiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=lastActiveBinding;},// Memory management of Interpolants for weight and time scale
_lendControlInterpolant:function _lendControlInterpolant(){var interpolants=this._controlInterpolants,lastActiveIndex=this._nActiveControlInterpolants++,interpolant=interpolants[lastActiveIndex];if(interpolant===undefined){interpolant=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer);interpolant.__cacheIndex=lastActiveIndex;interpolants[lastActiveIndex]=interpolant;}return interpolant;},_takeBackControlInterpolant:function _takeBackControlInterpolant(interpolant){var interpolants=this._controlInterpolants,prevIndex=interpolant.__cacheIndex,firstInactiveIndex=--this._nActiveControlInterpolants,lastActiveInterpolant=interpolants[firstInactiveIndex];interpolant.__cacheIndex=firstInactiveIndex;interpolants[firstInactiveIndex]=interpolant;lastActiveInterpolant.__cacheIndex=prevIndex;interpolants[prevIndex]=lastActiveInterpolant;},_controlInterpolantsResultBuffer:new Float32Array(1)});(0,_assign2.default)(AnimationMixer.prototype,EventDispatcher.prototype);/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Uniform(value){if(typeof value==='string'){console.warn('THREE.Uniform: Type parameter is no longer needed.');value=arguments[1];}this.value=value;}Uniform.prototype.clone=function(){return new Uniform(this.value.clone===undefined?this.value:this.value.clone());};/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function InstancedBufferGeometry(){BufferGeometry.call(this);this.type='InstancedBufferGeometry';this.maxInstancedCount=undefined;}InstancedBufferGeometry.prototype=(0,_create2.default)(BufferGeometry.prototype);InstancedBufferGeometry.prototype.constructor=InstancedBufferGeometry;InstancedBufferGeometry.prototype.isInstancedBufferGeometry=true;InstancedBufferGeometry.prototype.addGroup=function(start,count,materialIndex){this.groups.push({start:start,count:count,materialIndex:materialIndex});};InstancedBufferGeometry.prototype.copy=function(source){var index=source.index;if(index!==null){this.setIndex(index.clone());}var attributes=source.attributes;for(var name in attributes){var attribute=attributes[name];this.addAttribute(name,attribute.clone());}var groups=source.groups;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}return this;};/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function InterleavedBufferAttribute(interleavedBuffer,itemSize,offset,normalized){this.uuid=_Math.generateUUID();this.data=interleavedBuffer;this.itemSize=itemSize;this.offset=offset;this.normalized=normalized===true;}InterleavedBufferAttribute.prototype={constructor:InterleavedBufferAttribute,isInterleavedBufferAttribute:true,get count(){return this.data.count;},get array(){return this.data.array;},setX:function setX(index,x){this.data.array[index*this.data.stride+this.offset]=x;return this;},setY:function setY(index,y){this.data.array[index*this.data.stride+this.offset+1]=y;return this;},setZ:function setZ(index,z){this.data.array[index*this.data.stride+this.offset+2]=z;return this;},setW:function setW(index,w){this.data.array[index*this.data.stride+this.offset+3]=w;return this;},getX:function getX(index){return this.data.array[index*this.data.stride+this.offset];},getY:function getY(index){return this.data.array[index*this.data.stride+this.offset+1];},getZ:function getZ(index){return this.data.array[index*this.data.stride+this.offset+2];},getW:function getW(index){return this.data.array[index*this.data.stride+this.offset+3];},setXY:function setXY(index,x,y){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;return this;},setXYZ:function setXYZ(index,x,y,z){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;return this;},setXYZW:function setXYZW(index,x,y,z,w){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;this.data.array[index+3]=w;return this;}};/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function InterleavedBuffer(array,stride){this.uuid=_Math.generateUUID();this.array=array;this.stride=stride;this.count=array!==undefined?array.length/stride:0;this.dynamic=false;this.updateRange={offset:0,count:-1};this.onUploadCallback=function(){};this.version=0;}InterleavedBuffer.prototype={constructor:InterleavedBuffer,isInterleavedBuffer:true,set needsUpdate(value){if(value===true)this.version++;},setArray:function setArray(array){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.count=array!==undefined?array.length/this.stride:0;this.array=array;},setDynamic:function setDynamic(value){this.dynamic=value;return this;},copy:function copy(source){this.array=new source.array.constructor(source.array);this.count=source.count;this.stride=source.stride;this.dynamic=source.dynamic;return this;},copyAt:function copyAt(index1,attribute,index2){index1*=this.stride;index2*=attribute.stride;for(var i=0,l=this.stride;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},set:function set(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},clone:function clone(){return new this.constructor().copy(this);},onUpload:function onUpload(callback){this.onUploadCallback=callback;return this;}};/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function InstancedInterleavedBuffer(array,stride,meshPerAttribute){InterleavedBuffer.call(this,array,stride);this.meshPerAttribute=meshPerAttribute||1;}InstancedInterleavedBuffer.prototype=(0,_create2.default)(InterleavedBuffer.prototype);InstancedInterleavedBuffer.prototype.constructor=InstancedInterleavedBuffer;InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer=true;InstancedInterleavedBuffer.prototype.copy=function(source){InterleavedBuffer.prototype.copy.call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;};/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function InstancedBufferAttribute(array,itemSize,meshPerAttribute){BufferAttribute.call(this,array,itemSize);this.meshPerAttribute=meshPerAttribute||1;}InstancedBufferAttribute.prototype=(0,_create2.default)(BufferAttribute.prototype);InstancedBufferAttribute.prototype.constructor=InstancedBufferAttribute;InstancedBufferAttribute.prototype.isInstancedBufferAttribute=true;InstancedBufferAttribute.prototype.copy=function(source){BufferAttribute.prototype.copy.call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */function Raycaster(origin,direction,near,far){this.ray=new Ray(origin,direction);// direction is assumed to be normalized (for accurate distance calculations)
this.near=near||0;this.far=far||Infinity;this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},Sprite:{}};(0,_defineProperties2.default)(this.params,{PointCloud:{get:function get(){console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');return this.Points;}}});}function ascSort(a,b){return a.distance-b.distance;}function _intersectObject(object,raycaster,intersects,recursive){if(object.visible===false)return;object.raycast(raycaster,intersects);if(recursive===true){var children=object.children;for(var i=0,l=children.length;i<l;i++){_intersectObject(children[i],raycaster,intersects,true);}}}//
Raycaster.prototype={constructor:Raycaster,linePrecision:1,set:function set(origin,direction){// direction is assumed to be normalized (for accurate distance calculations)
this.ray.set(origin,direction);},setFromCamera:function setFromCamera(coords,camera){if(camera&&camera.isPerspectiveCamera){this.ray.origin.setFromMatrixPosition(camera.matrixWorld);this.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();}else if(camera&&camera.isOrthographicCamera){this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera
this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);}else{console.error('THREE.Raycaster: Unsupported camera type.');}},intersectObject:function intersectObject(object,recursive){var intersects=[];_intersectObject(object,this,intersects,recursive);intersects.sort(ascSort);return intersects;},intersectObjects:function intersectObjects(objects,recursive){var intersects=[];if(Array.isArray(objects)===false){console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');return intersects;}for(var i=0,l=objects.length;i<l;i++){_intersectObject(objects[i],this,intersects,recursive);}intersects.sort(ascSort);return intersects;}};/**
	 * @author alteredq / http://alteredqualia.com/
	 */function Clock(autoStart){this.autoStart=autoStart!==undefined?autoStart:true;this.startTime=0;this.oldTime=0;this.elapsedTime=0;this.running=false;}Clock.prototype={constructor:Clock,start:function start(){this.startTime=(performance||Date).now();this.oldTime=this.startTime;this.elapsedTime=0;this.running=true;},stop:function stop(){this.getElapsedTime();this.running=false;},getElapsedTime:function getElapsedTime(){this.getDelta();return this.elapsedTime;},getDelta:function getDelta(){var diff=0;if(this.autoStart&&!this.running){this.start();}if(this.running){var newTime=(performance||Date).now();diff=(newTime-this.oldTime)/1000;this.oldTime=newTime;this.elapsedTime+=diff;}return diff;}};/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The poles (phi) are at the positive and negative y axis.
	 * The equator starts at positive z.
	 */function Spherical(radius,phi,theta){this.radius=radius!==undefined?radius:1.0;this.phi=phi!==undefined?phi:0;// up / down towards top and bottom pole
this.theta=theta!==undefined?theta:0;// around the equator of the sphere
return this;}Spherical.prototype={constructor:Spherical,set:function set(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this;},// restrict phi to be betwee EPS and PI-EPS
makeSafe:function makeSafe(){var EPS=0.000001;this.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));return this;},setFromVector3:function setFromVector3(vec3){this.radius=vec3.length();if(this.radius===0){this.theta=0;this.phi=0;}else{this.theta=Math.atan2(vec3.x,vec3.z);// equator angle around y-up axis
this.phi=Math.acos(_Math.clamp(vec3.y/this.radius,-1,1));// polar angle
}return this;}};/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 *
	 */function Cylindrical(radius,theta,y){this.radius=radius!==undefined?radius:1.0;// distance from the origin to a point in the x-z plane
this.theta=theta!==undefined?theta:0;// counterclockwise angle in the x-z plane measured in radians from the positive z-axis
this.y=y!==undefined?y:0;// height above the x-z plane
return this;}Cylindrical.prototype={constructor:Cylindrical,set:function set(radius,theta,y){this.radius=radius;this.theta=theta;this.y=y;return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(other){this.radius=other.radius;this.theta=other.theta;this.y=other.y;return this;},setFromVector3:function setFromVector3(vec3){this.radius=Math.sqrt(vec3.x*vec3.x+vec3.z*vec3.z);this.theta=Math.atan2(vec3.x,vec3.z);this.y=vec3.y;return this;}};/**
	 * @author alteredq / http://alteredqualia.com/
	 */function MorphBlendMesh(geometry,material){Mesh.call(this,geometry,material);this.animationsMap={};this.animationsList=[];// prepare default animation
// (all frames played together in 1 second)
var numFrames=this.geometry.morphTargets.length;var name="__default";var startFrame=0;var endFrame=numFrames-1;var fps=numFrames/1;this.createAnimation(name,startFrame,endFrame,fps);this.setAnimationWeight(name,1);}MorphBlendMesh.prototype=(0,_create2.default)(Mesh.prototype);MorphBlendMesh.prototype.constructor=MorphBlendMesh;MorphBlendMesh.prototype.createAnimation=function(name,start,end,fps){var animation={start:start,end:end,length:end-start+1,fps:fps,duration:(end-start)/fps,lastFrame:0,currentFrame:0,active:false,time:0,direction:1,weight:1,directionBackwards:false,mirroredLoop:false};this.animationsMap[name]=animation;this.animationsList.push(animation);};MorphBlendMesh.prototype.autoCreateAnimations=function(fps){var pattern=/([a-z]+)_?(\d+)/i;var firstAnimation,frameRanges={};var geometry=this.geometry;for(var i=0,il=geometry.morphTargets.length;i<il;i++){var morph=geometry.morphTargets[i];var chunks=morph.name.match(pattern);if(chunks&&chunks.length>1){var name=chunks[1];if(!frameRanges[name])frameRanges[name]={start:Infinity,end:-Infinity};var range=frameRanges[name];if(i<range.start)range.start=i;if(i>range.end)range.end=i;if(!firstAnimation)firstAnimation=name;}}for(var name in frameRanges){var range=frameRanges[name];this.createAnimation(name,range.start,range.end,fps);}this.firstAnimation=firstAnimation;};MorphBlendMesh.prototype.setAnimationDirectionForward=function(name){var animation=this.animationsMap[name];if(animation){animation.direction=1;animation.directionBackwards=false;}};MorphBlendMesh.prototype.setAnimationDirectionBackward=function(name){var animation=this.animationsMap[name];if(animation){animation.direction=-1;animation.directionBackwards=true;}};MorphBlendMesh.prototype.setAnimationFPS=function(name,fps){var animation=this.animationsMap[name];if(animation){animation.fps=fps;animation.duration=(animation.end-animation.start)/animation.fps;}};MorphBlendMesh.prototype.setAnimationDuration=function(name,duration){var animation=this.animationsMap[name];if(animation){animation.duration=duration;animation.fps=(animation.end-animation.start)/animation.duration;}};MorphBlendMesh.prototype.setAnimationWeight=function(name,weight){var animation=this.animationsMap[name];if(animation){animation.weight=weight;}};MorphBlendMesh.prototype.setAnimationTime=function(name,time){var animation=this.animationsMap[name];if(animation){animation.time=time;}};MorphBlendMesh.prototype.getAnimationTime=function(name){var time=0;var animation=this.animationsMap[name];if(animation){time=animation.time;}return time;};MorphBlendMesh.prototype.getAnimationDuration=function(name){var duration=-1;var animation=this.animationsMap[name];if(animation){duration=animation.duration;}return duration;};MorphBlendMesh.prototype.playAnimation=function(name){var animation=this.animationsMap[name];if(animation){animation.time=0;animation.active=true;}else{console.warn("THREE.MorphBlendMesh: animation["+name+"] undefined in .playAnimation()");}};MorphBlendMesh.prototype.stopAnimation=function(name){var animation=this.animationsMap[name];if(animation){animation.active=false;}};MorphBlendMesh.prototype.update=function(delta){for(var i=0,il=this.animationsList.length;i<il;i++){var animation=this.animationsList[i];if(!animation.active)continue;var frameTime=animation.duration/animation.length;animation.time+=animation.direction*delta;if(animation.mirroredLoop){if(animation.time>animation.duration||animation.time<0){animation.direction*=-1;if(animation.time>animation.duration){animation.time=animation.duration;animation.directionBackwards=true;}if(animation.time<0){animation.time=0;animation.directionBackwards=false;}}}else{animation.time=animation.time%animation.duration;if(animation.time<0)animation.time+=animation.duration;}var keyframe=animation.start+_Math.clamp(Math.floor(animation.time/frameTime),0,animation.length-1);var weight=animation.weight;if(keyframe!==animation.currentFrame){this.morphTargetInfluences[animation.lastFrame]=0;this.morphTargetInfluences[animation.currentFrame]=1*weight;this.morphTargetInfluences[keyframe]=0;animation.lastFrame=animation.currentFrame;animation.currentFrame=keyframe;}var mix=animation.time%frameTime/frameTime;if(animation.directionBackwards)mix=1-mix;if(animation.currentFrame!==animation.lastFrame){this.morphTargetInfluences[animation.currentFrame]=mix*weight;this.morphTargetInfluences[animation.lastFrame]=(1-mix)*weight;}else{this.morphTargetInfluences[animation.currentFrame]=weight;}}};/**
	 * @author alteredq / http://alteredqualia.com/
	 */function ImmediateRenderObject(material){Object3D.call(this);this.material=material;this.render=function(renderCallback){};}ImmediateRenderObject.prototype=(0,_create2.default)(Object3D.prototype);ImmediateRenderObject.prototype.constructor=ImmediateRenderObject;ImmediateRenderObject.prototype.isImmediateRenderObject=true;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/function VertexNormalsHelper(object,size,hex,linewidth){this.object=object;this.size=size!==undefined?size:1;var color=hex!==undefined?hex:0xff0000;var width=linewidth!==undefined?linewidth:1;//
var nNormals=0;var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){nNormals=objGeometry.faces.length*3;}else if(objGeometry&&objGeometry.isBufferGeometry){nNormals=objGeometry.attributes.normal.count;}//
var geometry=new BufferGeometry();var positions=new Float32BufferAttribute(nNormals*2*3,3);geometry.addAttribute('position',positions);LineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));//
this.matrixAutoUpdate=false;this.update();}VertexNormalsHelper.prototype=(0,_create2.default)(LineSegments.prototype);VertexNormalsHelper.prototype.constructor=VertexNormalsHelper;VertexNormalsHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var normalMatrix=new Matrix3();return function update(){var keys=['a','b','c'];this.object.updateMatrixWorld(true);normalMatrix.getNormalMatrix(this.object.matrixWorld);var matrixWorld=this.object.matrixWorld;var position=this.geometry.attributes.position;//
var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){var vertices=objGeometry.vertices;var faces=objGeometry.faces;var idx=0;for(var i=0,l=faces.length;i<l;i++){var face=faces[i];for(var j=0,jl=face.vertexNormals.length;j<jl;j++){var vertex=vertices[face[keys[j]]];var normal=face.vertexNormals[j];v1.copy(vertex).applyMatrix4(matrixWorld);v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}}}else if(objGeometry&&objGeometry.isBufferGeometry){var objPos=objGeometry.attributes.position;var objNorm=objGeometry.attributes.normal;var idx=0;// for simplicity, ignore index and drawcalls, and render every normal
for(var j=0,jl=objPos.count;j<jl;j++){v1.set(objPos.getX(j),objPos.getY(j),objPos.getZ(j)).applyMatrix4(matrixWorld);v2.set(objNorm.getX(j),objNorm.getY(j),objNorm.getZ(j));v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}}position.needsUpdate=true;return this;};}();/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/function SpotLightHelper(light){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;var geometry=new BufferGeometry();var positions=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(var i=0,j=1,l=32;i<l;i++,j++){var p1=i/l*Math.PI*2;var p2=j/l*Math.PI*2;positions.push(Math.cos(p1),Math.sin(p1),1,Math.cos(p2),Math.sin(p2),1);}geometry.addAttribute('position',new Float32BufferAttribute(positions,3));var material=new LineBasicMaterial({fog:false});this.cone=new LineSegments(geometry,material);this.add(this.cone);this.update();}SpotLightHelper.prototype=(0,_create2.default)(Object3D.prototype);SpotLightHelper.prototype.constructor=SpotLightHelper;SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose();};SpotLightHelper.prototype.update=function(){var vector=new Vector3();var vector2=new Vector3();return function update(){var coneLength=this.light.distance?this.light.distance:1000;var coneWidth=coneLength*Math.tan(this.light.angle);this.cone.scale.set(coneWidth,coneWidth,coneLength);vector.setFromMatrixPosition(this.light.matrixWorld);vector2.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(vector2.sub(vector));this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);};}();/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */function SkeletonHelper(object){this.bones=this.getBoneList(object);var geometry=new BufferGeometry();var vertices=[];var colors=[];var color1=new Color(0,0,1);var color2=new Color(0,1,0);for(var i=0;i<this.bones.length;i++){var bone=this.bones[i];if(bone.parent&&bone.parent.isBone){vertices.push(0,0,0);vertices.push(0,0,0);colors.push(color1.r,color1.g,color1.b);colors.push(color2.r,color2.g,color2.b);}}geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors,depthTest:false,depthWrite:false,transparent:true});LineSegments.call(this,geometry,material);this.root=object;this.matrix=object.matrixWorld;this.matrixAutoUpdate=false;this.update();}SkeletonHelper.prototype=(0,_create2.default)(LineSegments.prototype);SkeletonHelper.prototype.constructor=SkeletonHelper;SkeletonHelper.prototype.getBoneList=function(object){var boneList=[];if(object&&object.isBone){boneList.push(object);}for(var i=0;i<object.children.length;i++){boneList.push.apply(boneList,this.getBoneList(object.children[i]));}return boneList;};SkeletonHelper.prototype.update=function(){var vector=new Vector3();var boneMatrix=new Matrix4();var matrixWorldInv=new Matrix4();return function update(){var geometry=this.geometry;var position=geometry.getAttribute('position');matrixWorldInv.getInverse(this.root.matrixWorld);for(var i=0,j=0;i<this.bones.length;i++){var bone=this.bones[i];if(bone.parent&&bone.parent.isBone){boneMatrix.multiplyMatrices(matrixWorldInv,bone.matrixWorld);vector.setFromMatrixPosition(boneMatrix);position.setXYZ(j,vector.x,vector.y,vector.z);boneMatrix.multiplyMatrices(matrixWorldInv,bone.parent.matrixWorld);vector.setFromMatrixPosition(boneMatrix);position.setXYZ(j+1,vector.x,vector.y,vector.z);j+=2;}}geometry.getAttribute('position').needsUpdate=true;};}();/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */function PointLightHelper(light,sphereSize){this.light=light;this.light.updateMatrixWorld();var geometry=new SphereBufferGeometry(sphereSize,4,2);var material=new MeshBasicMaterial({wireframe:true,fog:false});material.color.copy(this.light.color).multiplyScalar(this.light.intensity);Mesh.call(this,geometry,material);this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=false;/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/}PointLightHelper.prototype=(0,_create2.default)(Mesh.prototype);PointLightHelper.prototype.constructor=PointLightHelper;PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose();};PointLightHelper.prototype.update=function(){this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/};/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 */function RectAreaLightHelper(light){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();var materialFront=new MeshBasicMaterial({color:light.color,fog:false});var materialBack=new MeshBasicMaterial({color:light.color,fog:false,wireframe:true});var geometry=new BufferGeometry();geometry.addAttribute('position',new BufferAttribute(new Float32Array(6*3),3));// shows the "front" of the light, e.g. where light comes from
this.add(new Mesh(geometry,materialFront));// shows the "back" of the light, which does not emit light
this.add(new Mesh(geometry,materialBack));this.update();}RectAreaLightHelper.prototype=(0,_create2.default)(Object3D.prototype);RectAreaLightHelper.prototype.constructor=RectAreaLightHelper;RectAreaLightHelper.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose();this.children[1].geometry.dispose();this.children[1].material.dispose();};RectAreaLightHelper.prototype.update=function(){var vector1=new Vector3();var vector2=new Vector3();return function update(){var mesh1=this.children[0];var mesh2=this.children[1];if(this.light.target){vector1.setFromMatrixPosition(this.light.matrixWorld);vector2.setFromMatrixPosition(this.light.target.matrixWorld);var lookVec=vector2.clone().sub(vector1);mesh1.lookAt(lookVec);mesh2.lookAt(lookVec);}// update materials
mesh1.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);mesh2.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);// calculate new dimensions of the helper
var hx=this.light.width*0.5;var hy=this.light.height*0.5;// because the buffer attribute is shared over both geometries, we only have to update once
var position=mesh1.geometry.getAttribute('position');var array=position.array;// first face
array[0]=hx;array[1]=-hy;array[2]=0;array[3]=hx;array[4]=hy;array[5]=0;array[6]=-hx;array[7]=hy;array[8]=0;// second face
array[9]=-hx;array[10]=hy;array[11]=0;array[12]=-hx;array[13]=-hy;array[14]=0;array[15]=hx;array[16]=-hy;array[17]=0;position.needsUpdate=true;};}();/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */function HemisphereLightHelper(light,size){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;var geometry=new OctahedronBufferGeometry(size);geometry.rotateY(Math.PI*0.5);var material=new MeshBasicMaterial({vertexColors:VertexColors,wireframe:true});var position=geometry.getAttribute('position');var colors=new Float32Array(position.count*3);geometry.addAttribute('color',new BufferAttribute(colors,3));this.add(new Mesh(geometry,material));this.update();}HemisphereLightHelper.prototype=(0,_create2.default)(Object3D.prototype);HemisphereLightHelper.prototype.constructor=HemisphereLightHelper;HemisphereLightHelper.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose();};HemisphereLightHelper.prototype.update=function(){var vector=new Vector3();var color1=new Color();var color2=new Color();return function update(){var mesh=this.children[0];var colors=mesh.geometry.getAttribute('color');color1.copy(this.light.color).multiplyScalar(this.light.intensity);color2.copy(this.light.groundColor).multiplyScalar(this.light.intensity);for(var i=0,l=colors.count;i<l;i++){var color=i<l/2?color1:color2;colors.setXYZ(i,color.r,color.g,color.b);}mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());colors.needsUpdate=true;};}();/**
	 * @author mrdoob / http://mrdoob.com/
	 */function GridHelper(size,divisions,color1,color2){size=size||10;divisions=divisions||10;color1=new Color(color1!==undefined?color1:0x444444);color2=new Color(color2!==undefined?color2:0x888888);var center=divisions/2;var step=size*2/divisions;var vertices=[],colors=[];for(var i=0,j=0,k=-size;i<=divisions;i++,k+=step){vertices.push(-size,0,k,size,0,k);vertices.push(k,0,-size,k,0,size);var color=i===center?color1:color2;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;}var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}GridHelper.prototype=(0,_create2.default)(LineSegments.prototype);GridHelper.prototype.constructor=GridHelper;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author Hectate / http://www.github.com/Hectate
	 */function PolarGridHelper(radius,radials,circles,divisions,color1,color2){radius=radius||10;radials=radials||16;circles=circles||8;divisions=divisions||64;color1=new Color(color1!==undefined?color1:0x444444);color2=new Color(color2!==undefined?color2:0x888888);var vertices=[];var colors=[];var x,z;var v,i,j,r,color;// create the radials
for(i=0;i<=radials;i++){v=i/radials*(Math.PI*2);x=Math.sin(v)*radius;z=Math.cos(v)*radius;vertices.push(0,0,0);vertices.push(x,0,z);color=i&1?color1:color2;colors.push(color.r,color.g,color.b);colors.push(color.r,color.g,color.b);}// create the circles
for(i=0;i<=circles;i++){color=i&1?color1:color2;r=radius-radius/circles*i;for(j=0;j<divisions;j++){// first vertex
v=j/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);// second vertex
v=(j+1)/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);}}var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}PolarGridHelper.prototype=(0,_create2.default)(LineSegments.prototype);PolarGridHelper.prototype.constructor=PolarGridHelper;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/function FaceNormalsHelper(object,size,hex,linewidth){// FaceNormalsHelper only supports THREE.Geometry
this.object=object;this.size=size!==undefined?size:1;var color=hex!==undefined?hex:0xffff00;var width=linewidth!==undefined?linewidth:1;//
var nNormals=0;var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){nNormals=objGeometry.faces.length;}else{console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');}//
var geometry=new BufferGeometry();var positions=new Float32BufferAttribute(nNormals*2*3,3);geometry.addAttribute('position',positions);LineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));//
this.matrixAutoUpdate=false;this.update();}FaceNormalsHelper.prototype=(0,_create2.default)(LineSegments.prototype);FaceNormalsHelper.prototype.constructor=FaceNormalsHelper;FaceNormalsHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var normalMatrix=new Matrix3();return function update(){this.object.updateMatrixWorld(true);normalMatrix.getNormalMatrix(this.object.matrixWorld);var matrixWorld=this.object.matrixWorld;var position=this.geometry.attributes.position;//
var objGeometry=this.object.geometry;var vertices=objGeometry.vertices;var faces=objGeometry.faces;var idx=0;for(var i=0,l=faces.length;i<l;i++){var face=faces[i];var normal=face.normal;v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}position.needsUpdate=true;return this;};}();/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */function DirectionalLightHelper(light,size){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;if(size===undefined)size=1;var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute([-size,size,0,size,size,0,size,-size,0,-size,-size,0,-size,size,0],3));var material=new LineBasicMaterial({fog:false});this.add(new Line(geometry,material));geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,0,1],3));this.add(new Line(geometry,material));this.update();}DirectionalLightHelper.prototype=(0,_create2.default)(Object3D.prototype);DirectionalLightHelper.prototype.constructor=DirectionalLightHelper;DirectionalLightHelper.prototype.isDirectionalLightHeper=true;DirectionalLightHelper.prototype.dispose=function(){var lightPlane=this.children[0];var targetLine=this.children[1];lightPlane.geometry.dispose();lightPlane.material.dispose();targetLine.geometry.dispose();targetLine.material.dispose();};DirectionalLightHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var v3=new Vector3();return function update(){v1.setFromMatrixPosition(this.light.matrixWorld);v2.setFromMatrixPosition(this.light.target.matrixWorld);v3.subVectors(v2,v1);var lightPlane=this.children[0];var targetLine=this.children[1];lightPlane.lookAt(v3);lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);targetLine.lookAt(v3);targetLine.scale.z=v3.length();};}();/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */function CameraHelper(camera){var geometry=new BufferGeometry();var material=new LineBasicMaterial({color:0xffffff,vertexColors:FaceColors});var vertices=[];var colors=[];var pointMap={};// colors
var colorFrustum=new Color(0xffaa00);var colorCone=new Color(0xff0000);var colorUp=new Color(0x00aaff);var colorTarget=new Color(0xffffff);var colorCross=new Color(0x333333);// near
addLine("n1","n2",colorFrustum);addLine("n2","n4",colorFrustum);addLine("n4","n3",colorFrustum);addLine("n3","n1",colorFrustum);// far
addLine("f1","f2",colorFrustum);addLine("f2","f4",colorFrustum);addLine("f4","f3",colorFrustum);addLine("f3","f1",colorFrustum);// sides
addLine("n1","f1",colorFrustum);addLine("n2","f2",colorFrustum);addLine("n3","f3",colorFrustum);addLine("n4","f4",colorFrustum);// cone
addLine("p","n1",colorCone);addLine("p","n2",colorCone);addLine("p","n3",colorCone);addLine("p","n4",colorCone);// up
addLine("u1","u2",colorUp);addLine("u2","u3",colorUp);addLine("u3","u1",colorUp);// target
addLine("c","t",colorTarget);addLine("p","c",colorCross);// cross
addLine("cn1","cn2",colorCross);addLine("cn3","cn4",colorCross);addLine("cf1","cf2",colorCross);addLine("cf3","cf4",colorCross);function addLine(a,b,color){addPoint(a,color);addPoint(b,color);}function addPoint(id,color){vertices.push(0,0,0);colors.push(color.r,color.g,color.b);if(pointMap[id]===undefined){pointMap[id]=[];}pointMap[id].push(vertices.length/3-1);}geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));LineSegments.call(this,geometry,material);this.camera=camera;if(this.camera.updateProjectionMatrix)this.camera.updateProjectionMatrix();this.matrix=camera.matrixWorld;this.matrixAutoUpdate=false;this.pointMap=pointMap;this.update();}CameraHelper.prototype=(0,_create2.default)(LineSegments.prototype);CameraHelper.prototype.constructor=CameraHelper;CameraHelper.prototype.isCameraHelper=true;CameraHelper.prototype.update=function(){var geometry,pointMap;var vector=new Vector3();var camera=new Camera();function setPoint(point,x,y,z){vector.set(x,y,z).unproject(camera);var points=pointMap[point];if(points!==undefined){var position=geometry.getAttribute('position');for(var i=0,l=points.length;i<l;i++){position.setXYZ(points[i],vector.x,vector.y,vector.z);}}}return function update(){geometry=this.geometry;pointMap=this.pointMap;var w=1,h=1;// we need just camera projection matrix
// world matrix must be identity
camera.projectionMatrix.copy(this.camera.projectionMatrix);// center / target
setPoint("c",0,0,-1);setPoint("t",0,0,1);// near
setPoint("n1",-w,-h,-1);setPoint("n2",w,-h,-1);setPoint("n3",-w,h,-1);setPoint("n4",w,h,-1);// far
setPoint("f1",-w,-h,1);setPoint("f2",w,-h,1);setPoint("f3",-w,h,1);setPoint("f4",w,h,1);// up
setPoint("u1",w*0.7,h*1.1,-1);setPoint("u2",-w*0.7,h*1.1,-1);setPoint("u3",0,h*2,-1);// cross
setPoint("cf1",-w,0,1);setPoint("cf2",w,0,1);setPoint("cf3",0,-h,1);setPoint("cf4",0,h,1);setPoint("cn1",-w,0,-1);setPoint("cn2",w,0,-1);setPoint("cn3",0,-h,-1);setPoint("cn4",0,h,-1);geometry.getAttribute('position').needsUpdate=true;};}();/**
	 * @author mrdoob / http://mrdoob.com/
	 */function BoxHelper(object,color){if(color===undefined)color=0xffff00;var indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var positions=new Float32Array(8*3);var geometry=new BufferGeometry();geometry.setIndex(new BufferAttribute(indices,1));geometry.addAttribute('position',new BufferAttribute(positions,3));LineSegments.call(this,geometry,new LineBasicMaterial({color:color}));if(object!==undefined){this.update(object);}}BoxHelper.prototype=(0,_create2.default)(LineSegments.prototype);BoxHelper.prototype.constructor=BoxHelper;BoxHelper.prototype.update=function(){var box=new Box3();return function update(object){if(object&&object.isBox3){box.copy(object);}else{box.setFromObject(object);}if(box.isEmpty())return;var min=box.min;var max=box.max;/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/var position=this.geometry.attributes.position;var array=position.array;array[0]=max.x;array[1]=max.y;array[2]=max.z;array[3]=min.x;array[4]=max.y;array[5]=max.z;array[6]=min.x;array[7]=min.y;array[8]=max.z;array[9]=max.x;array[10]=min.y;array[11]=max.z;array[12]=max.x;array[13]=max.y;array[14]=min.z;array[15]=min.x;array[16]=max.y;array[17]=min.z;array[18]=min.x;array[19]=min.y;array[20]=min.z;array[21]=max.x;array[22]=min.y;array[23]=min.z;position.needsUpdate=true;this.geometry.computeBoundingSphere();};}();/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */var lineGeometry=new BufferGeometry();lineGeometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,1,0],3));var coneGeometry=new CylinderBufferGeometry(0,0.5,1,5,1);coneGeometry.translate(0,-0.5,0);function ArrowHelper(dir,origin,length,color,headLength,headWidth){// dir is assumed to be normalized
Object3D.call(this);if(color===undefined)color=0xffff00;if(length===undefined)length=1;if(headLength===undefined)headLength=0.2*length;if(headWidth===undefined)headWidth=0.2*headLength;this.position.copy(origin);this.line=new Line(lineGeometry,new LineBasicMaterial({color:color}));this.line.matrixAutoUpdate=false;this.add(this.line);this.cone=new Mesh(coneGeometry,new MeshBasicMaterial({color:color}));this.cone.matrixAutoUpdate=false;this.add(this.cone);this.setDirection(dir);this.setLength(length,headLength,headWidth);}ArrowHelper.prototype=(0,_create2.default)(Object3D.prototype);ArrowHelper.prototype.constructor=ArrowHelper;ArrowHelper.prototype.setDirection=function(){var axis=new Vector3();var radians;return function setDirection(dir){// dir is assumed to be normalized
if(dir.y>0.99999){this.quaternion.set(0,0,0,1);}else if(dir.y<-0.99999){this.quaternion.set(1,0,0,0);}else{axis.set(dir.z,0,-dir.x).normalize();radians=Math.acos(dir.y);this.quaternion.setFromAxisAngle(axis,radians);}};}();ArrowHelper.prototype.setLength=function(length,headLength,headWidth){if(headLength===undefined)headLength=0.2*length;if(headWidth===undefined)headWidth=0.2*headLength;this.line.scale.set(1,Math.max(0,length-headLength),1);this.line.updateMatrix();this.cone.scale.set(headWidth,headLength,headWidth);this.cone.position.y=length;this.cone.updateMatrix();};ArrowHelper.prototype.setColor=function(color){this.line.material.color.copy(color);this.cone.material.color.copy(color);};/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */function AxisHelper(size){size=size||1;var vertices=[0,0,0,size,0,0,0,0,0,0,size,0,0,0,0,0,0,size];var colors=[1,0,0,1,0.6,0,0,1,0,0.6,1,0,0,0,1,0,0.6,1];var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}AxisHelper.prototype=(0,_create2.default)(LineSegments.prototype);AxisHelper.prototype.constructor=AxisHelper;/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 *//*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/function CubicPoly(){var c0=0,c1=0,c2=0,c3=0;/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */function init(x0,x1,t0,t1){c0=x0;c1=t0;c2=-3*x0+3*x1-2*t0-t1;c3=2*x0-2*x1+t0+t1;}return{initCatmullRom:function initCatmullRom(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1));},initNonuniformCatmullRom:function initNonuniformCatmullRom(x0,x1,x2,x3,dt0,dt1,dt2){// compute tangents when parameterized in [t1,t2]
var t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;var t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;// rescale tangents for parametrization in [0,1]
t1*=dt1;t2*=dt1;init(x1,x2,t1,t2);},calc:function calc(t){var t2=t*t;var t3=t2*t;return c0+c1*t+c2*t2+c3*t3;}};}//
var tmp=new Vector3();var px=new CubicPoly();var py=new CubicPoly();var pz=new CubicPoly();function CatmullRomCurve3(p/* array of Vector3 */){this.points=p||[];this.closed=false;}CatmullRomCurve3.prototype=(0,_create2.default)(Curve.prototype);CatmullRomCurve3.prototype.constructor=CatmullRomCurve3;CatmullRomCurve3.prototype.getPoint=function(t){var points=this.points;var l=points.length;if(l<2)console.log('duh, you need at least 2 points');var point=(l-(this.closed?0:1))*t;var intPoint=Math.floor(point);var weight=point-intPoint;if(this.closed){intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/points.length)+1)*points.length;}else if(weight===0&&intPoint===l-1){intPoint=l-2;weight=1;}var p0,p1,p2,p3;// 4 points
if(this.closed||intPoint>0){p0=points[(intPoint-1)%l];}else{// extrapolate first point
tmp.subVectors(points[0],points[1]).add(points[0]);p0=tmp;}p1=points[intPoint%l];p2=points[(intPoint+1)%l];if(this.closed||intPoint+2<l){p3=points[(intPoint+2)%l];}else{// extrapolate last point
tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);p3=tmp;}if(this.type===undefined||this.type==='centripetal'||this.type==='chordal'){// init Centripetal / Chordal Catmull-Rom
var pow=this.type==='chordal'?0.5:0.25;var dt0=Math.pow(p0.distanceToSquared(p1),pow);var dt1=Math.pow(p1.distanceToSquared(p2),pow);var dt2=Math.pow(p2.distanceToSquared(p3),pow);// safety check for repeated points
if(dt1<1e-4)dt1=1.0;if(dt0<1e-4)dt0=dt1;if(dt2<1e-4)dt2=dt1;px.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);}else if(this.type==='catmullrom'){var tension=this.tension!==undefined?this.tension:0.5;px.initCatmullRom(p0.x,p1.x,p2.x,p3.x,tension);py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,tension);pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,tension);}return new Vector3(px.calc(weight),py.calc(weight),pz.calc(weight));};function CubicBezierCurve3(v0,v1,v2,v3){this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}CubicBezierCurve3.prototype=(0,_create2.default)(Curve.prototype);CubicBezierCurve3.prototype.constructor=CubicBezierCurve3;CubicBezierCurve3.prototype.getPoint=function(t){var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;return new Vector3(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y),CubicBezier(t,v0.z,v1.z,v2.z,v3.z));};function QuadraticBezierCurve3(v0,v1,v2){this.v0=v0;this.v1=v1;this.v2=v2;}QuadraticBezierCurve3.prototype=(0,_create2.default)(Curve.prototype);QuadraticBezierCurve3.prototype.constructor=QuadraticBezierCurve3;QuadraticBezierCurve3.prototype.getPoint=function(t){var v0=this.v0,v1=this.v1,v2=this.v2;return new Vector3(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y),QuadraticBezier(t,v0.z,v1.z,v2.z));};function LineCurve3(v1,v2){this.v1=v1;this.v2=v2;}LineCurve3.prototype=(0,_create2.default)(Curve.prototype);LineCurve3.prototype.constructor=LineCurve3;LineCurve3.prototype.getPoint=function(t){if(t===1){return this.v2.clone();}var vector=new Vector3();vector.subVectors(this.v2,this.v1);// diff
vector.multiplyScalar(t);vector.add(this.v1);return vector;};function ArcCurve(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){EllipseCurve.call(this,aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);}ArcCurve.prototype=(0,_create2.default)(EllipseCurve.prototype);ArcCurve.prototype.constructor=ArcCurve;/**
	 * @author alteredq / http://alteredqualia.com/
	 */var SceneUtils={createMultiMaterialObject:function createMultiMaterialObject(geometry,materials){var group=new Group();for(var i=0,l=materials.length;i<l;i++){group.add(new Mesh(geometry,materials[i]));}return group;},detach:function detach(child,parent,scene){child.applyMatrix(parent.matrixWorld);parent.remove(child);scene.add(child);},attach:function attach(child,scene,parent){var matrixWorldInverse=new Matrix4();matrixWorldInverse.getInverse(parent.matrixWorld);child.applyMatrix(matrixWorldInverse);scene.remove(child);parent.add(child);}};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Face4(a,b,c,d,normal,color,materialIndex){console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');return new Face3(a,b,c,normal,color,materialIndex);}var LineStrip=0;var LinePieces=1;function MeshFaceMaterial(materials){console.warn('THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial.');return new MultiMaterial(materials);}function PointCloud(geometry,material){console.warn('THREE.PointCloud has been renamed to THREE.Points.');return new Points(geometry,material);}function Particle(material){console.warn('THREE.Particle has been renamed to THREE.Sprite.');return new Sprite(material);}function ParticleSystem(geometry,material){console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');return new Points(geometry,material);}function PointCloudMaterial(parameters){console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function ParticleBasicMaterial(parameters){console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function ParticleSystemMaterial(parameters){console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function Vertex(x,y,z){console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');return new Vector3(x,y,z);}//
function DynamicBufferAttribute(array,itemSize){console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');return new BufferAttribute(array,itemSize).setDynamic(true);}function Int8Attribute(array,itemSize){console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');return new Int8BufferAttribute(array,itemSize);}function Uint8Attribute(array,itemSize){console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');return new Uint8BufferAttribute(array,itemSize);}function Uint8ClampedAttribute(array,itemSize){console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');return new Uint8ClampedBufferAttribute(array,itemSize);}function Int16Attribute(array,itemSize){console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');return new Int16BufferAttribute(array,itemSize);}function Uint16Attribute(array,itemSize){console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');return new Uint16BufferAttribute(array,itemSize);}function Int32Attribute(array,itemSize){console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');return new Int32BufferAttribute(array,itemSize);}function Uint32Attribute(array,itemSize){console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');return new Uint32BufferAttribute(array,itemSize);}function Float32Attribute(array,itemSize){console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');return new Float32BufferAttribute(array,itemSize);}function Float64Attribute(array,itemSize){console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');return new Float64BufferAttribute(array,itemSize);}//
Curve.create=function(construct,getPoint){console.log('THREE.Curve.create() has been deprecated');construct.prototype=(0,_create2.default)(Curve.prototype);construct.prototype.constructor=construct;construct.prototype.getPoint=getPoint;return construct;};//
function ClosedSplineCurve3(points){console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';this.closed=true;}ClosedSplineCurve3.prototype=(0,_create2.default)(CatmullRomCurve3.prototype);//
function SplineCurve3(points){console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';}SplineCurve3.prototype=(0,_create2.default)(CatmullRomCurve3.prototype);//
function Spline(points){console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';}Spline.prototype=(0,_create2.default)(CatmullRomCurve3.prototype);(0,_assign2.default)(Spline.prototype,{initFromArray:function initFromArray(a){console.error('THREE.Spline: .initFromArray() has been removed.');},getControlPointsArray:function getControlPointsArray(optionalTarget){console.error('THREE.Spline: .getControlPointsArray() has been removed.');},reparametrizeByArcLength:function reparametrizeByArcLength(samplingCoef){console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');}});//
function BoundingBoxHelper(object,color){console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');return new BoxHelper(object,color);}function EdgesHelper(object,hex){console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');return new LineSegments(new EdgesGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));}GridHelper.prototype.setColors=function(){console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');};function WireframeHelper(object,hex){console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');return new LineSegments(new WireframeGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));}//
function XHRLoader(manager){console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');return new FileLoader(manager);}function BinaryTextureLoader(manager){console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');return new DataTextureLoader(manager);}//
(0,_assign2.default)(Box2.prototype,{center:function center(optionalTarget){console.warn('THREE.Box2: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);},empty:function empty(){console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');return this.isEmpty();},isIntersectionBox:function isIntersectionBox(box){console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},size:function size(optionalTarget){console.warn('THREE.Box2: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);}});(0,_assign2.default)(Box3.prototype,{center:function center(optionalTarget){console.warn('THREE.Box3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);},empty:function empty(){console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');return this.isEmpty();},isIntersectionBox:function isIntersectionBox(box){console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},isIntersectionSphere:function isIntersectionSphere(sphere){console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);},size:function size(optionalTarget){console.warn('THREE.Box3: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);}});Line3.prototype.center=function(optionalTarget){console.warn('THREE.Line3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};_Math.random16=function(){console.warn('THREE.Math.random16() has been deprecated. Use Math.random() instead.');return Math.random();};(0,_assign2.default)(Matrix3.prototype,{flattenToArrayOffset:function flattenToArrayOffset(array,offset){console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(array,offset);},multiplyVector3:function multiplyVector3(vector){console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');return vector.applyMatrix3(this);},multiplyVector3Array:function multiplyVector3Array(a){console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');return this.applyToVector3Array(a);},applyToBuffer:function applyToBuffer(buffer,offset,length){console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');return this.applyToBufferAttribute(buffer);},applyToVector3Array:function applyToVector3Array(array,offset,length){console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');}});(0,_assign2.default)(Matrix4.prototype,{extractPosition:function extractPosition(m){console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');return this.copyPosition(m);},flattenToArrayOffset:function flattenToArrayOffset(array,offset){console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(array,offset);},getPosition:function(){var v1;return function getPosition(){if(v1===undefined)v1=new Vector3();console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');return v1.setFromMatrixColumn(this,3);};}(),setRotationFromQuaternion:function setRotationFromQuaternion(q){console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');return this.makeRotationFromQuaternion(q);},multiplyVector3:function multiplyVector3(vector){console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},multiplyVector4:function multiplyVector4(vector){console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},multiplyVector3Array:function multiplyVector3Array(a){console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');return this.applyToVector3Array(a);},rotateAxis:function rotateAxis(v){console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');v.transformDirection(this);},crossVector:function crossVector(vector){console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},translate:function translate(){console.error('THREE.Matrix4: .translate() has been removed.');},rotateX:function rotateX(){console.error('THREE.Matrix4: .rotateX() has been removed.');},rotateY:function rotateY(){console.error('THREE.Matrix4: .rotateY() has been removed.');},rotateZ:function rotateZ(){console.error('THREE.Matrix4: .rotateZ() has been removed.');},rotateByAxis:function rotateByAxis(){console.error('THREE.Matrix4: .rotateByAxis() has been removed.');},applyToBuffer:function applyToBuffer(buffer,offset,length){console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');return this.applyToBufferAttribute(buffer);},applyToVector3Array:function applyToVector3Array(array,offset,length){console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');},makeFrustum:function makeFrustum(left,right,bottom,top,near,far){console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');return this.makePerspective(left,right,top,bottom,near,far);}});Plane.prototype.isIntersectionLine=function(line){console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');return this.intersectsLine(line);};Quaternion.prototype.multiplyVector3=function(vector){console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');return vector.applyQuaternion(this);};(0,_assign2.default)(Ray.prototype,{isIntersectionBox:function isIntersectionBox(box){console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},isIntersectionPlane:function isIntersectionPlane(plane){console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');return this.intersectsPlane(plane);},isIntersectionSphere:function isIntersectionSphere(sphere){console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);}});(0,_assign2.default)(Shape.prototype,{extrude:function extrude(options){console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');return new ExtrudeGeometry(this,options);},makeGeometry:function makeGeometry(options){console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');return new ShapeGeometry(this,options);}});(0,_assign2.default)(Vector2.prototype,{fromAttribute:function fromAttribute(attribute,index,offset){console.error('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);}});(0,_assign2.default)(Vector3.prototype,{setEulerFromRotationMatrix:function setEulerFromRotationMatrix(){console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');},setEulerFromQuaternion:function setEulerFromQuaternion(){console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');},getPositionFromMatrix:function getPositionFromMatrix(m){console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');return this.setFromMatrixPosition(m);},getScaleFromMatrix:function getScaleFromMatrix(m){console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');return this.setFromMatrixScale(m);},getColumnFromMatrix:function getColumnFromMatrix(index,matrix){console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');return this.setFromMatrixColumn(matrix,index);},applyProjection:function applyProjection(m){console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');return this.applyMatrix4(m);},fromAttribute:function fromAttribute(attribute,index,offset){console.error('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);}});(0,_assign2.default)(Vector4.prototype,{fromAttribute:function fromAttribute(attribute,index,offset){console.error('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);}});//
Geometry.prototype.computeTangents=function(){console.warn('THREE.Geometry: .computeTangents() has been removed.');};(0,_assign2.default)(Object3D.prototype,{getChildByName:function getChildByName(name){console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');return this.getObjectByName(name);},renderDepth:function renderDepth(){console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');},translate:function translate(distance,axis){console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');return this.translateOnAxis(axis,distance);}});(0,_defineProperties2.default)(Object3D.prototype,{eulerOrder:{get:function get(){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');return this.rotation.order;},set:function set(value){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');this.rotation.order=value;}},useQuaternion:{get:function get(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');},set:function set(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');}}});(0,_defineProperties2.default)(LOD.prototype,{objects:{get:function get(){console.warn('THREE.LOD: .objects has been renamed to .levels.');return this.levels;}}});//
PerspectiveCamera.prototype.setLens=function(focalLength,filmGauge){console.warn("THREE.PerspectiveCamera.setLens is deprecated. "+"Use .setFocalLength and .filmGauge for a photographic setup.");if(filmGauge!==undefined)this.filmGauge=filmGauge;this.setFocalLength(focalLength);};//
(0,_defineProperties2.default)(Light.prototype,{onlyShadow:{set:function set(){console.warn('THREE.Light: .onlyShadow has been removed.');}},shadowCameraFov:{set:function set(value){console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');this.shadow.camera.fov=value;}},shadowCameraLeft:{set:function set(value){console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');this.shadow.camera.left=value;}},shadowCameraRight:{set:function set(value){console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');this.shadow.camera.right=value;}},shadowCameraTop:{set:function set(value){console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');this.shadow.camera.top=value;}},shadowCameraBottom:{set:function set(value){console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');this.shadow.camera.bottom=value;}},shadowCameraNear:{set:function set(value){console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');this.shadow.camera.near=value;}},shadowCameraFar:{set:function set(value){console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');this.shadow.camera.far=value;}},shadowCameraVisible:{set:function set(){console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');}},shadowBias:{set:function set(value){console.warn('THREE.Light: .shadowBias is now .shadow.bias.');this.shadow.bias=value;}},shadowDarkness:{set:function set(){console.warn('THREE.Light: .shadowDarkness has been removed.');}},shadowMapWidth:{set:function set(value){console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');this.shadow.mapSize.width=value;}},shadowMapHeight:{set:function set(value){console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');this.shadow.mapSize.height=value;}}});//
(0,_defineProperties2.default)(BufferAttribute.prototype,{length:{get:function get(){console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');return this.array.length;}}});(0,_assign2.default)(BufferGeometry.prototype,{addIndex:function addIndex(index){console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');this.setIndex(index);},addDrawCall:function addDrawCall(start,count,indexOffset){if(indexOffset!==undefined){console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');}console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');this.addGroup(start,count);},clearDrawCalls:function clearDrawCalls(){console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');this.clearGroups();},computeTangents:function computeTangents(){console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');},computeOffsets:function computeOffsets(){console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');}});(0,_defineProperties2.default)(BufferGeometry.prototype,{drawcalls:{get:function get(){console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');return this.groups;}},offsets:{get:function get(){console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');return this.groups;}}});//
(0,_defineProperties2.default)(Uniform.prototype,{dynamic:{set:function set(){console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');}},onUpdate:{value:function value(){console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');return this;}}});//
(0,_defineProperties2.default)(Material.prototype,{wrapAround:{get:function get(){console.warn('THREE.'+this.type+': .wrapAround has been removed.');},set:function set(){console.warn('THREE.'+this.type+': .wrapAround has been removed.');}},wrapRGB:{get:function get(){console.warn('THREE.'+this.type+': .wrapRGB has been removed.');return new Color();}}});(0,_defineProperties2.default)(MeshPhongMaterial.prototype,{metal:{get:function get(){console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');return false;},set:function set(){console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');}}});(0,_defineProperties2.default)(ShaderMaterial.prototype,{derivatives:{get:function get(){console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');return this.extensions.derivatives;},set:function set(value){console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');this.extensions.derivatives=value;}}});//
(0,_assign2.default)(WebGLRenderer.prototype,{supportsFloatTextures:function supportsFloatTextures(){console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');return this.extensions.get('OES_texture_float');},supportsHalfFloatTextures:function supportsHalfFloatTextures(){console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');return this.extensions.get('OES_texture_half_float');},supportsStandardDerivatives:function supportsStandardDerivatives(){console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');return this.extensions.get('OES_standard_derivatives');},supportsCompressedTextureS3TC:function supportsCompressedTextureS3TC(){console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');return this.extensions.get('WEBGL_compressed_texture_s3tc');},supportsCompressedTexturePVRTC:function supportsCompressedTexturePVRTC(){console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');return this.extensions.get('WEBGL_compressed_texture_pvrtc');},supportsBlendMinMax:function supportsBlendMinMax(){console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');return this.extensions.get('EXT_blend_minmax');},supportsVertexTextures:function supportsVertexTextures(){console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');return this.capabilities.vertexTextures;},supportsInstancedArrays:function supportsInstancedArrays(){console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');return this.extensions.get('ANGLE_instanced_arrays');},enableScissorTest:function enableScissorTest(boolean){console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');this.setScissorTest(boolean);},initMaterial:function initMaterial(){console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');},addPrePlugin:function addPrePlugin(){console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');},addPostPlugin:function addPostPlugin(){console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');},updateShadowMap:function updateShadowMap(){console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');}});(0,_defineProperties2.default)(WebGLRenderer.prototype,{shadowMapEnabled:{get:function get(){return this.shadowMap.enabled;},set:function set(value){console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');this.shadowMap.enabled=value;}},shadowMapType:{get:function get(){return this.shadowMap.type;},set:function set(value){console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');this.shadowMap.type=value;}},shadowMapCullFace:{get:function get(){return this.shadowMap.cullFace;},set:function set(value){console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');this.shadowMap.cullFace=value;}}});(0,_defineProperties2.default)(WebGLShadowMap.prototype,{cullFace:{get:function get(){return this.renderReverseSided?CullFaceFront:CullFaceBack;},set:function set(cullFace){var value=cullFace!==CullFaceBack;console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to "+value+".");this.renderReverseSided=value;}}});//
(0,_defineProperties2.default)(WebGLRenderTarget.prototype,{wrapS:{get:function get(){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');return this.texture.wrapS;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');this.texture.wrapS=value;}},wrapT:{get:function get(){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');return this.texture.wrapT;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');this.texture.wrapT=value;}},magFilter:{get:function get(){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');return this.texture.magFilter;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');this.texture.magFilter=value;}},minFilter:{get:function get(){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');return this.texture.minFilter;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');this.texture.minFilter=value;}},anisotropy:{get:function get(){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');return this.texture.anisotropy;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');this.texture.anisotropy=value;}},offset:{get:function get(){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');return this.texture.offset;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');this.texture.offset=value;}},repeat:{get:function get(){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');return this.texture.repeat;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');this.texture.repeat=value;}},format:{get:function get(){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');return this.texture.format;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');this.texture.format=value;}},type:{get:function get(){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');return this.texture.type;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');this.texture.type=value;}},generateMipmaps:{get:function get(){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');return this.texture.generateMipmaps;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');this.texture.generateMipmaps=value;}}});//
Audio.prototype.load=function(file){console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');var scope=this;var audioLoader=new AudioLoader();audioLoader.load(file,function(buffer){scope.setBuffer(buffer);});return this;};AudioAnalyser.prototype.getData=function(){console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');return this.getFrequencyData();};//
var GeometryUtils={merge:function merge(geometry1,geometry2,materialIndexOffset){console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');var matrix;if(geometry2.isMesh){geometry2.matrixAutoUpdate&&geometry2.updateMatrix();matrix=geometry2.matrix;geometry2=geometry2.geometry;}geometry1.merge(geometry2,matrix,materialIndexOffset);},center:function center(geometry){console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');return geometry.center();}};var ImageUtils={crossOrigin:undefined,loadTexture:function loadTexture(url,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');var loader=new TextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(url,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;},loadTextureCube:function loadTextureCube(urls,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');var loader=new CubeTextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(urls,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;},loadCompressedTexture:function loadCompressedTexture(){console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');},loadCompressedTextureCube:function loadCompressedTextureCube(){console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');}};function Projector(){console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');this.projectVector=function(vector,camera){console.warn('THREE.Projector: .projectVector() is now vector.project().');vector.project(camera);};this.unprojectVector=function(vector,camera){console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');vector.unproject(camera);};this.pickingRay=function(){console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');};}//
function CanvasRenderer(){console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');this.domElement=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');this.clear=function(){};this.render=function(){};this.setClearColor=function(){};this.setSize=function(){};}Vector2.InstanceScalarSize=2;Vector3.InstanceScalarSize=3;Vector4.InstanceScalarSize=4;Color.InstanceScalarSize=3;Quaternion.InstanceScalarSize=4;Matrix3.InstanceScalarSize=9;Matrix4.InstanceScalarSize=16;exports.WebGLRenderTargetCube=WebGLRenderTargetCube;exports.WebGLRenderTarget=WebGLRenderTarget;exports.WebGLRenderer=WebGLRenderer;exports.ShaderLib=ShaderLib;exports.UniformsLib=UniformsLib$1;exports.UniformsUtils=UniformsUtils;exports.ShaderChunk=ShaderChunk;exports.FogExp2=FogExp2;exports.Fog=Fog;exports.Scene=Scene;exports.LensFlare=LensFlare;exports.Sprite=Sprite;exports.LOD=LOD;exports.SkinnedMesh=SkinnedMesh;exports.Skeleton=Skeleton;exports.Bone=Bone;exports.Mesh=Mesh;exports.LineSegments=LineSegments;exports.Line=Line;exports.Points=Points;exports.Group=Group;exports.VideoTexture=VideoTexture;exports.DataTexture=DataTexture;exports.CompressedTexture=CompressedTexture;exports.CubeTexture=CubeTexture;exports.CanvasTexture=CanvasTexture;exports.DepthTexture=DepthTexture;exports.Texture=Texture;exports.CompressedTextureLoader=CompressedTextureLoader;exports.DataTextureLoader=DataTextureLoader;exports.CubeTextureLoader=CubeTextureLoader;exports.TextureLoader=TextureLoader;exports.ObjectLoader=ObjectLoader;exports.MaterialLoader=MaterialLoader;exports.BufferGeometryLoader=BufferGeometryLoader;exports.DefaultLoadingManager=DefaultLoadingManager;exports.LoadingManager=LoadingManager;exports.JSONLoader=JSONLoader;exports.ImageLoader=ImageLoader;exports.FontLoader=FontLoader;exports.FileLoader=FileLoader;exports.Loader=Loader;exports.Cache=Cache;exports.AudioLoader=AudioLoader;exports.SpotLightShadow=SpotLightShadow;exports.SpotLight=SpotLight;exports.PointLight=PointLight;exports.RectAreaLight=RectAreaLight;exports.HemisphereLight=HemisphereLight;exports.DirectionalLightShadow=DirectionalLightShadow;exports.DirectionalLight=DirectionalLight;exports.AmbientLight=AmbientLight;exports.LightShadow=LightShadow;exports.Light=Light;exports.StereoCamera=StereoCamera;exports.PerspectiveCamera=PerspectiveCamera;exports.OrthographicCamera=OrthographicCamera;exports.CubeCamera=CubeCamera;exports.Camera=Camera;exports.AudioListener=AudioListener;exports.PositionalAudio=PositionalAudio;exports.AudioContext=AudioContext;exports.AudioAnalyser=AudioAnalyser;exports.Audio=Audio;exports.VectorKeyframeTrack=VectorKeyframeTrack;exports.StringKeyframeTrack=StringKeyframeTrack;exports.QuaternionKeyframeTrack=QuaternionKeyframeTrack;exports.NumberKeyframeTrack=NumberKeyframeTrack;exports.ColorKeyframeTrack=ColorKeyframeTrack;exports.BooleanKeyframeTrack=BooleanKeyframeTrack;exports.PropertyMixer=PropertyMixer;exports.PropertyBinding=PropertyBinding;exports.KeyframeTrack=KeyframeTrack;exports.AnimationUtils=AnimationUtils;exports.AnimationObjectGroup=AnimationObjectGroup;exports.AnimationMixer=AnimationMixer;exports.AnimationClip=AnimationClip;exports.Uniform=Uniform;exports.InstancedBufferGeometry=InstancedBufferGeometry;exports.BufferGeometry=BufferGeometry;exports.GeometryIdCount=GeometryIdCount;exports.Geometry=Geometry;exports.InterleavedBufferAttribute=InterleavedBufferAttribute;exports.InstancedInterleavedBuffer=InstancedInterleavedBuffer;exports.InterleavedBuffer=InterleavedBuffer;exports.InstancedBufferAttribute=InstancedBufferAttribute;exports.Face3=Face3;exports.Object3D=Object3D;exports.Raycaster=Raycaster;exports.Layers=Layers;exports.EventDispatcher=EventDispatcher;exports.Clock=Clock;exports.QuaternionLinearInterpolant=QuaternionLinearInterpolant;exports.LinearInterpolant=LinearInterpolant;exports.DiscreteInterpolant=DiscreteInterpolant;exports.CubicInterpolant=CubicInterpolant;exports.Interpolant=Interpolant;exports.Triangle=Triangle;exports.Math=_Math;exports.Spherical=Spherical;exports.Cylindrical=Cylindrical;exports.Plane=Plane;exports.Frustum=Frustum;exports.Sphere=Sphere;exports.Ray=Ray;exports.Matrix4=Matrix4;exports.Matrix3=Matrix3;exports.Box3=Box3;exports.Box2=Box2;exports.Line3=Line3;exports.Euler=Euler;exports.Vector4=Vector4;exports.Vector3=Vector3;exports.Vector2=Vector2;exports.Quaternion=Quaternion;exports.Color=Color;exports.MorphBlendMesh=MorphBlendMesh;exports.ImmediateRenderObject=ImmediateRenderObject;exports.VertexNormalsHelper=VertexNormalsHelper;exports.SpotLightHelper=SpotLightHelper;exports.SkeletonHelper=SkeletonHelper;exports.PointLightHelper=PointLightHelper;exports.RectAreaLightHelper=RectAreaLightHelper;exports.HemisphereLightHelper=HemisphereLightHelper;exports.GridHelper=GridHelper;exports.PolarGridHelper=PolarGridHelper;exports.FaceNormalsHelper=FaceNormalsHelper;exports.DirectionalLightHelper=DirectionalLightHelper;exports.CameraHelper=CameraHelper;exports.BoxHelper=BoxHelper;exports.ArrowHelper=ArrowHelper;exports.AxisHelper=AxisHelper;exports.CatmullRomCurve3=CatmullRomCurve3;exports.CubicBezierCurve3=CubicBezierCurve3;exports.QuadraticBezierCurve3=QuadraticBezierCurve3;exports.LineCurve3=LineCurve3;exports.ArcCurve=ArcCurve;exports.EllipseCurve=EllipseCurve;exports.SplineCurve=SplineCurve;exports.CubicBezierCurve=CubicBezierCurve;exports.QuadraticBezierCurve=QuadraticBezierCurve;exports.LineCurve=LineCurve;exports.Shape=Shape;exports.Path=Path;exports.ShapePath=ShapePath;exports.Font=Font;exports.CurvePath=CurvePath;exports.Curve=Curve;exports.ShapeUtils=ShapeUtils;exports.SceneUtils=SceneUtils;exports.WireframeGeometry=WireframeGeometry;exports.ParametricGeometry=ParametricGeometry;exports.ParametricBufferGeometry=ParametricBufferGeometry;exports.TetrahedronGeometry=TetrahedronGeometry;exports.TetrahedronBufferGeometry=TetrahedronBufferGeometry;exports.OctahedronGeometry=OctahedronGeometry;exports.OctahedronBufferGeometry=OctahedronBufferGeometry;exports.IcosahedronGeometry=IcosahedronGeometry;exports.IcosahedronBufferGeometry=IcosahedronBufferGeometry;exports.DodecahedronGeometry=DodecahedronGeometry;exports.DodecahedronBufferGeometry=DodecahedronBufferGeometry;exports.PolyhedronGeometry=PolyhedronGeometry;exports.PolyhedronBufferGeometry=PolyhedronBufferGeometry;exports.TubeGeometry=TubeGeometry;exports.TubeBufferGeometry=TubeBufferGeometry;exports.TorusKnotGeometry=TorusKnotGeometry;exports.TorusKnotBufferGeometry=TorusKnotBufferGeometry;exports.TorusGeometry=TorusGeometry;exports.TorusBufferGeometry=TorusBufferGeometry;exports.TextGeometry=TextGeometry;exports.SphereBufferGeometry=SphereBufferGeometry;exports.SphereGeometry=SphereGeometry;exports.RingGeometry=RingGeometry;exports.RingBufferGeometry=RingBufferGeometry;exports.PlaneBufferGeometry=PlaneBufferGeometry;exports.PlaneGeometry=PlaneGeometry;exports.LatheGeometry=LatheGeometry;exports.LatheBufferGeometry=LatheBufferGeometry;exports.ShapeGeometry=ShapeGeometry;exports.ShapeBufferGeometry=ShapeBufferGeometry;exports.ExtrudeGeometry=ExtrudeGeometry;exports.EdgesGeometry=EdgesGeometry;exports.ConeGeometry=ConeGeometry;exports.ConeBufferGeometry=ConeBufferGeometry;exports.CylinderGeometry=CylinderGeometry;exports.CylinderBufferGeometry=CylinderBufferGeometry;exports.CircleBufferGeometry=CircleBufferGeometry;exports.CircleGeometry=CircleGeometry;exports.BoxBufferGeometry=BoxBufferGeometry;exports.BoxGeometry=BoxGeometry;exports.ShadowMaterial=ShadowMaterial;exports.SpriteMaterial=SpriteMaterial;exports.RawShaderMaterial=RawShaderMaterial;exports.ShaderMaterial=ShaderMaterial;exports.PointsMaterial=PointsMaterial;exports.MultiMaterial=MultiMaterial;exports.MeshPhysicalMaterial=MeshPhysicalMaterial;exports.MeshStandardMaterial=MeshStandardMaterial;exports.MeshPhongMaterial=MeshPhongMaterial;exports.MeshToonMaterial=MeshToonMaterial;exports.MeshNormalMaterial=MeshNormalMaterial;exports.MeshLambertMaterial=MeshLambertMaterial;exports.MeshDepthMaterial=MeshDepthMaterial;exports.MeshBasicMaterial=MeshBasicMaterial;exports.MeshCubeMaterial=MeshCubeMaterial;exports.LineDashedMaterial=LineDashedMaterial;exports.LineBasicMaterial=LineBasicMaterial;exports.MaterialMap=MaterialMap;exports.Material=Material;exports.Float64BufferAttribute=Float64BufferAttribute;exports.Float32BufferAttribute=Float32BufferAttribute;exports.Uint32BufferAttribute=Uint32BufferAttribute;exports.Int32BufferAttribute=Int32BufferAttribute;exports.Uint16BufferAttribute=Uint16BufferAttribute;exports.Int16BufferAttribute=Int16BufferAttribute;exports.Uint8ClampedBufferAttribute=Uint8ClampedBufferAttribute;exports.Uint8BufferAttribute=Uint8BufferAttribute;exports.Int8BufferAttribute=Int8BufferAttribute;exports.BufferAttribute=BufferAttribute;exports.REVISION=REVISION;exports.MOUSE=MOUSE;exports.CullFaceNone=CullFaceNone;exports.CullFaceBack=CullFaceBack;exports.CullFaceFront=CullFaceFront;exports.CullFaceFrontBack=CullFaceFrontBack;exports.FrontFaceDirectionCW=FrontFaceDirectionCW;exports.FrontFaceDirectionCCW=FrontFaceDirectionCCW;exports.BasicShadowMap=BasicShadowMap;exports.PCFShadowMap=PCFShadowMap;exports.PCFSoftShadowMap=PCFSoftShadowMap;exports.PCSSSoftShadowMap=PCSSSoftShadowMap;exports.FrontSide=FrontSide;exports.BackSide=BackSide;exports.DoubleSide=DoubleSide;exports.FlatShading=FlatShading;exports.SmoothShading=SmoothShading;exports.NoColors=NoColors;exports.FaceColors=FaceColors;exports.VertexColors=VertexColors;exports.NoBlending=NoBlending;exports.NormalBlending=NormalBlending;exports.AdditiveBlending=AdditiveBlending;exports.SubtractiveBlending=SubtractiveBlending;exports.MultiplyBlending=MultiplyBlending;exports.CustomBlending=CustomBlending;exports.AddEquation=AddEquation;exports.SubtractEquation=SubtractEquation;exports.ReverseSubtractEquation=ReverseSubtractEquation;exports.MinEquation=MinEquation;exports.MaxEquation=MaxEquation;exports.ZeroFactor=ZeroFactor;exports.OneFactor=OneFactor;exports.SrcColorFactor=SrcColorFactor;exports.OneMinusSrcColorFactor=OneMinusSrcColorFactor;exports.SrcAlphaFactor=SrcAlphaFactor;exports.OneMinusSrcAlphaFactor=OneMinusSrcAlphaFactor;exports.DstAlphaFactor=DstAlphaFactor;exports.OneMinusDstAlphaFactor=OneMinusDstAlphaFactor;exports.DstColorFactor=DstColorFactor;exports.OneMinusDstColorFactor=OneMinusDstColorFactor;exports.SrcAlphaSaturateFactor=SrcAlphaSaturateFactor;exports.NeverDepth=NeverDepth;exports.AlwaysDepth=AlwaysDepth;exports.LessDepth=LessDepth;exports.LessEqualDepth=LessEqualDepth;exports.EqualDepth=EqualDepth;exports.GreaterEqualDepth=GreaterEqualDepth;exports.GreaterDepth=GreaterDepth;exports.NotEqualDepth=NotEqualDepth;exports.MultiplyOperation=MultiplyOperation;exports.MixOperation=MixOperation;exports.AddOperation=AddOperation;exports.NoToneMapping=NoToneMapping;exports.LinearToneMapping=LinearToneMapping;exports.ReinhardToneMapping=ReinhardToneMapping;exports.Uncharted2ToneMapping=Uncharted2ToneMapping;exports.CineonToneMapping=CineonToneMapping;exports.UVMapping=UVMapping;exports.CubeReflectionMapping=CubeReflectionMapping;exports.CubeRefractionMapping=CubeRefractionMapping;exports.EquirectangularReflectionMapping=EquirectangularReflectionMapping;exports.EquirectangularRefractionMapping=EquirectangularRefractionMapping;exports.SphericalReflectionMapping=SphericalReflectionMapping;exports.CubeUVReflectionMapping=CubeUVReflectionMapping;exports.CubeUVRefractionMapping=CubeUVRefractionMapping;exports.RepeatWrapping=RepeatWrapping;exports.ClampToEdgeWrapping=ClampToEdgeWrapping;exports.MirroredRepeatWrapping=MirroredRepeatWrapping;exports.NearestFilter=NearestFilter;exports.NearestMipMapNearestFilter=NearestMipMapNearestFilter;exports.NearestMipMapLinearFilter=NearestMipMapLinearFilter;exports.LinearFilter=LinearFilter;exports.LinearMipMapNearestFilter=LinearMipMapNearestFilter;exports.LinearMipMapLinearFilter=LinearMipMapLinearFilter;exports.UnsignedByteType=UnsignedByteType;exports.ByteType=ByteType;exports.ShortType=ShortType;exports.UnsignedShortType=UnsignedShortType;exports.IntType=IntType;exports.UnsignedIntType=UnsignedIntType;exports.FloatType=FloatType;exports.HalfFloatType=HalfFloatType;exports.UnsignedShort4444Type=UnsignedShort4444Type;exports.UnsignedShort5551Type=UnsignedShort5551Type;exports.UnsignedShort565Type=UnsignedShort565Type;exports.UnsignedInt248Type=UnsignedInt248Type;exports.AlphaFormat=AlphaFormat;exports.RGBFormat=RGBFormat;exports.RGBAFormat=RGBAFormat;exports.LuminanceFormat=LuminanceFormat;exports.LuminanceAlphaFormat=LuminanceAlphaFormat;exports.RGBEFormat=RGBEFormat;exports.DepthFormat=DepthFormat;exports.DepthStencilFormat=DepthStencilFormat;exports.RGB_S3TC_DXT1_Format=RGB_S3TC_DXT1_Format;exports.RGBA_S3TC_DXT1_Format=RGBA_S3TC_DXT1_Format;exports.RGBA_S3TC_DXT3_Format=RGBA_S3TC_DXT3_Format;exports.RGBA_S3TC_DXT5_Format=RGBA_S3TC_DXT5_Format;exports.RGB_PVRTC_4BPPV1_Format=RGB_PVRTC_4BPPV1_Format;exports.RGB_PVRTC_2BPPV1_Format=RGB_PVRTC_2BPPV1_Format;exports.RGBA_PVRTC_4BPPV1_Format=RGBA_PVRTC_4BPPV1_Format;exports.RGBA_PVRTC_2BPPV1_Format=RGBA_PVRTC_2BPPV1_Format;exports.RGB_ETC1_Format=RGB_ETC1_Format;exports.LoopOnce=LoopOnce;exports.LoopRepeat=LoopRepeat;exports.LoopPingPong=LoopPingPong;exports.InterpolateDiscrete=InterpolateDiscrete;exports.InterpolateLinear=InterpolateLinear;exports.InterpolateSmooth=InterpolateSmooth;exports.ZeroCurvatureEnding=ZeroCurvatureEnding;exports.ZeroSlopeEnding=ZeroSlopeEnding;exports.WrapAroundEnding=WrapAroundEnding;exports.TrianglesDrawMode=TrianglesDrawMode;exports.TriangleStripDrawMode=TriangleStripDrawMode;exports.TriangleFanDrawMode=TriangleFanDrawMode;exports.LinearEncoding=LinearEncoding;exports.sRGBEncoding=sRGBEncoding;exports.GammaEncoding=GammaEncoding;exports.RGBEEncoding=RGBEEncoding;exports.LogLuvEncoding=LogLuvEncoding;exports.RGBM7Encoding=RGBM7Encoding;exports.RGBM16Encoding=RGBM16Encoding;exports.RGBDEncoding=RGBDEncoding;exports.BasicDepthPacking=BasicDepthPacking;exports.RGBADepthPacking=RGBADepthPacking;exports.OrderIndependentTransperancy=OrderIndependentTransperancy;exports.PaintersTransperancy=PaintersTransperancy;exports.CubeGeometry=BoxGeometry;exports.Face4=Face4;exports.LineStrip=LineStrip;exports.LinePieces=LinePieces;exports.MeshFaceMaterial=MeshFaceMaterial;exports.PointCloud=PointCloud;exports.Particle=Particle;exports.ParticleSystem=ParticleSystem;exports.PointCloudMaterial=PointCloudMaterial;exports.ParticleBasicMaterial=ParticleBasicMaterial;exports.ParticleSystemMaterial=ParticleSystemMaterial;exports.Vertex=Vertex;exports.DynamicBufferAttribute=DynamicBufferAttribute;exports.Int8Attribute=Int8Attribute;exports.Uint8Attribute=Uint8Attribute;exports.Uint8ClampedAttribute=Uint8ClampedAttribute;exports.Int16Attribute=Int16Attribute;exports.Uint16Attribute=Uint16Attribute;exports.Int32Attribute=Int32Attribute;exports.Uint32Attribute=Uint32Attribute;exports.Float32Attribute=Float32Attribute;exports.Float64Attribute=Float64Attribute;exports.ClosedSplineCurve3=ClosedSplineCurve3;exports.SplineCurve3=SplineCurve3;exports.Spline=Spline;exports.BoundingBoxHelper=BoundingBoxHelper;exports.EdgesHelper=EdgesHelper;exports.WireframeHelper=WireframeHelper;exports.XHRLoader=XHRLoader;exports.BinaryTextureLoader=BinaryTextureLoader;exports.GeometryUtils=GeometryUtils;exports.ImageUtils=ImageUtils;exports.Projector=Projector;exports.CanvasRenderer=CanvasRenderer;Object.defineProperty(exports,'__esModule',{value:true});});

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startAutoRotate = startAutoRotate;
exports.stopAutoRotate = stopAutoRotate;
exports.autoRotateTool = autoRotateTool;

var _scene = __webpack_require__(7);

var _animation = __webpack_require__(67);

function startAutoRotate(store) {
  var player = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
  var id = player && player.autoRotateNode;

  if (!player || !player.autoRotate || !id) return false;

  var increment = player.autoRotateDirection === '+' ? 360 : -360;
  var path = (0, _scene.find)(store, { id: id, plug: 'Transform', property: 'rotation' });
  var rotation = (0, _scene.get)(store, { id: id, plug: 'Transform', property: 'rotation' });

  var hasRotateAnimation = (0, _animation.findAnimationIndex)(store, 'autoRotate') !== -1;

  if (path && rotation && !hasRotateAnimation) {
    store.dispatch((0, _animation.queueAnimation)({
      name: 'autoRotate',
      autoplay: true,
      iterations: Infinity,
      easingDuration: 3000,
      tracks: [{
        path: path,
        start: 0,
        duration: player.autoRotateSpeed * 1000,
        value: { x: rotation.x, y: rotation.y + increment, z: rotation.z }
      }]
    }));
  }
}

function stopAutoRotate(store) {
  store.dispatch((0, _animation.removeAnimation)('autoRotate'));
}

function autoRotateTool(store) {
  var startingTimeout = void 0;

  var tool = {
    start: function start() {
      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5000;

      if (startingTimeout) return;

      startingTimeout = setTimeout(function () {
        startAutoRotate(store);
      }, timeout);
    },

    stop: function stop() {
      stopAutoRotate(store);
      clearTimeout(startingTimeout);
      startingTimeout = null;
    },

    mousedown: function mousedown() {
      return tool.stop();
    },
    mouseup: function mouseup() {
      return tool.start();
    }
  };

  return {
    enabled: true,
    tool: tool
  };
}

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(97);

var _extends3 = _interopRequireDefault(_extends2);

exports.getAnnotationProperties = getAnnotationProperties;

exports.default = function (store) {
  var rect = (0, _player.getRect)(store);

  return function (annotation) {
    var id = annotation.id,
        text = annotation.text,
        left = annotation.left,
        bottom = annotation.bottom,
        visible = annotation.visible,
        position = annotation.position,
        normal = annotation.normal,
        alpha = annotation.alpha; //data.position(store);

    if (position === undefined) return (0, _h2.default)('span');

    var state = store.getIn(['annotations', id]) || (0, _immutable.Map)({ open: annotation.open, pinned: annotation.open });
    var open = state.get('open');
    var pinned = state.get('pinned');

    var tb = position.y > 0.5 ? 't' : 'b';
    var lr = position.x < 0.6 ? 'l' : 'r';
    var side = [tb, lr].join('');

    function click(ev) {
      ev.preventDefault();
      store.dispatch((0, _annotations.setAnnotationProperties)(id, {
        open: !pinned ? true : !open,
        pinned: !pinned
      }));
    }

    function mouseover(ev) {
      if (!pinned) store.dispatch((0, _annotations.setAnnotationProperties)(id, { open: true }));
    }

    function mouseout(ev) {
      if (!pinned) store.dispatch((0, _annotations.setAnnotationProperties)(id, { open: false }));
    }

    var children = [(0, _h2.default)('img', {
      style: { cursor: 'pointer' },
      props: {
        width: 24,
        height: 24,
        src: "https://editor.vimarket.io" + '/img/annotation-' + (open ? 'open' : 'closed') + '-2.svg'
      }
    })];

    if (open) {
      var textCss = {
        fontSize: '12px',
        padding: '10px',
        color: '#fff',
        backgroundColor: '#000',
        borderRadius: '3px',
        opacity: '0.8',
        cursor: 'pointer',
        lineHeight: 1.3,
        width: text.length > 10 ? text.length > 50 ? '200px' : '150px' : '100px'
      };

      children.push((0, _h2.default)('div', { style: popupCsses[side] }, [lr === 'l' && (0, _h2.default)('div', { key: side, style: arrows[side] }), (0, _h2.default)('div', { key: 'text', style: textCss, on: { click: click } }, text), lr === 'r' && (0, _h2.default)('div', { key: side, style: arrows[side] })].filter(function (n) {
        return !!n;
      })));
    }

    return (0, _h2.default)('div', {
      key: id,
      style: {
        visibility: visible ? 'visible' : 'hidden',
        opacity: alpha,
        position: 'absolute',
        left: Math.round(left) + 'px',
        bottom: Math.round(bottom) + 'px'
      },
      on: { click: click, mouseover: mouseover, mouseout: mouseout }
    }, children);
  };
};

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

var _immutable = __webpack_require__(32);

var _player = __webpack_require__(8);

var _annotations = __webpack_require__(122);

var _scene = __webpack_require__(7);

var _sceneIO = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var imgStyle = { cursor: 'pointer' };

var initialAnnotationState = (0, _immutable.Map)({ open: false, pinned: false });

var bs = '5px solid #333';
var bi = '5px solid transparent';

var arrowCss = {
  position: 'absolute',
  display: 'inline-block',
  borderTop: bi,
  borderLeft: bi,
  borderRight: bi,
  borderBottom: bi,
  height: 0,
  width: 0,
  top: '',
  bottom: '',
  right: '',
  left: ''
};

var arrows = {
  tl: (0, _extends3.default)({}, arrowCss, { borderRight: bs, top: '12px', left: '-10px', marginTop: '-5px' }),
  bl: (0, _extends3.default)({}, arrowCss, { borderRight: bs, bottom: '8px', left: '-10px', marginTop: '-5px' }),
  tr: (0, _extends3.default)({}, arrowCss, { borderLeft: bs, top: '12px', right: '-10px', marginTop: '-5px' }),
  br: (0, _extends3.default)({}, arrowCss, { borderLeft: bs, bottom: '8px', right: '-10px', marginTop: '-5px' })
};

var popupCss = {
  position: 'absolute',
  textAlign: 'left',
  left: '',
  top: '',
  bottom: '',
  right: '',
  transition: 'opacity 0.3s ease-out',
  webkitTransition: 'opacity 0.3s ease-out',
  fontFamily: 'sans-serif',
  delayed: { opacity: 1 },
  remove: { opacity: 0 }
};

var popupCsses = {
  tl: (0, _extends3.default)({}, popupCss, { left: '30px', top: '0' }),
  bl: (0, _extends3.default)({}, popupCss, { left: '30px', bottom: '0' }),
  tr: (0, _extends3.default)({}, popupCss, { right: '30px', top: '0' }),
  br: (0, _extends3.default)({}, popupCss, { right: '30px', bottom: '0' })
};

function getAnnotationVisibility(store, data) {
  if (!data.visible) return false;

  var sceneId = (0, _sceneIO.getSceneId)(store);
  var hierarchyVisibility = (0, _scene.get)(store, {
    id: sceneId,
    plug: 'Properties',
    property: 'hierarchyVisibility'
  });
  if (hierarchyVisibility !== 'Enable') return data.visible;

  var parentId = (0, _scene.find)(store, { id: data.id, parent: true });
  var objectId = (0, _scene.find)(store, { from: sceneId, type: 'Objects', shallow: true });

  while (parentId && parentId !== objectId) {
    var visible = (0, _scene.get)(store, {
      id: parentId,
      plug: 'Properties',
      property: 'visible'
    });
    if (visible === false) return false;
    parentId = (0, _scene.find)(store, { id: parentId, parent: true });
  }

  return true;
}

function getAnnotationProperties(store, data) {
  var rect = (0, _player.getRect)(store);

  var _data$position = data.position(store),
      position = _data$position.position,
      normal = _data$position.normal,
      alpha = _data$position.alpha;

  if (!position) return false;

  var left = rect.width * position.x;
  var bottom = rect.height * position.y;
  var visible = !(left < 0 || left > rect.width - 24 || bottom < 0 || bottom > rect.height - 24) && getAnnotationVisibility(store, data);

  return (0, _extends3.default)({}, data.annotation, {
    id: data.id,
    alpha: alpha,
    normal: normal,
    position: position,
    top: rect.height - bottom,
    right: rect.width - left,
    bottom: bottom,
    left: left,
    visible: visible
  });
}

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

exports.default = canvas;

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

var _runtimeInfo = __webpack_require__(56);

var _runtimeInfo2 = _interopRequireDefault(_runtimeInfo);

var _annotation = __webpack_require__(332);

var _annotation2 = _interopRequireDefault(_annotation);

var _sceneIO = __webpack_require__(20);

var _annotations = __webpack_require__(122);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addResizeHandler(store) {
  function onResize() {
    var translator = store.getTranslator();
    if (translator) {
      if (_runtimeInfo2.default.name === 'safari') {
        setTimeout(function () {
          translator.resize();
        }, 50);
      } else translator.resize();
    }
  }

  return function (info) {
    return window.addEventListener('resize', onResize);
  };
}

function ignoreRightClick(ev) {
  ev.preventDefault();
}

function canvas(store) {
  var translator = store.getEvaluatedTranslator();
  var rendered = (0, _sceneIO.isSceneRendered)(store);

  var annotationFn = (0, _annotations.getCustomAnnotationFunction)(store);
  var overlayFn = (0, _annotations.getCustomOverlayFunction)(store);

  var allAnnotations = translator ? translator.getAnnotations() : {};
  var annotations = (0, _keys2.default)(allAnnotations).map(function (id) {
    return (0, _annotation.getAnnotationProperties)(store, allAnnotations[id]);
  }).filter(function (a) {
    return !!a;
  });

  function callCustomAnnotationFn(vnode) {
    if (annotationFn) annotations.forEach(function (annotation) {
      return annotationFn(annotation, vnode.elm);
    });
    if (overlayFn) overlayFn(vnode.elm);
  }

  var children = annotationFn || overlayFn ? [(0, _h2.default)('div.annotations', {
    style: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      pointerEvents: 'none'
    },
    hook: {
      insert: callCustomAnnotationFn,
      update: callCustomAnnotationFn
    }
  })] : annotations.map((0, _annotation2.default)(store));

  return (0, _h2.default)('div', {
    style: { position: 'relative', display: rendered ? 'block' : 'none' },
    on: { contextmenu: ignoreRightClick },
    hook: {
      update: function update(info) {
        return translator && translator.attach(info.elm);
      },
      insert: addResizeHandler(store)
    }
  }, children);
}

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = error;

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

var _styles = __webpack_require__(153);

var _styles2 = _interopRequireDefault(_styles);

var _sceneIO = __webpack_require__(20);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function error(store) {
  return (0, _h2.default)('div', { key: 'error', style: _styles2.default.absoluteMaxCentered }, [(0, _h2.default)('div', { style: { flex: '0 0 100%' } }, (0, _sceneIO.getErrors)(store).map(function (err) {
    return (0, _h2.default)('h2', err);
  }).toArray())]);
}

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

exports.hoverStyle = hoverStyle;
exports.default = manipulatorTools;

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

var _icons = __webpack_require__(152);

var svgIcons = _interopRequireWildcard(_icons);

var _player = __webpack_require__(8);

var _commands = __webpack_require__(43);

var _timeline = __webpack_require__(339);

var _timeline2 = _interopRequireDefault(_timeline);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isTouch = true && (!!('ontouchstart' in window) || window.navigator.msMaxTouchPoints > 0);

function hoverStyle(store) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var hoverColor = (0, _player.getHoverColor)(store);

  var hoverStyle = isTouch ? '' : '\n' + prefix + ' ul.tools li:not(.active):hover svg path {\n  fill: ' + hoverColor + ';\n}\n';
  return (0, _h2.default)('style', { props: { innerHTML: hoverStyle } });
}

function manipulatorTools(store) {
  var tools = (0, _commands.getCommands)(store, 'playerTools');
  var activeColor = (0, _player.getActiveColor)(store);

  function click(what) {
    return function (ev) {
      store.dispatch((0, _commands.runCommand)(what));
      var canvas = (0, _player.getCanvasElement)(store);
      if (canvas) canvas.focus();
    };
  }

  var toolChildren = [hoverStyle(store, 'div.claraplayer'), (0, _h2.default)('ul.tools', {
    style: {
      position: 'relative',
      bottom: 0,
      left: 0,
      listStyleType: 'none',
      padding: '0 5px',
      margin: 0,
      zIndex: (0, _player.isVRMode)(store) ? 2147483647 : 'inherit'
    }
  }, [svgIcons.glowFilter()].concat((0, _keys2.default)(tools).map(function (key) {
    var command = tools[key];
    var active = command.isActive ? command.isActive(store) : command.active;
    var label = command.active && command.activeLabel ? command.activeLabel : command.label;
    var svgIcon = svgIcons[command.options.icon || key];
    var iconChildren = [];

    if (typeof svgIcon === 'function') {
      iconChildren.push(svgIcon({ width: 34, height: 34, title: label }, { active: active, activeColor: activeColor }));
    } else {
      iconChildren.push((0, _h2.default)('span', {
        style: {
          color: active ? activeColor : '#fff',
          textShadow: '1px 1px 1px #333',
          position: 'relative',
          top: '10px'
        }
      }, label));
    }

    return (0, _h2.default)('li' + (active ? '.active' : ''), {
      attrs: { title: label },
      on: { click: click(key) },
      style: {
        cursor: 'pointer',
        float: 'left',
        borderRadius: '5px',
        padding: '5px',
        boxSizing: 'border-box',
        pointerEvents: 'auto'
      }
    }, iconChildren);
  })))];

  var tLine = (0, _timeline2.default)(store);
  if (tLine) toolChildren.push(tLine);

  return (0, _h2.default)('span', {
    style: {
      position: 'absolute',
      left: '5px',
      right: '5px',
      bottom: '5px',
      display: 'flex',
      flexWrap: 'nowrap',
      height: '54px',
      pointerEvents: 'none'
    }
  }, toolChildren);
}

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = marker;

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function marker(store, percentPlayed, duration, visible) {
  var markerStyle = {
    width: '0',
    height: '100%',
    position: 'absolute',
    left: percentPlayed + '%',
    top: '0',
    pointerEvents: 'auto',
    cursor: 'pointer'
  };

  var toolTipStyle = {
    boxSizing: 'border-box',
    position: 'absolute',
    zIndex: '1070',
    display: 'block',
    visibility: 'visible',
    fontSize: '12px',
    fontWeight: 'normal',
    lineHeight: '1.4',
    top: '-32px',
    left: '-25px',
    width: '50px',
    height: '22px',
    marginTop: '-3px',
    padding: '5px 0',
    opacity: '1'
  };
  if (!visible) {
    toolTipStyle.opacity = '0';
    toolTipStyle.transition = 'opacity 0.15s linear';
  }

  var innerStyle = {
    maxWidth: '200px',
    padding: '3px 8px',
    color: '#ffffff',
    textAlign: 'center',
    textDecoration: 'none',
    backgroundColor: '#000000',
    borderRadius: '4px',
    boxShadow: '#000 0 0 5px',
    margin: '0 auto',
    userSelect: 'none',
    WebkitUserSelect: 'none',
    MozUserSelect: 'none'
  };

  var arrowStyle = {
    boxSizing: 'border-box',
    position: 'absolute',
    width: '0',
    height: '0',
    bottom: '-10px',
    left: '50%',
    marginLeft: '-5px',
    borderWidth: '5px 5px 0',
    borderTopColor: '#000000',
    borderRightColor: 'transparent',
    borderBottomColor: 'transparent',
    borderLeftColor: 'transparent',
    borderStyle: 'solid'
  };

  function stopEvent(ev) {
    ev.stopPropagation();
  }

  return (0, _h2.default)('div.marker', { style: markerStyle, on: { mousedown: stopEvent, touchstart: stopEvent } }, [(0, _h2.default)('div.tooltip', { style: toolTipStyle }, [(0, _h2.default)('div.tooltip-arrow', { style: arrowStyle }), (0, _h2.default)('div.tooltip-inner', { style: innerStyle }, (duration * percentPlayed / 100000).toFixed(1))])]);
}

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

exports.default = player;

var _snabbdom = __webpack_require__(310);

var _snabbdom2 = _interopRequireDefault(_snabbdom);

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

var _class = __webpack_require__(306);

var _class2 = _interopRequireDefault(_class);

var _props = __webpack_require__(308);

var _props2 = _interopRequireDefault(_props);

var _attributes = __webpack_require__(305);

var _attributes2 = _interopRequireDefault(_attributes);

var _style = __webpack_require__(309);

var _style2 = _interopRequireDefault(_style);

var _eventlisteners = __webpack_require__(307);

var _eventlisteners2 = _interopRequireDefault(_eventlisteners);

var _canvas = __webpack_require__(333);

var _canvas2 = _interopRequireDefault(_canvas);

var _styles = __webpack_require__(153);

var _styles2 = _interopRequireDefault(_styles);

var _error = __webpack_require__(334);

var _error2 = _interopRequireDefault(_error);

var _manipulatorTools = __webpack_require__(335);

var _manipulatorTools2 = _interopRequireDefault(_manipulatorTools);

var _virtualProductTour = __webpack_require__(340);

var _virtualProductTour2 = _interopRequireDefault(_virtualProductTour);

var _vrSettingsView = __webpack_require__(341);

var _vrSettingsView2 = _interopRequireDefault(_vrSettingsView);

var _progress = __webpack_require__(338);

var _progress2 = _interopRequireDefault(_progress);

var _player = __webpack_require__(8);

var _sceneIO = __webpack_require__(20);

var _configuration = __webpack_require__(98);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// attaches event listeners
// makes it easy to toggle classes
var renderConfiguratorUI; // handles styling on elements with support for animations
// for setting properties on DOM elements

function getRenderConfiguratorUI() {
  if (renderConfiguratorUI) return _promise2.default.resolve(renderConfiguratorUI);
  return new _promise2.default(function (resolve) {
    __webpack_require__.e/* require.ensure */(0).then((function (require) {
      renderConfiguratorUI = __webpack_require__(721).default;
      resolve(renderConfiguratorUI);
    }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
  });
}

//const brokenThumbnails = {};

var patch = _snabbdom2.default.init([_class2.default, _props2.default, _attributes2.default, _style2.default, _eventlisteners2.default]);

function player(store, _ref) {
  var isFlex = _ref.isFlex,
      isRelative = _ref.isRelative,
      hasWebGL = _ref.hasWebGL;

  var rendered = (0, _sceneIO.isSceneRendered)(store);
  var configurators = (0, _configuration.getConfigurators)(store);

  var sceneId = store.getIn(['sceneIO', 'id']);
  var hideThumbnail = rendered || !sceneId || !(0, _player.shouldDisplayThumbnail)(store);
  var thumbnailUrl = !hideThumbnail && (0, _player.getThumbnailURL)(store, sceneId);

  var cssStyle = '\n  div.claraplayer canvas {\n    box-sizing: content-box;\n    -webkit-box-sizing: content-box;\n  }\n  div.claraplayer canvas:focus {\n    outline: none;\n  }\n';
  var children = [(0, _h2.default)('style', { props: { innerHTML: cssStyle } })];

  var fullscreenBackgroundColor = store.getIn(['player', 'fullscreenBackgroundColor']);
  var playerStyles = (0, _assign2.default)({}, _styles2.default.player, {
    backgroundImage: hideThumbnail ? '' : 'url(' + thumbnailUrl + ')',
    backgroundRepeat: 'no-repeat',
    backgroundSize: 'auto 100%',
    backgroundPosition: 'center',
    position: isFlex || isRelative ? 'absolute' : 'relative',
    boxSizing: 'border-box',
    backgroundColor: (0, _player.isFullscreen)(store) ? fullscreenBackgroundColor : 'transparent',
    overflow: 'hidden'
  });

  if ((0, _sceneIO.numErrors)(store)) {
    children.push((0, _error2.default)(store));
  } else {
    children.push((0, _canvas2.default)(store, 'player'));
    if (rendered) {
      children.push((0, _manipulatorTools2.default)(store));
      if ((0, _player.shouldDisplayVrSettings)(store)) {
        children.push((0, _vrSettingsView2.default)(store));
      } else {
        children.push('');
      }
      //if (configPanel.displayConfigMenu) children.push(configurationMenu(store));
      //children.push(h('div', { styled: { backgroundColor: 'red' } }));
      //
      configurators.forEach(function (_ref2) {
        var form = _ref2.form,
            el = _ref2.el,
            panel = _ref2.panel,
            id = _ref2.id;

        if (!form) return;
        var activeForm = (0, _configuration.getForm)(store, form, { id: id });

        children.push((0, _virtualProductTour2.default)(store, activeForm));

        if (el) {
          if (el.classList) el.classList.add('clara');
          getRenderConfiguratorUI().then(function (r) {
            return r(store, el, activeForm, true, id);
          });
        }
        if (panel) {
          children.push((0, _h2.default)('div.configurator.clara', {
            hook: {
              update: function update(info) {
                getRenderConfiguratorUI().then(function (r) {
                  return r(store, info.elm, activeForm, false, id);
                });
              },
              insert: function insert(info) {
                getRenderConfiguratorUI().then(function (r) {
                  return r(store, info.elm, activeForm, false, id);
                });
              }
            }
          }, ''));
        }
      });
    } else if (hasWebGL) {
      children.push((0, _progress2.default)(store));
    }
  }

  return (0, _h2.default)('div.claraplayer', {
    style: playerStyles,
    hook: {
      insert: attachFullscreenHandlers(store)
    }
  }, children);
}

function attachFullscreenHandlers(store) {
  return function () {
    [
    // ['fullscreenChange', 'fullscreenElement'],
    ['webkitfullscreenchange', 'webkitIsFullScreen'], ['mozfullscreenchange', 'mozFullScreen'], ['MSFullscreenChange', 'msFullscreenElement']].forEach(function (info) {
      document.addEventListener(info[0], function () {
        //console.log('FULLSCREEN', info[0], !!document[info[1]]);
        store.dispatch((0, _player.setFullscreen)(!!document[info[1]]));
      });
    });
  };
}

/*function statsReporter() {
  var pageLoadTime, toRenderedTime;
  if (typeof performace === 'undefined') return function() {};

  return function(store, pct) {
    if (pageLoadTime && toRenderedTime) return;
    if (!pageLoadTime) pageLoadTime = new Date().getTime() - performance.timing.navigationStart;
    if (pct < 1) return;
    toRenderedTime = new Date().getTime() - performance.timing.navigationStart;
    console.log(`Page loaded in ${pageLoadTime}ms and rendered in ${toRenderedTime}ms`);
  };
};

//
//
var circleDiv = {
  flex: '0 0 25%'
};

var r = 90;
var PIR2 = Math.PI * r * 2;

var outer = {
  r, cx: 100, cy: 100,
  fill: 'transparent',
  'stroke-dasharray': PIR2,
  'stroke-dashoffset': 0,
  'stroke-width': '1em',
  stroke: '#eee'
};
var inner = {
  r, cx: 100, cy: 100,
  fill: 'transparent',
  stroke: colour,
  transition: 'stroke-dashoffset 1s linear',
  'stroke-width': '1em',
  'stroke-dashoffset': PIR2,
  'stroke-dasharray': PIR2
};
var svg = {
  height: '100%',
  width: '100%',
  viewport: '0 0 100 100',
  viewBox: '0 0 200 200',
};

function progress(store, pct) {
  var r = 90;
  var degrees = PIR2*(1-pct);

  return h('div', {style: {...styles.absoluteMaxCentered, backgroundColor: 'transparent', boxSizing: 'border-box' }}, [
    h('div', {style: circleDiv}, [
      h('svg', {attrs: svg}, [
        h('circle', {attrs: outer}),
        h('circle', {props: {id: 'bar'}, attrs: {...inner, 'stroke-dashoffset': degrees}}),
      ])
    ])
  ]);
};*/

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(97);

var _extends3 = _interopRequireDefault(_extends2);

exports.circleProgress = circleProgress;
exports.linearProgress = linearProgress;
exports.noProgress = noProgress;
exports.default = progress;

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

var _styles = __webpack_require__(153);

var _styles2 = _interopRequireDefault(_styles);

var _sceneIO = __webpack_require__(20);

var _player = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var stats = statsReporter();

function statsReporter() {
  var pageLoadTime, toRenderedTime;
  if (typeof performace === 'undefined') return function () {};

  return function (store, pct) {
    if (pageLoadTime && toRenderedTime) return;
    if (!pageLoadTime) pageLoadTime = new Date().getTime() - performance.timing.navigationStart;
    if (pct < 1) return;
    toRenderedTime = new Date().getTime() - performance.timing.navigationStart;
    console.log('Page loaded in ' + pageLoadTime + 'ms and rendered in ' + toRenderedTime + 'ms');
  };
}

//
var spinnerColor = '#646766';

var circleDiv = {
  flex: '0 0 25%'
};

var r = 85;
var PIR2 = Math.PI * r * 2;

var outer = {
  r: r,
  cx: 100,
  cy: 100,
  fill: 'transparent',
  'stroke-dasharray': PIR2,
  'stroke-dashoffset': 0,
  'stroke-width': '1em',
  stroke: '#eee'
};
var inner = {
  r: r,
  cx: 100,
  cy: 100,
  fill: 'transparent',
  stroke: spinnerColor,
  transition: 'stroke-dashoffset 1s linear',
  'stroke-width': '1em',
  'stroke-dashoffset': PIR2,
  'stroke-dasharray': PIR2
};
var svg = {
  height: '100%',
  width: '100%',
  viewport: '0 0 100 100',
  viewBox: '0 0 200 200'
};

function circleProgress(store, pct) {
  var degrees = PIR2 * (1 - pct);

  return (0, _h2.default)('div', {
    style: (0, _extends3.default)({}, _styles2.default.absoluteMaxCentered, {
      backgroundColor: 'transparent',
      boxSizing: 'border-box'
    })
  }, [(0, _h2.default)('div', { style: circleDiv }, [(0, _h2.default)('svg', { attrs: svg }, [(0, _h2.default)('circle', { attrs: outer }), (0, _h2.default)('circle', {
    props: { id: 'bar' },
    attrs: (0, _extends3.default)({}, inner, { 'stroke-dashoffset': degrees })
  })])])]);
}

function linearProgress(store, pct) {
  return (0, _h2.default)('div', {
    style: {
      position: 'absolute',
      left: 0,
      right: 0,
      bottom: 0,
      height: '4px',
      backgroundColor: 'transparent',
      boxSizing: 'border-box'
    }
  }, [(0, _h2.default)('div', {
    style: {
      width: pct * 100 + '%',
      backgroundImage: 'linear-gradient(to bottom, #0b1a24 0%, #88b9d9 100%)',
      height: '100%'
    }
  }, [])]);
}

function noProgress(store) {
  return (0, _h2.default)('div', '');
}

var progressOptions = {
  default: circleProgress,
  circle: circleProgress,
  line: linearProgress,
  none: noProgress
};

function progress(store) {
  var pct = (0, _sceneIO.loadingProgress)(store);
  var progressOption = (0, _player.getProgressBar)(store);

  stats(store, pct);
  var progressFn = progressOptions[progressOption] || circleProgress;
  return progressFn(store, pct);
}

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = timeline;

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

var _icons = __webpack_require__(152);

var _marker = __webpack_require__(336);

var _marker2 = _interopRequireDefault(_marker);

var _player = __webpack_require__(8);

var _animation = __webpack_require__(67);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dragHandler = null;
var timeoutHandler = null;
var visible = false;

function timeline(store) {
  var timelineStyle = {
    flex: '1 1 auto',
    position: 'relative',
    bottom: 0,
    right: 0,
    borderRadius: '5px',
    padding: '0 20px',
    pointerEvents: 'auto'
  };

  var rulerStyle = {
    boxSizing: 'border-box',
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    border: '1px solid #ccc',
    position: 'relative',
    top: '17px',
    left: '56px',
    height: '10px',
    width: 'calc(100% - 55px)',
    cursor: 'pointer'
  };

  var activeColor = (0, _player.getActiveColor)(store);
  var hoverColor = (0, _player.getHoverColor)(store);
  var iconAttrs = { width: 34, height: 34, title: 'play' };
  var iconOptions = { active: false, activeColor: activeColor };

  var timeAnimation = (0, _animation.getTimelineAnimation)(store);
  if (!timeAnimation) return null;
  var startTime = timeAnimation.start;
  var duration = timeAnimation.duration / Math.abs(timeAnimation.playSpeed);
  var played = Math.max(Math.min(((0, _animation.getTime)(store) - startTime) / duration, 1), 0) * 100;

  var playedStyle = {
    backgroundColor: activeColor,
    width: 'calc(' + played + '% - 2px)',
    height: '6px',
    position: 'absolute',
    left: '1px',
    top: '1px',
    cursor: 'pointer'
  };

  var buttonStyle = {
    position: 'relative',
    display: 'inline-block',
    verticalAlign: 'middle',
    top: '-5px',
    cursor: 'pointer'
  };

  var hoverStyle = '\n    div.claraplayer div div svg:hover path {\n    fill: ' + hoverColor + ';\n  }';

  function createHandleDrag(_ref, touch) {
    var width = _ref.width,
        left = _ref.left;

    return function (ev) {
      visible = true;
      if (timeoutHandler) {
        window.clearTimeout(timeoutHandler);
      }

      timeoutHandler = window.setTimeout(function () {
        visible = false;
        store.dispatch({ type: 'POKE' });
      }, 2000);

      var evX = touch ? ev.touches[0].pageX : ev.pageX;
      var percentTime = Math.max(Math.min((evX - left) / width, 1), 0);
      var time = percentTime * duration + startTime;
      store.dispatch((0, _animation.setTime)(time));
    };
  }

  function handleClick(ev) {
    //console.log(ev.target.parentNode);
    visible = true;
    if (timeoutHandler) {
      window.clearTimeout(timeoutHandler);
    }

    timeoutHandler = window.setTimeout(function () {
      visible = false;
      store.dispatch({ type: 'POKE' });
    }, 2000);

    if (dragHandler !== null) {
      window.removeEventListener('mousemove', dragHandler);
      window.removeEventListener('mouseup', endDrag);
      window.removeEventListener('touchmove', dragHandler);
      window.removeEventListener('touchend', endDrag);
    }

    var touch = !!ev.touches;
    var evX = touch ? ev.touches[0].clientX : ev.clientX;

    var rectElement = ev.target.className === 'ruler' ? ev.target : ev.target.parentNode;
    var rect = rectElement.getBoundingClientRect();

    var time = (evX - rect.left) / rect.width * duration + startTime;
    store.dispatch((0, _animation.setTime)(time));

    dragHandler = createHandleDrag(rect, touch);
    if (!touch) {
      window.addEventListener('mousemove', dragHandler);
      window.addEventListener('mouseup', endDrag);
    } else {
      window.addEventListener('touchmove', dragHandler);
      window.addEventListener('touchend', endDrag);
    }
  }

  function endDrag(ev) {
    window.removeEventListener('mousemove', dragHandler);
    window.removeEventListener('mouseup', endDrag);
    window.removeEventListener('touchmove', dragHandler);
    window.removeEventListener('touchend', endDrag);
    dragHandler = null;
  }

  var icon = (0, _animation.isPlaying)(store) ? (0, _icons.pause)(iconAttrs, iconOptions) : (0, _icons.play)(iconAttrs, iconOptions);
  var clickAction = (0, _animation.isPlaying)(store) ? function () {
    return store.dispatch((0, _animation.stopPlaying)());
  } : function () {
    return store.dispatch((0, _animation.startPlaying)());
  };

  return (0, _h2.default)('div', { style: timelineStyle }, [(0, _h2.default)('style', { props: { innerHTML: hoverStyle } }), (0, _h2.default)('div.ruler', {
    style: rulerStyle,
    on: { mousedown: handleClick, touchstart: handleClick }
  }, [(0, _h2.default)('div.played', { style: playedStyle }), (0, _marker2.default)(store, played, duration, visible)]), (0, _h2.default)('div', { style: buttonStyle, on: { click: clickAction } }, [icon])]);
}

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(97);

var _extends3 = _interopRequireDefault(_extends2);

exports.default = virtualProductTour;

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

var _configuration = __webpack_require__(98);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// FIXME: store in state
var idx = 0;

var buttonStyle = {
  position: 'absolute',
  top: '50%',
  backgroundColor: 'transparent',
  width: 0,
  height: 0,
  borderStyle: 'solid',
  outline: 'none',
  cursor: 'pointer',
  margin: '8px',
  pointerEvents: 'auto'
};

var left = {
  left: '10px'
};

var right = {
  right: '10px'
};
var divStyle = {
  position: 'absolute',
  top: '50%',
  height: '50px',
  width: '50px',
  borderRadius: '50%',
  backgroundColor: 'rgba(100, 100, 100, 0.6)',
  cursor: 'pointer',
  pointerEvents: 'auto',
  marginTop: '-25px'
};
var arrowStyle = {
  position: 'absolute',
  top: '13px',
  width: 0,
  height: 0,
  borderStyle: 'solid',
  outline: 'none'
};
var arrowLeftStyle = {
  borderWidth: '12px 24px 12px 0',
  borderColor: 'transparent white transparent transparent'
};
var arrowRightStyle = {
  borderWidth: '12px 0 12px 24px',
  borderColor: 'transparent transparent transparent white'
};

var renderProductTour = function renderProductTour(store, attribute, form) {
  var formState = (0, _configuration.getFormState)(store, { id: form.nodeId });

  // Only cycle through option values that are actually visible/enabled
  var optionsVisible = formState && formState.optionsVisible && formState.optionsVisible[attribute.id];
  var values = attribute.values || [];
  if (optionsVisible) values = values.filter(function (v) {
    return optionsVisible[v];
  });

  var changeVariant = function changeVariant(increment) {
    return function () {
      idx = values.indexOf((0, _configuration.getConfiguration)(store)[attribute.name]) || 0;
      idx = (idx + increment) % values.length;
      if (idx < 0) idx = values.length - 1;
      store.dispatch((0, _configuration.executeAttribute)(attribute.name, values[idx]));
    };
  };
  var rootStyle = { height: '100%', width: '100%', pointerEvents: 'none' };
  var leftStyle = (0, _extends3.default)({}, divStyle, left);
  var leftArrowStyle = (0, _extends3.default)({}, arrowStyle, arrowLeftStyle, left);
  var rightStyle = (0, _extends3.default)({}, divStyle, right);
  var rightArrowStyle = (0, _extends3.default)({}, arrowStyle, arrowRightStyle, right);

  return (0, _h2.default)('div', { style: rootStyle }, [(0, _h2.default)('div', { style: leftStyle, on: { click: changeVariant(-1) } }, [(0, _h2.default)('div', { style: leftArrowStyle })]), (0, _h2.default)('div', { style: rightStyle, on: { click: changeVariant(1) } }, [(0, _h2.default)('div', { style: rightArrowStyle })])]);
};

function virtualProductTour(store, form) {
  var productTour = (0, _configuration.getProductTour)(store);

  if (productTour) return renderProductTour(store, productTour, form);

  if (productTour !== false && form) {
    for (var k = 0; k < form.fields.length; k++) {
      var field = form.fields[k];
      if (field.displayAs === 'Product Tour') {
        return renderProductTour(store, field.attribute, form);
      }
    }
  }

  // No product tour
  return (0, _h2.default)('div', { style: { pointerEvents: 'none' } });
}

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(97);

var _extends3 = _interopRequireDefault(_extends2);

var _maxSafeInteger = __webpack_require__(500);

var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);

exports.default = vrSettingsView;

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

var _commands = __webpack_require__(43);

var _player = __webpack_require__(8);

var _icons = __webpack_require__(152);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var rootStyle = {
  position: 'absolute',
  display: 'flex',
  flexDirection: 'column',
  left: 0,
  top: 0,
  height: '100%',
  width: '100%',
  backgroundColor: '#98989a',
  zIndex: _maxSafeInteger2.default
};

var columnStyle = {
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  flex: 1,

  width: '100%',
  height: '100%'
};

var rowStyle = {
  display: 'flex',
  flexDirection: 'row',
  justifyContent: 'center',
  alignItems: 'center',
  flex: 1,

  height: '100%'
};

var bottomBarStyle = {
  flex: 1,
  display: 'flex',
  flexDirection: 'row',
  alignItems: 'center',

  height: '100%',

  position: 'relative'
};

var textStyle = {
  fontFamily: 'sans-serif',
  color: '#000000',
  fontSize: '20px'
};

var buttonStyle = (0, _extends3.default)({}, textStyle, {
  color: 'lightgray',
  flex: 1,
  backgroundColor: 'black',
  backgroundRepeat: 'no-repeat',
  borderRadius: '8px',
  border: 'none',
  cursor: 'pointer',
  overflow: 'hidden',
  outline: 'none',
  width: '100%',
  height: '100%'
});

var innerPaneStyle = {
  position: 'absolute',
  top: 0,
  left: 0,
  bottom: 0,
  right: 0,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  flexDirection: 'row'
};

var buttonHolder = {
  height: '80%',
  width: '100%',
  display: 'flex',
  flexDirection: 'column',
  flex: 1,

  alignContent: 'center',
  justifyContent: 'center'
};

var feet = null; //localStorage.getItem('userHeightFeet');
var inches = null; //localStorage.getItem('userHeightInches');

function getHeight() {
  return {
    userHeightFeet: feet === null ? 5 : Number(feet),
    userHeightInches: inches === null ? 11 : Number(inches)
  };
}

function setFeet(value) {
  // localStorage.setItem('userHeightFeet', value);
  feet = value;
}

function setInches(value) {
  // localStorage.setItem('userHeightInches', value);
  inches = value;
}

var divWidth = 0;
var divHeight = 0;
var minDim = 350;

function updateDimensions(vnode) {
  var _vnode$elm$getBoundin = vnode.elm.getBoundingClientRect(),
      width = _vnode$elm$getBoundin.width,
      height = _vnode$elm$getBoundin.height;

  divWidth = width;
  divHeight = height;
}

function vrSettingsView(store) {
  var initialHeight = getHeight();
  var isPortrait = divHeight * 1.1 > divWidth;
  var isHeightEditable = true;
  if (divWidth && divHeight && isPortrait) {
    isHeightEditable = isHeightEditable && divWidth > minDim;
  }
  var topPaneStyle = isPortrait ? columnStyle : rowStyle;

  function enterVrHandler() {
    store.dispatch((0, _commands.setCommandOptions)('vrMode', getHeight()));
    store.dispatch((0, _commands.activateCommand)('vrMode'));
    store.dispatch((0, _player.displayVrSettings)(false));
  }

  function cancelVrHandler() {
    store.dispatch((0, _commands.deactivateCommand)('vrSettings'));
    store.dispatch((0, _player.displayVrSettings)(false));
  }

  function stepper(handler, from, to, name, selected) {
    var children = [];
    for (var i = from; i <= to; i++) {
      children.push((0, _h2.default)('option', {
        attrs: {
          selected: i === selected
        },
        style: textStyle
      }, i + ''));
    }

    return (0, _h2.default)('div', {
      style: {
        margin: '10px'
      }
    }, [(0, _h2.default)('select', {
      style: (0, _extends3.default)({}, textStyle, {
        width: '12vw',
        height: '42px',
        backgroundColor: '#d6d6d6'
      }),
      on: { change: handler }
    }, children), (0, _h2.default)('p', { style: (0, _extends3.default)({}, textStyle, { display: 'inline', marginLeft: '10px' }) }, name)]);
  }

  return (0, _h2.default)('div', {
    style: rootStyle,
    hook: {
      insert: function insert(vnode) {
        return updateDimensions(vnode);
      },
      update: function update(oldVnode, vnode) {
        return updateDimensions(vnode);
      }
    }
  }, [(0, _h2.default)('div', {
    style: (0, _extends3.default)({}, topPaneStyle, {
      flex: 2
    })
  }, [(0, _h2.default)('div', { style: columnStyle }, [(0, _h2.default)('p', { style: textStyle }, 'Put on your headset.'), (0, _h2.default)('div', {
    style: {
      position: 'relative',
      width: '24vw',
      paddingBottom: '24vw'
    }
  }, [(0, _icons.vrHeadSet)({}, innerPaneStyle)])]), isHeightEditable ? (0, _h2.default)('div', { style: columnStyle }, [(0, _h2.default)('p', { style: textStyle }, 'Enter your height:'), (0, _h2.default)('div', {
    style: {
      position: 'relative',
      width: '38vw',
      paddingBottom: '24vw'
    }
  }, [(0, _h2.default)('div', { style: innerPaneStyle }, [(0, _h2.default)('div', { style: (0, _extends3.default)({}, columnStyle, { alignItems: 'flex-start' }) }, [stepper(function (ev) {
    return setFeet(Number(ev.target.value));
  }, 4, 9, 'Feet', initialHeight.userHeightFeet), stepper(function (ev) {
    return setInches(Number(ev.target.value));
  }, 0, 11, 'Inches', initialHeight.userHeightInches)])])])]) : '']), (0, _h2.default)('div', { style: bottomBarStyle }, [(0, _h2.default)('div', { style: buttonHolder }, [(0, _h2.default)('div', {
    style: (0, _extends3.default)({}, buttonStyle, {
      backgroundColor: 'transparent',
      cursor: 'none',
      display: 'flex',
      alignItems: 'flex-end'
    })
  }, [(0, _h2.default)('a', {
    style: {
      color: 'black',
      bottom: 0,
      marginLeft: '10px'
    },
    on: { click: cancelVrHandler }
  }, 'Cancel')])]), (0, _h2.default)('div', {
    style: buttonHolder
  }, [isPortrait ? (0, _h2.default)('div', { style: { flex: 1 } }) : '', (0, _h2.default)('button', {
    style: buttonStyle,
    on: { click: enterVrHandler }
  }, 'Enter VR')]), (0, _h2.default)('div', { style: buttonHolder })])]);
}

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

exports.default = threehub;

var _eventEmitter = __webpack_require__(487);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _clientMiddleware = __webpack_require__(255);

var _clientMiddleware2 = _interopRequireDefault(_clientMiddleware);

var _animation = __webpack_require__(67);

var _animation2 = _interopRequireDefault(_animation);

var _annotations = __webpack_require__(122);

var _annotations2 = _interopRequireDefault(_annotations);

var _assets = __webpack_require__(33);

var _assets2 = _interopRequireDefault(_assets);

var _configuration = __webpack_require__(98);

var _configuration2 = _interopRequireDefault(_configuration);

var _commands = __webpack_require__(43);

var _commands2 = _interopRequireDefault(_commands);

var _player = __webpack_require__(8);

var _player2 = _interopRequireDefault(_player);

var _plugins = __webpack_require__(345);

var _plugins2 = _interopRequireDefault(_plugins);

var _sceneGraph = __webpack_require__(10);

var _sceneGraph2 = _interopRequireDefault(_sceneGraph);

var _sceneIO = __webpack_require__(20);

var _sceneIO2 = _interopRequireDefault(_sceneIO);

var _scene = __webpack_require__(7);

var _scene2 = _interopRequireDefault(_scene);

var _selection = __webpack_require__(45);

var _selection2 = _interopRequireDefault(_selection);

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _store = __webpack_require__(493);

var _store2 = _interopRequireDefault(_store);

var _bindActionCreatorsAndSelectors = __webpack_require__(491);

var _bindActionCreatorsAndSelectors2 = _interopRequireDefault(_bindActionCreatorsAndSelectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultReducers = {
  animation: _animation2.default.reducer,
  annotations: _annotations2.default.reducer,
  assets: _assets2.default.reducer,
  commands: _commands2.default.reducer,
  configuration: _configuration2.default.reducer,
  sceneGraph: _sceneGraph2.default.reducer,
  sceneIO: _sceneIO2.default.reducer,
  player: _player2.default.reducer,
  plugins: _plugins2.default.reducer,
  selection: _selection2.default.reducer
};

/**
 * The main function. This function initializes the player for a given scene
 *
 * @param {(String|DOMNode)} elOrId - the DOM Node or String id of a DOM Node.
 * @returns {API} The clara playera API.
 * @public
 */
function threehub() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (!options.fetchApi) throw new Error('Expect a "fetchApi" function');

  var fetchApi = options.fetchApi,
      subscribe = options.subscribe,
      translator = options.translator,
      modules = options.modules;


  var reducers = (0, _keys2.default)(modules || {}).reduce(function (acc, key) {
    acc[key] = modules[key].reducer;
    return acc;
  }, {});

  var store = (0, _store2.default)((0, _assign2.default)({}, defaultReducers, reducers), _clientMiddleware2.default);
  store.setApi(fetchApi);

  var actions = (0, _bindActionCreatorsAndSelectors2.default)(store, (0, _assign2.default)({
    animation: _animation2.default,
    annotations: _annotations2.default,
    assets: _assets2.default,
    commands: _commands2.default,
    configuration: _configuration2.default,
    scene: _scene2.default,
    sceneIO: _sceneIO2.default,
    sceneGraph: _sceneGraph2.default,
    selection: _selection2.default,
    player: _player2.default,
    plugins: _plugins2.default
  }, modules));

  var api = (0, _assign2.default)({}, (0, _eventEmitter2.default)(), { _store: store, deps: { THREE: THREE } }, actions);
  store.api = api;

  store.subscribe(function (events) {
    //try {
    if (subscribe) subscribe();
    if (events.length) events.forEach(function (e) {
      api.emit(e.type, e.args);
    });
    api.emit('change');
  });

  if (translator) store.setTranslator(translator, store);
  var currentTranslator = store.getTranslator();

  store.dispatch((0, _plugins.setApi)(api));

  (0, _keys2.default)(options.commands || {}).forEach(function (commandName) {
    var command = options.commands[commandName];
    api.commands.addCommand(typeof command === 'function' ? command(store, currentTranslator) : command, commandName);
  });

  return api;
}

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(147);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(148);

var _createClass3 = _interopRequireDefault(_createClass2);

var _v = __webpack_require__(79);

var _v2 = _interopRequireDefault(_v);

var _selection = __webpack_require__(45);

var _three = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Highlighter = function () {
  function Highlighter(store) {
    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, Highlighter);

    this.id = (0, _v2.default)();
    this._store = store;

    this._color = attrs.color || '#00ff00';
    this._thickness = attrs.thickness || 1;
    this._selectionSet = attrs.selectionSet || null;
  }

  (0, _createClass3.default)(Highlighter, [{
    key: '_touch',
    value: function _touch() {
      this._store.dispatch((0, _selection.touchHighlighter)(this));
    }
  }, {
    key: 'setSelectionSet',
    value: function setSelectionSet(ss) {
      this._selectionSet = ss;
      this._touch();
    }
  }, {
    key: 'setColor',
    value: function setColor(color) {
      this._color = color;
      this._touch();
    }
  }, {
    key: 'setThickness',
    value: function setThickness(thickness) {
      this._thickness = thickness;
      this._touch();
    }
  }, {
    key: 'color',
    get: function get() {
      return new _three.Color(this._color);
    }
  }, {
    key: 'thickness',
    get: function get() {
      return this._thickness;
    }
  }, {
    key: 'selectedIds',
    get: function get() {
      return this._selectionSet ? this._selectionSet.ids : [];
    }
  }]);
  return Highlighter;
}();

exports.default = Highlighter;

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(147);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(148);

var _createClass3 = _interopRequireDefault(_createClass2);

var _v = __webpack_require__(79);

var _v2 = _interopRequireDefault(_v);

var _selection = __webpack_require__(45);

var _scene = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function uniq(a) {
  var seen = {};
  return a.filter(function (item) {
    return seen[item] ? false : seen[item] = true;
  });
}

var SelectionSet = function () {
  function SelectionSet(store) {
    var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck3.default)(this, SelectionSet);

    this.id = (0, _v2.default)();

    this._store = store;
    this._ids = Array.isArray(ids) ? ids : (0, _scene.filter)(store, ids, { onlyNode: true });
  }

  (0, _createClass3.default)(SelectionSet, [{
    key: '_touch',
    value: function _touch() {
      this._store.dispatch((0, _selection.touchSelectionSet)(this));
    }
  }, {
    key: 'add',
    value: function add(query) {
      var ids = (0, _scene.filter)(this._store, query, { onlyNode: true });
      this._ids = uniq(this._ids.concat(ids));
      // console.log('add: ', query, this._ids.length);
      this._touch();
    }

    // Remove nodes from the SelectionSet via a query

  }, {
    key: 'remove',
    value: function remove(query) {
      var ids = (0, _scene.filter)(this._store, query, { onlyNode: true });
      this._ids = this._ids.filter(function (id) {
        return !ids.includes(id);
      });
      this._touch();
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._ids = [];
      this._touch();
    }

    //

  }, {
    key: 'destroy',
    value: function destroy() {
      this._store.dispatch((0, _selection.removeSelectionSet)(this.id));
    }
  }, {
    key: 'ids',
    get: function get() {
      return this._ids;
    }
  }]);
  return SelectionSet;
}();

exports.default = SelectionSet;

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _typeof2 = __webpack_require__(38);

var _typeof3 = _interopRequireDefault(_typeof2);

var _promise = __webpack_require__(39);

var _promise2 = _interopRequireDefault(_promise);

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _createReducer;

exports.get = get;
exports.setApi = setApi;
exports.getSetupCommand = getSetupCommand;

var _immutable = __webpack_require__(32);

var _createReducer2 = __webpack_require__(46);

var _createReducer3 = _interopRequireDefault(_createReducer2);

var _rsvp = __webpack_require__(204);

var _rsvp2 = _interopRequireDefault(_rsvp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Plugins: loading, running
 *
 * @module plugins
 * @private
 */

var SET_API = 'SET_API';
var LOAD_PLUGIN = 'LOAD_PLUGIN';
var LOADING_PLUGIN = 'LOADING_PLUGIN';
var LOADED_PLUGIN = 'LOADED_PLUGIN';
var SET_PLUGIN = 'SET_PLUGIN';
var LOADING_PLUGIN_ERROR = 'LOADING_PLUGIN_ERROR';

var initialState = (0, _immutable.Map)({
  api: null,
  plugins: (0, _immutable.Map)(),
  loading: (0, _immutable.Map)()
});

var reducer = (0, _createReducer3.default)(initialState, (_createReducer = {}, (0, _defineProperty3.default)(_createReducer, SET_API, function (state, api) {
  return state.set('api', api);
}), (0, _defineProperty3.default)(_createReducer, LOADING_PLUGIN, function (state, name) {
  return state.setIn(['loading', name], true);
}), (0, _defineProperty3.default)(_createReducer, LOADED_PLUGIN, function (state, name, _ref) {
  var action = _ref.action;

  return state.setIn(['loading', name], false);
}), (0, _defineProperty3.default)(_createReducer, SET_PLUGIN, function (state, _ref2) {
  var name = _ref2.name,
      plugin = _ref2.plugin;

  return state.setIn(['plugins', name], plugin);
}), _createReducer));

function initPlugin(store, name, response) {
  try {
    var buildPluginFn = function buildPluginFn(content) {
      var fn = new Function('api', content || '');
      return fn(store.getIn(['plugins', 'api']));
    };

    var content = response.content,
        loadFromServer = response.loadFromServer,
        url = response.url;

    if (!loadFromServer) return _promise2.default.resolve(buildPluginFn(content));

    console.log('Load plugin from server', url);
    return new _rsvp2.default.Promise(function (resolve, reject) {
      store.callApi({
        types: [LOADING_PLUGIN, LOADED_PLUGIN, LOADING_PLUGIN_ERROR],
        url: url,
        payload: name,
        queryKey: 'PLUGINexternal' + name,
        contentType: 'external'
      }).then(function (content) {
        console.log('fetched external plugin', typeof content === 'undefined' ? 'undefined' : (0, _typeof3.default)(content), content && content.length);
        try {
          var pluginFn = buildPluginFn(content);
          if (!pluginFn) console.log('External plugin must be a function that returns an object');
          resolve(pluginFn || {});
        } catch (e) {
          console.log('Error building plugin', e);
          if (e.stack) console.log(e.stack);
          resolve({});
        }
      }).catch(function (e) {
        console.log('Error loading external plugin', e);
        resolve({});
      });
    });
  } catch (e) {
    console.log('error', e);
  }
}

function loadPlugin(name) {
  return function (store) {
    var sceneId = store.getIn(['sceneIO', 'id']);
    if (!sceneId) return _promise2.default.reject('No scene attached');

    var api = store.getIn(['plugins', 'api']);
    if (api && api[name]) return _promise2.default.resolve(api[name]);

    return store.callApi({
      types: [LOADING_PLUGIN, LOADED_PLUGIN, LOADING_PLUGIN_ERROR],
      url: "https://editor.vimarket.io/api" + '/scenes/' + sceneId + '/plugins/' + name,
      payload: name,
      queryKey: 'PLUGIN' + name
    }).then(function (response) {
      return initPlugin(store, name, response).then(function (plugin) {
        store.dispatch({ type: SET_PLUGIN, payload: { name: name, plugin: plugin } });
        return plugin;
      });
    });
  };
}

function get(store, name) {
  var plugin = store.getIn(['plugins', 'plugins', name]);
  return plugin ? _promise2.default.resolve(plugin) : store.dispatch(loadPlugin(name));
}

function setApi(api) {
  return { type: SET_API, payload: api };
}

/**
 * Returns a function that will run the setup command
 */
function getSetupCommand(store, cmd, data) {
  try {
    var err = function err(msg) {
      console.log(msg);
      return _promise2.default.resolve(true);
    };

    var _cmd$split = cmd.split('/'),
        _cmd$split2 = (0, _slicedToArray3.default)(_cmd$split, 2),
        pluginName = _cmd$split2[0],
        command = _cmd$split2[1];

    var setupData = typeof data === 'string' ? JSON.parse(data) : data;
    return function () {
      console.log('Get plugin', pluginName, 'for command', command);
      return get(store, pluginName).then(function (plugin) {
        console.log('Fetched plugin', !!plugin, (typeof plugin === 'undefined' ? 'undefined' : (0, _typeof3.default)(plugin)) === 'object' && (0, _keys2.default)(plugin));
        if (!plugin) return err('Error getting plugin: ' + pluginName);
        if (!plugin[command]) return err('Unknown command: ' + command + ' for plugin: ' + pluginName);
        if (typeof plugin[command] !== 'function') return err('Command: ' + command + ' in plugin: ' + pluginName + ' is not a function');

        if (Array.isArray(setupData)) {
          return _promise2.default.resolve(plugin[command].apply(plugin, setupData));
        } else {
          return _promise2.default.resolve(plugin[command](setupData));
        }
      });
    };
  } catch (e) {
    return function () {
      console.error(e);
    };
  }
}

var publicApi = {
  reducer: reducer,
  actions: { loadPlugin: loadPlugin },
  selectors: { get: get, getSetupCommand: getSetupCommand }
};

exports.default = publicApi;

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.default = diffObjects;

var _getObject = __webpack_require__(154);

var _getObject2 = _interopRequireDefault(_getObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// /**
//  * Given two commit objects, diff the trees, and return a list of
//  * objects that are added.
//  */
function diffObjects(sceneGraph, toCommit, fromCommit) {
  var objects = sceneGraph.objects,
      activeSceneId = sceneGraph.activeSceneId;

  var get = (0, _getObject2.default)(objects);

  var objs = {};

  if (fromCommit && toCommit.root === fromCommit.root) return objs;

  objs[toCommit.root] = objects[toCommit.root];

  var to = get(toCommit.root);
  var from = fromCommit && get(fromCommit.root);

  if (to.heirarchy !== from.heirarchy) objs[to.heirarchy] = objects[to.heirarchy];
  if (to.references !== from.references) objs[to.references] = objects[to.references];

  var heirarchy = get(to.heirarchy);
  var fromHeirarchy = from && get(from.heirarchy);

  function diffPlugs(tohash, fromhash) {
    if (tohash === fromhash) return;
    objs[tohash] = objects[tohash];

    var toPlugs = get(tohash);
    var fromPlugs = fromhash && get(fromhash);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(toPlugs)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var plug = _step.value;

        var fromOps = fromPlugs && fromPlugs[plug] || [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = (0, _getIterator3.default)(toPlugs[plug]), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var ophash = _step2.value;

            if (fromOps.indexOf(ophash) === -1) objs[ophash] = objects[ophash];
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  function diffNode(id, tohash, fromhash) {
    // console.log('diffNode: ', id, tohash, fromhash);
    if (tohash === fromhash) return;
    objs[tohash] = objects[tohash];

    var contentNode = get(tohash);
    // console.log(' - ', contentNode.name);
    var fromContentNode = fromhash && get(fromhash);
    var childrenIds = heirarchy[id] || [];
    var fromChildrenIds = fromHeirarchy && fromHeirarchy[id] || [];

    diffPlugs(contentNode.plugs, fromContentNode && fromContentNode.plugs);

    childrenIds.forEach(function (childId, idx) {
      var fromIdx = fromChildrenIds.indexOf(childId);
      diffNode(childId, contentNode.children[idx], fromContentNode && fromContentNode.children[fromIdx]);
    });
  }

  diffNode(activeSceneId, to.content, from && from.content);

  function diffFiles(tohash, fromhash) {
    if (tohash === fromhash) return;
    objs[tohash] = objects[tohash];

    var toFiles = get(tohash);
    var fromFiles = fromhash ? get(fromhash) : {};
    (0, _keys2.default)(toFiles).forEach(function (id) {
      var hash = toFiles[id];
      if (fromFiles[id] !== hash) {
        //console.log('adding file to results', hash, objects[hash]);
        objs[hash] = objects[hash];
      }
    });
  }

  diffFiles(to.files, from && from.files);

  return objs;
}

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.default = diffReferences;

var _getObject = __webpack_require__(154);

var _getObject2 = _interopRequireDefault(_getObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function diffReferences(sceneGraph, toCommit, fromCommit, secondCommit, set) {
  var get = (0, _getObject2.default)(sceneGraph.objects);
  var to = get(toCommit.root);
  var from = fromCommit && get(fromCommit.root);
  var second = secondCommit && get(secondCommit.root);

  var references = get(to.references);
  var fromReferences = from ? get(from.references) : {};
  var secondReferences = second ? get(second.references) : {};

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(references)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var refKey = _step.value;

      set(JSON.parse(refKey), references[refKey]);
      // if (fromReferences[refKey] !== references[refKey]) {
      // }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(secondReferences)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var refKey = _step2.value;

      if (secondReferences[refKey] !== references[refKey]) {
        set(JSON.parse(refKey), references[refKey]);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(fromReferences)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var refKey = _step3.value;

      if (!references[refKey] && !secondReferences[refKey]) {
        set(JSON.parse(refKey), null);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }
}

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.default = diffTree;

var _getObject = __webpack_require__(154);

var _getObject2 = _interopRequireDefault(_getObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assert(truthy, message) {
  if (!truthy) throw new Error('assertion failure: ' + message);
}

function allIndexed(fn, list) {
  for (var i = 0; i < list.length; i++) {
    if (!fn(list[i], i)) return false;
  }
  return true;
}

function diffTree(sceneGraph, toCommit, fromCommit, secondCommit, changers) {
  var changeNode = changers.changeNode,
      addNode = changers.addNode,
      deleteNode = changers.deleteNode,
      addFile = changers.addFile,
      removeFile = changers.removeFile;
  var activeSceneId = sceneGraph.activeSceneId,
      objects = sceneGraph.objects,
      nodes = sceneGraph.nodes;

  var get = (0, _getObject2.default)(sceneGraph.objects);

  var to = get(toCommit.root);
  var from = fromCommit && get(fromCommit.root);
  var second = secondCommit && get(secondCommit.root);

  var heirarchy = get(to.heirarchy);
  var references = get(to.references);

  var fromHeirarchy = from && get(from.heirarchy);
  var fromReferences = from && get(from.references);

  var secondHeirarchy = second && get(second.heirarchy);
  var secondReferences = second && get(second.references);

  function diffNodeContent(id, contentNode, fromContentNode, secondContentNode) {
    if (contentNode.plugs === fromContentNode.plugs) {
      if (!secondContentNode) return;
      if (secondContentNode.plugs === contentNode.plugs) return;
    }

    var toPlugs = get(contentNode.plugs);
    var fromPlugs = get(fromContentNode.plugs);
    var secondPlugs = secondContentNode && get(secondContentNode.plugs);

    var newPlugs = {};

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var plug = _step.value;

        var plugSame = allIndexed(function (hash, idx) {
          return fromPlugs[plug][idx] === hash;
        }, toPlugs[plug]);
        if (!plugSame) {
          newPlugs[plug] = toPlugs[plug].map(get);
        }
        if (secondPlugs && allIndexed(function (hash, idx) {
          return fromPlugs[plug][idx] === hash;
        }, toPlugs[plug])) {
          newPlugs[plug] = secondPlugs[plug].map(get);
        }
      };

      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(toPlugs)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    changeNode({ id: id, plugs: newPlugs });
  }

  function diffNode(id, parentNodeId, toHash, fromHash, secondHash) {
    if (fromHash === toHash) {
      if (!secondHash) return;
      if (secondHash === toHash) return;
    }

    var childrenIds = heirarchy[id] || [];
    var fromChildrenIds = fromHeirarchy && fromHeirarchy[id] || [];
    var secondChildrenIds = secondHeirarchy && secondHeirarchy[id] || [];

    var contentNode = get(toHash);
    var fromContentNode = fromHash && get(fromHash);
    var secondContentNode = secondHash && get(secondHash);

    assert(contentNode.children.length === childrenIds.length, 'Expected heirarchy to match content: ' + id);
    if (secondContentNode) assert(secondContentNode.children.length === secondChildrenIds.length, 'Expected heirarchy to match content: ' + id);
    if (fromContentNode) assert(fromContentNode.children.length === fromChildrenIds.length, 'Expected heirarchy to match content: ' + id);

    var existingNode = nodes[id];

    if (fromContentNode) {
      diffNodeContent(id, contentNode, fromContentNode, secondContentNode);
    } else {
      var contentPlugs = get(contentNode.plugs);
      var plugs = {};
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(contentPlugs)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _plug = _step2.value;

          plugs[_plug] = contentPlugs[_plug].map(function (hash) {
            var op = get(hash);
            return [op.type, op, op.name];
          });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      addNode({
        id: id,
        parent: parentNodeId,
        plugs: plugs,
        children: [],
        name: contentNode.name,
        type: contentNode.type
      });
    }

    childrenIds.forEach(function (childId, idx) {
      var fromIdx = fromChildrenIds.indexOf(childId);
      var secondIdx = secondChildrenIds.indexOf(childId);
      diffNode(childId, id, contentNode.children[idx], fromContentNode && fromContentNode.children[fromIdx], secondContentNode && secondContentNode.children[secondIdx]);
    });

    secondChildrenIds.forEach(function (childId, idx) {
      var toChild = childrenIds.indexOf(childId);
      var fromIdx = fromChildrenIds.indexOf(childId);
      if (toChild === -1) {
        diffNode(childId, id, secondContentNode.children[idx], fromContentNode && fromContentNode.children[fromIdx]);
      }
    });

    fromChildrenIds.forEach(function (childId, idx) {
      if (childrenIds.indexOf(childId) === -1 && (!secondChildrenIds || secondChildrenIds.indexOf(childId) === -1)) {
        deleteNode(childId);
      }
    });
  }

  diffNode(activeSceneId, null, to.content, from && from.content, second && second.content);

  function diffFiles(toHash, fromHash, secondHash) {
    var files = get(toHash);
    var fromFiles = fromHash ? get(fromHash) : {};
    var secondFiles = secondHash ? get(secondHash) : {};
    //console.log('diffFiles', files, fromFiles, secondFiles);

    (0, _keys2.default)(files).forEach(function (id) {
      if (!fromFiles[id]) addFile((0, _assign2.default)({ id: id }, get(files[id])));else if (fromFiles[id] !== files[id]) throw new Error('Update file');
    });

    (0, _keys2.default)(secondFiles).forEach(function (id) {
      if (!fromFiles[id]) addFile(get(secondFiles[id]));else if (fromFiles[id] !== secondFiles[id]) throw new Error('Update file');
    });
  }

  diffFiles(to.files, from && from.files, second && second.files);
}

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = __webpack_require__(47);

var _stringify2 = _interopRequireDefault(_stringify);

exports.updateReferenceList = updateReferenceList;
exports.updateReference = updateReference;
exports.evaluateSceneGraph = evaluateSceneGraph;

var _three = __webpack_require__(0);

var _sceneIO = __webpack_require__(20);

var _player = __webpack_require__(8);

var _operators = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var doLog = false;
function log() {
  var _console;

  if (doLog) (_console = console).log.apply(_console, arguments);
}

function updateReferenceList(_ref, nodeId, plugName, opIdx, key, refs) {
  var from = _ref.from,
      to = _ref.to;

  var refKey = (0, _stringify2.default)([nodeId, plugName, opIdx, key]);
  var existingRefs = to[refKey];
  if (existingRefs) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(existingRefs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var existingRefId = _step.value;

        if (refs.indexOf(existingRefId) === -1) {
          delete from[existingRefId][refKey];
          if (!(0, _keys2.default)(from[existingRefId]).length) {
            delete from[existingRefId];
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator3.default)(refs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var refId = _step2.value;

      if (!from[refId]) from[refId] = {};
      from[refId][refKey] = true;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  to[refKey] = refs;
}

//
// refKey = JSON.stringify([nodeId,plugName,opIdx]);
// from: { [fileId]:  refKey },
// from: { [refId]:  { [refKey}: refPlug } }
// to:  { [refKey]: fileId },
//
function updateReference(sceneGraph, _ref2, nodeId, plugName, opIdx, key, op, refPlug) {
  var from = _ref2.from,
      to = _ref2.to;

  var refId = op[key];
  if (refId && sceneGraph && !sceneGraph.nodes[refId]) {
    console.warn('No reference to:', refId, 'from', nodeId, plugName, opIdx, key);
    op[key] = refId = null;
  }

  var refKey = (0, _stringify2.default)([nodeId, plugName, opIdx, key]);
  var existingRef = to[refKey];
  if (existingRef) {
    if (existingRef !== refId) {
      delete from[existingRef][refKey];
      if (refId) {
        if (!from[refId]) from[refId] = {};
        from[refId][refKey] = refPlug || true;
        to[refKey] = refId;
      } else {
        if (!(0, _keys2.default)(from[existingRef]).length) {
          delete from[existingRef];
        }

        delete to[refKey];
      }
    }
  } else if (refId) {
    if (!from[refId]) from[refId] = {};
    from[refId][refKey] = refPlug || true;
    to[refKey] = refId;
  }
}

function evaluateSceneGraph(store, sceneGraph, options) {
  var sceneId = sceneGraph.activeSceneId;
  var start = new Date();
  var i = 0;
  var id = null;

  // skipEvaluation lets us evaluate the dependencies of the sceneGraph, without running all the operators.
  var skipEvaluation = options.skipEvaluation;

  var sceneNodeIds = (0, _keys2.default)(sceneGraph.nodes);
  var evaluatedNodeIds = (0, _keys2.default)(sceneGraph.evaluatedNodes);
  var _sceneGraph$nodeRefer = sceneGraph.nodeReferences,
      from = _sceneGraph$nodeRefer.from,
      to = _sceneGraph$nodeRefer.to;

  // First evaluation after sceneGraph is loaded

  var transitionToLoaded = !sceneGraph.loaded && (0, _sceneIO.isSceneLoaded)(store);
  if (!sceneGraph.loaded) sceneGraph.loaded = transitionToLoaded;

  var worldTransforms = {};
  var toUpdate = {};
  var toDelete = {};
  var updating = {};
  var nodeUpdates = {};

  function getEvaluated(id, plug) {
    if (updating[id] && !nodeUpdates[id]) {
      console.error('Circular reference, updating', sceneGraph.nodes[id].name);
      throw new Error('Circular reference: ' + id);
    }

    if (toUpdate[id] && !updating[id]) updateNode(id, toUpdate[id]);

    //addReference(id, {id: nodeId, sourcePlug, destPlug}, toPlugKey(destPlug, opIndex, fromKey));
    var result = nodeUpdates[id] || sceneGraph.evaluatedNodes[id];
    if (plug) result = result && result[plug];
    return result;
  }

  function getWorldTransform(id) {
    sceneGraph.worldTransformReferences[id] = true;
    if (worldTransforms[id]) return worldTransforms[id];

    if ((toUpdate[id] === true || toUpdate[id] === 'Transform') && !updating[id]) updateNode(id, toUpdate[id]);
    var localTransform = getEvaluated(id, 'Transform');
    if (!localTransform) return null;

    var node = sceneGraph.nodes[id];
    var parent = node && node.parent;
    var parentTransform = parent && getWorldTransform(parent);

    worldTransforms[id] = parentTransform ? new _three.Matrix4().copy(parentTransform).multiply(localTransform.transform) : new _three.Matrix4().copy(localTransform.transform);
    return worldTransforms[id];
  }

  function getCameraWorldTransform(fromId) {
    sceneGraph.cameraReferences[fromId] = true;
    var id = (0, _player.getCamera)(store);
    return getWorldTransform(id);
  }

  function updateNode(id, updatePlug) {
    var node = sceneGraph.nodes[id];
    if (!node) return;

    var evalNode = sceneGraph.evaluatedNodes[id];
    if (!evalNode) {
      evalNode = sceneGraph.evaluatedNodes[id] = {
        name: node.name,
        _ev: 0,
        plugs: []
      };
      if (node.plugs.Properties) evalNode.plugs.push('Properties');
      if (node.plugs.Transform) evalNode.plugs.push('Transform');
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var plug = _step3.value;

          if (plug !== 'Properties' && plug !== 'Transform') evalNode.plugs.push(plug);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    nodeUpdates[id] = evalNode;
    // console.log('evaluateSceneGraph::updateNode', node.name, updatePlug);
    updating[id] = true;

    var nodeEvaluatedVersion = 0;

    function doUpdatePlug(plug) {
      var _this = this;

      // console.log('  - ', plug);
      var ops = node.plugs[plug];
      var previousResult = evalNode[plug];
      var previousVersion = previousResult ? previousResult._v : 0;

      evalNode[plug] = ops.reduce(function (result, op, idx) {
        // Only skip operator if active is `false`. Anything else means it is active (including undefined).
        if (op.active === false) return result;

        var operator = (0, _operators.lookupOperator)(plug, op.type, []);
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = (0, _getIterator3.default)(operator.fileReferenceKeys), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var key = _step4.value;

            updateReference(null, sceneGraph.fileReferences, id, plug, idx, key, op);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        var plugs = {};

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = (0, _getIterator3.default)(operator.nodeReferenceKeys), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _key = _step5.value;

            updateReference(sceneGraph, sceneGraph.nodeReferences, id, plug, idx, _key, op);
            if (op[_key] && !skipEvaluation) plugs[_key + 'Evaluated'] = getEvaluated(op[_key]);
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = (0, _getIterator3.default)((0, _keys2.default)(operator.plugReferences)), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var _key2 = _step6.value;

            updateReference(sceneGraph, sceneGraph.nodeReferences, id, plug, idx, _key2, op, operator.plugReferences[_key2]);
            if (op[_key2] && !skipEvaluation) plugs[_key2] = getEvaluated(op[_key2], operator.plugReferences[_key2]);
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }

        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = (0, _getIterator3.default)(operator.nodeReferenceListKeys), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var _key3 = _step7.value;

            updateReferenceList(sceneGraph.nodeReferences, id, plug, idx, _key3, op[_key3]);
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7.return) {
              _iterator7.return();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }

        if (operator.environment) {
          updateReference(sceneGraph, sceneGraph.nodeReferences, id, plug, idx, 'environment', { environment: sceneId }, 'Environment');
          if (!skipEvaluation) plugs.environment = getEvaluated(sceneId, 'Environment');
        }
        if (operator.hierarchyVisible) {
          updateReference(sceneGraph, sceneGraph.nodeReferences, id, plug, idx, 'hierarchyVisibility', { hierarchyVisibility: sceneId }, 'Properties');
          if (!skipEvaluation) plugs.sceneProperties = getEvaluated(sceneId, 'Properties');
        }
        if (operator.selfTransform) {
          if (!skipEvaluation) updateReference(sceneGraph, sceneGraph.nodeReferences, id, plug, idx, 'selfTransform', { selfTransform: id }, 'Transform');
        }
        if (operator.selfProperties) {
          if (!skipEvaluation) updateReference(sceneGraph, sceneGraph.nodeReferences, id, plug, idx, 'selfProperties', { selfProperties: id }, 'Properties');
        }

        if (skipEvaluation) return result;

        return operator.update((0, _assign2.default)({}, op, plugs), result, {
          sceneId: sceneId,
          node: node,
          store: store,
          properties: evalNode.Properties,
          getWorldTransform: getWorldTransform,
          getCameraWorldTransform: getCameraWorldTransform.bind(_this, id),
          previousResult: previousResult,
          loaded: sceneGraph.loaded,
          forceFetchAssets: options.forceFetchAssets
        });
      }, {});

      evalNode[plug]._v = previousVersion + 1;
    }

    var _iteratorNormalCompletion8 = true;
    var _didIteratorError8 = false;
    var _iteratorError8 = undefined;

    try {
      for (var _iterator8 = (0, _getIterator3.default)(evalNode.plugs), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
        var _plug = _step8.value;

        if (updatePlug === true || updatePlug === _plug) doUpdatePlug(_plug);
        nodeEvaluatedVersion += evalNode[_plug]._v;
      }
    } catch (err) {
      _didIteratorError8 = true;
      _iteratorError8 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion8 && _iterator8.return) {
          _iterator8.return();
        }
      } finally {
        if (_didIteratorError8) {
          throw _iteratorError8;
        }
      }
    }

    evalNode._v = node._v;
    evalNode._ev = nodeEvaluatedVersion;

    delete updating[id];
    delete toUpdate[id];
  }

  var _iteratorNormalCompletion9 = true;
  var _didIteratorError9 = false;
  var _iteratorError9 = undefined;

  try {
    for (var _iterator9 = (0, _getIterator3.default)(sceneNodeIds), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
      var _id3 = _step9.value;

      if (!sceneGraph.evaluatedNodes[_id3] || sceneGraph.evaluatedNodes[_id3]._v !== sceneGraph.nodes[_id3]._v) {
        if (sceneGraph.nodes[_id3]._changedPlug && sceneGraph.evaluatedNodes[_id3]) {
          toUpdate[_id3] = sceneGraph.nodes[_id3]._changedPlug;
          delete sceneGraph.nodes[_id3]._changedPlug;
        } else {
          toUpdate[_id3] = true;
        }
      }
    }

    // If any parent of leafId is updating, update leafId
  } catch (err) {
    _didIteratorError9 = true;
    _iteratorError9 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion9 && _iterator9.return) {
        _iterator9.return();
      }
    } finally {
      if (_didIteratorError9) {
        throw _iteratorError9;
      }
    }
  }

  function updateIfAnyParentIsUpdating(leafId, parentId) {
    if (parentId) {
      if (toUpdate[parentId]) {
        toUpdate[leafId] = toUpdate[leafId] ? true : 'Transform';
      } else updateIfAnyParentIsUpdating(leafId, sceneGraph.nodes[parentId].parent);
    }
  }

  var _iteratorNormalCompletion10 = true;
  var _didIteratorError10 = false;
  var _iteratorError10 = undefined;

  try {
    for (var _iterator10 = (0, _getIterator3.default)((0, _keys2.default)(sceneGraph.worldTransformReferences)), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
      var _id4 = _step10.value;

      if (toUpdate[_id4] !== true && toUpdate[_id4] !== 'Transform') updateIfAnyParentIsUpdating(_id4, sceneGraph.nodes[_id4].parent);
    }
  } catch (err) {
    _didIteratorError10 = true;
    _iteratorError10 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion10 && _iterator10.return) {
        _iterator10.return();
      }
    } finally {
      if (_didIteratorError10) {
        throw _iteratorError10;
      }
    }
  }

  if (toUpdate[(0, _player.getCamera)(store)]) {
    var _iteratorNormalCompletion11 = true;
    var _didIteratorError11 = false;
    var _iteratorError11 = undefined;

    try {
      for (var _iterator11 = (0, _getIterator3.default)((0, _keys2.default)(sceneGraph.cameraReferences)), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
        var _id = _step11.value;

        toUpdate[_id] = true;
      }
    } catch (err) {
      _didIteratorError11 = true;
      _iteratorError11 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion11 && _iterator11.return) {
          _iterator11.return();
        }
      } finally {
        if (_didIteratorError11) {
          throw _iteratorError11;
        }
      }
    }
  }

  var _iteratorNormalCompletion12 = true;
  var _didIteratorError12 = false;
  var _iteratorError12 = undefined;

  try {
    for (var _iterator12 = (0, _getIterator3.default)(evaluatedNodeIds), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
      var _id5 = _step12.value;

      if (!sceneGraph.nodes[_id5]) {
        toDelete[_id5] = true;
      }
    }
  } catch (err) {
    _didIteratorError12 = true;
    _iteratorError12 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion12 && _iterator12.return) {
        _iterator12.return();
      }
    } finally {
      if (_didIteratorError12) {
        throw _iteratorError12;
      }
    }
  }

  if (transitionToLoaded) {
    var _iteratorNormalCompletion13 = true;
    var _didIteratorError13 = false;
    var _iteratorError13 = undefined;

    try {
      for (var _iterator13 = (0, _getIterator3.default)(sceneNodeIds), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
        var _id2 = _step13.value;

        var evalNode = sceneGraph.evaluatedNodes[_id2];
        if (evalNode && evalNode.Properties && evalNode.Properties.prefetch) {
          toUpdate[_id2] = sceneGraph.nodes[_id2].type;
        }
      }
    } catch (err) {
      _didIteratorError13 = true;
      _iteratorError13 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion13 && _iterator13.return) {
          _iterator13.return();
        }
      } finally {
        if (_didIteratorError13) {
          throw _iteratorError13;
        }
      }
    }
  }

  function needsUpdateReference(refId, fromPlug) {
    if (from[refId]) {
      var _iteratorNormalCompletion14 = true;
      var _didIteratorError14 = false;
      var _iteratorError14 = undefined;

      try {
        for (var _iterator14 = (0, _getIterator3.default)((0, _keys2.default)(from[refId])), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
          var refKey = _step14.value;

          var refPlug = from[refId][refKey];

          var _JSON$parse = JSON.parse(refKey),
              _JSON$parse2 = (0, _slicedToArray3.default)(_JSON$parse, 4),
              nodeId = _JSON$parse2[0],
              plugName = _JSON$parse2[1],
              opIdx = _JSON$parse2[2],
              key = _JSON$parse2[3];
          //console.log(' - ref ', sceneGraph.nodes[nodeId].name, '-', plugName, '-', key, 'fromPlug: ', toUpdate[nodeId]);

          if (!fromPlug || refPlug === true || refPlug === fromPlug) {
            if (!toUpdate[nodeId]) {
              toUpdate[nodeId] = plugName;
              needsUpdateReference(nodeId, plugName);
            } else if (toUpdate[nodeId] !== plugName) {
              toUpdate[nodeId] = true;
              needsUpdateReference(nodeId, plugName);
            }
          }
        }
      } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion14 && _iterator14.return) {
            _iterator14.return();
          }
        } finally {
          if (_didIteratorError14) {
            throw _iteratorError14;
          }
        }
      }
    }
  }

  var _iteratorNormalCompletion15 = true;
  var _didIteratorError15 = false;
  var _iteratorError15 = undefined;

  try {
    for (var _iterator15 = (0, _getIterator3.default)((0, _keys2.default)(toUpdate)), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
      var _id6 = _step15.value;

      var fromPlug = toUpdate[_id6] === true ? false : toUpdate[_id6];
      if (from[_id6]) needsUpdateReference(_id6, fromPlug);
    }
  } catch (err) {
    _didIteratorError15 = true;
    _iteratorError15 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion15 && _iterator15.return) {
        _iterator15.return();
      }
    } finally {
      if (_didIteratorError15) {
        throw _iteratorError15;
      }
    }
  }

  var _iteratorNormalCompletion16 = true;
  var _didIteratorError16 = false;
  var _iteratorError16 = undefined;

  try {
    for (var _iterator16 = (0, _getIterator3.default)((0, _keys2.default)(toDelete)), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
      var _id7 = _step16.value;

      delete sceneGraph.evaluatedNodes[_id7];
    }

    // console.log('evalSceneGraph updating: ', Object.keys(toUpdate).length);
  } catch (err) {
    _didIteratorError16 = true;
    _iteratorError16 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion16 && _iterator16.return) {
        _iterator16.return();
      }
    } finally {
      if (_didIteratorError16) {
        throw _iteratorError16;
      }
    }
  }

  var _iteratorNormalCompletion17 = true;
  var _didIteratorError17 = false;
  var _iteratorError17 = undefined;

  try {
    for (var _iterator17 = (0, _getIterator3.default)((0, _keys2.default)(toUpdate)), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
      var _id8 = _step17.value;

      if (toUpdate[_id8]) updateNode(_id8, toUpdate[_id8]);
    }

    //if (nowLoaded) evalSceneGraph.loaded = true;

    // Store the current files and sceneGraph used to calculate evalSceneGraph
    //console.log('Update scene graph in: ', new Date() - start);
  } catch (err) {
    _didIteratorError17 = true;
    _iteratorError17 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion17 && _iterator17.return) {
        _iterator17.return();
      }
    } finally {
      if (_didIteratorError17) {
        throw _iteratorError17;
      }
    }
  }

  sceneGraph._ev = sceneGraph._v;
}

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

exports.initPhysics = initPhysics;
exports.updatePhysics = updatePhysics;

var _three = __webpack_require__(0);

var _mapObjIndexed = __webpack_require__(106);

var _mapObjIndexed2 = _interopRequireDefault(_mapObjIndexed);

var _scene = __webpack_require__(7);

var _physicsConstants = __webpack_require__(351);

var _physicsConstants2 = _interopRequireDefault(_physicsConstants);

var _triangulateMesh = __webpack_require__(240);

var _triangulateMesh2 = _interopRequireDefault(_triangulateMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// re-usable threeJS matrix decompose targets
var translation = new _three.Vector3();
var rotation = new _three.Quaternion();
var scale = new _three.Vector3();

function initWorld(store) {
  var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
  var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
  var overlappingPairCache = new Ammo.btDbvtBroadphase();
  var solver = new Ammo.btSequentialImpulseConstraintSolver();
  var dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);

  var gravity = (0, _scene.get)(store, { plug: 'Player', property: 'gravity' });
  if (!gravity) gravity = new _three.Vector3(0, -9.8, 0);
  dynamicsWorld.setGravity(new Ammo.btVector3(gravity.x, gravity.y, gravity.z));
  return dynamicsWorld;
}

function threeTransformToAmmo(threeTransform) {
  threeTransform.decompose(translation, rotation, scale);
  var ammoTranslation = new Ammo.btVector3(translation.x, translation.y, translation.z);
  var ammoRotation = new Ammo.btQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);
  return new Ammo.btTransform(ammoRotation, ammoTranslation);
}

function ammoTransformToThree(ammoTransform) {
  var ammoTranslation = ammoTransform.getOrigin();
  var ammoRotation = ammoTransform.getRotation();

  var threeTranslation = new _three.Vector3(ammoTranslation.x(), ammoTranslation.y(), ammoTranslation.z());
  var threeRotation = new _three.Quaternion(ammoRotation.x(), ammoRotation.y(), ammoRotation.z(), ammoRotation.w());
  var threeScale = new _three.Vector3(1, 1, 1);
  var threeTransform = new _three.Matrix4();

  threeTransform.compose(threeTranslation, threeRotation, threeScale);
  return threeTransform;
}

function createConvexHullFromPolyMesh(polyMesh) {
  var shape = new Ammo.btConvexHullShape();
  var verts = polyMesh.positions.values;

  var tmpVec3 = new _three.Vector3();
  for (var i = 0; i < verts.length; i++) {
    verts.getAt(i, tmpVec3);
    var pt = new Ammo.btVector3(tmpVec3.x, tmpVec3.y, tmpVec3.z);
    shape.addPoint(pt);
  }
  return shape;
}

function createCollisionMeshFromPolyMesh(translator, polyMesh, id) {
  // try to get already-triangulated mesh from ThreeJS, otherwise create new triangulation to use
  var threeMesh = translator.getThreeObject(id);
  var triMesh = null;
  if (threeMesh && threeMesh.userData && threeMesh.userData.triangulation) {
    triMesh = threeMesh.userData.triangulation.mesh;
  }
  if (!triMesh) {
    triMesh = (0, _triangulateMesh2.default)(polyMesh);
  }

  var verts = triMesh.positions.values;
  var indices = triMesh.positions.faceValueIndices;

  var mesh = new Ammo.btTriangleMesh(true, true);

  var tmpVec3a = new _three.Vector3();
  var tmpVec3b = new _three.Vector3();
  var tmpVec3c = new _three.Vector3();
  for (var i = 0; i < indices.length; i += 3) {
    verts.getAt(i, tmpVec3a);
    verts.getAt(i + 1, tmpVec3b);
    verts.getAt(i + 2, tmpVec3c);
    var ptA = new Ammo.btVector3(tmpVec3a.x, tmpVec3a.y, tmpVec3a.z);
    var ptB = new Ammo.btVector3(tmpVec3b.x, tmpVec3b.y, tmpVec3b.z);
    var ptC = new Ammo.btVector3(tmpVec3c.x, tmpVec3c.y, tmpVec3c.z);

    mesh.addTriangle(ptA, ptB, ptC, false);
  }

  var shape = new Ammo.btBvhTriangleMeshShape(mesh, true, true);
  return shape;
}

function createBoundingBoxShapeFromNode(nodeID, bbox) {
  var halfExtents = new Ammo.btVector3((bbox.max.x - bbox.min.x) / 2, (bbox.max.y - bbox.min.y) / 2, (bbox.max.z - bbox.min.z) / 2);
  return new Ammo.btBoxShape(halfExtents);
}

/*
 * Creates the Dynamics World, and initializes the Kinematic and Dynamic Bodies
 */
function initPhysics(store) {
  var kinematicBodies = {};
  var dynamicBodies = {};
  var translator = store.getEvaluatedTranslator();

  function createBodyWithProps(props, id) {
    var isKinematic = false;
    var isStatic = false;
    if (props.motionType === 'Kinematic') isKinematic = true;
    if (props.motionType === 'Static') isStatic = true;

    var colShape = null;
    var shapeLocalTransform = null;

    var worldTransformV2 = (0, _scene.getWorldTransform)(store, id);
    worldTransformV2.decompose(translation, rotation, scale);

    var shapeType = props.collisionShape;
    //  shapeType = 'Box';

    if (shapeType === 'Mesh') {
      var polyMesh = (0, _scene.get)(store, {
        id: id,
        evalPlug: 'PolyMesh',
        property: 'mesh'
      });
      if (polyMesh) {
        colShape = createCollisionMeshFromPolyMesh(translator, polyMesh, id);
        colShape.setLocalScaling(new Ammo.btVector3(scale.x, scale.y, scale.z));
      }
    } else if (shapeType === 'Box') {
      var bbox = (0, _scene.getNodeBoundingBox)(store, id);
      colShape = createBoundingBoxShapeFromNode(id, bbox);
      var bbCenter = new _three.Vector3((bbox.max.x + bbox.min.x) / 2, (bbox.max.y + bbox.min.y) / 2, (bbox.max.z + bbox.min.z) / 2);
      shapeLocalTransform = new _three.Matrix4().getInverse(worldTransformV2, true);
      shapeLocalTransform.multiply(new _three.Matrix4().makeTranslation(bbCenter.x, bbCenter.y, bbCenter.z));
      // bounding box already uses scaling?
    } else {
      // 'Convex'
      var _polyMesh = (0, _scene.get)(store, {
        id: id,
        evalPlug: 'PolyMesh',
        property: 'mesh'
      });
      if (_polyMesh) {
        colShape = createConvexHullFromPolyMesh(_polyMesh);
        // convex hull is created from base geometry, so still need to scale appropriately
        colShape.setLocalScaling(new Ammo.btVector3(scale.x, scale.y, scale.z));

        // For now let's set 0 margins. Better quality/appearance at the cost of performance, but
        // the demos seem to run fine for now.
        colShape.setMargin(0.0);
      }
    }

    if (!colShape) {
      var nodeName = (0, _scene.get)(store, { id: id, property: 'name' });
      console.warn('Could not create collision shape for \'' + nodeName + '\', defaulting to a unit sphere');
      colShape = new Ammo.btSphereShape(1);
    }

    // some shapes need custom offset compensation relative to the node's transform to be positioned/oriented correctly
    if (shapeLocalTransform) {
      worldTransformV2.multiply(shapeLocalTransform);
    }

    worldTransformV2.decompose(translation, rotation, scale);

    var startTransform = new Ammo.btTransform();
    startTransform.setIdentity();
    startTransform.setOrigin(new Ammo.btVector3(translation.x, translation.y, translation.z));
    startTransform.setRotation(new Ammo.btQuaternion(rotation.x, rotation.y, rotation.z, rotation.w));

    var mass = isKinematic || isStatic ? 0 : props.mass;
    var isDynamic = mass !== 0;
    var localInertia = new Ammo.btVector3(0, 0, 0);
    if (isDynamic) {
      colShape.calculateLocalInertia(mass, localInertia);
    }

    var myMotionState = new Ammo.btDefaultMotionState(startTransform);
    var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);
    rbInfo.m_linearDamping = props.linearDamping;
    rbInfo.m_angularDamping = props.angularDamping;
    rbInfo.m_friction = props.friction;
    rbInfo.m_rollingFriction = props.rollingFriction;
    rbInfo.m_linearSleepingThreshold = props.linearSleepingThreshold;
    rbInfo.m_angularSleepingThreshold = props.angularSleepingThreshold;
    rbInfo.m_restitution = props.restitution;
    var body = new Ammo.btRigidBody(rbInfo);

    if (isKinematic) {
      body.setCollisionFlags(body.getCollisionFlags() | _physicsConstants2.default.BODYFLAG_KINEMATIC_OBJECT);
      body.setActivationState(_physicsConstants2.default.BODYSTATE_DISABLE_DEACTIVATION);
    }

    dynamicsWorld.addRigidBody(body);
    if (isKinematic) kinematicBodies[id] = { body: body, shapeLocalTransform: shapeLocalTransform };else if (!isStatic) dynamicBodies[id] = { body: body, shapeLocalTransform: shapeLocalTransform };
    // don't need to do process any updates with static bodies after they are added to the world
  }

  var dynamicsWorld = initWorld(store);

  var physicsNodes = (0, _scene.getAll)(store, {
    plug: 'Properties',
    properties: { name: 'RigidBodyProperties' }
  });

  (0, _mapObjIndexed2.default)(createBodyWithProps, physicsNodes);

  return { dynamicsWorld: dynamicsWorld, kinematicBodies: kinematicBodies, dynamicBodies: dynamicBodies };
}

// Where do we want to perform this cleanup in the context of the V2 player?
function cleanupPhysics() {
  // Delete objects we created through |new|. We just do a few of them here, but you should do them all if you are not shutting down ammo.js
  // we'll free the objects in reversed order as they were created via 'new' to avoid the 'dead' object links
  // Ammo.destroy(dynamicsWorld);
  // Ammo.destroy(solver);
  // Ammo.destroy(overlappingPairCache);
  // Ammo.destroy(dispatcher);
  // Ammo.destroy(collisionConfiguration);
}

var internalSimulationInterval = 1 / 60;
var maxSubsteps = 4;

function updatePhysics(store, delta, globalTime, dynamicsWorld, dynamicBodies, kinematicBodies) {
  // run simulation step
  // see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World for param details
  // (actual deltaT in seconds, max # substeps, fixed minimum internal timestep)
  dynamicsWorld.stepSimulation(delta / 1000, maxSubsteps, internalSimulationInterval);

  var trans = new Ammo.btTransform();
  var rotationPhysics = new Ammo.btQuaternion();
  var translationPhysics = new Ammo.btVector3();
  var threeQuat = new _three.Quaternion();
  var euler = new _three.Euler();

  // process kinematic bodies
  (0, _keys2.default)(kinematicBodies).forEach(function (id) {
    var body = kinematicBodies[id].body;
    var worldTransformV2 = (0, _scene.getWorldTransform)(store, id);

    var shapeLocalTransform = kinematicBodies[id].shapeLocalTransform;
    if (shapeLocalTransform) {
      worldTransformV2.premultiply(shapeLocalTransform);
    }

    worldTransformV2.decompose(translation, rotation, scale);

    var motionState = body.getMotionState();
    var worldTransformPhysics = body.getWorldTransform();

    translationPhysics.setX(translation.x);
    translationPhysics.setY(translation.y);
    translationPhysics.setZ(translation.z);

    rotationPhysics.setX(rotation.x);
    rotationPhysics.setY(rotation.y);
    rotationPhysics.setZ(rotation.z);
    rotationPhysics.setW(rotation.w);

    worldTransformPhysics.setOrigin(translationPhysics);
    worldTransformPhysics.setRotation(rotationPhysics);
    motionState.setWorldTransform(worldTransformPhysics);
  });

  // process dynamic bodies
  (0, _keys2.default)(dynamicBodies).forEach(function (id) {
    var body = dynamicBodies[id].body;
    body.getMotionState().getWorldTransform(trans);
    var worldTransformV2 = ammoTransformToThree(trans);

    // if the node has a parent transform, need to convert Bullet's world-space transform to
    // a local transform for this node
    var parentNode = store.get('sceneGraph').nodes[id].parent;
    var worldTransformV2Parent = (0, _scene.getWorldTransform)(store, parentNode);
    if (worldTransformV2Parent) {
      worldTransformV2.premultiply(new _three.Matrix4().getInverse(worldTransformV2Parent, true));
    }

    // remove local shape transform
    var shapeLocalTransform = dynamicBodies[id].shapeLocalTransform;
    if (shapeLocalTransform) {
      worldTransformV2.premultiply(new _three.Matrix4().getInverse(shapeLocalTransform, true));
    }

    worldTransformV2.decompose(translation, rotation, scale);

    store.dispatch((0, _scene.set)({ id: id, plug: 'Transform', property: 'translation' }, [translation.x, translation.y, translation.z]));

    euler.setFromQuaternion(rotation, 'ZYX');

    store.dispatch((0, _scene.set)({ id: id, plug: 'Transform', property: 'rotation' }, [_three.Math.RAD2DEG * euler.x, _three.Math.RAD2DEG * euler.y, _three.Math.RAD2DEG * euler.z]));
  });
}

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// Adapted from:
// https://github.com/playcanvas/engine/blob/18bdc36d108031beca3fbfab948feb911eea2159/src/framework/components/rigid-body/constants.js

// Copyright (c) 2011-2017 PlayCanvas Ltd.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

var CONSTANTS = {
  // types
  BODYTYPE_STATIC: 'Static',
  BODYTYPE_DYNAMIC: 'Dynamic',
  BODYTYPE_KINEMATIC: 'Kinematic',

  // Collision flags
  BODYFLAG_STATIC_OBJECT: 1,
  BODYFLAG_KINEMATIC_OBJECT: 2,
  BODYFLAG_NORESPONSE_OBJECT: 4,

  // Activation states
  BODYSTATE_ACTIVE_TAG: 1,
  BODYSTATE_ISLAND_SLEEPING: 2,
  BODYSTATE_WANTS_DEACTIVATION: 3,
  BODYSTATE_DISABLE_DEACTIVATION: 4,
  BODYSTATE_DISABLE_SIMULATION: 5,

  // groups
  BODYGROUP_NONE: 0,
  BODYGROUP_DEFAULT: 1,
  BODYGROUP_DYNAMIC: 1,
  BODYGROUP_STATIC: 2,
  BODYGROUP_KINEMATIC: 4,
  BODYGROUP_ENGINE_1: 8,
  BODYGROUP_TRIGGER: 16,
  BODYGROUP_ENGINE_2: 32,
  BODYGROUP_ENGINE_3: 64,
  BODYGROUP_USER_1: 128,
  BODYGROUP_USER_2: 256,
  BODYGROUP_USER_3: 512,
  BODYGROUP_USER_4: 1024,
  BODYGROUP_USER_5: 2048,
  BODYGROUP_USER_6: 4096,
  BODYGROUP_USER_7: 8192,
  BODYGROUP_USER_8: 16384,

  // masks
  BODYMASK_NONE: 0,
  BODYMASK_ALL: 65535,
  BODYMASK_STATIC: 2,
  BODYMASK_NOT_STATIC: 65535 ^ 2,
  BODYMASK_NOT_STATIC_KINEMATIC: 65535 ^ (2 | 4)
};

exports.default = CONSTANTS;

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = __webpack_require__(47);

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

exports.default = syncSceneGraph;

var _rusha = __webpack_require__(693);

var _rusha2 = _interopRequireDefault(_rusha);

var _assets = __webpack_require__(33);

var _sceneGraph = __webpack_require__(10);

var _operators = __webpack_require__(101);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasher = new _rusha2.default();

function syncSceneGraph(store) {
  var sceneGraph = store.get('sceneGraph');
  var HEAD = sceneGraph.refs.HEAD;
  var objects = sceneGraph.objects,
      history = sceneGraph.history,
      syncedNodes = sceneGraph.syncedNodes;

  var sceneId = sceneGraph.activeSceneId;
  var sceneNodeIds = (0, _keys2.default)(sceneGraph.nodes);
  var evaluatedNodeIds = (0, _keys2.default)(sceneGraph.evaluatedNodes);
  var toUpdate = {};

  var newObjects = {};

  var heirarchy = {};

  function storeObject(obj) {
    var objString = (0, _stringify2.default)(obj);
    var hash = hasher.digest(objString);
    if (!objects[hash]) newObjects[hash] = objString;
    return hash;
  }

  function syncNode(id) {
    var node = sceneGraph.nodes[id];
    if (!node) return;

    heirarchy[id] = node.children;
    var children = node.children.map(syncNode);
    // if (node._sv === node._v) {
    //   console.log('skip tree: ', node.name);
    //   return node._hash;
    // }
    var toHash = { children: children, name: node.name, type: node.type };
    var plugs = {};
    // console.log(node.name);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var plug = _step.value;

        plugs[plug] = node.plugs[plug].map(function (op) {
          var operator = (0, _operators.lookupOperator)(plug, op.type, []);
          var toExport = operator.contentExport(op);
          var opHash = storeObject(toExport);
          // console.log(' - toExport: ', plug, op.type, opHash, toExport);
          return opHash;
        });
      };

      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(node.plugs)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    toHash.plugs = storeObject(plugs);
    var hash = storeObject(toHash);
    node._hash = hash;
    node._sv = node._v;
    // console.log('syncNode', node._v, node.name, node._hash);
    return hash;
  }

  var contentHash = syncNode(sceneId);
  var heirarchyHash = storeObject(heirarchy);

  var references = {};
  // FIXME: there must be a better way of reusing the references
  // than having to filter out the 'environment' references
  var refKeys = (0, _keys2.default)(sceneGraph.nodeReferences.to);
  // Sort, so that the references object is always stored the same way
  refKeys.sort();

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator3.default)(refKeys), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var refKey = _step2.value;

      var path = JSON.parse(refKey); //sceneGraph.nodeReferences.to[refKey]);
      if (!_sceneGraph.virtualNodes[path[0]] && !(path[1] === 'Material' && path[3] === 'environment')) {
        references[refKey] = sceneGraph.nodeReferences.to[refKey];
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var fileRefKeys = (0, _keys2.default)(sceneGraph.fileReferences.to);
  fileRefKeys.sort();

  var files = {};
  //console.log('store files?', fileRefKeys);
  fileRefKeys.forEach(function (refKey) {
    var id = sceneGraph.fileReferences.to[refKey];
    references[refKey] = id;

    var _getFile = (0, _assets.getFile)(store, id),
        name = _getFile.name,
        hash = _getFile.hash,
        type = _getFile.type,
        suffix = _getFile.suffix;

    if (hash) files[id] = storeObject({ name: name, hash: hash, type: type, suffix: suffix });
    //console.log('add fileReference: ', refKey, id, name, hash, type);
  });

  var referenceHash = storeObject(references);
  var fileHash = storeObject(files);
  //console.log('store file object: ', fileHash, files);

  var rootHash = storeObject({
    heirarchy: heirarchyHash,
    references: referenceHash,
    content: contentHash,
    files: fileHash
  });

  var commit = {
    root: rootHash,
    parents: HEAD ? [HEAD] : [],
    createdAt: new Date(),
    author: 'wvl',
    message: 'Version: ' + sceneGraph._v
  };

  var commitHash = storeObject(commit);

  return {
    commit: commit,
    commitHash: commitHash,
    objects: newObjects
  };

  // sceneGraph.commits[commitHash] = commit;
  // sceneGraph.history.push(commitHash);
  // sceneGraph._sv = sceneGraph._v;
  // return commitHash;
}

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// From: https://github.com/chenglou/tween-functions/blob/master/index.js
// t: current time, b: beginning value, _c: final value, d: total duration
var tweenFunctions = {
  linear: function linear(t, b, _c, d) {
    var c = _c - b;
    return c * t / d + b;
  },

  easeInQuad: function easeInQuad(t, b, _c, d) {
    var c = _c - b;
    return c * (t /= d) * t + b;
  },

  easeOutQuad: function easeOutQuad(t, b, _c, d) {
    var c = _c - b;
    return -c * (t /= d) * (t - 2) + b;
  },

  easeInOutQuad: function easeInOutQuad(t, b, _c, d) {
    var c = _c - b;
    if ((t /= d / 2) < 1) {
      return c / 2 * t * t + b;
    } else {
      return -c / 2 * (--t * (t - 2) - 1) + b;
    }
  },

  easeInCubic: function easeInCubic(t, b, _c, d) {
    var c = _c - b;
    return c * (t /= d) * t * t + b;
  },

  easeOutCubic: function easeOutCubic(t, b, _c, d) {
    var c = _c - b;
    return c * ((t = t / d - 1) * t * t + 1) + b;
  },

  easeInOutCubic: function easeInOutCubic(t, b, _c, d) {
    var c = _c - b;
    if ((t /= d / 2) < 1) {
      return c / 2 * t * t * t + b;
    } else {
      return c / 2 * ((t -= 2) * t * t + 2) + b;
    }
  },

  easeInQuart: function easeInQuart(t, b, _c, d) {
    var c = _c - b;
    return c * (t /= d) * t * t * t + b;
  },

  easeOutQuart: function easeOutQuart(t, b, _c, d) {
    var c = _c - b;
    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
  },

  easeInOutQuart: function easeInOutQuart(t, b, _c, d) {
    var c = _c - b;
    if ((t /= d / 2) < 1) {
      return c / 2 * t * t * t * t + b;
    } else {
      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    }
  },

  easeInQuint: function easeInQuint(t, b, _c, d) {
    var c = _c - b;
    return c * (t /= d) * t * t * t * t + b;
  },

  easeOutQuint: function easeOutQuint(t, b, _c, d) {
    var c = _c - b;
    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
  },

  easeInOutQuint: function easeInOutQuint(t, b, _c, d) {
    var c = _c - b;
    if ((t /= d / 2) < 1) {
      return c / 2 * t * t * t * t * t + b;
    } else {
      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    }
  },

  easeInSine: function easeInSine(t, b, _c, d) {
    var c = _c - b;
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
  },

  easeOutSine: function easeOutSine(t, b, _c, d) {
    var c = _c - b;
    return c * Math.sin(t / d * (Math.PI / 2)) + b;
  },

  easeInOutSine: function easeInOutSine(t, b, _c, d) {
    var c = _c - b;
    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
  },

  easeInExpo: function easeInExpo(t, b, _c, d) {
    var c = _c - b;
    var _ref;
    return (_ref = t === 0) !== null ? _ref : {
      b: c * Math.pow(2, 10 * (t / d - 1)) + b
    };
  },

  easeOutExpo: function easeOutExpo(t, b, _c, d) {
    var c = _c - b;
    var _ref;
    return (_ref = t === d) !== null ? _ref : b + {
      c: c * (-Math.pow(2, -10 * t / d) + 1) + b
    };
  },

  easeInOutExpo: function easeInOutExpo(t, b, _c, d) {
    var c = _c - b;
    if (t === 0) {
      b;
    }

    if (t === d) {
      b + c;
    }

    if ((t /= d / 2) < 1) {
      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
    } else {
      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
    }
  },

  easeInCirc: function easeInCirc(t, b, _c, d) {
    var c = _c - b;
    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
  },

  easeOutCirc: function easeOutCirc(t, b, _c, d) {
    var c = _c - b;
    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
  },

  easeInOutCirc: function easeInOutCirc(t, b, _c, d) {
    var c = _c - b;
    if ((t /= d / 2) < 1) {
      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
    } else {
      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    }
  },

  easeInElastic: function easeInElastic(t, b, _c, d) {
    var c = _c - b;
    var a, p, s;
    s = 1.70158;
    p = 0;
    a = c;
    if (t === 0) {
      b;
    } else if ((t /= d) === 1) {
      b + c;
    }

    if (!p) {
      p = d * 0.3;
    }

    if (a < Math.abs(c)) {
      a = c;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(c / a);
    }

    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
  },

  easeOutElastic: function easeOutElastic(t, b, _c, d) {
    var c = _c - b;
    var a, p, s;
    s = 1.70158;
    p = 0;
    a = c;
    if (t === 0) {
      b;
    } else if ((t /= d) === 1) {
      b + c;
    }

    if (!p) {
      p = d * 0.3;
    }

    if (a < Math.abs(c)) {
      a = c;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(c / a);
    }

    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
  },

  easeInOutElastic: function easeInOutElastic(t, b, _c, d) {
    var c = _c - b;
    var a, p, s;
    s = 1.70158;
    p = 0;
    a = c;
    if (t === 0) {
      b;
    } else if ((t /= d / 2) === 2) {
      b + c;
    }

    if (!p) {
      p = d * (0.3 * 1.5);
    }

    if (a < Math.abs(c)) {
      a = c;
      s = p / 4;
    } else {
      s = p / (2 * Math.PI) * Math.asin(c / a);
    }

    if (t < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    } else {
      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
    }
  },

  easeInBack: function easeInBack(t, b, _c, d, s) {
    var c = _c - b;
    if (s === void 0) {
      s = 1.70158;
    }

    return c * (t /= d) * t * ((s + 1) * t - s) + b;
  },

  easeOutBack: function easeOutBack(t, b, _c, d, s) {
    var c = _c - b;
    if (s === void 0) {
      s = 1.70158;
    }

    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  },

  easeInOutBack: function easeInOutBack(t, b, _c, d, s) {
    var c = _c - b;
    if (s === void 0) {
      s = 1.70158;
    }

    if ((t /= d / 2) < 1) {
      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
    } else {
      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
    }
  },

  easeInBounce: function easeInBounce(t, b, _c, d) {
    var c = _c - b;
    var v;
    v = tweenFunctions.easeOutBounce(d - t, 0, c, d);
    return c - v + b;
  },

  easeOutBounce: function easeOutBounce(t, b, _c, d) {
    var c = _c - b;
    if ((t /= d) < 1 / 2.75) {
      return c * (7.5625 * t * t) + b;
    } else if (t < 2 / 2.75) {
      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
    } else if (t < 2.5 / 2.75) {
      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
    } else {
      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
    }
  },

  easeInOutBounce: function easeInOutBounce(t, b, _c, d) {
    var c = _c - b;
    var v;
    if (t < d / 2) {
      v = tweenFunctions.easeInBounce(t * 2, 0, c, d);
      return v * 0.5 + b;
    } else {
      v = tweenFunctions.easeOutBounce(t * 2 - d, 0, c, d);
      return v * 0.5 + c * 0.5 + b;
    }
  }
};

exports.default = tweenFunctions;

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Annotation = {
  schema: {
    useText: {
      type: 'Boolean',
      label: 'Use Custom Text',
      defaultValue: false,
      animatable: false
    },
    text: {
      type: 'String',
      label: 'Custom Text',
      defaultValue: 'Annotation Text',
      animatable: false
    },
    open: {
      type: 'Boolean',
      label: 'Open by default',
      defaultValue: false,
      animatable: false
    },
    // Mis-spelled `limitVisibility`
    limitVisilibility: {
      type: 'Boolean',
      label: 'Limit Visibility',
      defaultValue: false,
      animatable: false
    },
    visibilityAngle: {
      type: 'Number',
      label: 'Visibility Angle',
      defaultValue: 180,
      step: 5,
      minValue: 10,
      maxValue: 360,
      animatable: false
    },
    directionMode: {
      label: 'Direction Mode',
      type: 'Options',
      labels: ['Manual', 'Away From Origin'],
      values: ['manual', 'awayFromOrigin'],
      defaultValue: 'manual'
    },
    directionAxis: {
      label: 'Direction',
      type: 'Options',
      labels: ['XAxis', 'YAxis', 'ZAxis'],
      values: ['x', 'y', 'z'],
      defaultValue: 'z'
    },
    directionTarget: { type: 'Node', label: 'Direction Target' }
  },

  update: function update(operator, primitive, _ref) {
    var node = _ref.node;

    (0, _assign2.default)(primitive, operator);
    if (!operator.useText) primitive.text = node.name;
  }
};

exports.default = { Annotation: Annotation };

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var filmSizes = {
  '-1': '[ Custom ]',
  35: '35mm',
  70: 'IMAX'
  // TODO: add more of these!
};

var viewType = {
  values: [0, 1],
  labels: ['Field of View', 'Focal Length']
};

var Camera = {
  schema: {
    targeted: {
      label: 'Enable Look Target',
      type: 'Boolean',
      defaultValue: false
    },
    focalDepthEnabled: {
      label: 'Use Focal Depth',
      type: 'Boolean',
      defaultValue: false
    },
    focalDepth: {
      label: 'Focal Depth',
      type: 'Number',
      defaultValue: 100,
      minValue: 0.001,
      animatable: true,
      hidden: true
    },

    axisDirection: { type: 'Object', hidden: true },
    zoomAxis: { type: 'Object', hidden: true },
    //size: { type: 'Object', hidden: true},  // Call getSize() to access this field, and call viewport.getViewRect(() for view resolution

    projection: {
      label: 'Projection',
      type: 'Options',
      defaultValue: 'Perspective',
      values: ['Perspective', 'Orthographic']
    },

    viewCtrl: {
      type: 'Options',
      defaultValue: 0,
      values: viewType.values,
      labels: viewType.labels,
      label: 'View Control'
    },
    fieldOfView: {
      label: 'Field of View',
      type: 'Number',
      defaultValue: 45,
      minValue: 5,
      maxValue: 179,
      animatable: true
    },
    orthoHeight: {
      label: 'Orthographic Height',
      type: 'Number',
      defaultValue: 1,
      minValue: 0,
      maxValue: 10000,
      step: 0.1,
      animatable: true
    },
    focalLength: {
      label: 'Focal Length (mm)',
      type: 'Number',
      defaultValue: 40,
      minValue: 1,
      maxValue: 400,
      step: 1,
      animatable: true
    },
    filmSizeBox: {
      type: 'Options',
      defaultValue: '35',
      values: (0, _keys2.default)(filmSizes),
      labels: filmSizes,
      label: 'Film Size'
    },
    customFilmSize: {
      label: 'Custom Film Size (mm)',
      type: 'Number',
      defaultValue: 35,
      step: 0.1,
      minValue: 1,
      maxValue: 1000
    },
    fStop: {
      label: 'F-Stop',
      type: 'Number',
      defaultValue: 2.8,
      minValue: 0.7,
      maxValue: 32,
      step: 0.1
    },
    filmOffset: {
      label: 'Film Offset (mm)',
      type: 'Vec2',
      defaultValue: { x: 0, y: 0 },
      minValue: -1000.0,
      step: 1.0,
      maxValue: 1000.0
    },

    aspectRatio: {
      label: 'Aspect Ratio',
      type: 'Number',
      defaultValue: 16.0 / 9.0,
      step: 0.01,
      minValue: 0.01,
      maxValue: 10
    },
    nearClip: {
      label: 'Near Clip',
      type: 'Number',
      step: 0.01,
      defaultValue: 0.1,
      minValue: 0.01
    },
    farClip: {
      label: 'Far Clip',
      type: 'Number',
      defaultValue: 50000,
      step: 1,
      minValue: 0.00001,
      maxValue: 1000000
    },
    orthoZoom: {
      label: 'Ortho Zoom',
      type: 'Number',
      defaultValue: 1,
      minValue: 0.01,
      step: 0.1
    },

    // Orbit around
    targetDistance: {
      label: 'Distance to Target',
      type: 'Number',
      defaultValue: 5.0,
      minValue: 0.01
    }, // Distance to target, in world space
    target: {
      label: 'Virtual Target',
      type: 'Vec3',
      defaultValue: { x: 0, y: 0, z: 0 },
      hidden: true
    }, // Virtual target, in world space

    // Display
    showFrustum: {
      label: 'Show Frustum',
      type: 'Boolean',
      defaultValue: false
    },
    frustumColor: {
      label: 'Frustum Color',
      type: 'Color',
      defaultValue: { r: 1, g: 0.78, b: 0 },
      animatable: true
    },
    showClipping: {
      label: 'Show Clipping',
      type: 'Boolean',
      defaultValue: false
    },
    showTarget: {
      label: 'Show Virtual Target',
      type: 'Boolean',
      defaultValue: false
    }
  },

  update: function update(operator, primitive, _ref) {
    var previousResult = _ref.previousResult;

    //console.log('Camera update?', operator.aspectRatio, operator.fieldOfView, primitive, previousResult);
    (0, _assign2.default)(primitive, operator);

    // Values initialized / editor from the translator that we carry through
    var keepKeys = ['pivotMatrix', 'upPosition', 'radiusConstraint', 'newRadiusConstraint', 'offset', 'newAngleAttrs'];
    if (previousResult) {
      for (var i = 0; i < keepKeys.length; i++) {
        if (previousResult[keepKeys[i]]) primitive[keepKeys[i]] = previousResult[keepKeys[i]];
      }
    }

    var box = operator.filmSizeBox;
    primitive.filmSize = box === -1 ? operator.customFilmSize : parseFloat(box);
  }
};

exports.default = { Camera: Camera };

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var backgroundStyle = {
  values: [0, 1, 2, 3, 4],
  labels: ['Default', 'Color', 'Image', 'CubeMap', 'EnvironmentMap']
};

var Environment = {
  schema: {
    ambientLight: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0, g: 0, b: 0 }
    },
    environmentMap: {
      label: 'Environment Map',
      type: 'Plug',
      plug: 'Material'
    },

    backgroundStyle: {
      label: 'Style',
      type: 'Options',
      defaultValue: 0,
      values: backgroundStyle.values,
      labels: backgroundStyle.labels
    },
    backgroundColor: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0, g: 0, b: 0 }
    },
    backgroundOpacity: {
      label: 'Opacity',
      type: 'Number',
      defaultValue: 1,
      minValue: 0,
      maxValue: 1,
      step: 0.1
    },

    background: { label: 'Image', type: 'Plug', plug: 'Image' },

    cubeMapBlurring: {
      label: 'CubeMap Blur',
      type: 'Number',
      defaultValue: 0,
      minValue: 0,
      maxValue: 10,
      step: 0.5,
      animatable: true
    },
    cubeMap: { label: 'CubeMap', type: 'Plug', plug: 'Material' }
  }
};

exports.default = { Environment: Environment };

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assets = __webpack_require__(33);

var Font = {
  schema: {
    fontAsset: { type: 'File', hidden: true }
  },
  update: function update(operator, primitive, _ref) {
    var store = _ref.store;

    // Don't download the font here, since it may not be required, and there
    // is no 'visible' property to the material.
    primitive.getFont = function () {
      return store.hasApi() && store.dispatch((0, _assets.getOrFetchFont)(operator.fontAsset));
    };
    return primitive;
  }
};

exports.default = { Font: Font };

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var RES_LIST = {
  values: [0, 1, 2, 3, 4, 5, 6, 7],
  labels: ['[ Custom ]', 'HD 720', 'HD 1080', '640x480', 'Full 1024', '1k Square', '2k Square', 'Retina']
};

var GeneralRenderer = {
  schema: {
    // general settings
    res: {
      label: 'Resolution',
      type: 'Options',
      defaultValue: '1',
      values: RES_LIST.values,
      labels: RES_LIST.labels
    },
    res_w: {
      label: 'Custom Width',
      type: 'Number',
      defaultValue: 1280,
      minValue: 100,
      isInteger: true
    },
    res_h: {
      label: 'Custom Height',
      type: 'Number',
      defaultValue: 720,
      minValue: 100,
      isInteger: true
    },
    output_dir: { label: 'Output directory', type: 'Text' },

    // current pass
    curPass: { label: 'Current Pass', type: 'Node' },

    // batch rendering
    frm_start: { label: 'Start Frame', type: 'Number', defaultValue: 1 },
    frm_last: { label: 'Last Frame', type: 'Number', defaultValue: 24 },
    frm_by: { label: 'By Frame', type: 'Number', defaultValue: 1 },

    ren_start: {
      label: 'Start number',
      type: 'Number',
      defaultValue: 1,
      isInteger: true
    },
    ren_by: {
      label: 'By Frame',
      type: 'Number',
      defaultValue: 1,
      isInteger: true
    },
    frm_pad: {
      label: 'Frame padding',
      type: 'Number',
      defaultValue: 1,
      minValue: 0,
      maxValue: 10,
      isInteger: true
    }
  }
};

exports.default = { GeneralRenderer: GeneralRenderer };

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _three = __webpack_require__(0);

var _assets = __webpack_require__(33);

var _path = __webpack_require__(689);

var _path2 = _interopRequireDefault(_path);

var _runtimeInfo = __webpack_require__(56);

var _asset = __webpack_require__(243);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var svgRegex = /\.svg/i;

var Linear = 3000;
var sRGB = 3001;
var RGBE = 3002;
var LogLUV = 3003;
var RGBM7 = 3004;
var RGBM16 = 3005;

var renderType = {
  Original: 0,
  WebGL: 1,
  Renderer: 3
};

var renderTypes = {
  values: [0, 1, 2],
  labels: ['Original', 'WebGL', 'Renderer']
};

var wrapType = {
  values: [0, 1, 2],
  labels: ['None', 'Wrap', 'Mirror']
};

var sampleFilter = {
  values: [_three.NearestFilter, _three.NearestMipMapNearestFilter, _three.NearestMipMapLinearFilter, _three.LinearFilter, _three.LinearMipMapNearestFilter, _three.LinearMipMapLinearFilter],
  labels: ['Nearest', 'Nearest MipMap Nearest', 'Nearest MipMap Linear', 'Linear', 'Linear MipMap Nearest', 'Linear MipMap Linear']
};

var encodingType = {
  values: [Linear, sRGB, RGBE, LogLUV, RGBM7, RGBM16],
  labels: ['Linear', 'sRGB', 'RGBE/Radiance', 'Log LUV', 'RGBM 7', 'RGBM 16']
};
// IE is not compatibility with all canvas blend mode, set the incompatible mode to 'source-over' in IE
var getCompatibleBlendMode = function getCompatibleBlendMode(selectMode) {
  // IE render the following blend mode correctly
  var ieCompatibleMode = ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor'];
  return _runtimeInfo.isIE && ieCompatibleMode.indexOf(selectMode) < 0 ? 'source-over' : selectMode;
};
var Image = {
  schema: {
    originalBitmapFile: { type: 'Image', hidden: true },
    glBitmapFile: { type: 'Image', hidden: true },
    rendererBitmapFile: { type: 'Image', hidden: true },
    hdrBitmapFile: { type: 'Image', hidden: true },

    renderOption: {
      label: 'Server Image',
      type: 'Options',
      defaultValue: 0,
      values: renderTypes.values,
      labels: renderTypes.labels
    },
    glOption: {
      label: 'WebGL Image',
      type: 'Options',
      defaultValue: 1,
      values: renderTypes.values,
      labels: renderTypes.labels
    },

    uOffset: {
      type: 'Number',
      label: 'U Offset',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    },
    vOffset: {
      type: 'Number',
      label: 'V Offset',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    },
    uTile: {
      type: 'Number',
      label: 'U Tile',
      defaultValue: 1,
      step: 0.1,
      animatable: true
    },
    vTile: {
      type: 'Number',
      label: 'V Tile',
      defaultValue: 1,
      step: 0.1,
      animatable: true
    },
    rotation: {
      type: 'Number',
      label: 'Rotation',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    },
    wrapU: {
      type: 'Options',
      defaultValue: 1,
      values: wrapType.values,
      labels: wrapType.labels,
      label: 'U Wrap Style'
    },
    wrapV: {
      type: 'Options',
      defaultValue: 1,
      values: wrapType.values,
      labels: wrapType.labels,
      label: 'V Wrap Style'
    },

    invert: {
      type: 'Boolean',
      label: 'Invert',
      defaultValue: false,
      animatable: true
    },
    gainPivot: {
      type: 'Number',
      label: 'Gain Pivot',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    },
    gain: {
      type: 'Number',
      label: 'Gain',
      defaultValue: 1.0,
      step: 0.1,
      animatable: true
    },
    brightness: {
      type: 'Number',
      label: 'Brightness',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    },

    magFilter: {
      type: 'Options',
      defaultValue: _three.LinearFilter,
      values: sampleFilter.values,
      labels: sampleFilter.labels,
      label: 'Magnify Filter'
    },
    minFilter: {
      type: 'Options',
      defaultValue: _three.LinearMipMapLinearFilter,
      values: sampleFilter.values,
      labels: sampleFilter.labels,
      label: 'Minify Filter'
    },
    generateMipMaps: {
      label: 'Use MipMaps',
      type: 'Boolean',
      defaultValue: true
    },

    hdrEncoding: {
      type: 'Options',
      defaultValue: RGBM16,
      values: encodingType.values,
      labels: encodingType.labels,
      label: 'HDR Encoding'
    },

    optimizeImage: {
      label: 'Optimize Image',
      type: 'Boolean',
      defaultValue: false
    },

    resizeImage: {
      label: 'Resize Image',
      type: 'Boolean',
      defaultValue: false
    },

    resizeWidth: {
      label: 'Width',
      type: 'Options',
      defaultValue: 512,
      values: [32, 64, 128, 256, 512, 1024, 2048, 4096],
      labels: ['32', '64', '128', '256', '512', '1024', '2048', '4096']
    },

    resizeHeight: {
      label: 'Height',
      type: 'Options',
      defaultValue: 512,
      values: [32, 64, 128, 256, 512, 1024, 2048, 4096],
      labels: ['32', '64', '128', '256', '512', '1024', '2048', '4096']
    },

    optimizeFormat: {
      label: 'Format',
      type: 'Options',
      defaultValue: '',
      values: ['', 'png', 'jpeg'],
      labels: ['Default', 'PNG', 'JPEG']
    }
  },

  update: function update(operator, primitive, _ref) {
    var node = _ref.node,
        store = _ref.store;

    var asset = null;

    var imageSourceUrl = (0, _assets.getUrl)(store, operator.originalBitmapFile);
    var extension = imageSourceUrl && _path2.default.extname(imageSourceUrl);
    //const renderOption = __SERVER__ ? operator.renderOption : operator.glOption;
    var renderOption = operator.glOption;

    if (renderOption === renderType.WebGL || svgRegex.exec(extension) && (_runtimeInfo.isIE || false)) {
      asset = operator.glBitmapFile || operator.originalBitmapFile;
    } else if (renderOption == renderType.Original) {
      asset = operator.originalBitmapFile;
    } else {
      asset = operator.rendererBitmapFile || operator.originalBitmapFile;
    }

    primitive.asset = asset;
    primitive.originalAsset = operator.originalBitmapFile;
    primitive.extension = extension;
    primitive.hdr = operator.hdrBitmapFile;

    // need reference to original hdr since headless/IE are not handling the hdr.png's properly
    // hdr extension must be 'hdr' - we do not support alternative hdr formats (ex. 'exr')
    if (operator.hdrBitmapFile && extension === '.hdr') {
      primitive.hdrSource = operator.originalBitmapFile;
    }

    ['uOffset', 'vOffset', 'uTile', 'vTile', 'rotation', 'wrapU', 'wrapV', 'gain', 'gainPivot', 'brightness', 'magFilter', 'minFilter', 'generateMipMaps', 'hdrEncoding', 'invert', 'optimizeImage', 'resizeImage', 'resizeWidth', 'resizeHeight', 'optimizeFormat'].forEach(function (key) {
      primitive[key] = operator[key];
    });

    primitive.preferHDR = operator.hdrEncoding !== Linear && !!operator.hdrBitmapFile;

    return primitive;
  }
};

var Canvas = {
  schema: {
    width: {
      type: 'Number',
      defaultValue: 512,
      minValue: 16,
      maxValue: 4096,
      step: 1,
      label: 'Width'
    },
    height: {
      type: 'Number',
      defaultValue: 512,
      minValue: 16,
      maxValue: 4096,
      step: 1,
      label: 'Height'
    },

    color: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0, g: 0, b: 0, a: 0 },
      animatable: true
    },
    opacity: {
      label: 'Opacity',
      type: 'Number',
      defaultValue: 1,
      minValue: 0,
      maxValue: 1,
      step: 0.1,
      animatable: true
    },

    uOffset: {
      type: 'Number',
      label: 'U Offset',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    },
    vOffset: {
      type: 'Number',
      label: 'V Offset',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    },
    uTile: {
      type: 'Number',
      label: 'U Tile',
      defaultValue: 1,
      step: 0.1,
      animatable: true
    },
    vTile: {
      type: 'Number',
      label: 'V Tile',
      defaultValue: 1,
      step: 0.1,
      animatable: true
    },
    rotation: {
      type: 'Number',
      label: 'Rotation',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    },
    wrapU: {
      type: 'Options',
      defaultValue: 1,
      values: wrapType.values,
      labels: wrapType.labels,
      label: 'U Wrap Style'
    },
    wrapV: {
      type: 'Options',
      defaultValue: 1,
      values: wrapType.values,
      labels: wrapType.labels,
      label: 'V Wrap Style'
    },

    invert: {
      type: 'Boolean',
      label: 'Invert',
      defaultValue: false,
      animatable: true
    },
    gainPivot: {
      type: 'Number',
      label: 'Gain Pivot',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    },
    gain: {
      type: 'Number',
      label: 'Gain',
      defaultValue: 1.0,
      step: 0.1,
      animatable: true
    },
    brightness: {
      type: 'Number',
      label: 'Brightness',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    },

    magFilter: {
      type: 'Options',
      defaultValue: _three.LinearFilter,
      values: sampleFilter.values,
      labels: sampleFilter.labels,
      label: 'Magnify Filter'
    },
    minFilter: {
      type: 'Options',
      defaultValue: _three.LinearMipMapLinearFilter,
      values: sampleFilter.values,
      labels: sampleFilter.labels,
      label: 'Minify Filter'
    },
    generateMipMaps: {
      label: 'Use MipMaps',
      type: 'Boolean',
      defaultValue: true
    },

    hdrEncoding: {
      type: 'Options',
      defaultValue: _three.RGBM16Encoding,
      values: encodingType.values,
      labels: encodingType.labels,
      label: 'HDR Encoding'
    },

    externalId: { type: 'String', defaultValue: '', label: 'External ID' }
  },

  update: function update(operator, primitive, _ref2) {
    var node = _ref2.node,
        store = _ref2.store;

    var ctxWidth = operator.width;
    var ctxHeight = operator.height;
    var id = operator.externalId;

    var color = operator.color;
    if (color) color = 'rgba(' + parseInt(color.r * 255) + ',' + parseInt(color.g * 255) + ',' + parseInt(color.b * 255) + ',' + operator.opacity + ')';
    ['uOffset', 'vOffset', 'uTile', 'vTile', 'rotation', 'wrapU', 'wrapV', 'gain', 'gainPivot', 'brightness', 'magFilter', 'minFilter', 'generateMipMaps', 'hdrEncoding', 'invert', 'width', 'height'].forEach(function (key) {
      primitive[key] = operator[key];
    });

    var externalCanvas = void 0;
    if (id !== '' && true) {
      externalCanvas = document.getElementById(id);
      if (!externalCanvas) {
        externalCanvas = store.createCanvas(ctxWidth, ctxHeight);
        document.body.appendChild(externalCanvas);
        externalCanvas.id = id;
        externalCanvas.style.display = 'none';
      }
    }

    var op = function op(context, store, canvas) {
      context.fillStyle = color;
      context.fillRect(0, 0, ctxWidth, ctxHeight);
      if (externalCanvas) {
        context.drawImage(externalCanvas, 0, 0, ctxWidth, ctxHeight);
      }
      return true;
    };

    if (!primitive.canvasOperations) {
      primitive.canvasOperations = [op];
    } else {
      primitive.canvasOperations.push(op);
    }

    return primitive;
  }
};

var CanvasLinearGradient = {
  schema: {
    startIs: {
      label: 'Start Is',
      type: 'Options',
      values: ['top', 'left', 'top-left', 'bottom-left'],
      initialValue: 'top'
    },
    startColor: {
      label: 'Start Color',
      type: 'Color',
      defaultValue: { r: 0, g: 0, b: 0, a: 0 },
      animatable: true
    },
    startOpacity: {
      label: 'Start Opacity',
      type: 'Number',
      defaultValue: 1,
      minValue: 0,
      maxValue: 1,
      step: 0.1,
      animatable: true
    },
    endColor: {
      label: 'End Color',
      type: 'Color',
      defaultValue: { r: 0, g: 0, b: 0, a: 0 },
      animatable: true
    },
    endOpacity: {
      label: 'End Opacity',
      type: 'Number',
      defaultValue: 1,
      minValue: 0,
      maxValue: 1,
      step: 0.1,
      animatable: true
    },

    xOffset: {
      type: 'Number',
      defaultValue: 0,
      minValue: -10000,
      maxValue: +10000,
      step: 1,
      label: 'X',
      animatable: true
    },
    yOffset: {
      type: 'Number',
      defaultValue: 0,
      minValue: -10000,
      maxValue: +10000,
      step: 1,
      label: 'Y',
      animatable: true
    },
    width: {
      type: 'Number',
      defaultValue: 512,
      minValue: 16,
      maxValue: 4096,
      step: 1,
      label: 'Width'
    },
    height: {
      type: 'Number',
      defaultValue: 512,
      minValue: 16,
      maxValue: 4096,
      step: 1,
      label: 'Height'
    },

    composition: {
      label: 'Mode',
      type: 'Options',
      values: ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'],
      initialValue: 'source-over'
    }
  },

  update: function update(operator, primitive) {
    var xOffset = operator.xOffset;
    var yOffset = operator.yOffset;
    var width = operator.width;
    var height = operator.height;

    var startColor = operator.startColor;
    var endColor = operator.endColor;
    if (startColor) startColor = 'rgba(' + parseInt(startColor.r * 255) + ',' + parseInt(startColor.g * 255) + ',' + parseInt(startColor.b * 255) + ',' + operator.startOpacity + ')';
    if (endColor) endColor = 'rgba(' + parseInt(endColor.r * 255) + ',' + parseInt(endColor.g * 255) + ',' + parseInt(endColor.b * 255) + ',' + operator.endOpacity + ')';

    var op = function op(canvasContext) {
      var grd = void 0;
      switch (operator.startIs) {
        case 'top':
          grd = canvasContext.createLinearGradient(xOffset, yOffset, xOffset, yOffset + height);
          break;
        case 'left':
          grd = canvasContext.createLinearGradient(xOffset, yOffset, xOffset + width, yOffset);
          break;
        case 'top-left':
          grd = canvasContext.createLinearGradient(xOffset, yOffset, xOffset + width, yOffset + height);
          break;
        default:
          grd = canvasContext.createLinearGradient(xOffset, yOffset + height, xOffset + width, yOffset);
          break;
      }
      grd.addColorStop(0, startColor);
      grd.addColorStop(1, endColor);
      canvasContext.fillStyle = grd;

      canvasContext.globalCompositeOperation = getCompatibleBlendMode(operator.composition);

      canvasContext.fillRect(xOffset, yOffset, width, height);
      return true;
    };

    if (!primitive.canvasOperations) {
      primitive.canvasOperations = [op];
    } else {
      primitive.canvasOperations.push(op);
    }

    return primitive;
  }
};

var CanvasFill = {
  schema: {
    color: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0, g: 0, b: 0, a: 0 },
      animatable: true
    },
    opacity: {
      label: 'Opacity',
      type: 'Number',
      defaultValue: 1,
      minValue: 0,
      maxValue: 1,
      step: 0.1,
      animatable: true
    },

    xOffset: {
      type: 'Number',
      defaultValue: 0,
      minValue: -10000,
      maxValue: +10000,
      step: 1,
      label: 'X',
      animatable: true
    },
    yOffset: {
      type: 'Number',
      defaultValue: 0,
      minValue: -10000,
      maxValue: +10000,
      step: 1,
      label: 'Y',
      animatable: true
    },
    width: {
      type: 'Number',
      defaultValue: 512,
      minValue: 16,
      maxValue: 4096,
      step: 1,
      label: 'Width'
    },
    height: {
      type: 'Number',
      defaultValue: 512,
      minValue: 16,
      maxValue: 4096,
      step: 1,
      label: 'Height'
    },

    composition: {
      label: 'Mode',
      type: 'Options',
      values: ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'],
      initialValue: 'source-over'
    }
  },

  update: function update(operator, primitive) {
    var xOffset = operator.xOffset;
    var yOffset = operator.yOffset;
    var width = operator.width;
    var height = operator.height;

    var color = operator.color;
    if (color) color = 'rgba(' + parseInt(color.r * 255) + ',' + parseInt(color.g * 255) + ',' + parseInt(color.b * 255) + ',' + operator.opacity + ')';

    var op = function op(canvasContext) {
      canvasContext.fillStyle = color;
      canvasContext.globalCompositeOperation = getCompatibleBlendMode(operator.composition);
      canvasContext.fillRect(xOffset, yOffset, width, height);
      return true;
    };

    if (!primitive.canvasOperations) {
      primitive.canvasOperations = [op];
    } else {
      primitive.canvasOperations.push(op);
    }

    return primitive;
  }
};

var cachedCanvas = void 0;

var CanvasComposite = {
  schema: {
    sourceImage: { type: 'Plug', plug: 'Image' },

    xOffset: {
      type: 'Number',
      defaultValue: 0,
      minValue: -10000,
      maxValue: +10000,
      step: 1,
      label: 'X Pixel',
      animatable: true
    },
    yOffset: {
      type: 'Number',
      defaultValue: 0,
      minValue: -10000,
      maxValue: +10000,
      step: 1,
      label: 'Y Pixel',
      animatable: true
    },
    windowed: {
      type: 'Boolean',
      label: 'Windowed',
      defaultValue: false,
      animatable: true
    },
    windowBorder: {
      type: 'Boolean',
      label: 'Window Border',
      defaultValue: true,
      animatable: true
    },
    windowWidth: {
      type: 'Number',
      defaultValue: 512,
      minValue: 0,
      maxValue: 4096,
      step: 1,
      label: 'Window Width',
      animatable: true
    },
    windowHeight: {
      type: 'Number',
      defaultValue: 512,
      minValue: 0,
      maxValue: 4096,
      step: 1,
      label: 'Window Height',
      animatable: true
    },
    windowRelativeWidth: {
      type: 'Number',
      defaultValue: 0.5,
      minValue: 0,
      maxValue: 1,
      step: 0.01,
      label: 'Relative Widnow Width',
      animatable: true
    },
    windowRelativeHeight: {
      type: 'Number',
      defaultValue: 0.5,
      minValue: 0,
      maxValue: 1,
      step: 0.01,
      label: 'Relative Window Height',
      animatable: true
    },
    windowFitMode: {
      type: 'Options',
      values: ['none', 'fit width', 'fit height', 'inside', 'full'],
      defaultValue: 'none',
      label: 'Window Fit Mode'
    },
    xRelativeOffset: {
      type: 'Number',
      defaultValue: 0,
      minValue: -10,
      maxValue: +10,
      step: 0.01,
      label: 'X Relative',
      animatable: true
    },
    yRelativeOffset: {
      type: 'Number',
      defaultValue: 0,
      minValue: -10,
      maxValue: +10,
      step: 0.01,
      label: 'Y Relative',
      animatable: true
    },
    offsetUnit: {
      label: 'Unit',
      type: 'Options',
      values: ['pixel', 'relative'],
      initialValue: 'absolute'
    },

    overrideSize: {
      type: 'Boolean',
      label: 'Override Default Size',
      defaultValue: false,
      animatable: true
    },
    overrideWidth: {
      type: 'Number',
      defaultValue: 0,
      minValue: -10000,
      maxValue: +10000,
      step: 1,
      label: 'Override Width',
      animatable: true
    },
    overrideHeight: {
      type: 'Number',
      defaultValue: 0,
      minValue: -10000,
      maxValue: +10000,
      step: 1,
      label: 'Override Height',
      animatable: true
    },
    overrideWidthRelative: {
      type: 'Number',
      defaultValue: 1,
      minValue: -100,
      maxValue: +100,
      step: 0.01,
      label: 'Relative Width',
      animatable: true
    },
    overrideHeightRelative: {
      type: 'Number',
      defaultValue: 1,
      minValue: -100,
      maxValue: +100,
      step: 0.01,
      label: 'Relative Height',
      animatable: true
    },
    overrideSizeUnit: {
      label: 'Unit',
      type: 'Options',
      values: ['pixel', 'relative'],
      initialValue: 'absolute'
    },

    rotation: {
      type: 'Number',
      defaultValue: 0,
      minValue: -3600,
      maxValue: 3600,
      step: 1,
      label: 'Rotation',
      animatable: true
    },
    horizontalAlign: {
      type: 'Options',
      defaultValue: 'left',
      values: ['left', 'center', 'right'],
      label: 'Horizontal Align'
    },
    verticalAlign: {
      type: 'Options',
      defaultValue: 'top',
      values: ['top', 'middle', 'bottom'],
      label: 'Vertical Align'
    },

    composition: {
      label: 'Composition',
      type: 'Options',
      values: ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'],
      initialValue: 'source-over'
    },

    tint: {
      label: 'Enabled',
      type: 'Boolean',
      defaultValue: false,
      animatable: true
    },
    tintColor: {
      label: 'Tint Color',
      type: 'Color',
      defaultValue: 0xffffff,
      animatable: true
    },
    tintOpacity: {
      label: 'Opacity',
      type: 'Number',
      defaultValue: 1,
      minValue: 0,
      maxValue: 1,
      step: 0.01,
      animatable: true
    },
    tintComposition: {
      label: 'Tint Mode',
      type: 'Options',
      values: ['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'],
      initialValue: 'multiply'
    }
  },

  update: function update(operator, primitive, _ref3) {
    var node = _ref3.node,
        store = _ref3.store;

    var sourceImage = operator.sourceImage;

    var xOffset = operator.xOffset;
    var yOffset = operator.yOffset;
    var xRelativeOffset = operator.xRelativeOffset;
    var yRelativeOffset = operator.yRelativeOffset;
    var offsetUnit = operator.offsetUnit;
    var windowed = operator.windowed;
    var windowBorder = operator.windowBorder;
    var windowWidth = operator.windowWidth;
    var windowHeight = operator.windowHeight;
    var windowRelativeWidth = operator.windowRelativeWidth;
    var windowRelativeHeight = operator.windowRelativeHeight;
    var windowFitMode = operator.windowFitMode;

    var overrideSize = operator.overrideSize;
    var overrideWidth = operator.overrideWidth;
    var overrideHeight = operator.overrideHeight;
    var overrideWidthRelative = operator.overrideWidthRelative;
    var overrideHeightRelative = operator.overrideHeightRelative;
    var overrideSizeUnit = operator.overrideSizeUnit;
    var composition = getCompatibleBlendMode(operator.composition);
    var tint = operator.tint;
    var tintColor = operator.tintColor;
    var tintOpacity = operator.tintOpacity;
    var tintComposition = operator.tintComposition;
    var rotation = operator.rotation * Math.PI / 180;
    var horizontalAlign = operator.horizontalAlign;
    var verticalAlign = operator.verticalAlign;

    var op = function op(context, store, canvas) {
      if (!sourceImage) return true;

      var textureImage = null;
      if (svgRegex.exec(sourceImage.extension)) {
        // if the source is actually an SVG, let use the original asset as the
        // asset instead
        var svgSourceImage = (0, _assign2.default)(sourceImage, {
          asset: sourceImage.originalAsset
        });
        textureImage = (0, _asset.fetchTextureImage)(store, svgSourceImage);
      } else {
        textureImage = (0, _asset.fetchTextureImage)(store, sourceImage);
      }

      if (!textureImage) {
        return true;
      }

      if (!overrideSize) {
        overrideWidth = textureImage.width;
        overrideHeight = textureImage.height;
      }
      if (overrideSize && overrideSizeUnit === 'relative') {
        overrideWidth = overrideWidthRelative * canvas.width;
        overrideHeight = overrideHeightRelative * canvas.height;
      }
      if (overrideWidth == 0) {
        overrideWidth = 1;
      }

      if (overrideHeight == 0) {
        overrideHeight = 1;
      }

      if (cachedCanvas) {
        cachedCanvas.width = overrideWidth;
        cachedCanvas.height = overrideHeight;
      }

      var imgCanvas = cachedCanvas || store.createCanvas(overrideWidth, overrideHeight);
      var imgCanvasContext = imgCanvas.getContext('2d');
      imgCanvasContext.clearRect(0, 0, imgCanvas.width, imgCanvas.height);

      cachedCanvas = imgCanvas;

      if (false) {
        //textureImage is ImageData, make it to be a canvas
        var textureCanvas = store.createCanvas(textureImage.width, textureImage.height);
        var textureCanvasContext = textureCanvas.getContext('2d');
        textureCanvasContext.putImageData(textureImage, 0, 0, 0, 0, textureImage.width, textureImage.height);
        textureImage = textureCanvas;

        // fix globalCompositeOperation in node-canvas, which apparently uses custom "hsl-" prefixed
        // versions of hue, saturation, color and luminosity
        var hslOperations = ['hue', 'saturation', 'color', 'luminosity'];
        if (hslOperations.indexOf(tintComposition) > -1) {
          tintComposition = 'hsl-' + tintComposition;
        }
        if (hslOperations.indexOf(composition) > -1) {
          composition = 'hsl-' + composition;
        }
      }

      if (tint) {
        //imgCanvasContext.save();
        var tintStyle = 'rgba(' + parseInt(tintColor.r * 255) + ',' + parseInt(tintColor.g * 255) + ',' + parseInt(tintColor.b * 255) + ',' + tintOpacity + ')';
        imgCanvasContext.fillStyle = tintStyle;
        imgCanvasContext.globalCompositeOperation = 'source-over';
        imgCanvasContext.fillRect(0, 0, overrideWidth, overrideHeight);

        imgCanvasContext.globalCompositeOperation = 'destination-in';
        imgCanvasContext.drawImage(textureImage, 0, 0, overrideWidth, overrideHeight);
        //imgCanvasContext.restore();
        imgCanvasContext.globalCompositeOperation = tintComposition;
      }

      imgCanvasContext.drawImage(textureImage, 0, 0, overrideWidth, overrideHeight);

      context.globalCompositeOperation = composition;

      if (offsetUnit === 'relative') {
        xOffset = xRelativeOffset * canvas.width;
        yOffset = yRelativeOffset * canvas.height;
        windowWidth = windowRelativeWidth * canvas.width;
        windowHeight = windowRelativeHeight * canvas.height;
      }

      context.translate(xOffset, yOffset);
      context.rotate(rotation);

      var sx = 0;
      var sy = 0;
      var swidth = overrideWidth;
      var sheight = overrideHeight;
      var x = 0;
      var y = 0;
      var width = overrideWidth;
      var height = overrideHeight;
      switch (horizontalAlign) {
        case 'left':
          break;
        case 'center':
          x = -overrideWidth / 2;
          break;
        default:
          x = -overrideWidth;
      }
      switch (verticalAlign) {
        case 'top':
          break;
        case 'middle':
          y = -overrideHeight / 2;
          break;
        default:
          y = -overrideHeight;
      }
      if (windowed && windowBorder) {
        var borderTop = 0;
        var borderLeft = 0;
        switch (verticalAlign) {
          case 'middle':
            borderTop = -windowHeight / 2;
            break;
          case 'bottom':
            borderTop = -windowHeight;
            break;
          default:
        }
        switch (horizontalAlign) {
          case 'center':
            borderLeft = -windowWidth / 2;
            break;
          case 'right':
            borderLeft = -windowWidth;
            break;
          default:
        }
        context.beginPath();
        context.moveTo(borderLeft, borderTop);
        context.lineTo(borderLeft, borderTop + windowHeight);
        context.lineTo(borderLeft + windowWidth, borderTop + windowHeight);
        context.lineTo(borderLeft + windowWidth, borderTop);
        context.lineTo(borderLeft, borderTop);
        context.stroke();
      }
      if (windowed) {
        var widthHeightRatio = windowWidth * overrideHeight / overrideWidth / windowHeight;
        width = windowWidth;
        height = windowHeight;
        switch (windowFitMode) {
          case 'width':
            swidth = overrideWidth;
            sheight = windowHeight * overrideWidth / windowWidth;
            break;
          case 'height':
            sheight = overrideHeight;
            swidth = windowWidth * overrideHeight / windowHeight;
            break;
          case 'inside':
            if (widthHeightRatio < 1) {
              swidth = overrideWidth;
              sheight = windowHeight * overrideWidth / windowWidth;
            } else {
              sheight = overrideHeight;
              swidth = windowWidth * overrideHeight / windowHeight;
            }
            break;
          case 'full':
            if (widthHeightRatio > 1) {
              swidth = overrideWidth;
              sheight = windowHeight * overrideWidth / windowWidth;
            } else {
              sheight = overrideHeight;
              swidth = windowWidth * overrideHeight / windowHeight;
            }
            break;
          default:
            swidth = windowWidth;
            sheight = windowHeight;
        }
        var widthDiff = overrideWidth - swidth;
        var heightDiff = overrideHeight - sheight;
        switch (horizontalAlign) {
          case 'left':
            break;
          case 'center':
            sx = widthDiff / 2;
            x = -windowWidth / 2;
            break;
          default:
            sx = widthDiff;
            x = -windowWidth;
        }
        switch (verticalAlign) {
          case 'top':
            break;
          case 'middle':
            sy = heightDiff / 2;
            y = -windowHeight / 2;
            break;
          default:
            sy = heightDiff;
            y = -windowHeight;
        }
      }
      context.drawImage(imgCanvas, sx, sy, swidth, sheight, x, y, width, height);

      return true;
    };

    if (!primitive.canvasOperations) {
      primitive.canvasOperations = [op];
    } else {
      primitive.canvasOperations.push(op);
    }

    return primitive;
  }
};

var CanvasText = {
  schema: {
    fontName: {
      label: 'Font Name',
      type: 'Options',
      defaultValue: 'serif',
      values: ['serif', 'sans serif', 'monospace', 'custom'],
      labels: ['Serif', 'Sans Serif', 'Monospace', 'Custom CSS Font']
    },
    fontCSSSpecifier: {
      label: 'CSS Font Specifer',
      type: 'String',
      defaultValue: 'Times New Roman, Times, serif'
    },
    text: {
      label: 'Text',
      type: 'String',
      defaultValue: 'Times New Roman, Times, serif'
    },
    fontSize: {
      label: 'Font Size',
      type: 'Number',
      defaultValue: 100,
      minValue: 1,
      maxValue: 10000,
      step: 1,
      animatable: true
    },
    italic: {
      label: 'Italic',
      type: 'Boolean',
      defaultValue: false,
      animatable: true
    },
    bold: {
      label: 'Bold',
      type: 'Boolean',
      defaultValue: false,
      animatable: true
    },
    multiLine: {
      label: 'Multi-Line',
      type: 'Boolean',
      defaultValue: false,
      animatable: true
    },
    style: {
      label: 'Drawing Style',
      type: 'Options',
      defaultValue: 'solid',
      values: ['solid', 'outline']
    },
    outlineWidth: {
      type: 'Number',
      defaultValue: 3,
      minValue: -10,
      maxValue: 100,
      step: 1,
      label: 'Outline Width',
      animatable: true
    },
    shadow: {
      label: 'Shadow',
      type: 'Boolean',
      defaultValue: false,
      animatable: true
    },
    shadowThickness: {
      label: 'Shadow Thickness',
      type: 'Number',
      defaultValue: 5,
      minValue: 0,
      maxValue: 100,
      step: 1,
      animatable: true
    },
    shadowColor: {
      label: 'Shadow Color',
      type: 'Color',
      defaultValue: 0x000000,
      animatable: true
    },
    shadowOffsetX: {
      label: 'Shadow Offset X',
      type: 'Number',
      defaultValue: 0,
      minValue: -100,
      maxValue: 100,
      step: 1,
      animatable: true
    },
    shadowOffsetY: {
      label: 'Shadow Offset Y',
      type: 'Number',
      defaultValue: 0,
      minValue: -100,
      maxValue: 100,
      step: 1,
      animatable: true
    },
    color: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0, g: 0, b: 0 },
      animatable: true
    },
    opacity: {
      label: 'Opacity',
      type: 'Number',
      defaultValue: 1,
      minValue: 0,
      maxValue: 1,
      step: 0.01,
      animatable: true
    },

    windowed: {
      label: 'Windowed',
      type: 'Boolean',
      defaultValue: false,
      animatable: true
    },
    windowBorder: {
      label: 'Display Window Border',
      type: 'Boolean',
      defaultValue: true,
      animatable: true
    },
    windowWidth: {
      label: 'Window Width',
      type: 'Number',
      defaultValue: 256,
      minValue: 0,
      maxValue: 4096,
      step: 1,
      animatable: true
    },
    windowHeight: {
      label: 'Window Height',
      type: 'Number',
      defaultValue: 256,
      minValue: 0,
      maxValue: 4096,
      step: 1,
      animatable: true
    },
    windowRelativeWidth: {
      label: 'Relative Window Width',
      type: 'Number',
      defaultValue: 0.5,
      minValue: 0,
      maxValue: 1,
      step: 0.01,
      animatable: true
    },
    windowRelativeHeight: {
      label: 'Relative Window Height',
      type: 'Number',
      defaultValue: 0.5,
      minValue: 0,
      maxValue: 1,
      step: 0.01,
      animatable: true
    },
    positionX: {
      type: 'Number',
      defaultValue: 256,
      minValue: -1000,
      maxValue: 10000,
      step: 1,
      label: 'Position X',
      animatable: true
    },
    positionY: {
      type: 'Number',
      defaultValue: 256,
      minValue: -1000,
      maxValue: 10000,
      step: 1,
      label: 'Position Y',
      animatable: true
    },

    positionXRelative: {
      type: 'Number',
      defaultValue: 0.5,
      minValue: -10,
      maxValue: +10,
      step: 0.01,
      label: 'X Relative',
      animatable: true
    },
    positionYRelative: {
      type: 'Number',
      defaultValue: 0.5,
      minValue: -10,
      maxValue: +10,
      step: 0.01,
      label: 'Y Relative',
      animatable: true
    },
    positionUnit: {
      label: 'Unit',
      type: 'Options',
      values: ['pixel', 'relative'],
      initialValue: 'absolute'
    },

    rotation: {
      type: 'Number',
      defaultValue: 0,
      minValue: -3600,
      maxValue: 3600,
      step: 1,
      label: 'Rotation',
      animatable: true
    },

    horizontalAlign: {
      type: 'Options',
      defaultValue: 'center',
      values: ['left', 'center', 'right'],
      label: 'Horizontal Align'
    },
    verticalAlign: {
      type: 'Options',
      defaultValue: 'middle',
      values: ['top', 'middle', 'bottom'],
      label: 'Vertical Align'
    }
  },

  update: function update(operator, primitive) {
    var fontName = operator.fontName;
    switch (fontName) {
      case 'serif':
        fontName = 'Times New Roman, Times, serif';
        break;
      case 'sans serif':
        fontName = 'Arial, Helvetica, sans-serif';
        break;
      case 'monospace':
        fontName = 'Courier New, Courier, monospace';
        break;
      case 'custom':
        fontName = operator.fontCSSSpecifier;
        break;
    }
    var text = operator.text,
        fontSize = operator.fontSize,
        italic = operator.italic,
        bold = operator.bold,
        multiLine = operator.multiLine,
        style = operator.style,
        outlineWidth = operator.outlineWidth,
        opacity = operator.opacity,
        positionX = operator.positionX,
        positionY = operator.positionY,
        positionXRelative = operator.positionXRelative,
        positionYRelative = operator.positionYRelative,
        positionUnit = operator.positionUnit,
        horizontalAlign = operator.horizontalAlign,
        verticalAlign = operator.verticalAlign,
        windowed = operator.windowed,
        windowBorder = operator.windowBorder,
        windowWidth = operator.windowWidth,
        windowHeight = operator.windowHeight,
        windowRelativeWidth = operator.windowRelativeWidth,
        windowRelativeHeight = operator.windowRelativeHeight,
        shadow = operator.shadow,
        shadowThickness = operator.shadowThickness,
        shadowOffsetX = operator.shadowOffsetX,
        shadowOffsetY = operator.shadowOffsetY;


    var color = operator.color;
    var shadowColor = operator.shadowColor;
    color = 'rgba(' + parseInt(color.r * 255) + ',' + parseInt(color.g * 255) + ',' + parseInt(color.b * 255) + ',' + opacity + ')';
    shadowColor = 'rgba(' + parseInt(shadowColor.r * 255) + ',' + parseInt(shadowColor.g * 255) + ',' + parseInt(shadowColor.b * 255) + ',' + opacity + ')';

    var rotation = operator.rotation * Math.PI / 180;

    var op = function op(canvasContext, store, canvas) {
      var localPositionX = positionX;
      var localPositionY = positionY;
      var localWindowWidth = windowWidth;
      var localWindowHeight = windowHeight;
      if (positionUnit === 'relative') {
        localPositionX = positionXRelative * canvas.width;
        localPositionY = positionYRelative * canvas.height;
        localWindowWidth = windowRelativeWidth * canvas.width;
        localWindowHeight = windowRelativeHeight * canvas.height;
      }

      canvasContext.fillStyle = color;
      //node-canvas only support font-size and font-family https://github.com/Automattic/node-canvas/issues/566
      var fontStyle =  false ? '' : italic ? 'italic' : 'normal';
      var fontWeight =  false ? '' : bold ? 700 : 400;
      canvasContext.font = fontStyle + ' ' + fontWeight + ' ' + fontSize + 'px ' + fontName;

      canvasContext.textAlign = horizontalAlign;
      canvasContext.textBaseline = verticalAlign;
      canvasContext.translate(localPositionX, localPositionY);
      canvasContext.rotate(rotation);

      // text is separated by break into sentences
      var localtext = multiLine ? text.split(/<br>|\\n|\\r/i) : text.split();
      var finalText = [];
      if (windowed) {
        var canDisplay = true;
        for (var i = 0; i < localtext.length && canDisplay; i += 1) {
          if (canvasContext.measureText(localtext[i]).width <= localWindowWidth) {
            // push sentenes into finalText if it is less than window width
            finalText.push(localtext[i]);
          } else {
            var tempText = '';
            var wordArray = localtext[i].split(' ');
            // sentence width is larger than window width
            // separate sentence by words
            for (var j = 0; j < wordArray.length && canDisplay; j += 1) {
              var newText = tempText.length ? tempText + ' ' + wordArray[j] : wordArray[j];
              if (canvasContext.measureText(newText).width > localWindowWidth) {
                if (tempText.length) {
                  // subsentence that can fit into window
                  finalText.push(tempText);
                  tempText = '';
                  j -= 1;
                } else {
                  // word width is larger than window width
                  // separate words by char
                  for (var k = 0; k < newText.length && canDisplay; k += 1) {
                    if (canvasContext.measureText(tempText + newText[k]).width > localWindowWidth) {
                      if (tempText.length) {
                        finalText.push(tempText);
                        tempText = '';
                        k -= 1;
                      } else {
                        canDisplay = false;
                        finalText.length = 0;
                        console.warn('canvasText window width is less than single char, no text will display.');
                      }
                    } else {
                      tempText += newText[k];
                    }
                  }
                }
              } else {
                tempText = newText;
              }
            }
            if (tempText.length) finalText.push(tempText);
          }
        }
      } else {
        finalText = localtext;
      }

      if (windowed && windowBorder) {
        var borderTop = 0;
        var borderLeft = 0;
        switch (verticalAlign) {
          case 'middle':
            borderTop = -localWindowHeight / 2;
            break;
          case 'bottom':
            borderTop = -localWindowHeight;
            break;
          default:
        }
        switch (horizontalAlign) {
          case 'center':
            borderLeft = -localWindowWidth / 2;
            break;
          case 'right':
            borderLeft = -localWindowWidth;
            break;
          default:
        }
        canvasContext.beginPath();
        canvasContext.moveTo(borderLeft, borderTop);
        canvasContext.lineTo(borderLeft, borderTop + localWindowHeight);
        canvasContext.lineTo(borderLeft + localWindowWidth, borderTop + localWindowHeight);
        canvasContext.lineTo(borderLeft + localWindowWidth, borderTop);
        canvasContext.lineTo(borderLeft, borderTop);
        canvasContext.stroke();
      }

      var textLeft = 0;
      var textTop = 0;
      var textHeight = finalText.length * fontSize;
      switch (verticalAlign) {
        case 'middle':
          textTop = windowed && textHeight >= localWindowHeight ? -(localWindowHeight - fontSize) / 2 : -(finalText.length - 1) / 2 * fontSize;
          break;
        case 'bottom':
          textTop = windowed && textHeight >= localWindowHeight ? -(localWindowHeight - fontSize) : -(finalText.length - 1) * fontSize;
          break;
        default:
      }
      if (shadow) {
        canvasContext.shadowBlur = shadowThickness;
        canvasContext.shadowColor = shadowColor;
        canvasContext.shadowOffsetX = shadowOffsetX;
        canvasContext.shadowOffsetY = shadowOffsetY;
      }
      for (var _i = 0; _i < finalText.length; _i += 1) {
        if (windowed && (_i + 1) * fontSize > localWindowHeight) break;
        if (style === 'outline') {
          canvasContext.lineWidth = outlineWidth;
          canvasContext.strokeStyle = color;
          canvasContext.strokeText(finalText[_i], textLeft, textTop);
        } else {
          canvasContext.fillStyle = color;
          canvasContext.fillText(finalText[_i], textLeft, textTop);
        }
        textTop += fontSize;
      }
      return true;
    };

    if (!primitive.canvasOperations) {
      primitive.canvasOperations = [op];
    } else {
      primitive.canvasOperations.push(op);
    }

    return primitive;
  }
};

exports.default = {
  Image: Image,
  Canvas: Canvas,
  CanvasLinearGradient: CanvasLinearGradient,
  CanvasFill: CanvasFill,
  CanvasComposite: CanvasComposite,
  CanvasText: CanvasText
};

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var DirectionalLight = {
  schema: {
    lightType: {
      label: 'type',
      type: 'String',
      defaultValue: 'DirectionalLight'
    },
    color: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 }
    },
    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.8 },
    sourceAngle: {
      label: 'Source Angle',
      type: 'Number',
      defaultValue: 0.0,
      step: 0.1,
      minValue: 0,
      maxValue: 20
    },

    shadow: { label: 'Enable', type: 'Boolean', defaultValue: false },
    autoShadow: { label: 'Auto Shadow', type: 'Boolean', default: false },
    showShadowCamera: {
      label: 'Show Frustum',
      type: 'Boolean',
      defaultValue: false
    },
    shadowBias: { label: 'Bias', type: 'Number', defaultValue: 0 },
    shadowSize: { label: 'Map Size', type: 'Number', defaultValue: 512 },
    shadowCameraSize: {
      label: 'Camera Size',
      type: 'Number',
      defaultValue: 500
    },
    shadowNearClip: {
      label: 'Near Clip',
      type: 'Number',
      step: 0.01,
      defaultValue: 0.1
    },
    shadowFarClip: { label: 'Far Clip', type: 'Number', defaultValue: 1000 },
    shadowFrustumColor: {
      label: 'Frustum Color',
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 }
    }
  }
};

var SpotLight = {
  schema: {
    lightType: { label: 'type', type: 'String', defaultValue: 'SpotLight' },
    color: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 }
    },
    radius: {
      label: 'Radius',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0,
      step: 0.01
    },
    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.8 },
    distance: { label: 'Cutoff Distance', type: 'Number', defaultValue: 0 },
    coneAngle: { label: 'Cone Angle', type: 'Number', defaultValue: 60 },
    coneFalloff: { label: 'Cone Falloff', type: 'Number', defaultValue: 0 },
    decayExponent: { label: 'Decay Exponent', type: 'Number', defaultValue: 0 },

    shadow: { label: 'Enable', type: 'Boolean', defaultValue: false },
    shadowBias: { label: 'Bias', type: 'Number', defaultValue: -0 },
    shadowSize: { label: 'Map Size', type: 'Number', defaultValue: 512 },
    autoShadow: { label: 'Auto Shadow', type: 'Boolean', default: false },
    shadowNearClip: {
      label: 'Near Clip',
      type: 'Number',
      step: 0.01,
      defaultValue: 0.1
    },
    shadowFarClip: { label: 'Far Clip', type: 'Number', defaultValue: 1000 },
    showShadowCamera: {
      label: 'Show Frustum',
      type: 'Boolean',
      defaultValue: false
    },
    shadowFrustumColor: {
      label: 'Frustum Color',
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 }
    }
  }
};

var PointLight = {
  schema: {
    lightType: { label: 'type', type: 'String', defaultValue: 'PointLight' },
    color: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 }
    },
    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.8 },
    radius: {
      label: 'Radius',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0,
      step: 0.01
    },
    distance: { label: 'Cutoff Distance', type: 'Number', defaultValue: 0 },
    decayExponent: { label: 'Decay Exponent', type: 'Number', defaultValue: 0 },

    shadow: { label: 'Enable', type: 'Boolean', defaultValue: false },
    shadowBias: { label: 'Bias', type: 'Number', defaultValue: 0 },
    shadowSize: { label: 'Map Size', type: 'Number', defaultValue: 512 },
    shadowNearClip: {
      label: 'Near Clip',
      type: 'Number',
      step: 0.01,
      defaultValue: 0.5
    },
    shadowFarClip: { label: 'Far Clip', type: 'Number', defaultValue: 500 }
  }
};

var HemisphereLight = {
  schema: {
    lightType: {
      label: 'type',
      type: 'String',
      defaultValue: 'HemisphereLight'
    },
    color: {
      label: 'Sky Color',
      type: 'Color',
      defaultValue: { r: 0.2, g: 0.52, b: 1 }
    },
    gndColor: {
      label: 'Sky Color',
      type: 'Color',
      defaultValue: { r: 1, g: 0.78, b: 0.5 }
    },
    intensity: { label: 'Intensity', type: 'Number', defaultValue: 0.6 }
  }
};

var AreaLight = {
  schema: {
    lightType: { label: 'type', type: 'String', defaultValue: 'AreaLight' },
    color: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 }
    },
    intensity: { label: 'Intensity', type: 'Number', defaultValue: 10 },
    width: { label: 'Source Width', type: 'Number', defaultValue: 1 },
    height: { label: 'Source Height', type: 'Number', defaultValue: 1 },
    shadow: { label: 'Enable', type: 'Boolean', defaultValue: false }
  }
};

exports.default = {
  DirectionalLight: DirectionalLight,
  SpotLight: SpotLight,
  PointLight: PointLight,
  HemisphereLight: HemisphereLight,
  AreaLight: AreaLight
};

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var Material = {
  schema: {
    color: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 }
    }
  },
  update: function update(operator, primitive) {
    return primitive.color = operator.color;
  }
};

var Physical = {
  environment: true,

  schema: {
    baseMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    baseMapTransparent: {
      label: 'Image Transparent',
      type: 'Boolean',
      defaultValue: false
    },
    baseColor: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 }
    },

    baseFalloff: { label: 'Falloff', type: 'Boolean', defaultValue: false },
    baseFalloffMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    baseFalloffColor: {
      label: 'Falloff Color',
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 },
      animatable: true
    },

    opacityMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    opacityFactor: {
      label: 'Factor',
      type: 'Number',
      defaultValue: 1.0,
      maxValue: 1.0,
      minValue: 0.0,
      step: 0.01,
      animatable: true
    },

    opacityFalloffMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    opacityFalloffFactor: {
      label: 'Falloff Factor',
      type: 'Number',
      defaultValue: 1.0,
      maxValue: 1.0,
      minValue: 0.0,
      step: 0.01,
      animatable: true
    },

    depthWrite: { label: 'Depth Write', type: 'Boolean', defaultValue: true },
    depthTest: { label: 'Depth Test', type: 'Boolean', defaultValue: true },

    specularMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    specularColor: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 1, g: 1, b: 1 },
      animatable: true
    },

    roughness: {
      label: 'Roughness',
      type: 'Number',
      defaultValue: 0.25,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.01,
      animatable: true
    },
    roughnessMap: { label: 'Image', type: 'Plug', plug: 'Image' },

    metallic: {
      label: 'Metallic',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.01,
      animatable: true
    },
    metallicMap: { label: 'Image', type: 'Plug', plug: 'Image' },

    clearCoat: {
      label: 'Thickness',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.01,
      animatable: true
    },
    clearCoatRoughness: {
      label: 'Roughness',
      type: 'Number',
      defaultValue: 0.25,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.01,
      animatable: true
    },

    aoMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    aoMapIntensity: {
      label: 'Factor',
      type: 'Number',
      defaultValue: 1.0,
      maxValue: 1.0,
      minValue: 0.0,
      step: 0.01,
      animatable: true
    },

    lightMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    ambientColor2: {
      label: 'Color',
      type: 'Color',
      animatable: true,
      defaultValue: { r: 0, g: 0, b: 0 }
    },

    emissiveMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    emissiveColor: {
      label: 'Color',
      type: 'Color',
      animatable: true,
      defaultValue: { r: 0, g: 0, b: 0 }
    },
    emissiveScale: {
      label: 'Scale',
      type: 'Number',
      defaultValue: 1.0,
      minValue: 0.0,
      maxValue: 100.0,
      step: 0.1,
      animatable: true
    },
    emissiveLabel: {
      type: 'Label',
      align: 'right',
      defaultValue: 'Emissive uses the second UV channel.'
    },

    translucencyColor: {
      label: 'Color',
      type: 'Color',
      animatable: true,
      defaultValue: { r: 0, g: 0, b: 0 }
    },
    translucencyMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    translucencyNormalAlpha: {
      label: 'Normal Alpha',
      type: 'Number',
      defaultValue: 0.75,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.05,
      animatable: true
    },
    translucencyNormalPower: {
      label: 'Normal Power',
      type: 'Number',
      defaultValue: 2.0,
      minValue: 0.01,
      maxValue: 100.0,
      step: 0.05,
      animatable: true
    },
    translucencyViewAlpha: {
      label: 'View Alpha',
      type: 'Number',
      defaultValue: 0.75,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.05,
      animatable: true
    },
    translucencyViewPower: {
      label: 'View Power',
      type: 'Number',
      defaultValue: 2.0,
      minValue: 0.01,
      maxValue: 100.0,
      step: 0.05,
      animatable: true
    },

    bumpMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    bumpScale: {
      label: 'Scale Factor',
      type: 'Number',
      defaultValue: 1,
      minValue: -5.0,
      maxValue: 5.0,
      step: 0.1,
      animatable: true
    },

    normalMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    normalFactor: {
      label: 'Scale Factor',
      type: 'Number',
      defaultValue: 1.0,
      minValue: -100.0,
      maxValue: 100.0,
      step: 0.001,
      animatable: true
    },
    normalRedFlip: {
      label: 'Red Channel Flip',
      type: 'Boolean',
      defaultValue: false
    },
    normalGreenFlip: {
      label: 'Green Channel Flip',
      type: 'Boolean',
      defaultValue: false
    },

    anisotropyLabel: {
      type: 'Label',
      align: 'right',
      defaultValue: 'Anisotropy requires the Tangent operator.'
    },
    anisotropyMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    anisotropy: {
      label: 'Offset',
      type: 'Number',
      defaultValue: 0.0,
      minValue: -1.0,
      maxValue: 1.0,
      step: 0.025,
      animatable: true
    },

    anisotropyRotationMap: { label: 'Image', type: 'Plug', plug: 'Image' },
    anisotropyRotation: {
      label: 'Rotation Offset',
      type: 'Number',
      defaultValue: 0.0,
      minValue: -1.0,
      maxValue: 1.0,
      step: 0.025,
      animatable: true
    },

    overrideEnvironment: {
      label: 'Override Environment',
      type: 'Boolean',
      defaultValue: false
    }
    //environmentMap: { label: "Environment Map", type: 'Node', filter: environmentMapFilter },
  }
};

var MaterialReference = {
  schema: {
    defaultColor: {
      label: 'Default Color',
      type: 'Color',
      defaultValue: { r: 1, g: 1, b: 1 }
    },
    reference: { type: 'Plug', plug: 'Material', label: 'Reference' }
  },
  update: function update(operator, primitive) {
    primitive.color = operator.defaultColor;
    //return operator.reference || primitive.color = operator.defaultColor;
  }
};

var Reference = {
  schema: {
    defaultColor: {
      label: 'Default Color',
      type: 'Color',
      defaultValue: { r: 1, g: 1, b: 1 }
    },
    reference: { type: 'Plug', plug: 'Material', label: 'Reference' }
  },
  update: function update(operator, primitive) {
    if (operator.reference) return operator.reference;
    primitive.defaultColor = operator.defaultColor;
  }
};

var EnvironmentMap = {
  schema: {
    thumbnailImage: { label: 'Thumbnail', type: 'Plug', plug: 'Image' },

    irradianceCubeMap: { label: 'Irradiance', type: 'Plug', plug: 'Material' }, //filter: cubeMapFilter },
    specularCubeMap: { label: 'Specular', type: 'Plug', plug: 'Material' }, //filter: cubeMapFilter },
    intensity: {
      label: 'Intensity',
      type: 'Number',
      defaultValue: 1.0,
      minValue: 0.001,
      maxValue: 100.0,
      step: 0.1,
      animatable: true
    }

    //giImage:   { label: 'Global Illumination', type: 'Node', initialValue: null, filter: exo.material.ImageUtils.nodeFilter },
    //// these two maps should usually be the global illumination map.
    //reflectionImage:   { label: 'Reflection', type: 'Node', initialValue: null, filter: exo.material.ImageUtils.nodeFilter },
    //refractionImage:   { label: 'Refraction', type: 'Node', initialValue: null, filter: exo.material.ImageUtils.nodeFilter },
  }
};

var CubeMap = {
  schema: {
    map0: { label: 'Map ( x)', type: 'Plug', plug: 'Image' },
    map1: { label: 'Map (-x)', type: 'Plug', plug: 'Image' },
    map2: { label: 'Map ( y)', type: 'Plug', plug: 'Image' },
    map3: { label: 'Map (-y)', type: 'Plug', plug: 'Image' },
    map4: { label: 'Map ( z)', type: 'Plug', plug: 'Image' },
    map5: { label: 'Map (-z)', type: 'Plug', plug: 'Image' }
  },
  update: function update(operator, primitive, _ref) {
    var node = _ref.node;

    primitive.maps = [operator.map0, operator.map1, operator.map2, operator.map3, operator.map4, operator.map5];
  }
};

var ProxyReference = {
  schema: {
    webgl: { type: 'Plug', label: 'WebGL Material', plug: 'Material' },
    vray: { type: 'Plug', label: 'VRay Material', plug: 'Material' }
  },
  update: function update(operator, primitive) {
    return operator.webgl || primitive;
  }
};

var Standard = {
  schema: {
    diffuseColor: {
      label: 'Color',
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 }
    }
  }
};

var MultiID = {
  schema: {
    defaultColor: {
      label: 'Default Color',
      type: 'Color',
      defaultValue: { r: 0.5, g: 0.5, b: 0.5 }
    },

    material0: { type: 'Plug', plug: 'Material', label: 'Material ID 0' },
    material1: { type: 'Plug', plug: 'Material', label: 'Material ID 1' },
    material2: { type: 'Plug', plug: 'Material', label: 'Material ID 2' },
    material3: { type: 'Plug', plug: 'Material', label: 'Material ID 3' },
    material4: { type: 'Plug', plug: 'Material', label: 'Material ID 4' },
    material5: { type: 'Plug', plug: 'Material', label: 'Material ID 5' },
    material6: { type: 'Plug', plug: 'Material', label: 'Material ID 6' },
    material7: { type: 'Plug', plug: 'Material', label: 'Material ID 7' },
    material8: { type: 'Plug', plug: 'Material', label: 'Material ID 8' },
    material9: { type: 'Plug', plug: 'Material', label: 'Material ID 9' },
    material10: { type: 'Plug', plug: 'Material', label: 'Material ID 10' },
    material11: { type: 'Plug', plug: 'Material', label: 'Material ID 11' },
    material12: { type: 'Plug', plug: 'Material', label: 'Material ID 12' },
    material13: { type: 'Plug', plug: 'Material', label: 'Material ID 13' },
    material14: { type: 'Plug', plug: 'Material', label: 'Material ID 14' },
    material15: { type: 'Plug', plug: 'Material', label: 'Material ID 15' },
    material16: { type: 'Plug', plug: 'Material', label: 'Material ID 16' },
    material17: { type: 'Plug', plug: 'Material', label: 'Material ID 17' },
    material18: { type: 'Plug', plug: 'Material', label: 'Material ID 18' },
    material19: { type: 'Plug', plug: 'Material', label: 'Material ID 19' },
    material20: { type: 'Plug', plug: 'Material', label: 'Material ID 20' },
    material21: { type: 'Plug', plug: 'Material', label: 'Material ID 21' },
    material22: { type: 'Plug', plug: 'Material', label: 'Material ID 22' },
    material23: { type: 'Plug', plug: 'Material', label: 'Material ID 23' },
    material24: { type: 'Plug', plug: 'Material', label: 'Material ID 24' },
    material25: { type: 'Plug', plug: 'Material', label: 'Material ID 25' },
    material26: { type: 'Plug', plug: 'Material', label: 'Material ID 26' },
    material27: { type: 'Plug', plug: 'Material', label: 'Material ID 27' },
    material28: { type: 'Plug', plug: 'Material', label: 'Material ID 28' },
    material29: { type: 'Plug', plug: 'Material', label: 'Material ID 29' },

    multiID: { type: 'Boolean', label: 'Is MultiID', defaultValue: true }
  }
};

var VRmat = {
  schema: {
    visMatZipFile: { type: 'File', hidden: true },
    viewColor: {
      type: 'Color',
      defaultValue: { r: 0.94, g: 0.94, b: 0.94 },
      label: 'Viewport Color'
    }
  }
};

var GemMaterial = {
  environment: true,
  schema: {
    gemstone: { type: 'Node', label: 'Gemstone', plug: 'PolyMesh' },
    ior: {
      type: 'Number',
      label: 'IOR',
      defaultValue: 1.6,
      minValue: 1,
      maxValue: 10.0,
      step: 0.05
    },
    transmissive: {
      type: 'Color',
      label: 'Color',
      defaultValue: { r: 1, g: 1, b: 1 }
    },

    bounces: {
      type: 'Number',
      label: 'Ray Bources',
      defaultValue: 4,
      minValue: 3,
      maxValue: 7,
      isInteger: true
    },

    boostFactor: {
      type: 'Number',
      label: 'Boost Factor',
      defaultValue: 1.0,
      minValue: 0.5,
      maxValue: 3.0,
      step: 0.05
    },
    spectrumSpread: {
      type: 'Number',
      label: 'Spectrum Spread',
      defaultValue: 0.0,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.05
    },

    squishFactor: {
      type: 'Vec3',
      label: 'Squish Factor',
      step: 0.01,
      minValue: 0.001,
      defaultValue: { x: 1.0, y: 1.0, z: 1.0 }
    },

    enableSparkles: { type: 'Boolean', label: 'Enabled', defaultValue: false },
    sparkleCount: {
      type: 'Number',
      label: 'Count',
      defaultValue: 5,
      minValue: 3,
      maxValue: 20,
      isInteger: true
    }
  }
};

exports.default = {
  Material: Material,
  Physical: Physical,
  MaterialReference: MaterialReference,
  Reference: Reference,
  EnvironmentMap: EnvironmentMap,
  CubeMap: CubeMap,
  Standard: Standard,
  ProxyReference: ProxyReference,
  MultiID: MultiID,
  'vray/VRmat': VRmat,
  GemMaterial: GemMaterial
};

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var targetCam = function targetCam(n) {
  return n.get('type') === 'Camera';
};
var targetRen = function targetRen(n) {
  return n.get('type') === 'Renderer';
};

var Pass = {
  schema: {
    activated: { label: 'Activated', type: 'Boolean', defaultValue: true },
    filename: { label: 'Filename', type: 'Text', defaultValue: null },
    fileFormat: { label: 'File Format', type: 'Text', defaultValue: null },

    over_res: { label: 'On', type: 'Boolean', defaultValue: false },
    over_res_x: {
      label: 'Image Width',
      type: 'Number',
      defaultValue: 1280,
      isInteger: true
    },
    over_res_y: {
      label: 'Image Height',
      type: 'Number',
      defaultValue: 720,
      isInteger: true
    },

    render_cam: { type: 'Node', label: 'Camera', filter: targetCam },
    render_red: { type: 'Node', label: 'Renderer', filter: targetRen }
  }
};

exports.default = { Pass: Pass };

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var Player = {
  schema: {
    autoRotate: {
      label: 'Auto-Rotate Camera',
      type: 'Boolean',
      defaultValue: false
    },
    autoRotateNode: { label: 'Rotate Node', type: 'Node' },
    autoRotateSpeed: {
      label: 'Rotate Speed (seconds)',
      type: 'Number',
      minValue: 1,
      maxValue: 60,
      defaultValue: 12
    },
    autoRotateDirection: {
      label: 'Rotate Direction',
      type: 'Options',
      values: ['-', '+'],
      labels: ['Clockwise', 'Counter-clockwise'],
      defaultValue: '-'
    },

    camera: { label: 'Camera', type: 'Node' },
    constraintCameraY: {
      label: 'Constrain Camera to Positive Y',
      type: 'Boolean',
      defaultValue: false
    },
    orbitTarget: { label: 'Orbit Target', type: 'Node' },
    orbitMode: {
      label: 'Orbit Mode',
      type: 'Options',
      values: ['gyroscope', 'trackball', 'firstPerson'],
      labels: ['Gyropscope', 'Trackball', 'First Person'],
      defaultValue: 'gyroscope'
    },
    overrideNavigation: {
      label: 'Override Camera Orbit Mode',
      type: 'Boolean',
      defaultValue: true
    },

    vrMode: {
      label: 'VR Mode',
      type: 'Options',
      values: ['firstperson', 'orbit'],
      labels: ['1st Person', 'Orbit'],
      defaultValue: 'firstperson'
    },
    vrCamera: { label: 'VR Camera', type: 'Node' },

    toneMapStyle: {
      label: 'Style',
      type: 'Options',
      values: ['Linear', 'Reinhard', 'Cineon', 'Filmic'],
      defaultValue: 'Linear'
    },
    toneMapExposureGain: {
      label: 'Exposure Gain',
      type: 'Number',
      defaultValue: 1.0,
      minValue: 0.0,
      maxValue: 20.0,
      step: 0.1
    },
    toneMapWhitePoint: {
      label: 'White Point',
      type: 'Number',
      defaultValue: 4.0,
      minValue: 0.0,
      maxValue: 20.0,
      step: 0.1
    },

    dofPass: { label: 'Enabled', type: 'Boolean', defaultValue: false },
    dofMaxBlur: {
      label: 'Max Blur',
      type: 'Number',
      defaultValue: 10.0,
      minValue: 0.0,
      maxValue: 100.0,
      step: 0.1
    },

    saoPass: { label: 'Enabled', type: 'Boolean', defaultValue: false },
    saoIntensity: {
      label: 'Intensity',
      type: 'Number',
      defaultValue: 1.0,
      minValue: 0.0,
      maxValue: 1000.0,
      step: 0.1
    },
    saoScale: {
      label: 'Scale',
      type: 'Number',
      defaultValue: 24.0,
      minValue: 0.0,
      maxValue: 1000.0,
      step: 0.1
    },

    bloomPass: { label: 'Enabled', type: 'Boolean', defaultValue: false },
    bloomThreshold: {
      label: 'Luminance Threshold',
      type: 'Number',
      defaultValue: 0.9,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.1
    },
    //bloomBlendRange: { label: 'Blend Range', type: 'Number', defaultValue: 0.1, minValue: 0.0, maxValue: 10.0, step: 0.1 }, //not configurable in threejs yet

    sparkleTexture: { label: 'Image', type: 'Plug', plug: 'Image' },
    sparkleSize: {
      label: 'World Size',
      type: 'Number',
      defaultValue: 0.05,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.001
    },

    reflectiveFloor: { label: 'Enabled', type: 'Boolean', defaultValue: false },
    reflectiveFloorWidth: {
      label: 'Width',
      type: 'Number',
      defaultValue: 1.0,
      minValue: 0.0,
      maxValue: 1000.0,
      step: 1.0
    },
    reflectiveFloorRoughness: {
      label: 'Roughness',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0,
      maxValue: 10.0,
      step: 0.1
    },
    reflectiveFloorMetallic: {
      label: 'Metallic',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.1
    },
    reflectiveFloorFade: {
      label: 'Fade',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0,
      maxValue: 10000.0,
      step: 0.1
    },
    reflectiveFloorHeight: {
      label: 'Height',
      type: 'Number',
      defaultValue: 0.0,
      minValue: -100.0,
      maxValue: 100.0,
      step: 0.1
    },
    reflectiveFloorOpacity: {
      label: 'Opacity',
      type: 'Number',
      defaultValue: 1.0,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.1
    },
    reflectiveFloorFresnel: {
      label: 'Fresnel Strength',
      type: 'Number',
      defaultValue: 1.0,
      minValue: -1.0,
      maxValue: 1.0,
      step: 0.1
    },
    reflectiveFloorExcludeServer: {
      label: 'Exclude on Server',
      type: 'Boolean',
      defaultValue: false
    },

    configurator: {
      label: 'Configurator',
      type: 'String',
      hidden: true,
      defaultValue: ''
    },

    // Physics
    gravity: {
      label: 'Gravity',
      type: 'Vec3',
      step: 1.0,
      defaultValue: [0.0, -9.8, 0.0]
    },
    shadowType: {
      label: 'Quality',
      type: 'Options',
      values: [0, 1, 2, 3],
      labels: ['Basic', 'Medium', 'High', 'Ultra'],
      defaultValue: 2
    },
    renderPassType: {
      label: 'Style',
      type: 'Options',
      values: [0, 1],
      labels: ['General', 'Order In Transparency'],
      defaultValue: 0
    }
  }
};

exports.default = { Player: Player };

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = __webpack_require__(0);

var _createMeshArray2 = __webpack_require__(235);

var _createMeshArray3 = _interopRequireDefault(_createMeshArray2);

var _mergePolyMeshes = __webpack_require__(103);

var _mergePolyMeshes2 = _interopRequireDefault(_mergePolyMeshes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Array = {
  // Depends on its world transform
  selfTransform: true,

  schema: {
    count: {
      type: 'Number',
      label: 'Count',
      defaultValue: 3,
      step: 1,
      minValue: 1
    },

    translation: {
      label: 'Translation',
      type: 'Vec3',
      step: 0.1,
      defaultValue: [1, 0, 0]
    },
    rotation: {
      label: 'Rotation',
      type: 'Vec3',
      step: 1,
      defaultValue: [0, 0, 0]
    },
    scale: {
      label: 'Scale',
      type: 'Vec3',
      minValue: 0.0001,
      step: 0.1,
      defaultValue: [1, 1, 1]
    },

    pivotType: {
      label: 'Pivot',
      type: 'Options',
      display: 'Dropdown',
      labels: ['None', 'Node'],
      values: ['None', 'Node'],
      defaultValue: 'None'
    },

    pivotPolyMesh: { label: 'Pivot Mesh', type: 'Node' }
  },

  update: function update(operator, primitive, _ref) {
    var getWorldTransform = _ref.getWorldTransform,
        node = _ref.node,
        store = _ref.store;

    if (!primitive.mesh) return primitive;
    var count = operator.count,
        translation = operator.translation,
        rotation = operator.rotation,
        scale = operator.scale,
        pivotType = operator.pivotType,
        pivotPolyMesh = operator.pivotPolyMesh;


    var pivotMesh = pivotPolyMesh && store.get('sceneGraph').evaluatedNodes[pivotPolyMesh];

    var rotationInRadians = rotation.clone().multiplyScalar(Math.PI / 180);
    var eulerRotation = new _three.Euler().setFromVector3(rotationInRadians, 'ZYX');

    var meshToPivotTransform = new _three.Matrix4();

    if (pivotType === 'Node' && pivotMesh) {
      var pivotToWorldTransform = getWorldTransform(pivotMesh.PolyMesh.id);
      var meshToWorldTransform = getWorldTransform(node.id);

      meshToPivotTransform.getInverse(pivotToWorldTransform, true).multiply(meshToWorldTransform);
    }

    translation = new _three.Vector3(translation.x, translation.y, translation.z);
    rotation = new _three.Quaternion().setFromEuler(eulerRotation);
    scale = new _three.Vector3(scale.x, scale.y, scale.z);

    var _createMeshArray = (0, _createMeshArray3.default)(primitive.mesh, count, translation, rotation, scale, meshToPivotTransform),
        meshArray = _createMeshArray.meshArray,
        transforms = _createMeshArray.transforms;

    primitive.mesh = (0, _mergePolyMeshes2.default)(meshArray, transforms);

    return primitive;
  }
};

exports.default = Array;

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = __webpack_require__(0);

var _bendPolyMesh = __webpack_require__(158);

var _bendPolyMesh2 = _interopRequireDefault(_bendPolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AxisTypes = _bendPolyMesh2.default.AxisTypes;

var BendDeformer = {
  schema: {
    defaultAxis: {
      label: 'Default Axis',
      type: 'Options',
      display: 'Radio',
      defaultValue: AxisTypes.Z,
      labels: ['X', 'Y', 'Z'],
      values: [AxisTypes.X, AxisTypes.Y, AxisTypes.Z]
    },
    bendAngle: {
      label: 'Angle',
      type: 'Number',
      defaultValue: 45,
      step: 1,
      minValue: -360,
      maxValue: 360,
      animatable: true
    },
    rotation: {
      label: 'Bend Rotation',
      type: 'Vec3',
      defaultValue: new _three.Vector3(0, 0, 0),
      animatable: true
    },
    translation: {
      label: 'Bend Pivot',
      type: 'Vec3',
      defaultValue: new _three.Vector3(0, 0, 0),
      animatable: true
    },
    fixedEndsEnabled: {
      label: 'Fixed Ends',
      type: 'Boolean',
      defaultValue: false,
      animatable: false
    }
  },

  update: function update(operator, primitive) {
    if (!primitive.mesh) return primitive;
    var defaultAxis = operator.defaultAxis,
        bendAngle = operator.bendAngle,
        rotation = operator.rotation,
        translation = operator.translation,
        fixedEndsEnabled = operator.fixedEndsEnabled;

    rotation = rotation.clone().multiplyScalar(-1);
    translation = translation.clone().multiplyScalar(-1);
    primitive.mesh = (0, _bendPolyMesh2.default)(primitive.mesh, defaultAxis, bendAngle, rotation, translation, fixedEndsEnabled);
    return primitive;
  }
};

exports.default = BendDeformer;

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _blendPolyMesh = __webpack_require__(426);

var _blendPolyMesh2 = _interopRequireDefault(_blendPolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var channelProp = { label: 'Channel', type: 'Text', name: 'Channel' };
var weightProp = {
  label: 'Weight',
  type: 'Number',
  name: 'Weight',
  minValue: -1.0,
  maxValue: 10.0,
  step: 0.05,
  defaultValue: 0.0
};

function createSchema(numChannels) {
  var schema = {};

  for (var i = 0; i < numChannels; ++i) {
    schema['chan' + i] = channelProp;
    schema['beta' + i] = weightProp;
  }

  return schema;
}

var NUM_CHANNELS = 16;

var BlendDeformer = {
  schema: createSchema(NUM_CHANNELS),

  update: function update(operator, primitive) {
    var mesh = primitive.mesh;

    if (!mesh) return primitive;

    // gather non-zero weights

    var channels = [];
    var weights = [];

    for (var i = 0; i < NUM_CHANNELS; ++i) {
      var channel = operator['chan' + i];
      var weight = operator['beta' + i];
      if (channel && weight) {
        channels.push(channel);
        weights.push(weight);
      }
    }

    if (mesh.blendShapes) {
      primitive.mesh = (0, _blendPolyMesh2.default)(mesh, channels, weights);
    }

    return primitive;
  }
};

exports.default = BlendDeformer;

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _BlendShapeData = __webpack_require__(231);

var _BlendShapeData2 = _interopRequireDefault(_BlendShapeData);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BlendShape = {
  schema: {
    bsChannel: { label: 'Channel', type: 'Text', defaultValue: 'shape0' },
    bsShape: { label: 'Shape', type: 'Plug', plug: 'PolyMesh' }
  },

  update: function update(operator, primitive) {
    var mesh = primitive.mesh;
    if (!mesh) return primitive;

    var channel = operator.bsChannel;
    var geometry = operator.bsShape.mesh;

    if (channel.length && geometry) {
      var gPositions = geometry.positions.values;

      if (mesh.positions.values.length === gPositions.length) {
        var pNormals = mesh.normalMap.values;
        var gNormals = geometry.normalMap.values;

        if (!(pNormals && gNormals) || pNormals.length !== gNormals.length) {
          gNormals = null;
        }

        var blendShapes = mesh.blendShapes;

        if (!blendShapes) {
          blendShapes = mesh.blendShapes = {};
        }

        blendShapes[channel] = new _BlendShapeData2.default(gPositions, gNormals, null);
      } else {
        console.log('The Blend Shape cannot be assigned because the number of vertices does not match with the original shape');
      }
    }

    return primitive;
  }
};

exports.default = BlendShape;

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Box = __webpack_require__(447);

var _Box2 = _interopRequireDefault(_Box);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Box = {
  schema: {
    depth: {
      type: 'Number',
      label: 'Depth',
      defaultValue: 1,
      step: 0.1,
      minValue: 0.0,
      animatable: true
    },
    width: {
      type: 'Number',
      label: 'Width',
      defaultValue: 1,
      step: 0.1,
      minValue: 0.0,
      animatable: true
    },
    height: {
      type: 'Number',
      label: 'Height',
      defaultValue: 1,
      step: 0.1,
      minValue: 0.0,
      animatable: true
    },
    depthSegments: {
      type: 'Number',
      label: 'Depth Segments',
      defaultValue: 1,
      minValue: 1,
      isInteger: true,
      animatable: true,
      i18n: { en: {}, xn: { label: 'XXX' }, hn: { label: 'DX' } }
    },
    widthSegments: {
      type: 'Number',
      label: 'Width Segments',
      defaultValue: 1,
      minValue: 1,
      isInteger: true,
      animatable: true
    },
    heightSegments: {
      type: 'Number',
      label: 'Height Segments',
      defaultValue: 1,
      minValue: 1,
      isInteger: true,
      animatable: true
    }
  },

  update: function update(operator, primitive) {
    var width = operator.width,
        height = operator.height,
        depth = operator.depth,
        widthSegments = operator.widthSegments,
        heightSegments = operator.heightSegments,
        depthSegments = operator.depthSegments;

    primitive.mesh = (0, _Box2.default)(width, height, depth, widthSegments, heightSegments, depthSegments);
  }
};

exports.default = Box;

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Capsule = __webpack_require__(448);

var _Capsule2 = _interopRequireDefault(_Capsule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Capsule = {
  schema: {
    radius: {
      type: 'Number',
      label: 'Radius',
      defaultValue: 0.5,
      minValue: 0.1,
      step: 0.1
    },
    height: {
      type: 'Number',
      label: 'Height',
      defaultValue: 1,
      minValue: 0.1,
      step: 0.1
    },
    radiusSegments: {
      label: 'Radial Segments',
      type: 'Integer',
      defaultValue: 12,
      minValue: 4,
      maxValue: 100
    },
    heightSegments: {
      label: 'Height Segments',
      type: 'Integer',
      defaultValue: 10,
      minValue: 1,
      maxValue: 100
    }
  },

  update: function update(operator, primitive) {
    var radius = operator.radius,
        height = operator.height,
        radiusSegments = operator.radiusSegments,
        heightSegments = operator.heightSegments;

    primitive.mesh = (0, _Capsule2.default)(radius, height, radiusSegments, heightSegments);
  }
};

exports.default = Capsule;

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Cylinder = __webpack_require__(241);

var _Cylinder2 = _interopRequireDefault(_Cylinder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Cone = {
  schema: {
    base: {
      type: 'Number',
      label: 'Base Radius',
      defaultValue: 0.5,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    height: {
      type: 'Number',
      label: 'Height',
      defaultValue: 1,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    radiusSegments: {
      label: 'Radial Segments',
      type: 'Integer',
      defaultValue: 12,
      minValue: 3,
      maxValue: 200,
      animatable: true
    },
    heightSegments: {
      label: 'Height Segments',
      type: 'Integer',
      defaultValue: 1,
      minValue: 1,
      maxValue: 200,
      animatable: true
    },
    openEnded: {
      label: 'Open Base',
      type: 'Boolean',
      defaultValue: false,
      animatable: true
    }
  },

  update: function update(operator, primitive) {
    var base = operator.base,
        height = operator.height,
        radiusSegments = operator.radiusSegments,
        heightSegments = operator.heightSegments,
        openEnded = operator.openEnded;

    primitive.mesh = (0, _Cylinder2.default)(0, base, height, radiusSegments, heightSegments, openEnded);
  }
};

exports.default = Cone;

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _CrossSectionLathe = __webpack_require__(450);

var _CrossSectionLathe2 = _interopRequireDefault(_CrossSectionLathe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_CROSS_SECTIONS = 8;
var DEG_TO_RAD = Math.PI / 180;

function createSchema() {
  var schema = {
    radius: { type: 'Number', label: 'Radius', minValue: 0, step: 0.1 },
    segments: {
      type: 'Number',
      label: 'Segments',
      defaultValue: 50,
      minValue: 1,
      isInteger: true
    },
    phiStart: {
      type: 'Number',
      label: 'Phi Start',
      defaultValue: 0,
      step: 1,
      minValue: 0,
      maxValue: 360
    },
    phiLength: {
      type: 'Number',
      label: 'Phi Length',
      defaultValue: 360,
      step: 1,
      minValue: 0,
      maxValue: 360
    },
    interpolationType: {
      type: 'Options',
      label: 'Interpolation',
      display: 'Radio',
      labels: ['Linear', 'Smooth Step'],
      values: [0, 1],
      defaultValue: 1
    }
  };

  for (var i = 0; i < MAX_CROSS_SECTIONS; ++i) {
    schema['crossSectionNode' + i] = {
      type: 'Plug',
      plug: 'PolyMesh',
      label: 'Cross Section ' + (i + 1)
    };
    schema['locationAngle' + i] = {
      type: 'Number',
      label: 'Angle' + (i + 1),
      defaultValue: 0,
      step: 1,
      minValue: 0,
      maxValue: 360
    };
  }

  return schema;
}

var CrossSectionRevolve = {
  schema: createSchema(),

  update: function update(operator, primitive) {
    var radius = operator.radius,
        segments = operator.segments,
        phiStart = operator.phiStart,
        phiLength = operator.phiLength,
        interpolationType = operator.interpolationType;

    var crossSections = [];
    var _mesh = void 0;
    var _locationAngle = void 0;
    for (var i = 0; i < MAX_CROSS_SECTIONS; ++i) {
      _mesh = operator['crossSectionNode' + i];
      _locationAngle = operator['locationAngle' + i];
      if (_mesh && _mesh.mesh && _mesh.mesh.positions.values.length && !isNaN(_locationAngle)) {
        crossSections.push({
          mesh: _mesh.mesh,
          locationAngle: _locationAngle * DEG_TO_RAD
        });
      }
    }

    if (crossSections.length < 1) {
      return primitive;
    }

    primitive.mesh = (0, _CrossSectionLathe2.default)(crossSections, radius, segments, phiStart * DEG_TO_RAD, phiLength * DEG_TO_RAD, interpolationType);
    return primitive;
  }
};

exports.default = CrossSectionRevolve;

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Cylinder = __webpack_require__(241);

var _Cylinder2 = _interopRequireDefault(_Cylinder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Cylinder = {
  schema: {
    radiusTop: {
      type: 'Number',
      label: 'Top Radius',
      defaultValue: 0.5,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    radiusBottom: {
      type: 'Number',
      label: 'Bottom Radius',
      defaultValue: 0.5,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    height: {
      type: 'Number',
      label: 'Height',
      defaultValue: 1,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    radiusSegments: {
      label: 'Radial Segments',
      type: 'Integer',
      defaultValue: 24,
      minValue: 3,
      maxValue: 200,
      animatable: true
    },
    heightSegments: {
      label: 'Height Segments',
      type: 'Integer',
      defaultValue: 1,
      minValue: 1,
      maxValue: 200,
      animatable: true
    },
    openEnded: {
      label: 'Open Ended',
      type: 'Boolean',
      defaultValue: false,
      animatable: true
    }
  },

  update: function update(operator, primitive) {
    var radiusTop = operator.radiusTop,
        radiusBottom = operator.radiusBottom,
        height = operator.height,
        radiusSegments = operator.radiusSegments,
        heightSegments = operator.heightSegments,
        openEnded = operator.openEnded;

    primitive.mesh = (0, _Cylinder2.default)(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded);
  }
};

exports.default = Cylinder;

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringIndicesToArray = __webpack_require__(69);

var _stringIndicesToArray2 = _interopRequireDefault(_stringIndicesToArray);

var _deleteComponentFromPolyMesh = __webpack_require__(429);

var _deleteComponentFromPolyMesh2 = _interopRequireDefault(_deleteComponentFromPolyMesh);

var _removeUnusedValues = __webpack_require__(237);

var _removeUnusedValues2 = _interopRequireDefault(_removeUnusedValues);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DeleteComponent = {
  schema: {
    removeOrphans: {
      label: 'Remove Unused Values',
      type: 'Boolean',
      defaultValue: true
    },
    indices: {
      label: 'Selection',
      type: 'TextArea',
      defaultValue: '',
      display: 'indexStyle'
    }, // vertex or face indices
    componentType: { type: 'Object', hidden: true, defaultValue: 'Vertex' }
  },

  update: function update(operator, primitive) {
    if (!primitive.mesh) {
      return primitive;
    }

    var componentType = operator.componentType;
    var indices = (0, _stringIndicesToArray2.default)(operator.indices);

    primitive.mesh = (0, _deleteComponentFromPolyMesh2.default)(primitive.mesh, indices, componentType);

    if (operator.removeOrphans) {
      (0, _removeUnusedValues2.default)(primitive.mesh);
    }

    return primitive;
  }
};

exports.default = DeleteComponent;

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Disk = __webpack_require__(452);

var _Disk2 = _interopRequireDefault(_Disk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Disk = {
  schema: {
    radius: {
      type: 'Number',
      label: 'Radius',
      defaultValue: 0.5,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    segments: {
      type: 'Integer',
      label: 'Segments',
      defaultValue: 12,
      minValue: 3,
      maxValue: 200,
      animatable: true
    },
    thetaStart: {
      label: 'Theta Start',
      type: 'Number',
      defaultValue: 0,
      minValue: 0,
      maxValue: 360,
      step: 10,
      animatable: true
    },
    thetaLength: {
      label: 'Theta Length',
      type: 'Number',
      defaultValue: 360,
      minValue: 0,
      maxValue: 360,
      step: 10,
      animatable: true
    },
    removeDuplicate: {
      label: 'Remove Duplicate Vertices',
      type: 'Boolean',
      defaultValue: false,
      hidden: true
    }
  },

  update: function update(operator, primitive) {
    var radius = operator.radius,
        segments = operator.segments,
        thetaStart = operator.thetaStart,
        thetaLength = operator.thetaLength;

    primitive.mesh = (0, _Disk2.default)(radius, segments, thetaStart, thetaLength);
  }
};

exports.default = Disk;

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExtrudeTypes = undefined;

var _stringIndicesToArray = __webpack_require__(69);

var _stringIndicesToArray2 = _interopRequireDefault(_stringIndicesToArray);

var _inset = __webpack_require__(435);

var _inset2 = _interopRequireDefault(_inset);

var _Selection = __webpack_require__(70);

var _Selection2 = _interopRequireDefault(_Selection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ExtrudeTypes = exports.ExtrudeTypes = {
  individualPolygon: 1,
  averageNormal: 2,
  localNormal: 3
};

var Extrude = {
  name: 'Extrude',

  schema: {
    extrudeLength: {
      label: 'Length',
      type: 'Number',
      step: 0.01,
      defaultValue: 0.2,
      animatable: true
    },
    extrudeType: {
      label: 'Extrude Type',
      type: 'Options',
      display: 'Dropdown',
      labels: ['Group - Average Normal', 'Group - Local Normals', 'Individual Polygons'],
      values: [ExtrudeTypes.averageNormal, ExtrudeTypes.localNormal, ExtrudeTypes.individualPolygon],
      defaultValue: 2
    },
    indices: {
      label: 'Selection',
      type: 'TextArea',
      defaultValue: '',
      display: 'indexStyle'
    },
    insetOffset: {
      label: 'Offset',
      type: 'Number',
      step: 0.01,
      defaultValue: 0.0
    },
    segments: {
      label: 'Segments',
      type: 'Number',
      step: 1,
      defaultValue: 1,
      minValue: 1
    }
  },

  update: function update(operator, primitive) {
    var mesh = primitive.mesh;
    if (!mesh) return primitive;
    var extrudeLength = operator.extrudeLength,
        extrudeType = operator.extrudeType,
        indices = operator.indices,
        insetOffset = operator.insetOffset,
        segments = operator.segments;


    if (!indices) return primitive;
    var selection = new _Selection2.default((0, _stringIndicesToArray2.default)(indices), _Selection2.default.Faces);

    primitive.mesh = (0, _inset2.default)(mesh, extrudeType, selection, extrudeLength, insetOffset, segments);
    return primitive;
  }
};

exports.default = Extrude;

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var Instance = {
  schema: {
    geometry: { label: 'Mesh', plug: 'PolyMesh', type: 'Plug' }
  },

  update: function update(operator, primitive) {
    primitive.mesh = operator.geometry && operator.geometry.mesh;
  }
};

exports.default = Instance;

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _opentype = __webpack_require__(210);

var opentype = _interopRequireWildcard(_opentype);

var _three = __webpack_require__(0);

var _ShapeSet = __webpack_require__(233);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _mergePolyMeshes = __webpack_require__(103);

var _mergePolyMeshes2 = _interopRequireDefault(_mergePolyMeshes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getGlyphWidth(glyphs, size, code) {
  var glyphIdx = (0, _keys2.default)(glyphs).find(function (i) {
    return glyphs[i].unicode === code;
  });
  return glyphs[glyphIdx] && glyphs[glyphIdx].advanceWidth ? glyphs[glyphIdx].advanceWidth / size : 1.0;
}

var LineText = {
  selfProperties: true,

  schema: {
    text: { label: 'Text', type: 'String', defaultValue: 'Text' },
    curveSegments: { type: 'Number', defaultValue: 4, minValue: 2 },
    font: { label: 'Font', type: 'Plug', plug: 'Font' },
    fontSize: {
      label: 'Font Size',
      type: 'Number',
      defaultValue: 72,
      minValue: 1,
      step: 1
    },

    compact: {
      label: 'On',
      type: 'Boolean',
      defaultValue: false
    },
    padding: { label: 'Offset', type: 'Number', defaultValue: 0.0 },

    bendAngle: {
      label: 'Angle',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0,
      maxValue: 90.0
    },

    bevel: { label: 'On', type: 'Boolean', defaultValue: false },
    bevelSegments: {
      label: 'Segments',
      type: 'Integer',
      defaultValue: 1,
      minValue: 1
    },
    bevelOffset: {
      label: 'Offset',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0
    },
    bevelThreshold: {
      label: 'Threshold ratio',
      type: 'Number',
      defaultValue: 2.0,
      minValue: 1.0
    },
    bevelLength: {
      label: 'Length',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0
    },
    bevelStyle: {
      label: 'Style',
      type: 'Options',
      display: 'Dropdown',
      labels: ['Round', 'Extended'],
      values: [_ShapeSet.ShapeSetBevelStyles.Round, _ShapeSet.ShapeSetBevelStyles.Extended],
      defaultValue: _ShapeSet.ShapeSetBevelStyles.Round
    },
    smoothingAngle: {
      type: 'Number',
      defaultValue: 30,
      minValue: -180,
      maxValue: 180
    },

    addRings: { label: 'Add', type: 'Boolean', defaultValue: false },
    ringPosition: {
      label: 'Position',
      type: 'Number',
      minValue: -1.0,
      maxValue: 1.0,
      defaultValue: 1.0
    },
    ringOuterRadius: {
      label: 'Outer Radius',
      type: 'Number',
      minValue: 0.1,
      defaultValue: 10.0
    },
    ringInnerRadius: {
      label: 'Inner Radius',
      type: 'Number',
      minValue: 0.1,
      defaultValue: 9.0
    }
  },

  update: function update(operator, primitive, _ref) {
    var store = _ref.store,
        properties = _ref.properties,
        loaded = _ref.loaded,
        forceFetchAssets = _ref.forceFetchAssets;

    var fetch = properties.visible || properties.prefetch && loaded || forceFetchAssets;
    var font = fetch && operator.font && operator.font.getFont();

    if (!font || (0, _keys2.default)(font).length === 0) return;

    var curveSegments = operator.curveSegments,
        fontSize = operator.fontSize,
        addRings = operator.addRings;

    var compactPadding = operator.compact ? operator.padding : undefined;

    // trim only if there's no compact, otherwise remove all spaces
    var text = compactPadding === undefined ? operator.text.trim() : operator.text.replace(/\s+/g, '');

    var size = font.unitsPerEm;
    var glyphs = font.glyphs.glyphs;
    var fontScale = fontSize / 72;
    var numSpaces = 0;

    var shapeSets = [];
    var shapeOffsets = [];
    var totalOffset = 0;
    var previousGlyphWidth = 0;
    var previousShapeSet = null;

    // to remember the edge values to compute the compact distance between each shapes
    // (faster computation)
    var lastCompactResult = { thisEdges: null };

    for (var i = 0; i < text.length; ++i) {
      var ringInfo = addRings && (i == 0 || i + 1 == text.length) ? {
        xPosition: i == 0 ? -1 : 1,
        yPosition: operator.ringPosition,
        outerRadius: operator.ringOuterRadius,
        innerRadius: operator.ringInnerRadius
      } : undefined;

      if (text.charAt(i) === ' ') {
        ++numSpaces;
        totalOffset += getGlyphWidth(glyphs, size, ' '.charCodeAt(0)) * fontScale;
      } else {
        var path = font.getPath(text.charAt(i), 0, fontSize, fontSize);
        var charShapeSet = _ShapeSet.ShapeSet.fromPath(path, curveSegments, fontSize, compactPadding, ringInfo);

        var code = text.charCodeAt(i);
        if (compactPadding !== undefined) {
          var shapeWidth = 0;
          if (previousShapeSet) {
            shapeWidth = previousShapeSet.getHorizontalDistance(charShapeSet, previousGlyphWidth, compactPadding, lastCompactResult);
          }
          previousGlyphWidth = getGlyphWidth(glyphs, size, code) * fontScale;

          totalOffset += shapeWidth;
          shapeOffsets.push(new _three.Vector3(totalOffset, 0.0, 0.0));
        } else {
          var _shapeWidth = getGlyphWidth(glyphs, size, code) * fontScale;

          shapeOffsets.push(new _three.Vector3(totalOffset, 0.0, 0.0));
          totalOffset += _shapeWidth;
        }

        previousShapeSet = charShapeSet;
        shapeSets.push(charShapeSet);
      }
    }

    if (!shapeSets.length) return;

    var compiledShapeSet = shapeSets.length === 1 ? shapeSets[0] : _ShapeSet.ShapeSet.mergeShapeSets(shapeSets, shapeOffsets);

    if (operator.bendAngle !== 0.0) {
      compiledShapeSet.bend(operator.bendAngle);
    }

    if (operator.bevel && operator.bevelLength) {
      compiledShapeSet.bevelShapeSet(operator.bevelOffset, operator.bevelLength, operator.bevelSegments, operator.bevelStyle, operator.bevelThreshold, operator.smoothingAngle);
    }

    primitive.mesh = _PolyMesh2.default.fromShapeSet(compiledShapeSet);
    return primitive;
  }
};

exports.default = LineText;

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _stringIndicesToArray = __webpack_require__(69);

var _stringIndicesToArray2 = _interopRequireDefault(_stringIndicesToArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MaterialIDs = {
  schema: {
    materialID: {
      label: 'Material ID',
      type: 'Integer',
      step: 1,
      minValue: 0,
      defaultValue: 0
    },
    indices: {
      label: 'Selection',
      type: 'TextArea',
      defaultValue: '',
      display: 'indexStyle'
    }, // Face Indices
    deleteAll: { label: 'Delete All', type: 'Boolean', defaultValue: false }
  },

  update: function update(operator, primitive) {
    if (!primitive.mesh) {
      return primitive;
    }
    var materialID = operator.materialID,
        indices = operator.indices,
        deleteAll = operator.deleteAll;

    var mesh = primitive.mesh;
    var newMaterialIds = void 0;

    if (deleteAll) {
      mesh.materialIds = null;
    } else {
      var faceRangeOffsets = mesh.faceRangeOffsets;
      var selectedFaces = (0, _stringIndicesToArray2.default)(indices);
      if (selectedFaces.length < 1) {
        return primitive;
      }

      if (mesh.materialIds) {
        newMaterialIds = new Uint32Array(mesh.materialIds);
      } else {
        newMaterialIds = new Uint32Array(faceRangeOffsets.length - 1);
      }

      for (var i = 0; i < selectedFaces.length; ++i) {
        newMaterialIds[selectedFaces[i]] = materialID;
      }
    }
    primitive.mesh = new _PolyMesh2.default(mesh, { materialIds: newMaterialIds });
    return primitive;
  }
};

exports.default = MaterialIDs;

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bingeom = __webpack_require__(162);

var _assets = __webpack_require__(33);

var _Normals = __webpack_require__(50);

var Mesh = {
  selfProperties: true,

  schema: {
    geometry: { type: 'File', label: 'PolyMesh Geometry File' }
  },

  update: function update(operator, primitive, _ref) {
    var node = _ref.node,
        store = _ref.store,
        properties = _ref.properties,
        previousResult = _ref.previousResult,
        loaded = _ref.loaded,
        forceFetchAssets = _ref.forceFetchAssets;

    var visible = properties.visible;
    var geom = operator.geometry; // Request geometry so the asset gets referenced
    var fetch = visible || properties.prefetch && loaded || forceFetchAssets;
    var ref = fetch && geom;
    var bingeom = ref && store.hasApi() && store.dispatch((0, _assets.getOrFetchBinary)(ref));
    var mesh = bingeom && (0, _bingeom.convertToCNSPolyMesh)(bingeom, ref);
    //console.log('Mesh update', 'visible:', visible, 'prefetch:', properties.prefetch, 'fetch:', fetch, 'bingeom:', !!bingeom,  node.name, mesh);

    // Let's always have at least a flat normal back as default, in case no normals provided
    // This provides at least some reasonable shading, and the user is free to apply other normal operators
    // as desired.
    if (mesh && !mesh.normalMap) mesh = (0, _Normals.flatNormalMap)(mesh);

    primitive.mesh = mesh;
    primitive.previousMesh = previousResult && previousResult.mesh;
    return primitive;
  }
};

exports.default = Mesh;

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _subdivision = __webpack_require__(444);

var _subdivision2 = _interopRequireDefault(_subdivision);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MeshSmooth = {
  schema: {
    subdivisions: {
      label: 'Subdivisions',
      type: 'Number',
      defaultValue: 1,
      minValue: 0,
      maxValue: 4
    },
    smoothByMaterialIds: {
      label: 'Smooth by Material Ids',
      type: 'Boolean',
      defaultValue: true
    }
    //hardEdges: { label: 'Hard Edges', type: 'Boolean', defaultValue: false },
  },

  update: function update(operator, primitive) {
    var mesh = primitive.mesh;
    var subdivisions = operator.subdivisions !== undefined ? operator.subdivisions : 1;
    //currently we are always assuming hard edges
    //const hardEdges = operator.hardEdges || true;
    if (!mesh) return primitive;

    for (var i = 0; i < subdivisions; i++) {
      mesh = (0, _subdivision2.default)(mesh, operator.smoothByMaterialIds);
    }

    primitive.mesh = mesh;
    return primitive;
  }
};

exports.default = MeshSmooth;

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Plane = __webpack_require__(453);

var _Plane2 = _interopRequireDefault(_Plane);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Plane = {
  schema: {
    width: {
      label: 'Width',
      type: 'Number',
      defaultValue: 4,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    height: {
      label: 'Height',
      type: 'Number',
      defaultValue: 4,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    widthSegments: {
      type: 'Number',
      label: 'Width Segments',
      defaultValue: 1,
      minValue: 1,
      isInteger: true,
      animatable: true
    },
    heightSegments: {
      type: 'Number',
      label: 'Height Segments',
      defaultValue: 1,
      minValue: 1,
      isInteger: true,
      animatable: true
    }
  },

  update: function update(operator, primitive) {
    var width = operator.width,
        height = operator.height,
        widthSegments = operator.widthSegments,
        heightSegments = operator.heightSegments;

    primitive.mesh = (0, _Plane2.default)(width, height, widthSegments, heightSegments);
  }
};

exports.default = Plane;

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bingeom = __webpack_require__(162);

var _assets = __webpack_require__(33);

var _Normals = __webpack_require__(50);

function extractLevelBinary(nbLevel, level) {
  var prop = null;
  if (level === 1.0 || nbLevel === 1) {
    prop = 'binary';
  } else {
    level = Math.ceil(level * nbLevel);
    if (level >= nbLevel) {
      prop = 'binary';
    } else if (level <= 0.0) {
      prop = 'level0';
    } else {
      prop = 'level' + (level - 1);
    }
  }
  return prop;
}

var ProxyMesh = {
  selfProperties: true,

  schema: {
    binary: { type: 'Binary', label: 'Binary Geometry File' },
    reducedBinary: { type: 'Binary', label: 'Reduced Binary Geometry File' },
    operatorDisplay: {
      type: 'Number',
      defaultValue: 1,
      label: 'Operator Display Type'
    },
    nbLevel: { type: 'Number', defaultValue: 1 }, // 1 -> only binary, 2 -> level0 and binary, 3 -> level0, level1, binary, ....
    level0: { type: 'Binary', label: 'Binary Geometry File' },
    level1: { type: 'Binary', label: 'Binary Geometry File' },
    level2: { type: 'Binary', label: 'Binary Geometry File' },
    level3: { type: 'Binary', label: 'Binary Geometry File' },
    level4: { type: 'Binary', label: 'Binary Geometry File' },
    clientLevel: {
      type: 'Number',
      defaultValue: 0.5,
      minValue: 0.0,
      maxValue: 1.0,
      label: 'Reduction Level'
    }
  },

  update: function update(operator, primitive, _ref) {
    var store = _ref.store,
        properties = _ref.properties,
        previousResult = _ref.previousResult,
        loaded = _ref.loaded,
        forceFetchAssets = _ref.forceFetchAssets;

    var visible = properties.visible;
    //const binary = operator.binary;
    var nbLevel = operator.nbLevel;
    var clientLevel = operator.clientLevel;
    var propName = extractLevelBinary(nbLevel, clientLevel);
    var binary = operator[propName];

    var fetch = visible || properties.prefetch && loaded || forceFetchAssets;
    var bingeom = fetch && binary && store.hasApi() && (0, _assets.getOrFetchBinary)(binary)(store);
    var mesh = bingeom && (0, _bingeom.convertToCNSPolyMesh)(bingeom, binary);
    //console.log('Mesh update', 'visible:', visible, 'prefetch:', properties.prefetch, 'fetch:', fetch, 'bingeom:', !!bingeom, node.name, mesh);

    // Let's always have at least a flat normal back as default, in case no normals provided
    // This provides at least some reasonable shading, and the user is free to apply other normal operators
    // as desired.
    if (mesh && !mesh.normalMap) mesh = (0, _Normals.flatNormalMap)(mesh);

    primitive.mesh = mesh;
    primitive.previousMesh = previousResult && previousResult.mesh;
  }
};

exports.default = ProxyMesh;

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _RevolveReferenceMesh = __webpack_require__(454);

var _RevolveReferenceMesh2 = _interopRequireDefault(_RevolveReferenceMesh);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Revolve = {
  schema: {
    phiStart: {
      type: 'Number',
      label: 'Phi Start',
      defaultValue: 0,
      step: 1,
      minValue: 0,
      maxValue: 360
    },
    phiLength: {
      type: 'Number',
      label: 'Phi End',
      defaultValue: 360,
      step: 1,
      minValue: 0,
      maxValue: 360
    },
    segments: {
      type: 'Number',
      label: 'Segments',
      defaultValue: 50,
      minValue: 1,
      isInteger: true
    },
    otherPolyMesh: { type: 'Node', plug: 'PolyMesh', label: 'Other PolyMesh' }
  },

  update: function update(operator, primitive, _ref) {
    var getWorldTransform = _ref.getWorldTransform,
        node = _ref.node,
        store = _ref.store;
    var phiStart = operator.phiStart,
        phiLength = operator.phiLength,
        segments = operator.segments,
        otherPolyMesh = operator.otherPolyMesh,
        otherPolyMeshEvaluated = operator.otherPolyMeshEvaluated;

    var refMesh = otherPolyMeshEvaluated && otherPolyMeshEvaluated.PolyMesh && otherPolyMeshEvaluated.PolyMesh.mesh;

    if (!refMesh) {
      primitive.mesh = new _PolyMesh2.default();
      return primitive;
    }
    var latheToWorldTransform = getWorldTransform(node.id);
    var meshToWorldTransform = getWorldTransform(otherPolyMesh);

    primitive.mesh = (0, _RevolveReferenceMesh2.default)(refMesh, segments, phiStart, phiLength, latheToWorldTransform, meshToWorldTransform);
    return primitive;
  }
};

exports.default = Revolve;

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _RevolveReferenceSegment = __webpack_require__(455);

var _RevolveReferenceSegment2 = _interopRequireDefault(_RevolveReferenceSegment);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AxisTypes = _RevolveReferenceSegment2.default.AxisTypes;

var SegmentRevolve = {
  schema: {
    referenceNode: { type: 'Plug', plug: 'PolyMesh', label: 'Reference Node' },
    axis: {
      type: 'Options',
      label: 'Axis',
      display: 'Radio',
      labels: ['X', 'Y', 'Z'],
      values: [AxisTypes.X, AxisTypes.Y, AxisTypes.Z],
      defaultValue: AxisTypes.Y
    },
    repeats: {
      type: 'Number',
      label: 'Repeats',
      defaultValue: 4,
      minValue: 1,
      isInteger: true
    },
    radius: {
      type: 'Number',
      label: 'Radius',
      defaultValue: 1,
      step: 0.1,
      minValue: 0,
      animatable: true
    },
    revolutionAngle: {
      type: 'Number',
      label: 'Degrees',
      defaultValue: 360,
      minValue: 0,
      maxValue: 360,
      step: 1,
      animatable: true
    },
    spacingAngle: {
      type: 'Number',
      label: 'Spacing Angle',
      defaultValue: 0,
      maxValue: 360,
      step: 1,
      animatable: true
    }
  },

  update: function update(operator, primitive) {
    var referenceNode = operator.referenceNode,
        axis = operator.axis,
        repeats = operator.repeats,
        radius = operator.radius,
        revolutionAngle = operator.revolutionAngle,
        spacingAngle = operator.spacingAngle;

    if (!referenceNode || !referenceNode.mesh) {
      primitive.mesh = new _PolyMesh2.default();
      return primitive;
    }

    primitive.mesh = (0, _RevolveReferenceSegment2.default)(referenceNode.mesh, axis, repeats, radius, revolutionAngle, spacingAngle);
    return primitive;
  }
};

exports.default = SegmentRevolve;

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shearPolyMesh = __webpack_require__(441);

var _shearPolyMesh2 = _interopRequireDefault(_shearPolyMesh);

var _three = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Shear = {
  schema: {
    // center and rotation are in local space
    center: {
      label: 'Local Center',
      type: 'Vec3',
      defaultValue: new _three.Vector3(0, 0, 0),
      step: 0.01,
      animatable: true
    },
    rotation: {
      label: 'Local Rotation',
      type: 'Vec3',
      defaultValue: new _three.Vector3(0, 0, 0),
      step: 1,
      animatable: true
    },
    shearFactor: {
      label: 'Shear Factor',
      type: 'Number',
      step: '0.1',
      defaultValue: '0',
      animatable: true
    },
    vertexIndices: {
      label: 'Selection',
      type: 'TextArea',
      defaultValue: '',
      display: 'indexStyle'
    }
  },

  update: function update(operator, primitive) {
    if (!primitive.mesh) {
      return primitive;
    }
    var center = operator.center,
        rotation = operator.rotation,
        shearFactor = operator.shearFactor,
        vertexIndices = operator.vertexIndices;

    primitive.mesh = (0, _shearPolyMesh2.default)(primitive.mesh, center, rotation, shearFactor, vertexIndices);
    return primitive;
  }
};

exports.default = Shear;

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Skin = {
  // PolyMesh depends on its world transform
  selfTransform: true,

  schema: {
    boneNodeList: { type: 'NodeList', label: 'Select Bones', plug: 'Bone' },
    optionalRootBone: {
      type: 'Node',
      label: 'Optional Root Bone',
      defaultValue: null,
      filter: function filter(n) {
        return n.isBone();
      }
    }
  },

  update: function update(operator, primitive, _ref) {
    var node = _ref.node,
        getWorldTransform = _ref.getWorldTransform;

    var skinWorldTransform = getWorldTransform(node.id);

    // Ensure we reference the bone node list, so that the dependency
    // graph gets updated properly.
    var nodeList = operator.boneNodeList;
    var rootBone = operator.optionalRootBone;
    var rootBoneIndex = -1;

    if (nodeList.length === 0) return primitive;

    //get world transforms for each bone
    var boneWorldTransforms = nodeList.map(function (boneNode) {
      return getWorldTransform(boneNode);
    });

    //get the index of the root bone
    if (rootBone) {
      for (var i = 0, il = nodeList.length; i < il; i++) {
        var boneNode = nodeList[i];
        if (boneNode == rootBone) {
          rootBoneIndex = i;
          break;
        }
      }
    }

    var polyMesh = primitive.mesh;

    primitive.mesh = skin(polyMesh, skinWorldTransform, boneWorldTransforms, rootBoneIndex);
  }
};

function skin(polyMesh, skinToWorldTransform, boneWorldTransforms, rootBoneIndex) {
  if (!polyMesh || !polyMesh.skinning) {
    return polyMesh;
  }

  var skinning = polyMesh.skinning;
  var newValues = skinning.applyTransforms(polyMesh.positions.values, skinToWorldTransform, boneWorldTransforms, rootBoneIndex);

  var newPositions = new _PolyMap2.default({
    faceRangeOffsets: polyMesh.faceRangeOffsets,
    faceValueIndices: polyMesh.positions.faceValueIndices,
    values: newValues
  });

  var newMesh = (0, _assign2.default)({}, polyMesh, { positions: newPositions });
  var resultMesh = new _PolyMesh2.default(newMesh);

  return resultMesh;
}

exports.default = Skin;

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _slicePolyMesh = __webpack_require__(238);

var _slicePolyMesh2 = _interopRequireDefault(_slicePolyMesh);

var _Selection = __webpack_require__(70);

var _Selection2 = _interopRequireDefault(_Selection);

var _findPlaneFromRotation = __webpack_require__(236);

var _findPlaneFromRotation2 = _interopRequireDefault(_findPlaneFromRotation);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var stringToArray = function stringIndicesToArray() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var indices = str.split(',');
  var outIndices = [];
  var i = void 0,
      j = void 0,
      start = void 0,
      end = void 0,
      v = void 0;
  for (i = 0; i < indices.length; i++) {
    v = indices[i];
    if (v.indexOf('-') !== -1) {
      var _v$split = v.split('-');

      var _v$split2 = (0, _slicedToArray3.default)(_v$split, 2);

      start = _v$split2[0];
      end = _v$split2[1];

      start = Number(start);
      end = Number(end);
      for (j = start; j <= end; j++) {
        outIndices.push(j);
      }
    } else {
      outIndices.push(Number(v));
    }
  }

  return outIndices;
};

// -1 because the v1 slice is inverted compared to v2
var defaultNormal = new THREE.Vector3(0, 0, -1);

var Slice = {
  //from V1, type might need to be changed
  name: 'Slice',
  label: 'Slice / Cut',
  type: 'Edit',

  schema: {
    //From V1
    // center and rotation are in local space
    center: {
      label: 'Local Center',
      type: 'Vec3',
      defaultValue: new THREE.Vector3(0, 0, 0),
      step: 0.01,
      animatable: true
    },
    rotation: {
      label: 'Local Rotation',
      type: 'Vec3',
      defaultValue: new THREE.Vector3(0, 0, 0),
      step: 1,
      animatable: true
    },
    _rotationAxis: {
      label: 'Rotation',
      type: 'Vec3',
      defaultValue: new THREE.Vector3(0, 0, 0),
      step: 1,
      hidden: true
    },
    axis: {
      label: 'Axis',
      type: 'Options',
      display: 'Dropdown',
      labels: ['X', 'Y', 'Z'],
      values: [1, 2, 3],
      defaultValue: 1
    },
    flip: { label: 'Flip', type: 'Boolean', defaultValue: false },
    cut: { label: 'Cut', type: 'Boolean', defaultValue: false },
    indices: {
      label: 'Selection',
      type: 'TextArea',
      defaultValue: '',
      display: 'indexStyle'
    } // Face Indices
  },

  update: function update(operator, primitive, _ref) {
    var node = _ref.node;

    var mesh = primitive.mesh;
    if (!mesh) return primitive;
    var center = operator.center,
        rotation = operator.rotation,
        axis = operator.axis,
        flip = operator.flip,
        cut = operator.cut,
        indices = operator.indices;


    var faceIndices = indices ? stringToArray(indices) : null;
    var selection = indices ? new _Selection2.default(faceIndices, _Selection2.default.Faces) : null;
    var rotateOrder = node.plugs.Transform[0].rotateOrder;
    var plane = (0, _findPlaneFromRotation2.default)(rotation, rotateOrder, axis, center, defaultNormal);

    primitive.mesh = (0, _slicePolyMesh2.default)(mesh, plane, cut, flip, selection);
    return primitive;
  }
};

exports.default = Slice;

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sortFacesByAxis = __webpack_require__(442);

var _sortFacesByAxis2 = _interopRequireDefault(_sortFacesByAxis);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SortFacesByAxis = {
  schema: {
    axis: {
      label: 'Direction',
      type: 'Vec3',
      step: 0.1,
      defaultValue: { x: 1, y: 1, z: 0 },
      animatable: true
    }
  },

  update: function update(operator, primitive, _ref) {
    var store = _ref.store;

    //using an import from player.js for getThreeCamera for some reason wipes the active camera
    //const camera =  store.getIn(['player','threeCamera']);
    //const cameraWorldMatrix = camera.matrix;
    var axis = operator.axis.normalize();

    //does not account for the local space of an object
    //const cameraDirection = new Vector3(0,0,-1);
    //cameraDirection.transformDirection(cameraWorldMatrix);

    var polyMesh = primitive.mesh;
    primitive.mesh = (0, _sortFacesByAxis2.default)(polyMesh, axis);
  }
};

exports.default = SortFacesByAxis;

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _findMinimalSpacing = __webpack_require__(431);

var _findMinimalSpacing2 = _interopRequireDefault(_findMinimalSpacing);

var _transform = __webpack_require__(239);

var _transform2 = _interopRequireDefault(_transform);

var _Selection = __webpack_require__(70);

var _Selection2 = _interopRequireDefault(_Selection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Spacing = {
  schema: {
    overlap: { type: 'Number', defaultValue: 0, step: 0.01 }
  },

  update: function update(operator, primitive) {
    if (!primitive.mesh) return primitive;
    var mesh = primitive.mesh;
    var overlap = operator.overlap;


    var idVertices = getVerticesFromMaterialId(mesh, 0);
    var id = 0;
    var groups = [idVertices];
    var newMesh = mesh;
    var backwardOffset = void 0,
        forwardOffset = { x: -Infinity, y: -Infinity, z: -Infinity };
    while (idVertices.length) {
      backwardOffset = (0, _findMinimalSpacing2.default)(newMesh, id, idVertices, false);
      var offset = backwardOffset.max(forwardOffset);
      if (offset.lengthSq() < Infinity) {
        var scale = 1 + overlap / offset.length();
        newMesh = (0, _transform2.default)(newMesh, offset.multiplyScalar(scale), new _Selection2.default(idVertices, _Selection2.default.Vertices));
      }
      forwardOffset = (0, _findMinimalSpacing2.default)(newMesh, id, idVertices, true).multiplyScalar(-1);
      id++;
      idVertices = getVerticesFromMaterialId(newMesh, id);
      groups.push(idVertices);
    }
    primitive.mesh = newMesh;
    return primitive;
  }
};

function getVerticesFromMaterialId(polymesh, id) {
  return polymesh.materialIds.reduce(function (indices, matId, idx) {
    var faceBegin = polymesh.faceRangeOffsets[idx];
    var faceEnd = polymesh.faceRangeOffsets[idx + 1];
    if (polymesh.materialIds[idx] !== id) return indices;
    for (var f = faceBegin; f < faceEnd; f++) {
      var index = polymesh.positions.faceValueIndices[f];
      if (indices.indexOf(index) === -1) indices.push(index);
    }
    return indices;
  }, []);
}

exports.default = Spacing;

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Sphere = __webpack_require__(456);

var _Sphere2 = _interopRequireDefault(_Sphere);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Sphere = {
  schema: {
    radius: {
      label: 'Radius',
      type: 'Number',
      defaultValue: 0.5,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    widthSegments: {
      label: 'Longitudinal Segments',
      type: 'Integer',
      defaultValue: 24,
      minValue: 3,
      maxValue: 200,
      step: 1,
      animatable: true
    },
    heightSegments: {
      label: 'Latitudinal Segments',
      type: 'Integer',
      defaultValue: 24,
      minValue: 3,
      maxValue: 200,
      step: 1,
      animatable: true
    },
    phiStart: {
      label: 'Phi Start',
      type: 'Number',
      defaultValue: 0,
      minValue: 0,
      maxValue: 360,
      step: 10,
      animatable: true
    },
    phiLength: {
      label: 'Phi Length',
      type: 'Number',
      defaultValue: 360,
      minValue: 0,
      maxValue: 360,
      step: 10,
      animatable: true
    },
    thetaStart: {
      label: 'Theta Start',
      type: 'Number',
      defaultValue: 0,
      minValue: 0,
      maxValue: 180,
      step: 10,
      animatable: true
    },
    thetaLength: {
      label: 'Theta Length',
      type: 'Number',
      defaultValue: 180,
      minValue: 0,
      maxValue: 180,
      step: 10,
      animatable: true
    }
  },

  update: function update(operator, primitive) {
    var radius = operator.radius,
        widthSegments = operator.widthSegments,
        heightSegments = operator.heightSegments,
        phiStart = operator.phiStart,
        phiLength = operator.phiLength,
        thetaStart = operator.thetaStart,
        thetaLength = operator.thetaLength;

    primitive.mesh = (0, _Sphere2.default)(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
  }
};

exports.default = Sphere;

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stretchPolyMesh = __webpack_require__(443);

var _stretchPolyMesh2 = _interopRequireDefault(_stretchPolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AxisTypes = { X: 1, Y: 2, Z: 3 };

var Stretch = {
  schema: {
    axis: {
      label: 'Axis',
      type: 'Options',
      display: 'Radio',
      defaultValue: AxisTypes.X,
      labels: ['X', 'Y', 'Z'],
      values: [AxisTypes.X, AxisTypes.Y, AxisTypes.Z]
    },
    margin: {
      label: 'Margin',
      type: 'Number',
      defaultValue: 0,
      step: 0.1,
      minValue: 0,
      animatable: true
    },
    stretchDistance: {
      label: 'Stretch Distance',
      type: 'Number',
      defaultValue: 0,
      step: 0.1,
      animatable: true
    }
  },

  update: function update(operator, primitive) {
    if (!primitive.mesh) {
      return primitive;
    }
    var axis = operator.axis,
        margin = operator.margin,
        stretchDistance = operator.stretchDistance;

    var axisMap = ['x', 'y', 'z'];
    primitive.mesh = (0, _stretchPolyMesh2.default)(primitive.mesh, axisMap[axis - 1], margin, stretchDistance);
  }
};

exports.default = Stretch;

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _symmetry = __webpack_require__(445);

var _symmetry2 = _interopRequireDefault(_symmetry);

var _findPlaneFromRotation = __webpack_require__(236);

var _findPlaneFromRotation2 = _interopRequireDefault(_findPlaneFromRotation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var axisArray = ['x', 'y', 'z'];
var defaultNormal = new THREE.Vector3(0, 0, 1);

var Symmetry = {
  name: 'Symmetry',
  label: 'Symmetry / Mirror',

  schema: {
    // center and rotation are in local space
    center: {
      label: 'Local Center',
      type: 'Vec3',
      defaultValue: new THREE.Vector3(0, 0, 0),
      step: 0.1,
      animatable: true
    },
    rotation: {
      label: 'Local Rotation',
      type: 'Vec3',
      defaultValue: new THREE.Vector3(0, 0, 0),
      step: 1,
      animatable: true
    },
    axis: {
      label: 'Axis',
      type: 'Options',
      display: 'Dropdown',
      labels: ['X', 'Y', 'Z'],
      values: [1, 2, 3],
      defaultValue: 1
    },
    flip: { label: 'Flip Mirroring', type: 'Boolean', defaultValue: true },
    slice: { label: 'Slice', type: 'Boolean', defaultValue: false },
    copyMirror: {
      label: 'Copy and Mirror',
      type: 'Boolean',
      defaultValue: false
    }
  },

  update: function update(operator, primitive, _ref) {
    var node = _ref.node;

    var mesh = primitive.mesh;
    if (!mesh) return primitive;

    var center = operator.center,
        rotation = operator.rotation,
        axis = operator.axis,
        flip = operator.flip,
        slice = operator.slice,
        copyMirror = operator.copyMirror;

    var rotateOrder = node.plugs.Transform[0].rotateOrder;
    var normal = new THREE.Vector3().copy(defaultNormal);

    if (flip) {
      normal.negate();
    }
    var plane = (0, _findPlaneFromRotation2.default)(rotation, rotateOrder, axis, center, normal);

    primitive.mesh = (0, _symmetry2.default)(mesh, plane, copyMirror, slice);

    return primitive;
  }
};

exports.default = Symmetry;

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _computeTangents = __webpack_require__(428);

var _computeTangents2 = _interopRequireDefault(_computeTangents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Tangents = {
  schema: {},

  update: function update(operator, primitive) {
    if (!primitive.mesh) {
      return primitive;
    }

    primitive.mesh = (0, _computeTangents2.default)(primitive.mesh);

    return primitive;
  }
};

exports.default = Tangents;

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Torus = __webpack_require__(457);

var _Torus2 = _interopRequireDefault(_Torus);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Torus = {
  schema: {
    radius: {
      label: 'Radius',
      type: 'Number',
      defaultValue: 0.3,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    tube: {
      label: 'Tube Radius',
      type: 'Number',
      defaultValue: 0.2,
      minValue: 0.0,
      step: 0.1,
      animatable: true
    },
    radialSegments: {
      label: 'Longitudinal Segments',
      type: 'Integer',
      defaultValue: 24,
      minValue: 3,
      step: 1,
      animatable: true
    },
    tubularSegments: {
      label: 'Latitudinal Segments',
      type: 'Integer',
      defaultValue: 24,
      minValue: 3,
      step: 1,
      animatable: true
    },
    phiStart: {
      label: 'Phi Start',
      type: 'Number',
      defaultValue: 0,
      minValue: 0,
      maxValue: 360,
      step: 10,
      animatable: true
    },
    phiLength: {
      label: 'Phi Length',
      type: 'Number',
      defaultValue: 360,
      minValue: 0,
      maxValue: 360,
      step: 10,
      animatable: true
    },
    thetaStart: {
      label: 'Theta Start',
      type: 'Number',
      defaultValue: 0,
      minValue: 0,
      maxValue: 360,
      step: 10,
      animatable: true
    },
    thetaLength: {
      label: 'Theta Length',
      type: 'Number',
      defaultValue: 360,
      minValue: 0,
      maxValue: 360,
      step: 10,
      animatable: true
    }
  },

  update: function update(operator, primitive) {
    var radius = operator.radius,
        tube = operator.tube,
        radialSegments = operator.radialSegments,
        tubularSegments = operator.tubularSegments,
        phiStart = operator.phiStart,
        phiLength = operator.phiLength,
        thetaStart = operator.thetaStart,
        thetalength = operator.thetalength;

    primitive.mesh = (0, _Torus2.default)(radius, tube, radialSegments, tubularSegments, phiStart, phiLength, thetaStart, thetalength);
  }
};

exports.default = Torus;

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = __webpack_require__(0);

var _polyMesh = __webpack_require__(161);

var _stringIndicesToArray = __webpack_require__(69);

var _stringIndicesToArray2 = _interopRequireDefault(_stringIndicesToArray);

var _getCentroidByVertices = __webpack_require__(432);

var _getCentroidByVertices2 = _interopRequireDefault(_getCentroidByVertices);

var _getSoftSelection2 = __webpack_require__(434);

var _getSoftSelection3 = _interopRequireDefault(_getSoftSelection2);

var _calculateFalloffWeights = __webpack_require__(234);

var _transform = __webpack_require__(239);

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TransformVertices = {
  schema: {
    translation: {
      label: 'Translation',
      type: 'Vec3',
      step: 0.1,
      defaultValue: { x: 0, y: 0, z: 0 },
      animatable: true
    },
    rotation: {
      label: 'Rotation',
      type: 'Vec3',
      step: 1,
      defaultValue: { x: 0, y: 0, z: 0 },
      animatable: true,
      hidden: true
    },
    scale: {
      label: 'Scale',
      type: 'Vec3',
      minValue: 0.0001,
      step: 0.1,
      defaultValue: { x: 1, y: 1, z: 1 },
      animatable: true,
      hidden: true
    },
    updateNormals: {
      label: 'Update Normals',
      type: 'Boolean',
      defaultValue: true,
      hidden: true
    },
    centerType: {
      label: 'Center',
      type: 'Options',
      display: 'Dropdown',
      labels: ['Selection Center', 'World Center', 'Pivot'],
      values: ['SelectionCenter', 'WorldCenter', 'Pivot'],
      defaultValue: 'SelectionCenter'
    },
    // matrix is used in baking transform and overrides other parameters
    matrix: { type: 'Object', defaultValue: null, hidden: true },
    vertexIndices: { label: 'Selection', type: 'String', defaultValue: '' },

    // Soft Selection
    softSelection: {
      label: 'Soft Selection',
      type: 'Boolean',
      defaultValue: false
    },
    falloffRadius: {
      label: 'Falloff Radius',
      type: 'Number',
      step: 0.1,
      defaultValue: 0.1,
      minValue: 0
    },
    falloffCurve: {
      label: 'Falloff Curve',
      type: 'Options',
      display: 'Dropdown',
      labels: ['Sinusoidal', 'Linear'],
      values: [_calculateFalloffWeights.falloffFunctionPresets.sinusoidal, _calculateFalloffWeights.falloffFunctionPresets.linear],
      defaultValue: _calculateFalloffWeights.falloffFunctionPresets.sinusoidal
    }
  },

  update: function update(operator, primitive, _ref) {
    var getWorldTransform = _ref.getWorldTransform,
        node = _ref.node;

    var mesh = primitive.mesh;
    if (!mesh) return primitive;

    var matrix = new _three.Matrix4();

    var indices = (0, _stringIndicesToArray2.default)(operator.vertexIndices);

    // note: matrix-based transforms are expected to have all transforms needed, no centerType applied
    if (operator.matrix && operator.matrix.elements) {
      matrix.fromArray(operator.matrix.elements);
    } else {
      var rotInRads = operator.rotation.clone().multiplyScalar(Math.PI / 180);
      var rotEuler = new _three.Euler().setFromVector3(rotInRads, 'ZYX');
      var rotQuat = new _three.Quaternion().setFromEuler(rotEuler);
      matrix.compose(operator.translation, rotQuat, operator.scale);

      // Take centerType into account
      var centerType = operator.centerType;

      var worldTransform = getWorldTransform(node.id);

      // The mesh is already in local space
      // Thus no additional work is required for 'Pivot'
      if (centerType === 'SelectionCenter') {
        var pivot = (0, _getCentroidByVertices2.default)(mesh, indices);
        var pivotM = new _three.Matrix4().setPosition(pivot);
        var pivotMInverse = new _three.Matrix4().getInverse(pivotM);

        matrix.multiply(pivotMInverse);
        matrix.premultiply(pivotM);
      } else if (centerType === 'WorldCenter') {
        matrix.multiply(worldTransform);
        matrix.premultiply(new _three.Matrix4().getInverse(worldTransform));
      }
    }

    var selection = operator.vertexIndices ? new _polyMesh.Selection(indices, _polyMesh.Selection.Vertices) : null;

    var softSelection = operator.softSelection,
        falloffRadius = operator.falloffRadius,
        falloffCurve = operator.falloffCurve;

    var softSelectionIndices = void 0,
        softSelectionWeights = void 0;

    if (softSelection && falloffRadius > 0) {
      var _getSoftSelection = (0, _getSoftSelection3.default)(mesh, indices, falloffRadius, falloffCurve);

      softSelectionIndices = _getSoftSelection.softSelectionIndices;
      softSelectionWeights = _getSoftSelection.softSelectionWeights;

      selection = selection && new _polyMesh.Selection(softSelectionIndices, _polyMesh.Selection.Vertices);
    }

    primitive.mesh = (0, _transform2.default)(mesh, matrix, selection, null, softSelectionWeights);
  }
};

exports.default = TransformVertices;

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = __webpack_require__(149);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _three = __webpack_require__(0);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _stringIndicesToArray = __webpack_require__(69);

var _stringIndicesToArray2 = _interopRequireDefault(_stringIndicesToArray);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EPSILON = 0.000001;

var UVMapType = {
  Planar: 0,
  Box: 1,
  Cylindrical: 2,
  Spherical: 3
};
var UVAxisType = {
  X: 0,
  Y: 1,
  Z: 2,
  AverageNormals: 4 //to match v1 numbers
};

var UVMap = {
  // Depends on its world transform
  selfTransform: true,

  schema: {
    mWidth: {
      type: 'Number',
      label: 'Width',
      defaultValue: 1,
      step: 0.1,
      minValue: 0.0,
      animatable: true
    },
    mHeight: {
      type: 'Number',
      label: 'Height',
      defaultValue: 1,
      step: 0.1,
      minValue: 0.0,
      animatable: true
    },
    mLength: {
      type: 'Number',
      label: 'Length',
      defaultValue: 1,
      step: 0.1,
      minValue: 0.0,
      animatable: true
    },

    center: {
      label: 'Center',
      type: 'Vec3',
      step: 0.1,
      defaultValue: new _three.Vector3(0, 0, 0),
      animatable: true
    },
    rotation: {
      label: 'Rotation',
      type: 'Vec3',
      step: 1,
      minValue: -360,
      maxValue: 360,
      defaultValue: new _three.Vector3(0, 0, 0),
      animatable: true
    },
    uTile: {
      label: 'U Tile',
      type: 'Number',
      step: 0.1,
      defaultValue: 1.0,
      animatable: true
    },
    vTile: {
      label: 'V Tile',
      type: 'Number',
      step: 0.1,
      defaultValue: 1.0,
      animatable: true
    },

    uvProjectionMode: {
      label: 'Projection',
      type: 'Options',
      display: 'Radio',
      values: [UVMapType.Planar, UVMapType.Box, UVMapType.Cylindrical, UVMapType.Spherical],
      labels: ['Planar', 'Box', 'Cylindrical', 'Spherical'],
      defaultValue: UVMapType.Planar /* FIXME PROPER value*/
    },
    xAxis: {
      label: 'Align Local Axis',
      type: 'Options',
      display: 'Radio',
      values: [UVAxisType.X, UVAxisType.Y, UVAxisType.Z, UVAxisType.AverageNormals],
      labels: ['X', 'Y', 'Z', 'Average Normals'],
      defaultValue: 1
    },
    uvMapChannel: {
      label: 'UV Channel',
      type: 'String',
      defaultValue: 'default'
    },

    autoFit: { label: 'Auto Fit', type: 'Button' },
    autoAlign: { label: 'Auto Align', type: 'Button' }, // Hidden until local manipulators fixed
    autoFitAlign: { label: 'Best Fit', type: 'Button' }, // Hidden until local manipulators fixed
    autoCenter: { label: 'Auto Center', type: 'Button' },
    resetUVs: { label: 'Reset', type: 'Button' },

    worldRelative: {
      label: 'Project in World Space',
      type: 'Boolean',
      defaultValue: false
    },

    // SubObjects
    indices: {
      label: 'Selection',
      type: 'TextArea',
      defaultValue: '',
      display: 'indexStyle'
    }
    //componentType: { type: 'Object', hidden: true, defaultValue: 'Face' },

    // For backward compatibility
    //scale: { label: 'scale', type: 'Vec3', step: 0.1, defaultValue: {x: 0, y: 0, z: 0}, hidden: true },

    //subdivisions: { label: 'Subdivisions', type: 'Number', defaultValue: 1, minValue: 0, maxValue: 4 },
    //hardEdges: { label: 'Hard Edges', type: 'Boolean', defaultValue: false }
  },

  update: function update(operator, primitive, _ref) {
    var getWorldTransform = _ref.getWorldTransform,
        node = _ref.node;

    var mesh = primitive.mesh;
    if (!mesh) return primitive;

    var options = {};

    options.selectedFaces = (0, _stringIndicesToArray2.default)(operator.indices);
    options.uTile = operator.uTile;
    options.vTile = operator.vTile;
    options.uvProjectionMode = operator.uvProjectionMode;
    options.alignmentAxis = operator.xAxis;
    options.center = operator.center;
    options.rotation = operator.rotation;
    options.mapChannel = operator.uvMapChannel;
    options.scale = new _three.Vector3(operator.mWidth, operator.mHeight, operator.mLength);
    options.worldSpace = operator.worldRelative;
    if (options.worldSpace) {
      options.nodeTransform = getWorldTransform(node.id);
    }

    primitive.mesh = applyUVMap(mesh, options);
  }
};

function applyUVMap(polyMesh, uvMapOptions) {
  uvMapOptions = uvMapOptions || {}; // because all values can be defaulted, uvMapOptions should be allowed to be null/undefined too!

  var selectedFaces = uvMapOptions.selectedFaces;
  if (!selectedFaces.length) {
    //if no selected faces, then assume every face is selected
    selectedFaces = [].concat((0, _toConsumableArray3.default)(Array(polyMesh.faceRangeOffsets.length - 1).keys()));
  }

  //in v1, auto align changes the rotation settings and then sets the axis to Z
  //so in v2, we should just use the passed rotation value, until we have an editor
  //autoAlign(uvMapOptions, polyMesh, selectedFaces);
  if (uvMapOptions.alignmentAxis === UVAxisType.AverageNormals) {
    uvMapOptions.alignmentAxis = UVAxisType.Z;
  }

  var rotation = uvMapOptions.rotation ? uvMapOptions.rotation.clone().multiplyScalar(Math.PI / 180) : new _three.Vector3();
  var scale = uvMapOptions.scale || new _three.Vector3(1, 1, 1);
  var center = uvMapOptions.center || new _three.Vector3();
  var uvProjectionMode = uvMapOptions.uvProjectionMode !== undefined ? uvMapOptions.uvProjectionMode : 0;
  var alignmentAxis = uvMapOptions.alignmentAxis !== undefined ? uvMapOptions.alignmentAxis : UVAxisType.Y;
  var mapChannel = uvMapOptions.mapChannel !== undefined ? uvMapOptions.mapChannel : 'default';
  var uTile = uvMapOptions.uTile !== undefined ? uvMapOptions.uTile : 1.0;
  var vTile = uvMapOptions.vTile !== undefined ? uvMapOptions.vTile : 1.0;

  var rotationQuat = new _three.Quaternion().setFromEuler(new _three.Euler().setFromVector3(rotation, 'ZYX'));
  if (uvMapOptions.worldSpace) {
    var invNodeScale = new _three.Vector3();
    var invNodeRotation = new _three.Quaternion();
    var invNodeTranslation = new _three.Vector3();
    var invNodeTransform = new _three.Matrix4().getInverse(uvMapOptions.nodeTransform);
    invNodeTransform.decompose(invNodeTranslation, invNodeRotation, invNodeScale);

    scale.multiply(invNodeScale);
    rotationQuat.premultiply(invNodeRotation);
  }

  // Inverse matrix should be used, so uv map follows the gimzo
  var matrixRotation = new _three.Matrix4().makeRotationFromQuaternion(rotationQuat);
  var matrixRotationInv = new _three.Matrix4().getInverse(matrixRotation);

  var faceRangeOffsets = polyMesh.faceRangeOffsets;
  var faceValueIndices = polyMesh.positions.faceValueIndices;
  var values = polyMesh.positions.values;

  var oldUVPolyMap = _PolyMaps2.default.resolveMap(polyMesh, 'uvMaps.' + mapChannel) || new _PolyMap2.default();
  var uvFaceValueIndices = new Uint32Array(faceValueIndices.length);
  uvFaceValueIndices.set(oldUVPolyMap.faceValueIndices);
  var uvValues = [];

  var vertex1 = new _three.Vector3();
  var vertex2 = new _three.Vector3();
  var faceNormal = new _three.Vector3();
  var newUV = void 0;

  //for every face
  var faceBegin = 0;
  var faceEnd = 0;
  var uvValueCounter = oldUVPolyMap.values.length;
  for (var i = 0; i < selectedFaces.length; i++) {
    faceBegin = faceRangeOffsets[selectedFaces[i]];
    faceEnd = faceRangeOffsets[selectedFaces[i] + 1];

    //compute the face normal
    faceNormal.multiplyScalar(0);
    for (var j = faceBegin; j < faceEnd; j++) {
      var k = 1 + j;
      if (k >= faceEnd) {
        k = faceBegin;
      }

      values.getAt(faceValueIndices[j], vertex1);
      values.getAt(faceValueIndices[k], vertex2);

      faceNormal.x += (vertex1.y - vertex2.y) * (vertex1.z + vertex2.z);
      faceNormal.y += (vertex1.z - vertex2.z) * (vertex1.x + vertex2.x);
      faceNormal.z += (vertex1.x - vertex2.x) * (vertex1.y + vertex2.y);
    }

    faceNormal.normalize();

    //for every index on that face
    for (var _j = faceBegin; _j < faceEnd; _j++) {
      newUV = new _three.Vector2();
      values.getAt(faceValueIndices[_j], vertex1);

      vertex1.sub(center); // Translate to center
      vertex1.applyMatrix4(matrixRotationInv); // Apply Inverse rotation to the vertex (to follow gizmo)

      switch (uvProjectionMode) {
        case UVMapType.Planar:
          //Planar
          planarUVMap(vertex1, alignmentAxis, scale, newUV);
          break;

        case UVMapType.Box:
          //Box
          boxUVMap(vertex1, faceNormal, scale, newUV);
          break;

        case UVMapType.Cylindrical:
          //Cylindrical
          cylindricalUVMap(vertex1, alignmentAxis, scale, newUV);
          break;

        case UVMapType.Spherical:
          //Spherical
          sphericalUVMap(vertex1, alignmentAxis, scale, newUV);
          break;

        default:
          newUV.set(0, 0);
          break;
      }

      // Apply tiling
      if (uTile !== 1.0) {
        newUV.x *= uTile;
      }

      if (vTile !== 1.0) {
        newUV.y *= vTile;
      }

      // Avoid disconnected uv faces
      //TODO check for duplicate uv's on that vertex and don't store it twice;
      uvFaceValueIndices[_j] = uvValueCounter++;
      uvValues.push(newUV);
    }
  }

  var uvValuesObjectArrayView = new _ObjectArrayView2.default(_three.Vector2, oldUVPolyMap.values.length + uvValues.length);

  for (var m = 0; m < uvValuesObjectArrayView.length; ++m) {
    if (m < oldUVPolyMap.values.length) {
      uvValuesObjectArrayView.setAt(m, oldUVPolyMap.values.getAt(m));
    } else {
      uvValuesObjectArrayView.setAt(m, uvValues[m - oldUVPolyMap.values.length]);
    }
  }

  var resultMesh = new _PolyMesh2.default(polyMesh);

  var newUVMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: uvFaceValueIndices,
    values: uvValuesObjectArrayView
  });

  if (uvProjectionMode === UVMapType.Cylindrical || uvProjectionMode === UVMapType.Spherical) {
    cleanSeamUVMap(newUVMap, selectedFaces, uvProjectionMode, uTile, vTile);
  }

  if (!resultMesh.uvMaps) resultMesh.uvMaps = new _ObjectsByName2.default();
  resultMesh.uvMaps.set(mapChannel, newUVMap);

  return resultMesh;
}

/*
 * Fix uv steam issues for Cylindrical and Spherical projections
 */
function cleanSeamUVMap(uvMap, selectedFaces, uvMode, uTile, vTile) {
  var differenceX = void 0;
  var uvThreshold = 0.4 * uTile;
  var firstUvCopied = void 0;
  var nextj = void 0;
  var uv1 = new _three.Vector2();
  var uv2 = new _three.Vector2();
  var faceBegin = void 0;
  var faceEnd = void 0;

  for (var i = 0, il = selectedFaces.length; i < il; i++) {
    faceBegin = uvMap.faceRangeOffsets[selectedFaces[i]];
    faceEnd = uvMap.faceRangeOffsets[selectedFaces[i] + 1];

    firstUvCopied = false;
    for (var j = faceBegin; j < faceEnd; j++) {
      nextj = j + 1 < faceEnd ? j + 1 : faceBegin;

      uvMap.values.getAt(uvMap.faceValueIndices[j], uv1);
      uvMap.values.getAt(uvMap.faceValueIndices[nextj], uv2);

      differenceX = Math.abs(uv1.x - uv2.x);

      var sphereConvergence = uvMode === 3 && (uv1.y < EPSILON || uv1.y > vTile - EPSILON);
      //sudden change in uv.x means we are at seam, as long as we aren't at a convergence point (top/bottom)
      if (differenceX > uvThreshold && !sphereConvergence) {
        if (uv1.x < uv2.x) {
          uv1.x += uTile;
          uvMap.values.setAt(uvMap.faceValueIndices[j], uv1);

          // the first and last uv (nextj) must be duplicated only once in each face
          if (i === 0) {
            firstUvCopied = true;
          }
        } else {
          if (firstUvCopied) {
            continue; // already copied
          }
          uv2.x += uTile;
          uvMap.values.setAt(uvMap.faceValueIndices[nextj], uv2);
        }
      }
    }
  }
}

function boxUVMap(vertex, normal, scale, uv) {
  var s = 0;
  var t = 0;

  var x = vertex.x;
  var y = vertex.y;
  var z = vertex.z;
  // Face normal
  var nx = Math.abs(normal.x);
  var ny = Math.abs(normal.y);
  var nz = Math.abs(normal.z);

  if (nx >= ny && nx >= nz) {
    s = -z / scale.z + 0.5;
    t = y / scale.y + 0.5;
  }

  if (ny >= nx && ny >= nz) {
    s = x / scale.x + 0.5;
    t = -z / scale.z + 0.5;
  }

  if (nz >= nx && nz >= ny) {
    s = x / scale.x + 0.5;
    t = y / scale.y + 0.5;
  }

  // Otherside of box is mirror of the other side
  // However, only making them negative is not a good solution for tiling, so we add them to 1 to be flipped in positive side
  if (normal.x < 0) {
    s = -s + 1;
  }

  if (normal.y < 0) {
    s = -s + 1;
  }

  if (normal.z < 0) {
    s = -s + 1;
  }

  uv.set(s, t);
  return uv;
}

function planarUVMap(vertex, planeAxis, scale, uv) {
  // Note: In case of plane we will not use scale.z
  var u = planeAxis === 0 ? -vertex.z : vertex.x;
  var v = planeAxis === 1 ? -vertex.z : vertex.y;

  u = u / scale.x + 0.5;
  v = v / scale.y + 0.5;

  uv.set(u, v);

  return uv;
}

function cylindricalUVMap(vertex, cylinderAxis, scale, uv) {
  var lon = void 0;
  var t = void 0;

  switch (cylinderAxis) {
    case 0:
      lon = xyz_to_longitude(vertex.z / scale.z, vertex.x / scale.x, -vertex.y / scale.y);
      t = -vertex.x / scale.x + 0.5;
      break;

    case 1:
      lon = xyz_to_longitude(vertex.x / scale.x, vertex.y / scale.y, vertex.z / scale.z);
      t = vertex.y / scale.y + 0.5;
      break;

    case 2:
      lon = xyz_to_longitude(-vertex.x / scale.x, vertex.z / scale.z, -vertex.y / scale.y);
      t = -vertex.z / scale.z + 0.5;
      break;
  }

  // convert it from [0-2PI] to [0-1]
  lon = lon / (Math.PI * 2);
  uv.set(lon, t);

  return uv;
}

function sphericalUVMap(vertex, sphereAxis, scale, uv) {
  var lonlat = void 0;
  var lat = void 0,
      lon = void 0;

  switch (sphereAxis) {
    case 0:
      lonlat = xyz_to_longitudelatitude(vertex.z / scale.z, vertex.x / scale.x, -vertex.y / scale.y);
      break;

    case 1:
      lonlat = xyz_to_longitudelatitude(vertex.x / scale.x, -vertex.y / scale.y, vertex.z / scale.z);
      break;

    case 2:
      lonlat = xyz_to_longitudelatitude(-vertex.x / scale.x, vertex.z / scale.z, -vertex.y / scale.y);
      break;
  }

  // convert longitude from [0, 2PI] to [0,1], and latitude from [-PI, +PI] to [0,1]
  lon = lonlat.lon / (Math.PI * 2);
  lat = 0.5 - lonlat.lat / Math.PI;
  uv.set(lon, lat);

  return uv;
}

// convert XYZ space to longitude
// Returns longitude is in interval [-PI,+PI]
function xyz_to_longitude(x, y, z) {
  var lon = void 0;

  if (Math.abs(x) < EPSILON && Math.abs(z) < EPSILON) {
    lon = 0;
  } else {
    lon = Math.atan2(x, z);

    // longitude is in interval [-PI,+PI], so we add two PI to negative longitudes to be between [0,2PI]
    if (lon < 0) {
      lon += Math.PI * 2;
    }
  }

  return lon;
}

// convert XYZ space to longitude and latitude
// Returns longitude [0, 2PI] and latitude [-PI, +PI]
function xyz_to_longitudelatitude(x, y, z) {
  var lo = void 0,
      la = void 0;

  if (Math.abs(x) < EPSILON && Math.abs(z) < EPSILON) {
    lo = 0;

    if (Math.abs(y) < EPSILON) {
      la = 0;
    } else {
      la = y < 0 ? -Math.PI / 2 : Math.PI / 2;
    }
  } else {
    lo = Math.atan2(x, z);

    // longitude is in interval [-PI,+PI], so we add two PI to negative longitudes to be between [0,2PI]
    if (lo < 0) {
      lo += Math.PI * 2;
    }

    var h = Math.sqrt(x * x + z * z);
    // latitude is in [-PI,+PI]
    la = Math.atan2(y, h);
  }
  return {
    lon: lo,
    lat: la
  };
}

function autoAlign(uvMapOptions, polyMesh, selectedFaces) {
  if (uvMapOptions.alignmentAxis === UVAxisType.AverageNormals) {
    uvMapOptions.alignmentAxis = UVAxisType.Z;
    if (uvMapOptions.rotation) {
      uvMapOptions.rotation.copy(computeAverageNormalsRotation(polyMesh, selectedFaces));
    }
  }
}

/**
 * This function gives a rotation with the positive z-axis aligned with the averaged normals of selected faceIndices.
 */
function computeAverageNormalsRotation(polyMesh, faceIndices) {
  var normalMap = polyMesh.normalMap;
  var faceRangeOffsets = normalMap.faceRangeOffsets;

  var perFaceNormal = new _three.Vector3();
  var avgNormal = new _three.Vector3();
  var numFaces = void 0;
  if (faceIndices.length) {
    numFaces = faceIndices.length;
  } else {
    numFaces = faceRangeOffsets.length - 1;
  }

  var faceBegin = void 0;
  var faceEnd = void 0;
  for (var i = 0; i < numFaces; ++i) {
    if (faceIndices.length) {
      faceBegin = faceRangeOffsets[faceIndices[i]];
      faceEnd = faceRangeOffsets[faceIndices[i] + 1];
    } else {
      faceBegin = faceRangeOffsets[i];
      faceEnd = faceRangeOffsets[i + 1];
    }

    computeNormal(polyMesh, faceBegin, faceEnd, perFaceNormal);

    avgNormal.add(perFaceNormal);
  }

  //if avg normal is zero, use the normal of first selected face
  var firstFaceInd = faceIndices.length ? faceIndices[0] : 0;
  if (avgNormal.lengthSq() < 0.0000001) {
    computeNormal(polyMesh, faceRangeOffsets[firstFaceInd], faceRangeOffsets[firstFaceInd + 1], avgNormal);
  } else {
    avgNormal.normalize();
  }

  var upVector = new _three.Vector3();
  upVector.subVectors(polyMesh.positions.values.getAt(polyMesh.positions.faceValueIndices[faceRangeOffsets[firstFaceInd]]), polyMesh.positions.values.getAt(polyMesh.positions.faceValueIndices[faceRangeOffsets[firstFaceInd] + 1])).normalize();

  var lookMat = new _three.Matrix4().lookAt(avgNormal, new _three.Vector3(0, 0, 0), upVector);
  var eulerRotation = new _three.Euler().setFromRotationMatrix(lookMat, 'ZYX');
  var newRotation = eulerRotation.toVector3().multiplyScalar(180 / Math.PI);
  return newRotation;
}

/**
 * This function can calculate a normal for non-planar or non-convex polygons,
 * in that the normal takes the contribution of all vertices equally.
 * For more information check : Newell's algorithm
 */
function computeNormal(polyMesh, faceBegin, faceEnd, optionalResult) {
  var normal = optionalResult ? optionalResult.set(0, 0, 0) : new _three.Vector3(0, 0, 0);

  if (polyMesh.positions.length < 1) {
    return normal;
  }

  var vertex1 = new _three.Vector3();
  var vertex2 = new _three.Vector3();
  var j = void 0;
  for (var i = faceBegin; i < faceEnd; ++i) {
    j = i + 1;
    if (j === faceEnd) {
      j = faceBegin;
    }
    polyMesh.positions.values.getAt(polyMesh.positions.faceValueIndices[i], vertex1);
    polyMesh.positions.values.getAt(polyMesh.positions.faceValueIndices[j], vertex2);

    normal.x += (vertex1.y - vertex2.y) * (vertex1.z + vertex2.z);
    normal.y += (vertex1.z - vertex2.z) * (vertex1.x + vertex2.x);
    normal.z += (vertex1.x - vertex2.x) * (vertex1.y + vertex2.y);
  }

  return normal.normalize();
}

exports.default = UVMap;

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = __webpack_require__(0);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ScaleMode = {
  Scale: 0,
  Tiling: 1
};

var UVTransform = {
  name: 'UVTransform',
  label: 'UV Transform',

  schema: {
    rotation: {
      label: 'Rotation',
      type: 'Number',
      step: 0.1,
      minValue: -360,
      maxValue: 360,
      defaultValue: 0,
      animatable: true
    },
    scaleMode: {
      label: 'Scale Mode',
      type: 'Options',
      display: 'Dropdown',
      labels: ['Scale', 'Tiling'],
      values: [ScaleMode.Scale, ScaleMode.Tiling],
      defaultValue: ScaleMode.Scale
    },
    tiling: {
      label: 'Tiling',
      type: 'Vec2',
      step: 0.1,
      defaultValue: new _three.Vector2(1, 1),
      animatable: true
    },
    scale: {
      label: 'Scale',
      type: 'Vec2',
      step: 0.1,
      defaultValue: new _three.Vector2(1, 1),
      animatable: true
    },
    translation: {
      label: 'Translation',
      type: 'Vec2',
      step: 0.1,
      defaultValue: new _three.Vector2(0, 0),
      animatable: true
    },
    pivotCenter: {
      label: 'Pivot Center',
      type: 'Vec2',
      step: 0.1,
      defaultValue: new _three.Vector2(0, 0),
      animatable: true
    },

    uvMapChannel: {
      label: 'UV Channel',
      type: 'String',
      defaultValue: 'default'
    }
  },

  update: function update(operator, primitive) {
    var mesh = primitive.mesh;
    if (!mesh) return primitive;

    var mapChannel = operator.uvMapChannel || 'default'; //consider empty channel as default

    var uvMap = mesh.uvMaps ? mesh.uvMaps.byName[mapChannel] : null;
    if (!uvMap) return primitive;

    var uvVec3 = new _three.Vector3();
    var uv = new _three.Vector2();
    var uvValues = new _ObjectArrayView2.default(_three.Vector2, uvMap.values.length);

    var rotation = operator.rotation;
    var scaleMode = operator.scaleMode;
    var scale = operator.scale;
    var tiling = operator.tiling;
    var translation = operator.translation;
    var pivotCenter = operator.pivotCenter;

    var uvTransform = getUVTransform(rotation, tiling, scaleMode === ScaleMode.Scale, scale, translation, pivotCenter);

    for (var i = 0; i < uvMap.values.length; i++) {
      uvMap.values.getAt(i, uv);
      uvVec3.set(uv.x, uv.y, 0);
      uvVec3.applyMatrix4(uvTransform);
      uv.set(uvVec3.x, uvVec3.y);
      uvValues.setAt(i, uv);
    }

    var resultMesh = new _PolyMesh2.default(mesh);

    var newUVMap = new _PolyMap2.default({
      faceRangeOffsets: mesh.faceRangeOffsets,
      faceValueIndices: uvMap.faceValueIndices,
      values: uvValues
    });

    resultMesh.uvMaps.set(mapChannel, newUVMap);

    primitive.mesh = resultMesh;
  }
};

function getUVTransform(rotation, tiling, useScale, scale, translation, pivotCenter) {
  var result = new _three.Matrix4();

  result.multiply(new _three.Matrix4().makeTranslation(pivotCenter.x, pivotCenter.y, 0));
  result.multiply(new _three.Matrix4().makeRotationZ(_three.Math.degToRad(rotation)));
  if (useScale) {
    result.multiply(new _three.Matrix4().makeScale(scale.x, scale.y, 0));
  } else {
    var safeInverse = function safeInverse(v) {
      return v == 0 ? 1 : 1 / v;
    };

    result.multiply(new _three.Matrix4().makeScale(safeInverse(tiling.x), safeInverse(tiling.y), 0));
  }

  result.multiply(new _three.Matrix4().makeTranslation(-pivotCenter.x, -pivotCenter.y, 0));
  result.multiply(new _three.Matrix4().makeTranslation(translation.x, translation.y, 0));

  return result;
}

exports.default = UVTransform;

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Mesh = __webpack_require__(379);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _TransformVertices = __webpack_require__(395);

var _TransformVertices2 = _interopRequireDefault(_TransformVertices);

var _MeshSmooth = __webpack_require__(380);

var _MeshSmooth2 = _interopRequireDefault(_MeshSmooth);

var _UVMap = __webpack_require__(396);

var _UVMap2 = _interopRequireDefault(_UVMap);

var _UVTransform = __webpack_require__(397);

var _UVTransform2 = _interopRequireDefault(_UVTransform);

var _Skin = __webpack_require__(386);

var _Skin2 = _interopRequireDefault(_Skin);

var _Box = __webpack_require__(368);

var _Box2 = _interopRequireDefault(_Box);

var _Sphere = __webpack_require__(390);

var _Sphere2 = _interopRequireDefault(_Sphere);

var _Cone = __webpack_require__(370);

var _Cone2 = _interopRequireDefault(_Cone);

var _Capsule = __webpack_require__(369);

var _Capsule2 = _interopRequireDefault(_Capsule);

var _Cylinder = __webpack_require__(372);

var _Cylinder2 = _interopRequireDefault(_Cylinder);

var _Normals = __webpack_require__(50);

var _Normals2 = _interopRequireDefault(_Normals);

var _Plane = __webpack_require__(381);

var _Plane2 = _interopRequireDefault(_Plane);

var _Torus = __webpack_require__(394);

var _Torus2 = _interopRequireDefault(_Torus);

var _Disk = __webpack_require__(374);

var _Disk2 = _interopRequireDefault(_Disk);

var _ProxyMesh = __webpack_require__(382);

var _ProxyMesh2 = _interopRequireDefault(_ProxyMesh);

var _Instance = __webpack_require__(376);

var _Instance2 = _interopRequireDefault(_Instance);

var _SortFacesByAxis = __webpack_require__(388);

var _SortFacesByAxis2 = _interopRequireDefault(_SortFacesByAxis);

var _BendDeformer = __webpack_require__(365);

var _BendDeformer2 = _interopRequireDefault(_BendDeformer);

var _Slice = __webpack_require__(387);

var _Slice2 = _interopRequireDefault(_Slice);

var _Symmetry = __webpack_require__(392);

var _Symmetry2 = _interopRequireDefault(_Symmetry);

var _BlendShape = __webpack_require__(367);

var _BlendShape2 = _interopRequireDefault(_BlendShape);

var _BlendDeformer = __webpack_require__(366);

var _BlendDeformer2 = _interopRequireDefault(_BlendDeformer);

var _Revolve = __webpack_require__(383);

var _Revolve2 = _interopRequireDefault(_Revolve);

var _Tangents = __webpack_require__(393);

var _Tangents2 = _interopRequireDefault(_Tangents);

var _Stretch = __webpack_require__(391);

var _Stretch2 = _interopRequireDefault(_Stretch);

var _Shear = __webpack_require__(385);

var _Shear2 = _interopRequireDefault(_Shear);

var _Array = __webpack_require__(364);

var _Array2 = _interopRequireDefault(_Array);

var _SegmentRevolve = __webpack_require__(384);

var _SegmentRevolve2 = _interopRequireDefault(_SegmentRevolve);

var _Extrude = __webpack_require__(375);

var _Extrude2 = _interopRequireDefault(_Extrude);

var _Tessellate = __webpack_require__(225);

var _Tessellate2 = _interopRequireDefault(_Tessellate);

var _MaterialIDs = __webpack_require__(378);

var _MaterialIDs2 = _interopRequireDefault(_MaterialIDs);

var _LineText = __webpack_require__(377);

var _LineText2 = _interopRequireDefault(_LineText);

var _Spacing = __webpack_require__(389);

var _Spacing2 = _interopRequireDefault(_Spacing);

var _DeleteComponent = __webpack_require__(373);

var _DeleteComponent2 = _interopRequireDefault(_DeleteComponent);

var _CrossSectionRevolve = __webpack_require__(371);

var _CrossSectionRevolve2 = _interopRequireDefault(_CrossSectionRevolve);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  Mesh: _Mesh2.default,
  MeshSmooth: _MeshSmooth2.default,
  Skin: _Skin2.default,
  TransformVertices: _TransformVertices2.default,
  UVMap: _UVMap2.default,
  UVTransform: _UVTransform2.default,
  Box: _Box2.default,
  Sphere: _Sphere2.default,
  Cone: _Cone2.default,
  Capsule: _Capsule2.default,
  Cylinder: _Cylinder2.default,
  Normals: _Normals2.default,
  Plane: _Plane2.default,
  Torus: _Torus2.default,
  Disk: _Disk2.default,
  ProxyMesh: _ProxyMesh2.default,
  Instance: _Instance2.default,
  SortFacesByAxis: _SortFacesByAxis2.default,
  BlendShape: _BlendShape2.default,
  BlendDeformer: _BlendDeformer2.default,
  Revolve: _Revolve2.default,
  BendDeformer: _BendDeformer2.default,
  Slice: _Slice2.default,
  Symmetry: _Symmetry2.default,
  Tangents: _Tangents2.default,
  Stretch: _Stretch2.default,
  Shear: _Shear2.default,
  Array: _Array2.default,
  SegmentRevolve: _SegmentRevolve2.default,
  Extrude: _Extrude2.default,
  MaterialIDs: _MaterialIDs2.default,
  Tessellate: _Tessellate2.default,
  LineText: _LineText2.default,
  Spacing: _Spacing2.default,
  DeleteComponent: _DeleteComponent2.default,
  CrossSectionRevolve: _CrossSectionRevolve2.default
};

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var CameraProperties = {
  schema: {
    visible: { label: 'Visible', type: 'Boolean', defaultValue: true },
    orbitMode: {
      label: 'Orbit Mode',
      type: 'Options',
      values: ['gyroscope', 'trackball', 'firstPerson'],
      labels: ['Gyropscope', 'Trackball', 'First Person'],
      defaultValue: 'gyroscope'
    },
    orbitTarget: { label: 'Orbit Target', type: 'Node' },
    constraintCameraY: {
      label: 'Constrain Camera to Positive Y',
      type: 'Boolean',
      defaultValue: false
    },

    constrainCameraSphere: {
      label: 'Constrain Camera Within Sphere',
      type: 'Boolean',
      defaultValue: false
    },
    maxZoom: {
      label: 'Maximum Zoom',
      type: 'Number',
      defaultValue: 5.0,
      minValue: 1
    }
  }
};

exports.default = CameraProperties;

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var Default = {
  hierarchyVisible: true,

  schema: {
    visible: {
      label: 'Visible',
      type: 'Boolean',
      defaultValue: true,
      animatable: true
    }
  },

  update: function update(operator, primitive, _ref) {
    var node = _ref.node;

    primitive.visible = node.type === 'Annotation' ? operator.visible : checkHierarchyVisibility(operator.sceneProperties, operator.visible);
    return primitive;
  }
};

function checkHierarchyVisibility(sceneProperties, nodeVisibility) {
  var hierarchyVisibility = sceneProperties && sceneProperties.hierarchyVisibility === 'Enable';
  return !hierarchyVisibility ? true : nodeVisibility;
}

exports.default = Default;

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ImageProperties = {
  schema: {
    prefetch: {
      label: 'Pre-fetch Image',
      type: 'Boolean',
      defaultValue: false
    }
  }
};

exports.default = ImageProperties;

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var MaterialProperties = {
  schema: {
    prefetch: {
      label: 'Pre-fetch Material',
      type: 'Boolean',
      defaultValue: false
    }
  }
};

exports.default = MaterialProperties;

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var MetaData = {
  schema: {
    key: { label: 'Name', type: 'String', defaultValue: '' },
    value: { label: 'Value', type: 'String', defaultValue: '' }
  },
  update: function update(operator, primitive) {
    if (!primitive.metaData) primitive.metaData = {};
    if (operator.key) {
      primitive.metaData[operator.key] = operator.value;
    }
    return primitive;
  }
};

exports.default = MetaData;

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ModelProperties = {
  hierarchyVisible: true,

  schema: {
    visible: {
      label: 'Visible',
      type: 'Boolean',
      defaultValue: true,
      animatable: true
    },
    renderable: { label: 'Renderable', type: 'Boolean', defaultValue: true },
    selectable: { label: 'Selectable', type: 'Boolean', defaultValue: true },
    overrideChildSelection: {
      label: 'Override Child Selection',
      type: 'Boolean',
      defaultValue: true
    },
    configurator: {
      label: 'Configurator',
      type: 'String',
      hidden: true,
      defaultValue: ''
    }
  },

  update: function update(operator, primitive) {
    primitive.visible = checkHierarchyVisibility(operator.sceneProperties, operator.visible);
    return primitive;
  }
};

function checkHierarchyVisibility(sceneProperties, nodeVisibility) {
  var hierarchyVisibility = sceneProperties && sceneProperties.hierarchyVisibility === 'Enable';
  return !hierarchyVisibility ? true : nodeVisibility;
}

exports.default = ModelProperties;

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var PolyMeshProperties = {
  schema: {
    // Note: right now we use double-sided rendering by default in threehub. This property is currently
    // used only to set the appropriate value in the V2 importers for export back to V1
    doubleSided: {
      label: 'Double Sided',
      type: 'Boolean',
      defaultValue: false
    },
    visible: {
      label: 'Visible',
      type: 'Boolean',
      defaultValue: true,
      animatable: true
    },
    prefetch: { label: 'Pre-fetch mesh', type: 'Boolean', defaultValue: false },
    castShadow: { label: 'Cast Shadow', type: 'Boolean', defaultValue: true },
    receiveShadow: {
      label: 'Receive Shadow',
      type: 'Boolean',
      defaultValue: true
    },
    discardable: { label: 'Discardable', type: 'Boolean', defaultValue: false },
    interactive: { label: 'Interactive', type: 'Boolean', defaultValue: false },
    walkableInVR: { label: 'Walkable', type: 'Boolean', defaultValue: false }
  }
};

exports.default = PolyMeshProperties;

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var motionTypes = ['Static', 'Kinematic', 'Dynamic'];
var shapeValues = ['Box', 'Convex', 'Mesh'];
var shapeLabels = ['Bounding Box', 'Convex Hull', 'Mesh (Non-Dynamic)'];

var RigidBodyProperties = {
  schema: {
    collisionShape: {
      label: 'Collision Shape',
      type: 'Options',
      display: 'Dropdown',
      values: shapeValues,
      labels: shapeLabels,
      defaultValue: 'Convex'
    },
    motionType: {
      label: 'Motion Type',
      type: 'Options',
      display: 'Dropdown',
      values: motionTypes,
      labels: motionTypes,
      defaultValue: 'Dynamic'
    },
    mass: {
      label: 'Mass',
      type: 'Number',
      defaultValue: 1.0,
      minValue: 0.0,
      step: 1
    },
    linearDamping: {
      label: 'Linear Damping',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.1
    },
    angularDamping: {
      label: 'Angular Damping',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.1
    },
    //   gravity: { label: 'Local Gravity', type: 'Vec3', step: 1.0, defaultValue: [0, -9.8, 0] },
    linearFactor: {
      label: 'Linear Factor',
      type: 'Vec3',
      defaultValue: [1.0, 1.0, 1.0]
    },
    angularFactor: {
      label: 'Angular Factor',
      type: 'Vec3',
      defaultValue: [1.0, 1.0, 1.0]
    },
    linearVelocity: {
      label: 'Linear Velocity',
      type: 'Vec3',
      defaultValue: [0.0, 0.0, 0.0]
    },
    angularVelocity: {
      label: 'Angular Velocity',
      type: 'Vec3',
      defaultValue: [0.0, 0.0, 0.0]
    },
    linearSleepingThreshold: {
      label: 'Linear Sleep Threshold',
      type: 'Number',
      defaultValue: 0.8,
      minValue: 0.0,
      step: 0.1
    },
    angularSleepingThreshold: {
      label: 'Angular Sleep Threshold',
      type: 'Number',
      defaultValue: 1.0,
      minValue: 0.0,
      step: 0.1
    },
    friction: {
      label: 'Friction',
      type: 'Number',
      defaultValue: 0.5,
      minValue: 0.0,
      step: 0.1
    },
    rollingFriction: {
      label: 'Rolling Friction',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0,
      step: 0.1
    },
    restitution: {
      label: 'Bounce',
      type: 'Number',
      defaultValue: 0.0,
      minValue: 0.0,
      maxValue: 1.0,
      step: 0.1
    }
  }
};

exports.default = RigidBodyProperties;

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var SceneProperties = {
  schema: {
    hierarchyVisibility: {
      label: 'Hierarchical Visibility',
      type: 'Options',
      values: ['Enable', 'Disable'],
      labels: ['Yes', 'No']
    }
  }
};

exports.default = SceneProperties;

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _CameraProperties = __webpack_require__(399);

var _CameraProperties2 = _interopRequireDefault(_CameraProperties);

var _Default = __webpack_require__(400);

var _Default2 = _interopRequireDefault(_Default);

var _ImageProperties = __webpack_require__(401);

var _ImageProperties2 = _interopRequireDefault(_ImageProperties);

var _MaterialProperties = __webpack_require__(402);

var _MaterialProperties2 = _interopRequireDefault(_MaterialProperties);

var _MetaData = __webpack_require__(403);

var _MetaData2 = _interopRequireDefault(_MetaData);

var _ModelProperties = __webpack_require__(404);

var _ModelProperties2 = _interopRequireDefault(_ModelProperties);

var _PolyMeshProperties = __webpack_require__(405);

var _PolyMeshProperties2 = _interopRequireDefault(_PolyMeshProperties);

var _RigidBodyProperties = __webpack_require__(406);

var _RigidBodyProperties2 = _interopRequireDefault(_RigidBodyProperties);

var _SceneProperties = __webpack_require__(407);

var _SceneProperties2 = _interopRequireDefault(_SceneProperties);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  CameraProperties: _CameraProperties2.default,
  Default: _Default2.default,
  ImageProperties: _ImageProperties2.default,
  MaterialProperties: _MaterialProperties2.default,
  MetaData: _MetaData2.default,
  ModelProperties: _ModelProperties2.default,
  PolyMeshProperties: _PolyMeshProperties2.default,
  RigidBodyProperties: _RigidBodyProperties2.default,
  SceneProperties: _SceneProperties2.default
};

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var WebGLRenderer = {
  schema: {
    format: {
      type: 'Options',
      defaultValue: 'jpeg',
      values: ['jpeg', 'png'],
      labels: ['JPEG', 'PNG'],
      label: 'Output Format'
    },
    v2renderer: { type: 'Boolean', defaultValue: false, label: 'v2 renderer' }
  }
};

exports.default = { WebGLRenderer: WebGLRenderer };

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var Timeline = {
  schema: {
    useBufferClips: {
      label: 'Use V2 Clip Format',
      type: 'Boolean',
      defaultValue: false
    }
  }
};

exports.default = { Timeline: Timeline };

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _three = __webpack_require__(0);

var _scene = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getAxis(axisType, flipAxis) {
  if (axisType === 1) {
    return new _three.Vector3(flipAxis ? -1 : 1, 0, 0);
  } else if (axisType === 2) {
    return new _three.Vector3(0, flipAxis ? -1 : 1, 0);
  } else {
    // For Z and unknown axisType
    return new _three.Vector3(0, 0, flipAxis ? -1 : 1);
  }
}

function getQuaternionAxis(axisType, flipAxis) {
  var quat = new _three.Quaternion();

  if (axisType === 1) {
    quat.setFromAxisAngle(new _three.Vector3(0, 1, 0), flipAxis ? -Math.PI / 2 : Math.PI / 2);
  } else if (axisType === 2) {
    quat.setFromAxisAngle(new _three.Vector3(1, 0, 0), flipAxis ? Math.PI / 2 : -Math.PI / 2);
  } else if (axisType === 3) {
    quat.setFromAxisAngle(new _three.Vector3(0, 1, 0), flipAxis ? 0 : Math.PI);
  }

  return quat;
}

var Transform = {
  schema: {
    translation: {
      label: 'Translation',
      type: 'Vec3',
      step: 0.1,
      defaultValue: { x: 0, y: 0, z: 0 },
      animatable: true
    },
    rotation: {
      label: 'Rotation',
      type: 'Vec3',
      step: 1.0,
      defaultValue: { x: 0, y: 0, z: 0 },
      animatable: true
    },
    scale: {
      label: 'Scale',
      type: 'Vec3',
      step: 0.01,
      defaultValue: { x: 1, y: 1, z: 1 },
      animatable: true
    }, // Scale's step must be 0.01 as 1 percent
    shear: {
      label: 'Shear',
      type: 'Vec3',
      step: 0.1,
      defaultValue: { x: 0, y: 0, z: 0 },
      animatable: true
    },
    rotateOrder: {
      label: 'Rotate Order',
      type: 'Options',
      display: 'Dropdown',
      values: ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'],
      defaultValue: 'ZYX'
    },
    preRotation: {
      label: 'Pre-Rotation',
      type: 'Vec3',
      step: 1.0,
      defaultValue: { x: 0, y: 0, z: 0 }
    },
    rotatePivotOffset: {
      label: 'Rotate Pivot Offset',
      type: 'Vec3',
      step: 0.1,
      defaultValue: { x: 0, y: 0, z: 0 }
    },
    scalePivotOffset: {
      label: 'Scale Pivot Offset',
      type: 'Vec3',
      step: 0.1,
      defaultValue: { x: 0, y: 0, z: 0 }
    },
    localRotatePivot: {
      label: 'Local Rotate Pivot',
      type: 'Vec3',
      step: 0.1,
      defaultValue: { x: 0, y: 0, z: 0 }
    },
    localScalePivot: {
      label: 'Local Scale Pivot',
      type: 'Vec3',
      step: 0.1,
      defaultValue: { x: 0, y: 0, z: 0 }
    }
  },

  update: function update(operator, primitive) {
    primitive.transform = (0, _scene.getLocalTransform)(operator);
  }
};

var LookAt = {
  schema: {
    target: { label: 'LookAt Target', type: 'Plug', plug: 'Transform' },
    orientation: {
      label: 'Orientation',
      type: 'Vec3',
      defaultValue: { x: 0, y: 0, z: 0 },
      animatable: true
    },

    lookAtAxis: {
      label: 'Look Axis',
      type: 'Options',
      display: 'Dropdown',
      defaultValue: 'Z',
      labels: ['X', 'Y', 'Z'],
      values: ['X', 'Y', 'Z']
    },
    flipLookAtAxis: {
      label: 'Flip Look Axis',
      type: 'Boolean',
      defaultValue: true
    },

    upAxis: {
      label: 'Up Axis',
      type: 'Options',
      display: 'Dropdown',
      defaultValue: 2,
      labels: ['X', 'Y', 'Z'],
      values: [1, 2, 3]
    },
    flipUpAxis: { label: 'Flip Up Axis', type: 'Boolean', defaultValue: false }
  },

  update: function update(operator, primitive, _ref) {
    var node = _ref.node,
        getCameraWorldTransform = _ref.getCameraWorldTransform,
        getWorldTransform = _ref.getWorldTransform,
        store = _ref.store;

    if (node.type === 'Camera') {
      return (0, _assign2.default)(primitive, operator);
    }

    var useCurrentCamera = operator.target && operator.target.id === (0, _scene.get)(store, { scene: true, plug: 'Player', property: 'camera' });
    if (useCurrentCamera) getWorldTransform(node.id, node.id, 'Transform');
    var targetNodeTransform = useCurrentCamera ? getCameraWorldTransform() : operator.target ? operator.target.transform : null;

    var orientation = operator.orientation;
    var lookAtAxis = operator.lookAtAxis;
    var upAxis = operator.upAxis;
    var flipUpAxis = operator.flipUpAxis;
    var flipLookAtAxis = operator.flipLookAtAxis;
    var lookMatrix = new _three.Matrix4();
    var quaternion = new _three.Quaternion();

    if (targetNodeTransform && primitive.transform) {
      var targetPos = new _three.Vector3().setFromMatrixPosition(targetNodeTransform);
      var eyePos = new _three.Vector3().setFromMatrixPosition(primitive.transform);
      var upDirection = getAxis(upAxis, flipUpAxis);

      lookMatrix.lookAt(eyePos, targetPos, upDirection);
      quaternion.setFromRotationMatrix(lookMatrix);

      quaternion.multiply(getQuaternionAxis(lookAtAxis, flipLookAtAxis));
      quaternion.multiply(new _three.Quaternion().setFromEuler(new _three.Euler().setFromVector3(orientation.clone().multiplyScalar(Math.PI / 180), 'ZYX')));

      // quaternion from world to local space
      var parentTransform = getWorldTransform(node.parent);

      if (parentTransform) {
        var parentInverse = new _three.Matrix4().getInverse(parentTransform);
        var rotMat = new _three.Matrix4().makeRotationFromQuaternion(quaternion);
        var newRotMat = new _three.Matrix4().multiplyMatrices(parentInverse, rotMat);
        quaternion.setFromRotationMatrix(newRotMat);
      }
      // LookAt will not change other local transfrom variables,
      // only overwrites the local quaternion from decomposed matrix
      var oldPosition = new _three.Vector3();
      var oldQuat = new _three.Quaternion();
      var oldScale = new _three.Vector3();
      primitive.transform.decompose(oldPosition, oldQuat, oldScale);
      primitive.transform.compose(oldPosition, quaternion, oldScale);
      //primitive.transform.setTargetNode(targetNode);
    }
  }
};

var BoneTransform = {
  schema: {
    translation: {
      label: 'Translation',
      type: 'Vec3',
      step: 0.1,
      defaultValue: { x: 0, y: 0, z: 0 },
      animatable: true
    },
    rotation: {
      label: 'Rotation',
      type: 'Vec3',
      step: 1.0,
      defaultValue: { x: 0, y: 0, z: 0 },
      animatable: true
    },
    scale: {
      label: 'Scale',
      type: 'Vec3',
      step: 0.1,
      defaultValue: { x: 1, y: 1, z: 1 },
      animatable: true
    },
    rotateOrder: {
      label: 'Rotate Order',
      type: 'Options',
      display: 'Dropdown',
      values: ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'],
      defaultValue: 'ZYX'
    },
    preRotation: {
      label: 'Pre-Rotation',
      type: 'Vec3',
      step: 1.0,
      defaultValue: { x: 0, y: 0, z: 0 }
    }, // hidden: true
    rotateAxis: {
      label: 'Rotate Axis',
      type: 'Vec3',
      step: 1.0,
      defaultValue: { x: 0, y: 0, z: 0 }
    }
  },

  update: function update(operator, primitive, _ref2) {
    var node = _ref2.node;
    var translation = operator.translation,
        rotation = operator.rotation,
        scale = operator.scale,
        rotateOrder = operator.rotateOrder,
        preRotation = operator.preRotation,
        rotateAxis = operator.rotateAxis;

    if (scale.x === 0) scale.x = 0.0000001;
    if (scale.y === 0) scale.y = 0.0000001;
    if (scale.z === 0) scale.z = 0.0000001;

    var translationM = new _three.Matrix4().makeTranslation(translation.x, translation.y, translation.z);
    var rotationRadians = new _three.Vector3().copy(rotation).multiplyScalar(Math.PI / 180);
    var rotationM = new _three.Matrix4().makeRotationFromEuler(new _three.Euler(rotationRadians.x, rotationRadians.y, rotationRadians.z, 'ZYX'));
    var shearM = new _three.Matrix4();
    var scaleM = new _three.Matrix4().makeScale(scale.x, scale.y, scale.z);

    var preRotationRadians = new _three.Vector3().copy(preRotation).multiplyScalar(Math.PI / 180);
    var lPreRotationM = new _three.Matrix4().makeRotationFromEuler(new _three.Euler(preRotationRadians.x, preRotationRadians.y, preRotationRadians.z, 'ZYX'));

    var rotateAxisRadians = new _three.Vector3().copy(rotateAxis).multiplyScalar(Math.PI / 180);
    var lPostRotationM = new _three.Matrix4().makeRotationFromEuler(new _three.Euler(rotateAxisRadians.x, rotateAxisRadians.y, rotateAxisRadians.z, 'ZYX'));

    primitive.transform = new _three.Matrix4().multiply(translationM).multiply(lPreRotationM).multiply(rotationM).multiply(lPostRotationM).multiply(scaleM);
  }
};

exports.default = { Transform: Transform, BoneTransform: BoneTransform, LookAt: LookAt };

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = makeAllOperators;

var _mapObjIndexed = __webpack_require__(106);

var _mapObjIndexed2 = _interopRequireDefault(_mapObjIndexed);

var _schemaTypes = __webpack_require__(207);

var _schemaTypes2 = _interopRequireDefault(_schemaTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function makeAllOperators(hierarchy, _ref) {
  var withNone = _ref.withNone;

  var records = (0, _mapObjIndexed2.default)(function (ops, plug) {
    return (0, _mapObjIndexed2.default)(function (op, name) {
      return makeOperator(plug, op, name);
    }, ops);
  }, hierarchy);
  if (withNone) records.None = { NoOp: makeOperator('None', { schema: {} }, 'NoOp') };
  return records;
}

function makeOperator(plug, op, name) {
  var nonReferenceKeys = [];
  var fileReferenceKeys = [];
  var referenceKeys = [];
  var nodeReferenceKeys = [];
  var nodeReferenceListKeys = [];
  var plugReferences = {};

  var props = (0, _mapObjIndexed2.default)(function (info, key) {
    var prop = _schemaTypes2.default[info.type] ? (0, _assign2.default)({ type: info.type, schema: info }, _schemaTypes2.default[info.type](info)) : { set: function set(v) {
        return v;
      } };

    if (prop.isFileReference) {
      fileReferenceKeys.push(key);
    } else if (prop.isNodeReference) {
      nodeReferenceKeys.push(key);
      referenceKeys.push(key);
    } else if (prop.isPlugReference) {
      plugReferences[key] = prop.isPlugReference;
      referenceKeys.push(key);
    } else if (prop.isReferenceList) {
      nodeReferenceListKeys.push(key);
    } else {
      nonReferenceKeys.push(key);
    }

    return prop;
  }, op.schema);

  var keys = (0, _keys2.default)(props);

  return {
    schema: op.schema,

    keys: keys,
    referenceKeys: referenceKeys,
    fileReferenceKeys: fileReferenceKeys,
    nodeReferenceKeys: nodeReferenceKeys,
    nodeReferenceListKeys: nodeReferenceListKeys,
    plugReferences: plugReferences,
    nonReferenceKeys: nonReferenceKeys,

    // For dependencies on the scene node
    environment: op.environment,
    hierarchyVisible: op.hierarchyVisible,
    selfTransform: op.selfTransform,
    selfProperties: op.selfProperties,

    getProperties: function getProperties() {
      return props;
    },
    typeOf: function typeOf(key) {
      return op.schema[key] && op.schema[key].type;
    },
    set: function set(data, key, val) {
      var newVal = props[key] ? props[key].set(val) : val;
      var isChanged = props[key] && props[key].equals ? !props[key].equals(newVal, data[key]) : newVal !== data[key];
      if (isChanged) data[key] = props[key] && props[key].get ? props[key].get(newVal) : newVal;
      return isChanged;
    },


    /*
    equals(data1, data2) {
      //return (JSON.stringify(data1) === JSON.stringify(data2));
      let isEqual = true;
       for(let key in keys){
        if(data1.hasOwnProperty(key) &&
          ((data1[key].equals && !data1[key].equals(data2)) ||
          (data1[key] !== data2[key]))){
            isEqual = false;
            break;
        }
      }
      return isEqual;
    },
    */

    export: function _export(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options.onlyChanged) {
        // only export changed properties
        return (0, _keys2.default)(data).reduce(function (acc, key) {
          var val = props[key] ? props[key].set() : undefined;
          var isChanged = props[key] && props[key].equals ? !props[key].equals(val, data[key]) : val !== data[key];
          if (isChanged && key !== 'name' && key !== 'type') {
            acc[key] = data[key];
          }
          return acc;
        }, {});
      } else {
        return (0, _assign2.default)({}, data, {
          name: name,
          primitive: plug
        });
      }
    },
    contentExport: function contentExport(data) {
      var result = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(nonReferenceKeys), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          result[key] = data[key];
        }
        // console.log('op export', name, data.name);
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      result.type = name;
      result.name = data.name;
      return result;
    },
    get: function get(data, key) {
      return props[key] && props[key].get ? props[key].get(data[key]) : data[key];
    },
    init: function init(type) {
      var initAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var name = arguments[2];

      var result = { type: type, name: name || type };
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(keys), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;

          result[key] = props[key].set(initAttrs[key]); //props.set(result, key, props[key]);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (initAttrs.active === false) {
        // Default for operators is enabled. Only indicate if it is NON active
        result.active = false;
      }
      //result._v = 1;
      return result;
    },
    update: function update(data, primitive, options) {
      var newPrimitive = op.update ? op.update.call(op, data, primitive, options) : (0, _assign2.default)(primitive, data);
      var result = newPrimitive || primitive;

      if (!result.nodeId) result.nodeId = options.node.id;
      if (!result.id) result.id = options.node.id;
      result._v = options.node._v;
      return result;
    }
  };
}

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _rollbarBrowser = __webpack_require__(692);

var _rollbarBrowser2 = _interopRequireDefault(_rollbarBrowser);

__webpack_require__(664);

__webpack_require__(669);

__webpack_require__(672);

__webpack_require__(673);

__webpack_require__(667);

__webpack_require__(670);

__webpack_require__(668);

__webpack_require__(671);

__webpack_require__(665);

__webpack_require__(666);

__webpack_require__(608);

__webpack_require__(655);

__webpack_require__(674);

__webpack_require__(675);

__webpack_require__(637);

__webpack_require__(638);

__webpack_require__(639);

__webpack_require__(640);

__webpack_require__(643);

__webpack_require__(641);

__webpack_require__(642);

__webpack_require__(644);

__webpack_require__(645);

__webpack_require__(646);

__webpack_require__(647);

__webpack_require__(649);

__webpack_require__(648);

__webpack_require__(636);

__webpack_require__(663);

__webpack_require__(633);

__webpack_require__(634);

__webpack_require__(635);

__webpack_require__(607);

__webpack_require__(660);

__webpack_require__(658);

__webpack_require__(656);

__webpack_require__(661);

__webpack_require__(662);

__webpack_require__(657);

__webpack_require__(659);

__webpack_require__(650);

__webpack_require__(651);

__webpack_require__(652);

__webpack_require__(654);

__webpack_require__(653);

__webpack_require__(605);

__webpack_require__(606);

__webpack_require__(601);

__webpack_require__(604);

__webpack_require__(603);

__webpack_require__(602);

__webpack_require__(203);

__webpack_require__(627);

__webpack_require__(628);

__webpack_require__(630);

__webpack_require__(629);

__webpack_require__(626);

__webpack_require__(632);

__webpack_require__(631);

__webpack_require__(609);

__webpack_require__(610);

__webpack_require__(611);

__webpack_require__(612);

__webpack_require__(613);

__webpack_require__(614);

__webpack_require__(615);

__webpack_require__(616);

__webpack_require__(617);

__webpack_require__(618);

__webpack_require__(620);

__webpack_require__(619);

__webpack_require__(621);

__webpack_require__(622);

__webpack_require__(623);

__webpack_require__(624);

__webpack_require__(625);

__webpack_require__(676);

__webpack_require__(679);

__webpack_require__(677);

__webpack_require__(678);

__webpack_require__(681);

__webpack_require__(680);

__webpack_require__(684);

__webpack_require__(683);

__webpack_require__(682);

__webpack_require__(691);

var _snabbdom = __webpack_require__(310);

var _snabbdom2 = _interopRequireDefault(_snabbdom);

var _h = __webpack_require__(37);

var _h2 = _interopRequireDefault(_h);

var _class = __webpack_require__(306);

var _class2 = _interopRequireDefault(_class);

var _props = __webpack_require__(308);

var _props2 = _interopRequireDefault(_props);

var _attributes = __webpack_require__(305);

var _attributes2 = _interopRequireDefault(_attributes);

var _style = __webpack_require__(309);

var _style2 = _interopRequireDefault(_style);

var _eventlisteners = __webpack_require__(307);

var _eventlisteners2 = _interopRequireDefault(_eventlisteners);

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _api = __webpack_require__(490);

var _api2 = _interopRequireDefault(_api);

var _clientMiddleware = __webpack_require__(255);

var _clientMiddleware2 = _interopRequireDefault(_clientMiddleware);

var _sceneGraph = __webpack_require__(10);

var _index = __webpack_require__(342);

var _index2 = _interopRequireDefault(_index);

var _player = __webpack_require__(337);

var _player2 = _interopRequireDefault(_player);

var _autoRotate = __webpack_require__(331);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// handles styling on elements with support for animations
// for setting properties on DOM elements
var patch = _snabbdom2.default.init([_class2.default, _props2.default, _attributes2.default, _style2.default, _eventlisteners2.default]); // attaches event listeners

// makes it easy to toggle classes


var deps = {
  patch: patch,
  h: _h2.default,
  THREE: THREE
};

// Set the webpack public path dynamically based on where we are loading
// claraplayer from. This will then work in all environments, whether using
// the cdn or not.
var scripts = document.getElementsByTagName('script');
for (var i = 0; i < scripts.length; i++) {
  if (scripts[i].src && scripts[i].src.match(/claraplayer/)) {
    __webpack_require__.p = scripts[i].src.split(/claraplayer/)[0];
  }
}

function initGA() {
  var script = document.createElement('script');
  script.innerText = '(function(i,s,o,g,r,a,m){i[\'GoogleAnalyticsObject\']=r;i[r]=i[r]||function(){\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n  })(window,document,\'script\',\'https://www.google-analytics.com/analytics.js\',\'ga\');\n  ga(\'create\', \'' + "UA-38840155-3" + '\'' + ', \'auto\', \'playerv2\');\n  ga(\'playerv2.require\', \'displayfeatures\');\n  ga(\'playerv2.send\', \'pageview\');\n  ';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(script);
}

/**
 * The main function. This function initializes the player for a given DOM Node.
 *
 * @param {(String|DOMNode)} elOrId - the DOM Node or String id of a DOM Node.
 * @param {Object} options
 * @param {Function} options.callback - an optional initialization function that will be called (with api as argument) before the first render.
 * @returns {API} The clara playera API.
 * @public
 */
function claraplayer(elOrId, opts) {
  initGA();
  var initializationFn = void 0;
  var options = void 0;
  if (typeof opts === 'function') {
    initializationFn = opts;
    options = {};
    console.warn('DEPRECATED: second argument to `claraplayer` should be an options object');
  } else {
    options = opts || {};
    initializationFn = options.callback;
  }

  var Rollbar = "74f3517e176d41cfa5e9c41f446b5531" && _rollbarBrowser2.default.init({
    accessToken: "74f3517e176d41cfa5e9c41f446b5531",
    verbose: false,
    captureUncaught: !options.devMode,
    payload: {
      environment: "vimarket",
      context: 'playerv2'
    }
  });

  var hasWebGL = false || claraplayer.hasWebGL();
  var parentEl = typeof elOrId === 'string' ? document.getElementById(elOrId) : elOrId;
  parentEl.appendChild(document.createElement('div'));
  var rect = parentEl.getBoundingClientRect();
  if (!rect.height) {
    throw new Error('Player element must have a height');
  }

  var el = parentEl.children[0];
  var parentStyle = window.getComputedStyle(parentEl, null);
  var isFlex = parentStyle.display === 'flex';
  var isRelative = parentStyle.position === 'relative';

  var vnode = void 0;
  var api = (0, _index2.default)({
    fetchApi: _api2.default,
    subscribe: function subscribe() {
      // Start evaluating the scene if the translator is not available
      //  -- this could be done on demand, if we don't want three.js to be loaded.
      if (store && !store.getTranslator()) (0, _sceneGraph.getEvalSceneGraph)(store);
      vnode = patch(vnode || el, (0, _player2.default)(store, { isFlex: isFlex, isRelative: isRelative, parentEl: parentEl, hasWebGL: hasWebGL }));
    }
  });
  var store = api._store;

  if (Rollbar) store.useRollbar(Rollbar);
  var windowSize = (rect && rect.width) * rect.height * (window && window.devicePixelRatio);
  store.trackEvent('Display Window', 'Display size', Math.round(windowSize));

  (0, _assign2.default)(api.deps, deps);
  api.version = "2.3.41";

  //api.three = {
  //  scene: translator.scene,
  //  camera: translator.camera,
  //};
  if (initializationFn) initializationFn(api);

  var autoRotateToolObj = (0, _autoRotate.autoRotateTool)(store);
  api.commands.addCommand(autoRotateToolObj, 'autoRotate');

  api.on('loaded', function () {
    // TODO: zoom camera
    autoRotateToolObj.tool.start(1000);
  });

  if (hasWebGL) {
    //require.ensure([], function(require) {
    //const THREE = require('three');
    var threeTranslator = __webpack_require__(244).default;
    store.setTranslator(threeTranslator, store);
    var translator = store.getTranslator();

    var commands = __webpack_require__(470).default;
    (0, _keys2.default)(commands).forEach(function (commandName) {
      var command = commands[commandName];
      api.commands.addCommand(typeof command === 'function' ? command(store, translator) : command, commandName);
    });

    store.dispatch((0, _sceneGraph.touch)());

    //require.ensure([], function(require) {
    var vrMode = __webpack_require__(477).default;
    api.commands.addCommand(vrMode(store, store.getTranslator()), 'vrMode');
    var vrSettings = __webpack_require__(478).default;
    api.commands.addCommand(vrSettings(store, store.getTranslator()), 'vrSettings');
    //  }, 'vr');
    //}, 'three');

    //TODO: add conf controller scene ids across vagrant and production
    /*Object.keys(__VR_ASSETS_SCENE_IDS__).forEach((id)=> {
      api.sceneIO.fetch(__VR_ASSETS_SCENE_IDS__[id]);
    })*/
  }

  return api;
}

claraplayer.deps = deps;

claraplayer.hasWebGL = function () {
  var canvas = document.createElement('canvas');
  return !!canvas.getContext('webgl') || !!canvas.getContext('experimental-webgl');
};

exports.default = claraplayer;

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = GlobalCompaction;

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

var _BitSet = __webpack_require__(155);

var _BitSet2 = _interopRequireDefault(_BitSet);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _IndexMappings = __webpack_require__(124);

var _IndexMappings2 = _interopRequireDefault(_IndexMappings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Construct a compact (injective / scattering) map to globally unique values
 * within an ObjectArrayView and optionally also the (injective / compacting)
 * source-to-target mapping (STTM).
 *
 * For each index in the input data, the STTM contains the index in compacted
 * form. The STTM can be used to transcribe existing indices into the data or,
 * if the data is "unindexed", it is the indices.
 *
 * @constructor
 *
 * @param {!ObjectArrayView} values
 * @param {boolean=} ttsOnly whether to only create the target-to-source map
 */
function GlobalCompaction(values, ttsOnly) {
  var nValues = values.length;

  var tupleOrder = _Arrays2.default.sort(_IndexMappings2.default.identity(nValues), values.newCompareAtIndicesStable());

  var nUnique = 0;
  var sourceToTargetMap = null;

  var compare = values.newCompareAtIndices();

  if (ttsOnly) {
    nUnique = _Arrays2.default.unique(tupleOrder, compare);
  } else {
    // customized UNIQUE algo that builds the STTM on the fly

    sourceToTargetMap = new Uint32Array(nValues);

    var writeIndex = 0;
    var prevUniqueAt = 0;
    var minValueIndex = tupleOrder[0];

    for (var i = 1; i < nValues; ++i) {
      var valueIndex = tupleOrder[i];

      if (compare(valueIndex, minValueIndex) !== 0) {
        for (var j = prevUniqueAt; j !== i; ++j) {
          sourceToTargetMap[tupleOrder[j]] = minValueIndex;
        }prevUniqueAt = i;
        minValueIndex = valueIndex;

        if (++writeIndex !== i) tupleOrder[writeIndex] = valueIndex;
      }
    }

    for (var _j = prevUniqueAt; _j !== nValues; ++_j) {
      sourceToTargetMap[tupleOrder[_j]] = minValueIndex;
    }nUnique = writeIndex + 1;
  }

  // Now that duplicates have been removed, restore the original order by
  // sorting the indices (since we have a finite integer range, we can do
  // so very quickly using a BitSet):

  var targetToSourceMap = new _BitSet2.default(nValues).includeFromArray(tupleOrder, 0, nUnique).toIndexArray(nUnique);

  if (sourceToTargetMap !== null) {
    // The STTM already has all equal indices mapped to the first, but
    // these indices are still in respect to the input, so they need to
    // be translated to refer to compact data:

    var reusableMemory = tupleOrder;

    var sparseCompaction = _IndexMappings2.default.inverse(targetToSourceMap, null, reusableMemory);

    _IndexMappings2.default.apply(sourceToTargetMap, sparseCompaction);
  }

  this.targetToSourceMap = targetToSourceMap;
  this.sourceToTargetMap = sourceToTargetMap;
}

GlobalCompaction.prototype = {
  constructor: GlobalCompaction,

  compactedValues: function compactedValues(data) {
    var map = this.targetToSourceMap;
    var nCompact = map.length;

    var result = new _ObjectArrayView2.default(data.type, nCompact);

    var elementData = data.newRangeArray();

    for (var i = 0; i !== nCompact; ++i) {
      data.rangeToArray(map[i], 1, elementData);
      result.arrayToRange(elementData, i, 1);
    }

    return result;
  },

  indices: function indices(nFaceVertices) {
    return new Uint32Array(this.sourceToTargetMap);
  },

  transcribeIndices: function transcribeIndices(indices) {
    return _IndexMappings2.default.apply(indices, this.sourceToTargetMap);
  }
};

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = MergeSort;
function MergeSort(arrayType, maxRangeLength) {
  this.ping = new arrayType(maxRangeLength);
  this.pong = new arrayType(maxRangeLength);
}

MergeSort.apply = function (array) {
  var sorter = new MergeSort(array.constructor, array.length);
  sorter.sortRange(array, 0, array.length);
};

MergeSort.prototype = {
  constructor: MergeSort,

  sortRange: function sortRange(array, begin, until) {
    var length = until - begin;

    if (length <= 4) {
      // this implementation requires at least three elements and also
      // has a high base cost when it comes to very short ranges

      if (length >= 2) this._handleShortRange(array, begin, length);
      return;
    }

    var read = array;
    var readBegin = begin;
    var readUntil = until;

    var write = this.ping;
    var writeOffset = 0;

    var blockSize = 1;
    var blockPairSize = 2;

    for (var run = true; run;) {
      var nMerges = (length + blockSize - 1) / blockSize >> 1,
          l = readBegin,
          endR = readBegin + blockPairSize;

      for (var last = 0; last <= 1; ++last) {
        for (var i = 1; i !== nMerges; ++i, l += blockSize, endR += blockPairSize) {
          var r = l + blockSize,
              endL = r,
              valL = read[l],
              valR = read[r];

          for (var merge = true; merge;) {
            if (valR < valL) {
              write[writeOffset++] = valR;

              if (++r === endR) {
                write[writeOffset++] = valL;
                while (++l !== endL) {
                  write[writeOffset++] = read[l];
                }merge = false;
              } else valR = read[r];
            } else {
              write[writeOffset++] = valL;

              if (++l === endL) {
                write[writeOffset++] = valR;
                while (++r !== endR) {
                  write[writeOffset++] = read[r];
                }merge = false;
              } else valL = read[l];
            }
          }
        }

        // Handle edge cases before the last pass:

        if (last === 0) {
          nMerges = 2; // one more merge (1-based, exclusive)

          if (endR > readUntil) endR = readUntil;else if (endR !== readUntil) {
            var writeOffsetTemp = writeOffset + blockPairSize;

            for (var j = endR; j !== readUntil; ++j) {
              write[writeOffsetTemp++] = read[j];
            }
          }
        }
      }

      if (write !== array) {
        // not done yet? prepare next level

        blockSize = blockPairSize;
        blockPairSize <<= 1;

        read = write;
        readBegin = 0;
        readUntil = length;

        if (blockPairSize < length) {
          // at least two more levels? destination is temporary

          var ping = this.ping;
          write = write === ping ? this.pong : ping;
          writeOffset = 0;
        } else {
          // next will be the last level -> write back to source

          write = array;
          writeOffset = begin;
        }
      } else run = false;
    }
  },

  _handleShortRange: function _handleShortRange(array, begin, length) {
    var valA = array[begin];
    var valB = array[begin + 1];

    switch (length) {
      case 2:
        if (valB < valA) {
          array[begin] = valB;
          array[begin + 1] = valA;
        }

        break;

      case 3:
        {
          var valC = array[begin + 2];

          if (valB < valA) {
            var tmp = valA;
            valA = valB;
            valB = tmp;
          }

          if (valC < valB) {
            var _tmp = valB;
            valB = valC;
            valC = _tmp;
          }

          if (valB < valA) {
            var _tmp2 = valA;
            valA = valB;
            valB = _tmp2;
          }

          array[begin] = valA;
          array[begin + 1] = valB;
          array[begin + 2] = valC;

          break;
        }

      case 4:
        {
          var _valC = array[begin + 2];
          var valD = array[begin + 3];

          if (valB < valA) {
            var _tmp3 = valA;
            valA = valB;
            valB = _tmp3;
          }

          if (valD < _valC) {
            var _tmp4 = _valC;
            _valC = valD;
            valD = _tmp4;
          }

          if (_valC < valA) {
            var _tmp5 = valA;
            valA = _valC;
            _valC = _tmp5;
          }

          if (valD < valB) {
            var _tmp6 = valB;
            valB = valD;
            valD = _tmp6;
          }

          if (_valC < valB) {
            var _tmp7 = valB;
            valB = _valC;
            _valC = _tmp7;
          }

          array[begin] = valA;
          array[begin + 1] = valB;
          array[begin + 2] = _valC;
          array[begin + 3] = valD;
        }
    }
  }
};

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(147);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(148);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Inspired by: https://github.com/dtudury/discontinuous-range/blob/master/index.js
 */

/**
  * Represents a single number range bound by a start and end value (which may be the same)
  */
var Range = function () {
  function Range(a, b) {
    (0, _classCallCheck3.default)(this, Range);

    this.start = a;
    this.end = b;
  }

  (0, _createClass3.default)(Range, [{
    key: "intersects",
    value: function intersects(range) {
      return range && this.start <= range.end && this.end >= range.start;
    }
  }, {
    key: "merge",
    value: function merge(range) {
      this.start = Math.min(this.start, range.start);
      this.end = Math.max(this.end, range.end);
    }
  }, {
    key: "compare",
    value: function compare(val) {
      if (this.start > val) return 1;else if (this.end < val) return -1;
      return 0;
    }
  }]);
  return Range;
}();

/**
 * Represents a collection of sorted, non-contiguous number ranges.
 * Ex. 3-5, 7, 10-30, etc
 */


var RangeSet = function () {
  function RangeSet() {
    (0, _classCallCheck3.default)(this, RangeSet);

    this.ranges = [];

    /**
     * Helper method using binary array to find where
     * @param {*} array
     * @param {*} value
     */
    this.sortedIndex = function (array, value) {
      var low = 0;
      var high = array.length;

      while (low < high) {
        var mid = low + high >>> 1;
        if (array[mid].compare(value) < 0) low = mid + 1;else high = mid;
      }
      return low;
    };
  }

  (0, _createClass3.default)(RangeSet, [{
    key: "add",
    value: function add(a, b) {
      if (!b) b = a; // represent single element as range from/to itself
      if (a > b) {
        console.error("Attempting to add invalid range (" + a + "," + b + ")");
        return;
      }
      var subRange = new Range(a, b);

      if (!this.ranges.length) {
        this.ranges.push(subRange);
        return;
      }

      // find indices of existing ranges which the incoming range intersects
      var startIdx = this.sortedIndex(this.ranges, a);
      var endIdx = this.sortedIndex(this.ranges, b);
      if (endIdx < this.ranges.length && b >= this.ranges[endIdx].start) endIdx += 1;

      // if startIdx === endIdx, no overlap with existing ranges, insert new range at that index
      if (startIdx === endIdx) this.ranges.splice(startIdx, 0, subRange);else {
        // incoming range covers one or more existing subranges, so merge them
        var mergedRange = subRange;
        for (var i = startIdx; i < endIdx; i++) {
          mergedRange.merge(this.ranges[i]);
        }
        this.ranges.splice(startIdx, endIdx - startIdx, mergedRange);
      }
    }

    /**
     * Return array with expanded range values.
     * Ex. [(3,5), (8,10)] --> [3, 4, 5, 8, 9, 10]
     */

  }, {
    key: "expanded",
    value: function expanded() {
      var expandedArray = [];
      var count = void 0;
      var range = void 0;
      var block = void 0;
      // concat expansions of each subrange together for the final result
      for (var i = 0; i < this.ranges.length; i++) {
        range = this.ranges[i];
        count = range.end - range.start + 1;
        block = new Array(count);
        for (var j = 0; j < count; ++j) {
          block[j] = range.start + j;
        }
        expandedArray = expandedArray.concat(block);
      }

      return expandedArray;
    }
  }]);
  return RangeSet;
}();

exports.default = RangeSet;

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


[Uint32Array, Int32Array, Uint8Array, Int8Array].forEach(function (cls) {
  if (!cls.prototype.fill) {
    Object.defineProperty(cls.prototype, 'fill', {
      value: function value(_value, start, end) {
        start = start || 0;
        end = end || this.length;
        for (var i = start; i < end; i++) {
          this[i] = _value;
        }

        return this;
      }
    });
  }

  if (!cls.prototype.slice) {
    Object.defineProperty(cls.prototype, 'slice', {
      value: function value(start, end) {
        var i = start === undefined ? 0 : start;
        var finalIdx = end === undefined ? this.length : end;
        var count = finalIdx - i;
        var a = new this.constructor(count);
        var n = 0;
        while (i < finalIdx) {
          a[n] = this[i];
          ++n;
          ++i;
        }

        return a;
      }
    });
  }

  if (!cls.prototype.sort) {
    // https://github.com/inexorabletash/polyfill/blob/master/es6.js
    Object.defineProperty(cls.prototype, 'sort', {
      value: function sort(comparefn) {
        function sortCompare(x, y) {
          // console.assert(Type(x) === 'number' && Type(y) === 'number');
          if (x !== x && y !== y) return +0;
          if (x !== x) return 1;
          if (y !== y) return -1;
          if (comparefn !== undefined) {
            return comparefn(x, y);
          }
          if (x < y) return -1;
          if (x > y) return 1;
          return +0;
        }
        return Array.prototype.sort.call(this, sortCompare);
      }
    });
  }

  if (!cls.from) {
    (function () {
      cls.from = function (obj, func, thisObj) {
        var typedArrayClass = cls.prototype;

        if (this.prototype !== typedArrayClass) {
          throw new TypeError('this is not a typed array.');
        }

        func = func || function (elem) {
          return elem;
        };

        if (typeof func !== 'function') {
          throw new TypeError('specified argument is not a function');
        }

        obj = Object(obj);
        if (!obj['length']) {
          return new this(0);
        }
        var copy_data = [];
        for (var i = 0; i < obj.length; i++) {
          copy_data.push(obj[i]);
        }

        copy_data = copy_data.map(func, thisObj);

        var typed_array = new this(copy_data.length);
        for (var i = 0; i < typed_array.length; i++) {
          typed_array[i] = copy_data[i];
        }
        return typed_array;
      };
    })();
  }
});

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

var _GlobalCompaction = __webpack_require__(414);

var _GlobalCompaction2 = _interopRequireDefault(_GlobalCompaction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ImportConversions = {
  collapsePositions: function collapsePositions(positions, indices) {
    var compaction = new _GlobalCompaction2.default(positions),
        compactPositions = compaction.compactedValues(positions);

    if (indices) compaction.transcribeIndices(indices);

    return compactPositions;
  },

  collapseMapVertexValues: function collapseMapVertexValues(polyMesh, polyMap) {
    var positions = polyMesh.positions.updateInverseIndex(),
        indexRanges = polyMesh.faceRangeOffsets,
        positionIndices = positions.faceValueIndices,
        faceRangeOffsets = positions.faceRangeOffsets,
        currFaceIndex = -1,
        nextFaceStart = 0,
        faceIndexOffsets = positions.valueFaceIndexOffsets,
        faceIndices = positions.valueFaceIndices,
        values = polyMap.values,
        data = values.data,
        elementSize = values.elementSize,
        valueIndices = polyMap.faceValueIndices;

    for (var i = 0, n = polyMesh.getNumFaceVertices(); i !== n; ++i) {
      var positionIndex = positionIndices[i],
          currValueIndex = valueIndices[i],
          currValueOffset = currValueIndex * elementSize;

      if (i === nextFaceStart) nextFaceStart = faceRangeOffsets[++currFaceIndex + 1];

      var facesStart = faceIndexOffsets[positionIndex],
          facesUntil = faceIndexOffsets[positionIndex + 1];

      for (var j = facesStart; j !== facesUntil; ++j) {
        var faceIndex = faceIndices[j];
        if (faceIndex === currFaceIndex) break;

        var valueIndexOffset = positions.findValueIndexOffset(faceIndex, positionIndex),
            valueIndex = valueIndices[valueIndexOffset];

        if (valueIndex !== currValueIndex) {
          if (_Arrays2.default.rangeEquals(data, currValueOffset, data, valueIndex * elementSize, elementSize)) valueIndices[i] = valueIndex;
        }
      }
    }
  }
};

exports.default = ImportConversions;

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RenderIndexing;

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FOUND_CORRUPTION = false;

function RenderIndexing(polyMesh, optionalMapIdWhitelist) {
  var mapIds = [],
      mapStates = [];

  for (var iter = new _PolyMaps2.default.Iterator(polyMesh); iter.next();) {
    var map = iter.element,
        mapId = iter.getId();

    if (optionalMapIdWhitelist && optionalMapIdWhitelist.indexOf(mapId) === -1) continue;

    mapIds.push(mapId);
    mapStates.push({
      map: map,
      faceIndices: map.updateInverseIndex().valueFaceIndices,
      facesOffset: 0
    });
  }

  // Processing face vertices, an n-way MERGE-like step is performed to
  // identify a previously processed face that uses the same combination
  // of value indices. Forward processing and the sorted nature of the
  // inverse PolyMap indices allow this algorithm to be very efficient.

  var nFaceVertices = polyMesh.getNumFaceVertices(),
      nMaps = mapStates.length,
      renderIndices = new Uint32Array(nFaceVertices),
      valueIndices = new Uint32Array(nFaceVertices * nMaps),
      writeOffset = 0,
      nVertices = 0,
      faceRangeOffsets = polyMesh.faceRangeOffsets,
      faceIndex = -1,
      nextFaceStart = 0,
      pivotState = mapStates[nMaps - 1],
      pivotFaces = pivotState.faceIndices,
      mapScanStart = nMaps - 2;

  for (var i = 0; i !== nFaceVertices; ++i) {
    if (i === nextFaceStart) nextFaceStart = faceRangeOffsets[++faceIndex + 1];

    // Try to find a face before this one that already uses all the
    // values for this vertex:

    var reusePossible = true,
        reuseFromFace = 0;

    for (var j = 0; j !== nMaps; ++j) {
      var mapState = mapStates[j],
          map = mapState.map,
          valueIndex = map.faceValueIndices[i];
      // Speculatively write data:
      valueIndices[writeOffset + j] = valueIndex;

      if (reusePossible) {
        var facesBegin = map.valueFaceIndexOffsets[valueIndex];
        if (facesBegin === undefined) {
          if (!FOUND_CORRUPTION) {
            console.warn('GOT INVALID INDICES, using default index of zero to avoid errors, but this may lead to bad looking meshes');
            FOUND_CORRUPTION = true;
          }
          facesBegin = 0;
        }
        var firstFaceIndex = map.valueFaceIndices[facesBegin];

        // Speculatively prepare the scanning state:
        mapState.facesOffset = facesBegin;

        // Early-out when a value index is used for the first time:
        reusePossible = firstFaceIndex !== faceIndex;
      }
    }
    if (reusePossible) {
      var pivotFaceIdxPos = pivotState.facesOffset,
          pivotFaceIndex = 0,
          pivotFaceGood = true;

      do {
        pivotFaceIndex = pivotFaces[pivotFaceIdxPos++];
        pivotFaceGood = pivotFaceIndex !== faceIndex;
        reusePossible = pivotFaceGood;

        for (var j = mapScanStart; pivotFaceGood && j !== -1; --j) {
          var mapState = mapStates[j],
              faceIdxPos = mapState.facesOffset,
              faceIndices = mapState.faceIndices,
              candidate = faceIndices[faceIdxPos];

          while (candidate < pivotFaceIndex) {
            candidate = faceIndices[++faceIdxPos];
          }if (candidate !== pivotFaceIndex) pivotFaceGood = false;
          if (candidate === faceIndex) reusePossible = false;else mapState.facesOffset = faceIdxPos;

          // Note that the next pivot face will have a higher index
          // and that we'll see the current face when out of input.
          // Also note that the pivot face has a lower index than
          // the current face.
        }
      } while (pivotFaceIdxPos < pivotFaces.length && reusePossible && !pivotFaceGood);

      reusePossible = pivotFaceGood;
      reuseFromFace = pivotFaceIndex;
    }

    if (reusePossible) {
      var positionMap = mapStates[0].map,
          faceVertexIndex = positionMap.findValueIndexOffset(reuseFromFace, positionMap.faceValueIndices[i]),
          reuseIndex = renderIndices[faceVertexIndex];

      renderIndices[i] = reuseIndex;
    } else {
      renderIndices[i] = nVertices++;
      writeOffset += nMaps;
    }
  }

  this.mesh = polyMesh;
  this.mapIds = mapIds;
  this.renderIndices = renderIndices;
  this.valueIndices = valueIndices.slice(0, writeOffset);
  this.numVertices = nVertices;
}

RenderIndexing.prototype = {
  constructor: RenderIndexing,

  getMapValues: function getMapValues(mapId, targetView) {
    var mapIds = this.mapIds,
        mapIndex = mapIds.indexOf(mapId),
        nVertices = this.numVertices,
        valueIndices = this.valueIndices;

    if (mapIndex === -1) throw Error("Map with id '" + mapId + "' not found!");

    var map = _PolyMaps2.default.resolveMap(this.mesh, mapId),
        mapValues = map.values;

    if (targetView.length < nVertices) throw Error("Data won't fit!");

    var viOffset = mapIndex,
        viStride = mapIds.length,
        tmp = new targetView.type();

    for (var i = 0; i !== nVertices; ++i) {
      var valueIndex = valueIndices[viOffset + i * viStride];
      targetView.setAt(i, mapValues.getAt(valueIndex, tmp));
    }
  }
};

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SimpleFanTriangulation;

var _three = __webpack_require__(0);

function SimpleFanTriangulation(mesh) {
  this.mesh = mesh;
  this.groups = null;
  var nTriangles = 0,
      faceOffsets = mesh.faceRangeOffsets,
      faceBegin = faceOffsets[0],
      maxNumVerticesPerFace = 0;

  for (var i = 1, n = faceOffsets.length; i < n; ++i) {
    var faceUntil = faceOffsets[i],
        nVertices = faceUntil - faceBegin;

    if (nVertices >= 3) nTriangles += nVertices - 2;

    maxNumVerticesPerFace = Math.max(maxNumVerticesPerFace, nVertices);

    faceBegin = faceUntil;
  }

  this.startFaceIndices = this.getStartFaceIndices(mesh.positions, maxNumVerticesPerFace);
  //console.log( 'this.startFaceIndices', this.startFaceIndices );

  this.numTriangles = nTriangles;
}

SimpleFanTriangulation.prototype = {
  constructor: SimpleFanTriangulation,

  getStartFaceIndices: function getStartFaceIndices(positionsPolyMap, maxNumVerticesPerFace) {
    //return an array of size faces, that says which face vertex index to use as the starting vertex in simple fan triangulation.
    // you will want return the first convex vertex face vertex index (in the range 0 to number of vertices in that face), if there is one
    // otherwise you can return 0.

    var faceOffsets = this.mesh.faceRangeOffsets;

    var numFaces = this.mesh.faceRangeOffsets.length - 1;
    var startFaceIndices = new Uint32Array(numFaces);
    var faceEdgeSign = new Float32Array(maxNumVerticesPerFace);

    var faceValueIndices = positionsPolyMap.faceValueIndices;
    var positionValues = positionsPolyMap.values;

    var dPrev = new _three.Vector3();
    var d = new _three.Vector3();
    var dNext = new _three.Vector3();
    var dTemp;

    var pPrev = new _three.Vector3();
    var p = new _three.Vector3();
    var pNext = new _three.Vector3();
    var pNextNext = new _three.Vector3();
    var pTemp;

    var cpTemp;
    var cp = new _three.Vector3();
    var cpNext = new _three.Vector3();

    for (var i = 0, il = faceOffsets.length - 1; i < il; ++i) {
      var faceBegin = faceOffsets[i];
      var faceUntil = faceOffsets[i + 1];
      var numFaceVertices = faceUntil - faceBegin;

      if (numFaceVertices <= 3) {
        continue;
      }

      var vPrev;
      var v = faceValueIndices[faceBegin + (numFaceVertices - 1)];
      var vNext = faceValueIndices[faceBegin];
      var vNextNext = faceValueIndices[faceBegin + 1 % numFaceVertices];

      positionValues.getAt(v, p);
      positionValues.getAt(vNext, pNext);
      positionValues.getAt(vNextNext, pNextNext);

      d.copy(pNext).sub(p);
      dNext.copy(pNextNext).sub(pNext);

      cpNext.copy(dNext).cross(d);

      for (var j = 0; j < numFaceVertices; ++j) {
        vPrev = v;
        v = vNext;
        vNext = vNextNext;
        vNextNext = faceValueIndices[faceBegin + (j + 2) % numFaceVertices];

        pTemp = pPrev;
        pPrev = p;
        p = pNext;
        pNext = pNextNext;
        pNextNext = pTemp;
        positionValues.getAt(vNextNext, pNextNext);

        dTemp = dPrev;
        dPrev = d;
        d = dNext;
        dNext = dTemp;
        dNext.copy(pNextNext).sub(pNext);

        cpTemp = cp;
        cp = cpNext;
        cpNext = cpTemp;
        cpNext.copy(dNext).cross(d);

        var sign = cp.dot(cpNext);

        faceEdgeSign[j] = sign;
      }

      //console.log( 'faceEdgeSign for face: ', i, faceEdgeSign );

      for (var j = 0; j < numFaceVertices; ++j) {
        var sign = faceEdgeSign[j];
        var signNext = faceEdgeSign[(j + 1) % numFaceVertices];
        if (sign >= 0 && signNext >= 0) {
          startFaceIndices[i] = (j + 1) % numFaceVertices;
          break;
        }
      }
    }

    return startFaceIndices;
  },

  translateIndices: function translateIndices(inputArray, outputView) {
    var MAX_MATERIAL_IDS = 30;

    var faceOffsets = this.mesh.faceRangeOffsets,
        outputArray = outputView.data,
        writeIndex = outputView.offset,
        stride = outputView.stride;

    var materialIds = null;
    var polygonOrder = null;
    var groupMin = null;
    var groupMax = null;

    // if multi-materials, sort polygons in material order and create material groups
    if (this.mesh.materialIds) {
      materialIds = this.mesh.materialIds;

      var numPolygons = faceOffsets.length - 1;
      var polygonOrder = new Uint32Array(numPolygons);
      for (var i = 0; i < polygonOrder.length; i++) {
        polygonOrder[i] = i;
      }

      polygonOrder.sort(function (a, b) {
        return materialIds[a] - materialIds[b];
      });
      //----FOR VRAY MATERIAL, which only has 0 and 4294967295:
      /*
      var originalToCompactMaterialIds = {};
      var nextCompactMaterialId = 0;
      var compactMaterialIds = new Uint32Array( numPolygons );
      for(var i = 0; i < materialIds.length; i++) {
        var originalMaterialId = materialIds[i];
        if( originalToCompactMaterialIds[originalMaterialId] === undefined ) {
          originalToCompactMaterialIds[originalMaterialId] = nextCompactMaterialId ++;
        }
        compactMaterialIds[i] = originalToCompactMaterialIds[originalMaterialId];
      }*/

      //-------------------------------------------------------------------------------
      var numMaterials = Math.min(materialIds[polygonOrder[numPolygons - 1]] + 1, MAX_MATERIAL_IDS);

      groupMin = new Uint32Array(numMaterials);
      for (var i = 0; i < numMaterials; i++) {
        groupMin[i] = outputArray.length;
      }
      groupMax = new Uint32Array(numMaterials);
    }

    for (var i = 0; i < this.startFaceIndices.length; ++i) {
      var polygonIndex = i;
      if (polygonOrder) {
        polygonIndex = polygonOrder[i];
      }

      var startOffset = this.startFaceIndices[polygonIndex];
      var startIndex = faceOffsets[polygonIndex];
      var endIndex = faceOffsets[polygonIndex + 1];
      var polygonLength = endIndex - startIndex;

      for (var j = 0; j < polygonLength - 2; ++j) {
        if (materialIds) {
          var materialId = Math.min(materialIds[polygonIndex], MAX_MATERIAL_IDS - 1);
          groupMin[materialId] = Math.min(groupMin[materialId], writeIndex);
          groupMax[materialId] = Math.max(groupMax[materialId], writeIndex + stride * 2);
        }

        outputArray[writeIndex] = inputArray[startIndex + startOffset];
        writeIndex += stride;

        outputArray[writeIndex] = inputArray[startIndex + (startOffset + j + 1) % polygonLength];
        writeIndex += stride;

        outputArray[writeIndex] = inputArray[startIndex + (startOffset + j + 2) % polygonLength];
        writeIndex += stride;
      }
    }

    if (materialIds) {
      // convert max to length in place
      for (var i = 0; i < groupMax.length; i++) {
        groupMax[i] = groupMax[i] - groupMin[i] + 1;
      }
      this.groups = {
        groupStarts: groupMin,
        groupCounts: groupMax
      };
    }
  },

  translateMaterialIds: function translateMaterialIds(outputView) {
    var faceOffsets = this.mesh.faceRangeOffsets,
        inputArray = this.mesh.materialIds,
        faceBegin = faceOffsets[0];

    for (var i = 1, j = 0, n = faceOffsets.length; i < n; ++i) {
      var materialId = inputArray[i - 1],
          faceUntil = faceOffsets[i],
          nVertices = faceUntil - faceBegin,
          nTriangles = nVertices >= 3 ? nVertices - 2 : 0;

      for (var writeUntil = writeIndex + nTriangles * stride; writeIndex !== writeUntil; writeIndex += stride) {
        outputArray[writeIndex] = materialId;
      }faceBegin = faceUntil;
    }
  },

  translateToUnindexedValues: function translateToUnindexedValues(inputView, outputView, indices) {
    var faceOffsets = this.mesh.faceRangeOffsets,
        writeIndex = 0,
        temp = inputView.newRangeArray(1);

    var materialIds = null;
    var polygonOrder = null;
    var groupMin = null;
    var groupMax = null;

    // if multi-materials, sort polygons in material order and create material groups
    if (this.mesh.materialIds) {
      materialIds = this.mesh.materialIds;

      var numPolygons = faceOffsets.length - 1;
      var polygonOrder = new Uint32Array(numPolygons);
      for (var i = 0; i < polygonOrder.length; i++) {
        polygonOrder[i] = i;
      }

      polygonOrder.sort(function (a, b) {
        return materialIds[a] - materialIds[b];
      });

      var numMaterials = materialIds[polygonOrder[numPolygons - 1]] + 1;

      groupMin = new Uint32Array(numMaterials);
      for (var i = 0; i < numMaterials; i++) {
        groupMin[i] = outputView.length;
      }
      groupMax = new Uint32Array(numMaterials);
    }

    for (var i = 0; i < this.startFaceIndices.length; ++i) {
      var polygonIndex = i;
      if (polygonOrder) {
        polygonIndex = polygonOrder[i];
      }

      var startOffset = this.startFaceIndices[polygonIndex];
      var startIndex = faceOffsets[polygonIndex];
      var endIndex = faceOffsets[polygonIndex + 1];
      var polygonLength = endIndex - startIndex;

      for (var j = 0; j < polygonLength - 2; ++j) {
        if (materialIds) {
          var materialId = materialIds[polygonIndex];
          groupMin[materialId] = Math.min(groupMin[materialId], writeIndex);
          groupMax[materialId] = Math.max(groupMax[materialId], writeIndex + 2);
        }

        outputView.arrayToRange(inputView.rangeToArray(indices[startIndex + startOffset], 1, temp), writeIndex, 1);

        outputView.arrayToRange(inputView.rangeToArray(indices[startIndex + (startOffset + j + 1) % polygonLength], 1, temp), writeIndex + 1, 1);

        outputView.arrayToRange(inputView.rangeToArray(indices[startIndex + (startOffset + j + 2) % polygonLength], 1, temp), writeIndex + 2, 1);

        writeIndex += 3;
      }
    }

    if (materialIds) {
      // convert max to length in place
      for (var i = 0; i < groupMax.length; i++) {
        groupMax[i] = groupMax[i] - groupMin[i] + 1;
      }
      this.groups = {
        groupStarts: groupMin,
        groupCounts: groupMax
      };
    }
  }
};

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Skinning;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Skinning(from) {
  this.positionSkinRange = from.positionSkinRange; //Uint32Array
  this.skinWeights = from.skinWeights; //Float32Array
  this.skinBoneIndices = from.skinBoneIndices; //Uint16Array

  this.poseSkinToPoseBoneTransform = from.poseSkinToPoseBoneTransform; //ObjectArrayView of Matrix4's
}

Skinning.prototype = {
  constructor: Skinning,

  applyTransforms: function applyTransforms(positions, skinToWorldTransform, boneWorldTransforms, rootBoneIndex) {
    return this.deform(this.createFinalTransforms(skinToWorldTransform, boneWorldTransforms, rootBoneIndex), positions);
  },

  createFinalTransforms: function createFinalTransforms(skinToWorldTransform, boneWorldTransforms, rootBoneIndex) {
    var poseSkinToPoseBoneTransform = this.poseSkinToPoseBoneTransform;
    var worldToSkinTransform = new _three.Matrix4().getInverse(skinToWorldTransform, true);
    var finalTransforms = new Array(poseSkinToPoseBoneTransform.length);

    var identity = new _three.Matrix4().identity();

    if (poseSkinToPoseBoneTransform.length === 0) {
      return finalTransforms;
    }

    var rootToWorldTransform = void 0;
    var worldToRootTransform = void 0;
    var poseRootToSkinTransform = void 0;

    if (rootBoneIndex > -1) {
      rootToWorldTransform = boneWorldTransforms[rootBoneIndex];
      worldToRootTransform = new _three.Matrix4().getInverse(rootToWorldTransform, true);
      poseRootToSkinTransform = new _three.Matrix4().getInverse(poseSkinToPoseBoneTransform.getAt(rootBoneIndex), true);
    }

    var boneToRootTransform = new _three.Matrix4();
    var boneToSkinTransform = new _three.Matrix4();
    var finalTransform = new _three.Matrix4();

    for (var i = 0, il = poseSkinToPoseBoneTransform.length; i < il; i++) {
      var boneToWorldTransform = boneWorldTransforms[i];
      if (rootBoneIndex > -1) {
        boneToRootTransform.multiplyMatrices(worldToRootTransform, boneToWorldTransform);
        boneToSkinTransform.multiplyMatrices(poseRootToSkinTransform, boneToRootTransform);
      } else {
        boneToSkinTransform.multiplyMatrices(worldToSkinTransform, boneToWorldTransform);
      }

      finalTransforms[i] = new _three.Matrix4().multiplyMatrices(boneToSkinTransform, poseSkinToPoseBoneTransform.getAt(i));
    }

    return finalTransforms;
  },

  deform: function deform(finalTransforms, positions) {
    var positionSkinRange = this.positionSkinRange;
    var skinWeights = this.skinWeights;
    var skinBoneIndices = this.skinBoneIndices;

    var deformedPositions = new _ObjectArrayView2.default(_three.Vector3, positions.length);
    var v = new _three.Vector3();
    var d = new _three.Vector3();

    for (var i = 0; i < positions.length; i++) {
      positions.getAt(i, v);
      d.multiplyScalar(0);
      for (var j = positionSkinRange[i]; j < positionSkinRange[i + 1]; j++) {
        positions.getAt(i, v);
        v.applyMatrix4(finalTransforms[skinBoneIndices[j]]);
        v.multiplyScalar(skinWeights[j]);
        d.addVectors(d, v);
      }

      if (positionSkinRange[i + 1] - positionSkinRange[i] === 0) {
        d.copy(v);
      }

      deformedPositions.setAt(i, d);
    }

    return deformedPositions;
  }
};

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = EdgeVertexAdjacency;

var _MergeSort = __webpack_require__(415);

var _MergeSort2 = _interopRequireDefault(_MergeSort);

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @template T
 * @constructor
 *
 */
function EdgeVertexAdjacency(polyMap) {
  this.polyMap = polyMap;

  // The low value index acts as the pivot for edge enumeration, so
  // the following array is indexed by edge UIDs:
  this.edgeHighVertexIndices = null;

  // Low -> high value index mapping (describes ranges of edge UIDs):
  this.edgePivotRangeOffsets = null;

  this.edgeVertices = null;

  this._compactEdgeLowToHighMap(this._buildEdgeLowToHighMap());

  this._inverseMapping();
}

EdgeVertexAdjacency.prototype = {
  constructor: EdgeVertexAdjacency,

  getNumEdges: function getNumEdges() {
    return this.edgeHighVertexIndices.length;
  },

  // VV -> E
  findEdgeId: function findEdgeId(faceValueIndexA, faceValueIndexB) {
    var loVertex = faceValueIndexA;
    var hiVertex = faceValueIndexB;

    if (hiVertex < loVertex) {
      loVertex = faceValueIndexB;
      hiVertex = faceValueIndexA;
    }

    var rangeOffsets = this.edgePivotRangeOffsets;

    return _Arrays2.default.binarySearch(this.edgeHighVertexIndices, hiVertex, rangeOffsets[loVertex], rangeOffsets[loVertex + 1]);
  },

  // E -> VV
  getVerticesForEdge: function getVerticesForEdge(edgeId, optionalResult) {
    if (optionalResult) {
      optionalResult[0] = this.edgeVertices[edgeId * 2];
      optionalResult[1] = this.edgeVertices[edgeId * 2 + 1];
      return optionalResult;
    } else {
      return {
        v: this.edgeVertices[edgeId * 2],
        vNext: this.edgeVertices[edgeId * 2 + 1]
      };
    }
  },

  _inverseMapping: function _inverseMapping() {
    var numEdges = this.getNumEdges();

    var edgeVertices = new Uint32Array(numEdges * 2);

    for (var v0 = 0; v0 < this.edgePivotRangeOffsets.length - 1; v0++) {
      var edgeBegin = this.edgePivotRangeOffsets[v0];
      var edgeEnd = this.edgePivotRangeOffsets[v0 + 1];

      for (var i = edgeBegin; i <= edgeEnd; i++) {
        var v1 = this.edgeHighVertexIndices[i];

        edgeVertices[i * 2 + 0] = v0;
        edgeVertices[i * 2 + 1] = v1;
      }
    }

    this.edgeVertices = edgeVertices;
  },

  _buildEdgeLowToHighMap: function _buildEdgeLowToHighMap() {
    var faceOffsets = this.polyMap.faceRangeOffsets;
    var valueIndices = this.polyMap.faceValueIndices;

    var nValues = this.polyMap.values.length;
    var offsets = new Uint32Array(nValues + 2);
    var histogramArea = offsets.subarray(2);

    var faceBegin = faceOffsets[0];
    var maxEdgesSharingPivot = 0;

    // Construct histogram and accumulate:

    for (var i = 1, n = faceOffsets.length; i !== n; ++i) {
      var faceUntil = faceOffsets[i];
      var vertexA = valueIndices[faceUntil - 1];

      for (var j = faceBegin; j !== faceUntil; ++j) {
        var vertexB = valueIndices[j];
        var loVertex = vertexB < vertexA ? vertexB : vertexA;

        var nEdges = ++histogramArea[loVertex];

        if (nEdges > maxEdgesSharingPivot) maxEdgesSharingPivot = nEdges;

        vertexA = vertexB;
      }

      faceBegin = faceUntil;
    }

    _Arrays2.default.accumulate(histogramArea);

    // Build the indices array (shifting the offsets):

    var writeOffsets = offsets.subarray(1);
    var indices = new Uint32Array(writeOffsets[nValues]);

    faceBegin = faceOffsets[0];

    for (var _i = 1, _n = faceOffsets.length; _i !== _n; ++_i) {
      var _faceUntil = faceOffsets[_i];
      var _vertexA = valueIndices[_faceUntil - 1];

      for (var _j = faceBegin; _j !== _faceUntil; ++_j) {
        var _vertexB = valueIndices[_j];

        var _loVertex = _vertexA;
        var hiVertex = _vertexB;

        if (hiVertex < _loVertex) {
          _loVertex = _vertexB;
          hiVertex = _vertexA;
        }

        indices[writeOffsets[_loVertex]++] = hiVertex;

        _vertexA = _vertexB;
      }

      faceBegin = _faceUntil;
    }

    this.edgePivotRangeOffsets = offsets;
    this.edgeHighVertexIndices = indices;

    return maxEdgesSharingPivot;
  },

  _compactEdgeLowToHighMap: function _compactEdgeLowToHighMap(maxEdgesSharingPivot) {
    var offsets = this.edgePivotRangeOffsets;
    var indices = this.edgeHighVertexIndices;

    var sorter = new _MergeSort2.default(Uint32Array, maxEdgesSharingPivot);

    var nOffsets = this.polyMap.values.length + 1;

    var rangeUntil = 0;
    var rangeBegin = 0;
    var writeOffset = 0;

    for (var i = 1; i !== nOffsets; ++i) {
      rangeUntil = offsets[i];

      if (rangeBegin !== rangeUntil) {
        sorter.sortRange(indices, rangeBegin, rangeUntil);

        // Unique-compact indices within each range:

        var prevElement = indices[rangeBegin];
        indices[writeOffset++] = prevElement;

        for (var j = rangeBegin + 1; j < rangeUntil; ++j) {
          var element = indices[j];
          if (element !== prevElement) {
            indices[writeOffset++] = element;
            prevElement = element;
          }
        }
      }

      offsets[i] = writeOffset; // re-write compact offsets
      rangeBegin = rangeUntil; // certainly >= writeOffset
    }

    // Shrink to fit (offsets only has 2 extra elements, so view it):

    this.edgeHighVertexIndices = _Arrays2.default.slice(indices, 0, writeOffset);

    this.edgePivotRangeOffsets = offsets.subarray(0, nOffsets);
  }
};

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = FaceEdgeAdjacency;
function FaceEdgeAdjacency(polyMap) {
  this.polyMap = polyMap;

  this.faceEdgeIndices = null;

  this.edgeFaceCounts = null;
  this.edgeFaceIndices = null;

  this._compute();
}

FaceEdgeAdjacency.prototype = {
  constructor: FaceEdgeAdjacency,

  // F -> E
  //faceValueIndex is the index of value on the face
  //ie: the index of the value in faceValueIndices
  //    not the value of faceValueIndices
  getEdgeIdFromFaceValueIndex: function getEdgeIdFromFaceValueIndex(faceValueIndex) {
    return this.faceEdgeIndices[faceValueIndex];
  },

  // E -> F, part 1
  getNumFacesForEdgeId: function getNumFacesForEdgeId(edgeID) {
    return this.edgeFaceCounts[edgeID];
  },
  // E -> F, part 2
  getFaceForEdgeId: function getFaceForEdgeId(edgeId, faceOffset) {
    return this.edgeFaceIndices[edgeId * 2 + faceOffset];
  },

  //returns false if there is an invalid surface
  //if this function returns false this adjacency structure is invalid and cannot be used
  checkValidity: function checkValidity() {
    var invalidSurface = true;
    for (var i = 0; i < this.edgeFaceCounts.length; i++) {
      if (this.edgeFaceCounts[i] > 2) invalidSurface = false;
    }

    return invalidSurface;
  },

  _compute: function _compute() {
    var polyMap = this.polyMap;
    var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;

    var faceRangeOffsets = polyMap.faceRangeOffsets;
    var faceValueIndices = polyMap.faceValueIndices;

    var numEdges = edgeVertexAdjacency.edgeHighVertexIndices.length;
    //const numFaces = faceRangeOffsets.length - 1;
    var edgeFaceCounts = new Uint32Array(numEdges);
    var edgeFaceIndices = new Uint32Array(numEdges * 2);
    var faceEdgeIndices = new Uint32Array(faceValueIndices.length);

    for (var f = 0; f < faceRangeOffsets.length - 1; f++) {
      var faceBegin = faceRangeOffsets[f];
      var faceUntil = faceRangeOffsets[f + 1];
      var numFaceValues = faceUntil - faceBegin;

      var vNext = faceValueIndices[faceBegin];

      // count faces on each edge.
      for (var fv = 0; fv < numFaceValues; fv++) {
        var v = vNext;
        vNext = faceValueIndices[faceBegin + (fv + 1) % numFaceValues];

        var edgeId = edgeVertexAdjacency.findEdgeId(v, vNext);

        var faceValueIndex = faceBegin + fv;

        faceEdgeIndices[faceValueIndex] = edgeId;

        edgeFaceIndices[edgeId * 2 + edgeFaceCounts[edgeId]] = f;
        edgeFaceCounts[edgeId]++;
      }
    }

    this.faceEdgeIndices = faceEdgeIndices;

    this.edgeFaceCounts = edgeFaceCounts;
    this.edgeFaceIndices = edgeFaceIndices;

    return this;
  }
};

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = FaceFaceAdjacency;
function FaceFaceAdjacency(polyMap) {
  //for each face there is an offset array (faceFaceCounts)
  //this offset array indexes into an array of all faces that are adjacent (faceFaceIndices)

  this.polyMap = polyMap;

  this.faceFaceCounts = null;
  this.faceFaceIndices = null;

  this._compute();
}

FaceFaceAdjacency.prototype = {
  constructor: FaceFaceAdjacency,

  //F->F
  getAdjacentFaces: function getAdjacentFaces(face) {
    var numAdjacentFaces = this.faceFaceCounts[face + 1] - this.faceFaceCounts[face];
    var adjacentFaces = new Uint32Array(numAdjacentFaces);
    for (var i = this.faceFaceCounts[face], j = 0; i < this.faceFaceCounts[face + 1]; i++, j++) {
      adjacentFaces[j] = this.faceFaceIndices[i];
    }

    return adjacentFaces;
  },

  //return array of 0-2 faces
  //valuesIndex is the index of the vertex in the values array
  adjacentFacesOnVertex: function adjacentFacesOnVertex(face, valuesIndex) {
    var adjacentFaces = this.getAdjacentFaces(face);
    var faceRangeOffsets = this.polyMap.faceRangeOffsets;
    var faceValueIndices = this.polyMap.faceValueIndices;
    var adjacentFacesOnVertex = [];

    for (var i = 0; i < adjacentFaces.length; i++) {
      for (var j = faceRangeOffsets[adjacentFaces[i]]; j < faceRangeOffsets[adjacentFaces[i] + 1]; j++) {
        if (faceValueIndices[j] === valuesIndex) {
          adjacentFacesOnVertex.push(adjacentFaces[i]);
          break;
        }
      }
    }

    return adjacentFacesOnVertex;
  },

  _compute: function _compute() {
    var faceRangeOffsets = this.polyMap.faceRangeOffsets;
    var faceValueIndices = this.polyMap.faceValueIndices;
    var faceEdgeAdjacency = this.polyMap.faceEdgeAdjacency;

    var faceFaceCounts = new Uint32Array(faceRangeOffsets.length);
    var faceFaceIndices = [];

    for (var i = 0; i < faceRangeOffsets.length - 1; i++) {
      var adjacentFaces = [];
      for (var j = faceRangeOffsets[i]; j < faceRangeOffsets[i + 1]; j++) {
        var edge = faceEdgeAdjacency.getEdgeIdFromFaceValueIndex(j);

        //if edge has 2 faces then find the adjacent face that isnt the given face
        var numFaces = faceEdgeAdjacency.getNumFacesForEdgeId(edge);
        if (numFaces > 1) {
          var adjacentFaceIndex = faceEdgeAdjacency.getFaceForEdgeId(edge, 0);
          if (adjacentFaceIndex === i) adjacentFaceIndex = faceEdgeAdjacency.getFaceForEdgeId(edge, 1);
          adjacentFaces.push(adjacentFaceIndex);
        }
      }

      faceFaceCounts[i + 1] = faceFaceCounts[i] + adjacentFaces.length;
      faceFaceIndices.push.apply(faceFaceIndices, adjacentFaces);
    }

    this.faceFaceCounts = faceFaceCounts;
    this.faceFaceIndices = new Uint32Array(faceFaceIndices);

    return this;
  }
};

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ValueAdjacency;
function ValueAdjacency(polyMap) {
  this.polyMap = polyMap;

  this._compute();
}

ValueAdjacency.prototype = {
  constructor: ValueAdjacency,

  // V -> E, part 1
  getNumEdgesForVertex: function getNumEdgesForVertex(valueIndex) {
    var valueBegin = this.valueEdgeOffsets[valueIndex];
    var valueUntil = this.valueEdgeOffsets[valueIndex + 1];
    var numValueEdges = valueUntil - valueBegin;

    return numValueEdges;
  },

  // V -> E, part 2
  getEdgeForVertexId: function getEdgeForVertexId(valueIndex, edgeOffset) {
    var valueBegin = this.valueEdgeOffsets[valueIndex];
    return this.valueEdgeIndices[valueBegin + edgeOffset];
  },

  //returns an array of edgeId's in CC order for a given Vertex
  getEdgeOrderForVertexId: function getEdgeOrderForVertexId(valueIndex) {
    var vertexValence = this.getNumEdgesForVertex(valueIndex);
    var edgeVertexAdjacency = this.polyMap.edgeVertexAdjacency;
    var faceEdgeAdjacency = this.polyMap.faceEdgeAdjacency;
    var faceRangeOffsets = this.polyMap.faceRangeOffsets;
    var faceValueIndices = this.polyMap.faceValueIndices;

    var startEdgeId = this.getEdgeForVertexId(valueIndex, 0);
    var startFaceId = faceEdgeAdjacency.getNumFacesForEdgeId(startEdgeId, 0);
    var complete = false;
    var i = 0;

    //Checks if the vertex has a gap in adjacent faces
    //if gap present, it starts at an edge there to find the ordering of edges
    while (!complete && i < vertexValence) {
      var _edgeId = this.getEdgeForVertexId(valueIndex, i);
      var edgeFaceCount = faceEdgeAdjacency.getNumFacesForEdgeId(_edgeId);

      if (edgeFaceCount === 1) {
        var tempFaceId = faceEdgeAdjacency.getFaceForEdgeId(_edgeId, 0);
        var faceBegin = faceRangeOffsets[tempFaceId];
        var faceUntil = faceRangeOffsets[tempFaceId + 1];
        var faceValuesCount = faceUntil - faceBegin;

        var nextValue = faceValueIndices[faceBegin];
        var nextNextValue = faceValueIndices[faceBegin + 1];

        for (var fv = 0; fv < faceValuesCount; ++fv) {
          var value = nextValue;
          nextValue = nextNextValue;
          nextNextValue = faceValueIndices[faceBegin + (fv + 2) % faceValuesCount];

          if (value === valueIndex) {
            var tempEdgeId = edgeVertexAdjacency.findEdgeId(value, nextValue);

            if (tempEdgeId === _edgeId) {
              startEdgeId = _edgeId;
              startFaceId = tempFaceId;
              complete = true;
            }
          }
        }
      }

      ++i;
    }

    //If no gap present, find the starting face Id
    if (!complete) {
      var _faceBegin = faceRangeOffsets[startFaceId];
      var _faceUntil = faceRangeOffsets[startFaceId + 1];
      var _faceValuesCount = _faceUntil - _faceBegin;

      var _nextValue = faceValueIndices[_faceBegin];
      var _nextNextValue = faceValueIndices[_faceBegin + 1];

      for (var _fv = 0; _fv < _faceValuesCount; ++_fv) {
        var _value = _nextValue;
        _nextValue = _nextNextValue;
        _nextNextValue = faceValueIndices[_faceBegin + (_fv + 2) % _faceValuesCount];

        if (_value === valueIndex) {
          var _tempEdgeId = edgeVertexAdjacency.findEdgeId(_value, _nextValue);

          if (_tempEdgeId !== startEdgeId) {
            startFaceId = faceEdgeAdjacency.getFaceForEdgeId(startEdgeId, 1);
          }
        }
      }
    }

    //start here to go around the vertex in CC order at startEdgeId
    var orderedEdges = new Uint32Array(vertexValence);
    var edgeId = startEdgeId;
    var faceId = startFaceId;

    for (var e = 0; e < vertexValence; ++e) {
      orderedEdges[e] = edgeId;
      var _faceBegin2 = faceRangeOffsets[faceId];
      var _faceUntil2 = faceRangeOffsets[faceId + 1];
      var _faceValuesCount2 = _faceUntil2 - _faceBegin2;

      var _nextValue2 = faceValueIndices[_faceBegin2];
      var _nextNextValue2 = faceValueIndices[_faceBegin2 + 1];

      for (var _fv2 = 0; _fv2 < _faceValuesCount2; ++_fv2) {
        var _value2 = _nextValue2;
        _nextValue2 = _nextNextValue2;
        _nextNextValue2 = faceValueIndices[_faceBegin2 + (_fv2 + 2) % _faceValuesCount2];

        if (_value2 === valueIndex) {
          var previousValue = faceValueIndices[_faceBegin2 + (_fv2 + _faceValuesCount2 - 1) % _faceValuesCount2];
          edgeId = edgeVertexAdjacency.findEdgeId(previousValue, _value2);
          var _tempFaceId = faceEdgeAdjacency.getFaceForEdgeId(edgeId, 0);

          if (faceId === _tempFaceId && faceEdgeAdjacency.getNumFacesForEdgeId(edgeId) === 2) {
            faceId = faceEdgeAdjacency.getFaceForEdgeId(edgeId, 1);
          } else {
            faceId = _tempFaceId;
          }
        }
      }
    }

    return orderedEdges;
  },

  //V->VV returns the adjacent values to a given vertex
  getAdjacentValues: function getAdjacentValues(valueIndex) {
    var edgeVertexAdjacency = this.polyMap.edgeVertexAdjacency;
    var adjacentValues = [];
    var numEdges = this.getNumEdgesForVertex(valueIndex);

    for (var i = 0; i < numEdges; i++) {
      var edge = this.getEdgeForVertexId(valueIndex, i);
      var values = edgeVertexAdjacency.getVerticesForEdge(edge);
      var adjacentValue = values.v === valueIndex ? values.vNext : values.v;
      adjacentValues.push(adjacentValue);
    }

    return adjacentValues;
  },

  //V->VV for a given faceValueIndex and face
  //returns the (0-2) adjacent faceValueIndices on that face
  getAdjacentFaceValuesIndicesOnFace: function getAdjacentFaceValuesIndicesOnFace(faceValueIndex, face) {
    var adjacentValuesOnFace = [];
    var faceBegin = this.polyMap.faceRangeOffsets[face];
    var faceEnd = this.polyMap.faceRangeOffsets[face + 1];
    var faceSize = faceEnd - faceBegin;
    if (faceSize < 3) return adjacentValuesOnFace;

    var next = faceValueIndex === faceEnd - 1 ? faceBegin : faceValueIndex + 1;
    var prev = faceValueIndex === faceBegin ? faceEnd - 1 : faceValueIndex - 1;

    adjacentValuesOnFace.push(prev);
    adjacentValuesOnFace.push(next);

    return adjacentValuesOnFace;
  },

  // V -> F, part 1
  getNumFacesForVertex: function getNumFacesForVertex(faceValueIndex) {
    var valueBegin = this.valueFaceOffsets[faceValueIndex];
    var valueUntil = this.valueFaceOffsets[faceValueIndex + 1];
    var numValueFace = valueUntil - valueBegin;

    return numValueFace;
  },

  // V -> F, part 2
  getFaceForVertexId: function getFaceForVertexId(faceValueIndex, faceOffset) {
    var valueBegin = this.valueFaceOffsets[faceValueIndex];
    return this.valueFaceIndices[valueBegin + faceOffset];
  },

  _compute: function _compute() {
    var polyMap = this.polyMap;

    var faceRangeOffsets = polyMap.faceRangeOffsets;
    var faceValueIndices = polyMap.faceValueIndices;

    var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;

    var valueFaceCount = new Uint32Array(polyMap.values.length);
    var valueEdgeCount = new Uint32Array(polyMap.values.length);
    //const numFaces = faceRangeOffsets.length - 1;

    var numEdges = edgeVertexAdjacency.getNumEdges();
    var edgeUnique = new Uint8Array(numEdges);

    // histogram.
    for (var f = 0; f < polyMap.faceRangeOffsets.length - 1; f++) {
      var faceBegin = polyMap.faceRangeOffsets[f];
      var faceUntil = polyMap.faceRangeOffsets[f + 1];
      var numFaceValues = faceUntil - faceBegin;

      var vNext = polyMap.faceValueIndices[faceBegin];

      for (var fv = 0; fv < numFaceValues; fv++) {
        var v = vNext;
        vNext = polyMap.faceValueIndices[faceBegin + (fv + 1) % numFaceValues];

        var e = edgeVertexAdjacency.findEdgeId(v, vNext);

        valueFaceCount[v]++;

        // is this the first time processing this edge
        if (edgeUnique[e] === 0) {
          edgeUnique[e] = 1;

          valueEdgeCount[v]++;
          valueEdgeCount[vNext]++;
        }
      }
    }

    // create offset arrays.
    var faceSum = 0,
        edgeSum = 0;
    var valueFaceOffsets = new Uint32Array(valueFaceCount.length + 1);
    var valueEdgeOffsets = new Uint32Array(valueEdgeCount.length + 1);
    for (var i = 0; i < valueFaceCount.length; i++) {
      valueFaceOffsets[i] = faceSum;
      faceSum += valueFaceCount[i];
      valueFaceCount[i] = 0;

      valueEdgeOffsets[i] = edgeSum;
      edgeSum += valueEdgeCount[i];
      valueEdgeCount[i] = 0;
    }

    valueFaceOffsets[valueFaceCount.length] = faceSum;
    valueEdgeOffsets[valueEdgeCount.length] = edgeSum;

    // fill in the values
    var valueFaceIndices = new Uint32Array(faceSum);
    var valueEdgeIndices = new Uint32Array(edgeSum);

    for (var _f = 0; _f < polyMap.faceRangeOffsets.length - 1; _f++) {
      var _faceBegin3 = polyMap.faceRangeOffsets[_f];
      var _faceUntil3 = polyMap.faceRangeOffsets[_f + 1];
      var _numFaceValues = _faceUntil3 - _faceBegin3;

      var _vNext = polyMap.faceValueIndices[_faceBegin3];

      for (var _fv3 = 0; _fv3 < _numFaceValues; _fv3++) {
        var _v = _vNext;
        _vNext = polyMap.faceValueIndices[_faceBegin3 + (_fv3 + 1) % _numFaceValues];

        var _e = edgeVertexAdjacency.findEdgeId(_v, _vNext);

        valueFaceIndices[valueFaceOffsets[_v] + valueFaceCount[_v]++] = _f;

        // is this the first time processing this edge
        if (edgeUnique[_e] === 1) {
          edgeUnique[_e] = 2;

          valueEdgeIndices[valueEdgeOffsets[_v] + valueEdgeCount[_v]++] = _e;
          valueEdgeIndices[valueEdgeOffsets[_vNext] + valueEdgeCount[_vNext]++] = _e;
        }
      }
    }

    this.valueFaceOffsets = valueFaceOffsets;
    this.valueFaceIndices = valueFaceIndices;

    this.valueEdgeOffsets = valueEdgeOffsets;
    this.valueEdgeIndices = valueEdgeIndices;
  }
};

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = blendPolyMesh;

var _three = __webpack_require__(0);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function initBlendArray(polyMap) {
  var polyMapValues = polyMap.values;
  var tmpVertex = new _three.Vector3();

  var polyMapLength = polyMapValues.length;
  var polyMapValuesCopy = new _ObjectArrayView2.default(polyMapValues.type, polyMapLength);

  for (var currentVertex = 0; currentVertex < polyMapLength; ++currentVertex) {
    polyMapValues.getAt(currentVertex, tmpVertex);
    polyMapValuesCopy.setAt(currentVertex, tmpVertex);
  }
  return polyMapValuesCopy;
}

function addingWeightedDeltas(modifiedValues, finalShape, originalValues, weight, normal) {
  if (weight) {
    var tmpModifiedVector = new _three.Vector3();
    var tmpInitialVector = new _three.Vector3();
    var tmpFinalVector = new _three.Vector3();

    for (var index = 0; index < finalShape.length; ++index) {
      modifiedValues.getAt(index, tmpModifiedVector);
      originalValues.getAt(index, tmpInitialVector);
      finalShape.getAt(index, tmpFinalVector);

      var blendVector = tmpModifiedVector.add(tmpFinalVector.sub(tmpInitialVector).multiplyScalar(weight));

      if (!normal || blendVector.length() !== 0) {
        modifiedValues.setAt(index, blendVector);
      }
    }
  }
}

function blendPolyMesh(mesh, channels, weights) {
  var weightsLength = weights.length;
  var channelLength = channels.length;
  if (channelLength !== weightsLength) return mesh;

  // Clone positions
  mesh = new _PolyMesh2.default(mesh);
  var mapId = _PolyMaps2.default.IdPositions;
  var newPolyMap = new _PolyMap2.default(_PolyMaps2.default.resolveMap(mesh, mapId));
  var newMapValues = newPolyMap.values.clone();
  newPolyMap.values = newMapValues;
  _PolyMaps2.default.assignMap(mesh, mapId, newPolyMap);

  // Clone normals
  mapId = _PolyMaps2.default.IdNormals;
  newPolyMap = new _PolyMap2.default(_PolyMaps2.default.resolveMap(mesh, mapId));
  newMapValues = newPolyMap.values.clone();
  newPolyMap.values = newMapValues;

  _PolyMaps2.default.assignMap(mesh, mapId, newPolyMap);

  var originalPositionsMap = mesh.positions;
  var originalPositionValues = originalPositionsMap.values;

  var originalNormalsMap = mesh.normalMap;
  var useNormals = !!originalNormalsMap;

  var numVerticesOriginal = originalPositionValues.length;

  var blendShapes = mesh.blendShapes;

  if (blendShapes) {
    for (var c = 0; c < channelLength; ++c) {
      var blendShape = blendShapes[channels[c]];

      if (blendShape) {
        if (blendShape.positions.length !== numVerticesOriginal) {
          console.log('BLEND DEFORM IGNORED: cannot use channel', channels[c], "because the number of vertices doesn't match with the original shape");
          return mesh;
        } else if (useNormals && (!blendShape.normals || blendShape.normals.length !== originalNormalsMap.values.length)) {
          useNormals = false;
        }
      } else {
        console.log('BLEND DEFORM IGNORED: missing channel', channels[c]);
        return mesh;
      }
    }
  } else {
    console.log('BLEND DEFORM IGNORED: no blend shape');
    return mesh;
  }

  var originalNormalValues = useNormals ? originalNormalsMap.values : -1;

  var modifiedPositionValues = initBlendArray(originalPositionsMap);
  var modifiedNormalValues = initBlendArray(originalNormalsMap);

  for (var i = 0; i < weightsLength; ++i) {
    addingWeightedDeltas(modifiedPositionValues, blendShapes[channels[i]].positions, originalPositionValues, weights[i]);

    addingWeightedDeltas(modifiedNormalValues, blendShapes[channels[i]].normals, originalNormalValues, weights[i], true);
  }

  // Replace original data
  mesh.positions.values = modifiedPositionValues;
  if (useNormals) {
    var tmpNormalVertex = new _three.Vector3();
    for (var n = 0, normalLength = modifiedNormalValues.length; n < normalLength; ++n) {
      modifiedNormalValues.getAt(n, tmpNormalVertex);
      tmpNormalVertex.normalize();
      modifiedNormalValues.setAt(n, tmpNormalVertex);
    }
    mesh.normalMap.values = modifiedNormalValues;
  }

  return mesh;
}

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateVolume;

var _three = __webpack_require__(0);

var _triangulateMesh = __webpack_require__(240);

var _triangulateMesh2 = _interopRequireDefault(_triangulateMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The volume calculated will generally be correct for *closed* meshes. The volume calculated for some open
 * meshes can be correct under certain situations (see refPt below), but generally will exhibit a range
 * of error depending on the nature of the mesh's holes and their orientation with respect to the refPt.
 * @param {*} polyMesh
 */
// Adapted from:
// http://stackoverflow.com/questions/1406029/how-to-calculate-the-volume-of-a-3d-mesh-object-the-surface-of-which-is-made-up/1568551#1568551
// See also referenced paper at: http://chenlab.ece.cornell.edu/Publication/Cha/icip01_Cha.pdf

function calculateVolume(polyMesh) {
  var triMesh = (0, _triangulateMesh2.default)(polyMesh); // easy way to check if mesh already tri's?
  var positions = triMesh.positions.values;
  var indices = triMesh.positions.faceValueIndices;

  var numFaces = triMesh.getNumFaces();

  var volume = 0;

  // const refPt = new Vector3(0, 0, 0); // TODO: allow argument for non-origin ref point, which
  // can improve volume estimate for open meshes (make pt planar with mesh opening) or meshes extremely
  // far from the origin

  var p1 = new _three.Vector3();
  var p2 = new _three.Vector3();
  var p3 = new _three.Vector3();
  var tmp = new _three.Vector3();
  for (var i = 0; i < numFaces * 3; i += 3) {
    positions.getAt(indices[i], p1);
    positions.getAt(indices[i + 1], p2);
    positions.getAt(indices[i + 2], p3);

    // calculate volume of tetrahedron defined by face triangle and point at origin
    volume += p1.dot(tmp.crossVectors(p2, p3)) / 6;
  }

  return volume;
}

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = computeTangents;

var _three = __webpack_require__(0);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Computes basic tangents.
 */

function computeTangents(mesh, uvChannelName) {
  var intermediateVector = new _three.Vector3();

  function handleTriangle(positions, a, b, c, uvs, ua, ub, uc, fa, fb, fc) {
    var vA = positions.getAt(a);
    var vB = positions.getAt(b);
    var vC = positions.getAt(c);

    var uvA = uvs.getAt(ua);
    var uvB = uvs.getAt(ub);
    var uvC = uvs.getAt(uc);

    var x1 = vB.x - vA.x;
    var x2 = vC.x - vA.x;
    var y1 = vB.y - vA.y;
    var y2 = vC.y - vA.y;
    var z1 = vB.z - vA.z;
    var z2 = vC.z - vA.z;

    var s1 = uvB.x - uvA.x;
    var s2 = uvC.x - uvA.x;
    var t1 = uvB.y - uvA.y;
    var t2 = uvC.y - uvA.y;

    var r = 1.0 / (s1 * t2 - s2 * t1);

    var sdir = new _three.Vector3((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
    var tdir = new _three.Vector3((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);

    tan1.setAt(fa, tan1.getAt(fa, intermediateVector).add(sdir));
    tan1.setAt(fb, tan1.getAt(fb, intermediateVector).add(sdir));
    tan1.setAt(fc, tan1.getAt(fc, intermediateVector).add(sdir));

    tan2.setAt(fa, tan2.getAt(fa, intermediateVector).add(tdir));
    tan2.setAt(fb, tan2.getAt(fb, intermediateVector).add(tdir));
    tan2.setAt(fc, tan2.getAt(fc, intermediateVector).add(tdir));
  }

  // Clone positions
  mesh = new _PolyMesh2.default(mesh);
  var mapId = _PolyMaps2.default.IdPositions;
  var newPolyMap = new _PolyMap2.default(_PolyMaps2.default.resolveMap(mesh, mapId));
  var newMapValues = newPolyMap.values.clone();
  newPolyMap.values = newMapValues;
  _PolyMaps2.default.assignMap(mesh, mapId, newPolyMap);

  // Clone normals
  mapId = _PolyMaps2.default.IdNormals;
  newPolyMap = new _PolyMap2.default(_PolyMaps2.default.resolveMap(mesh, mapId));
  newMapValues = newPolyMap.values.clone();
  newPolyMap.values = newMapValues;

  _PolyMaps2.default.assignMap(mesh, mapId, newPolyMap);

  // Cannot generate normal if there is no normal map.
  if (!mesh.normalMap || !mesh.uvMaps) {
    return;
  }

  var uvMap = mesh.uvMaps.byName[uvChannelName];

  if (!uvMap) {
    uvMap = mesh.uvMaps.byName[mesh.uvMaps.namesByIndex[0]];
  }

  // Cannot generate UV if there is no UV map.
  if (!uvMap) {
    return;
  }

  var faceOffsets = mesh.faceRangeOffsets;

  // Based on http://www.terathon.com/code/tangent.html
  // Tangents go to vertices
  var positions = mesh.positions.values;
  var faceValueIndices = mesh.positions.faceValueIndices;

  var uvFaceValueIndices = uvMap.faceValueIndices;
  var uvValues = uvMap.values;

  var normalFaceValueIndices = mesh.normalMap.faceValueIndices;
  var normalValues = mesh.normalMap.values;

  var totalNumberOfTangents = normalValues.length;
  var tangentValues = new _ObjectArrayView2.default(_three.Vector4, totalNumberOfTangents);

  var tan1 = new _ObjectArrayView2.default(_three.Vector3, totalNumberOfTangents);
  var tan2 = new _ObjectArrayView2.default(_three.Vector3, totalNumberOfTangents);

  var numberOfFaces = faceOffsets.length - 1;

  for (var currentFaceIndex = 0; currentFaceIndex < numberOfFaces; ++currentFaceIndex) {
    var currentFace = faceValueIndices.slice(faceOffsets[currentFaceIndex], faceOffsets[currentFaceIndex + 1]);
    var uvFace = uvFaceValueIndices.slice(faceOffsets[currentFaceIndex], faceOffsets[currentFaceIndex + 1]); // use UV layer 0 for tangents
    var normalFace = normalFaceValueIndices.slice(faceOffsets[currentFaceIndex], faceOffsets[currentFaceIndex + 1]);

    for (var i = 0; i < currentFace.length - 2; ++i) {
      handleTriangle(positions, currentFace[i], currentFace[i + 1], currentFace[i + 2], uvValues, uvFace[i], uvFace[i + 1], uvFace[i + 2], normalFace[i], normalFace[i + 1], normalFace[i + 2]);
    }
  }

  var nVector = new _three.Vector3();
  var tVector = new _three.Vector3();
  var tmpVector2 = new _three.Vector3();

  for (var f = 0, fl = faceOffsets.length; f < fl - 1; ++f) {
    var face = normalFaceValueIndices.slice(faceOffsets[f], faceOffsets[f + 1]);

    for (var currentVertex = 0, faceLength = face.length; currentVertex < faceLength; ++currentVertex) {
      var currentVertexIndex = face[currentVertex];

      normalValues.getAt(currentVertexIndex, nVector);
      tan1.getAt(currentVertexIndex, tVector);

      // Gram-Schmidt Orthogonalize

      var tmpVector1 = tVector.clone();
      tmpVector1.sub(nVector.multiplyScalar(nVector.dot(tVector))).normalize();

      // Calculate Handedness
      tmpVector2.crossVectors(normalValues.getAt(currentVertexIndex), tmpVector1);
      var test = tmpVector2.dot(tan2.getAt(currentVertexIndex));
      var w = test < 0.0 ? -1.0 : 1.0;
      var tangentVector4 = new _three.Vector4(tmpVector1.x, tmpVector1.y, tmpVector1.z, w);

      tangentValues.setAt(currentVertexIndex, tangentVector4);
    }
  }

  var tangentMap = new _PolyMap2.default.fromData(faceOffsets, normalFaceValueIndices, tangentValues);

  return new _PolyMesh2.default((0, _assign2.default)({}, mesh, { tangentMap: tangentMap }));
}

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deleteComponentFromPolyMesh;

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// REMOVE FACES
function removeFaceRangeOffsets(originalFaceRangeOffsets, faceIndicesToRemove) {
  // Create new faceRangeOffsets
  var numOriginalFaces = originalFaceRangeOffsets.length - 1;
  var newFaceRangeOffsets = new Uint32Array(numOriginalFaces - faceIndicesToRemove.length + 1);

  var nextFaceToRemove = 0;
  var newFaceRangeOffsetIndex = 0;

  var totalFaceValueIndicesRemoved = 0;

  for (var f = 0; f <= numOriginalFaces; ++f) {
    if (f !== faceIndicesToRemove[nextFaceToRemove]) {
      newFaceRangeOffsets[newFaceRangeOffsetIndex++] = originalFaceRangeOffsets[f] - totalFaceValueIndicesRemoved;
    } else {
      nextFaceToRemove++;
      totalFaceValueIndicesRemoved += originalFaceRangeOffsets[f + 1] - originalFaceRangeOffsets[f];
    }
  }

  return { newFaceRangeOffsets: newFaceRangeOffsets, totalFaceValueIndicesRemoved: totalFaceValueIndicesRemoved };
}

function removeFaceValueIndices(originalFaceRangeOffsets, totalFaceValueIndicesRemoved, originalFaceValueIndices, faceIndicesToRemove) {
  var numOriginalFaces = originalFaceRangeOffsets.length - 1;
  var numFaceValueIndices = originalFaceValueIndices.length;

  // Create new faceValueIndices
  var newFaceValueIndices = new Uint32Array(numFaceValueIndices - totalFaceValueIndicesRemoved);

  var nextFaceToRemove = 0;
  var nextFaceValueIndex = 0;

  for (var f = 0; f < numOriginalFaces; ++f) {
    if (f !== faceIndicesToRemove[nextFaceToRemove]) {
      var startIndex = originalFaceRangeOffsets[f];
      var endIndex = originalFaceRangeOffsets[f + 1];

      for (var i = startIndex; i < endIndex; ++i) {
        newFaceValueIndices[nextFaceValueIndex++] = originalFaceValueIndices[i];
      }
    } else {
      nextFaceToRemove++;
    }
  }

  // Returns a new polymap with the updated faceRangeOffsets and faceValueIndices
  return newFaceValueIndices;
}

function removeFacesFromPolyMesh(mesh, faceIndicesToRemove) {
  var newPolyMesh = {};
  var originalFaceRangeOffsets = mesh.faceRangeOffsets;

  var _removeFaceRangeOffse = removeFaceRangeOffsets(originalFaceRangeOffsets, faceIndicesToRemove),
      newFaceRangeOffsets = _removeFaceRangeOffse.newFaceRangeOffsets,
      totalFaceValueIndicesRemoved = _removeFaceRangeOffse.totalFaceValueIndicesRemoved;

  newPolyMesh.faceRangeOffsets = newFaceRangeOffsets;

  var polyMapsIterator = new _PolyMaps2.default.Iterator(mesh);
  while (polyMapsIterator.next()) {
    var mapId = polyMapsIterator.getId();
    var originalPolyMap = _PolyMaps2.default.resolveMap(mesh, mapId);
    var newPolyMap = new _PolyMap2.default(originalPolyMap, {
      faceRangeOffsets: newFaceRangeOffsets,
      faceValueIndices: removeFaceValueIndices(originalFaceRangeOffsets, totalFaceValueIndicesRemoved, originalPolyMap.faceValueIndices, faceIndicesToRemove)
    });

    _PolyMaps2.default.assignMap(newPolyMesh, mapId, newPolyMap);
  }

  var originalMaterialIds = mesh.materialIds;

  if (originalMaterialIds) {
    var numOriginalFaces = mesh.faceRangeOffsets.length - 1;
    var newMaterialIds = new Uint32Array(numOriginalFaces - faceIndicesToRemove.length);

    var nextFaceToRemove = 0;
    var nextMaterialIdIndex = 0;

    for (var f = 0; f < numOriginalFaces; ++f) {
      if (f !== faceIndicesToRemove[nextFaceToRemove]) {
        newMaterialIds[nextMaterialIdIndex++] = originalMaterialIds[f];
      } else {
        nextFaceToRemove++;
      }
    }

    newPolyMesh.materialIds = newMaterialIds;
  }

  return new _PolyMesh2.default(newPolyMesh);
}

// REMOVE EDGES
function convertEdgeIndicesToFaceIndices(mesh, edgeIndices) {
  var faceEdgeAdjacency = mesh.positions.faceEdgeAdjacency;
  var totalFaces = mesh.faceRangeOffsets.length - 1;
  var isFaceSelected = new Uint8Array(totalFaces);

  var numFacesSelected = 0;

  var totalEdgeIndices = edgeIndices.length;
  for (var edgeIndex = 0; edgeIndex < totalEdgeIndices; ++edgeIndex) {
    var currentEdge = edgeIndices[edgeIndex];
    var faceCount = faceEdgeAdjacency.getNumFacesForEdgeId(currentEdge);

    for (var f = 0; f < faceCount; ++f) {
      var faceIndex = faceEdgeAdjacency.getFaceForEdgeId(edgeIndex, f);
      if (isFaceSelected[faceIndex] === 0) {
        numFacesSelected++;
        isFaceSelected[faceIndex] = 1;
      }
    }
  }

  var faceIndices = new Uint32Array(numFacesSelected);

  var nextFaceIndex = 0;

  for (var _f = 0; _f < totalFaces; ++_f) {
    if (isFaceSelected[_f] === 1) {
      faceIndices[nextFaceIndex++] = _f;
    }
  }

  return faceIndices;
}

function removeEdgesFromPolyMesh(mesh, edgeIndicesToRemove) {
  return removeFacesFromPolyMesh(mesh, convertEdgeIndicesToFaceIndices(mesh, edgeIndicesToRemove));
}

// REMOVE VERTICES
function convertVertexIndicesToFaceIndices(mesh, vertexIndices) {
  var valueAdjacency = mesh.positions.valueAdjacency;
  var totalFaces = mesh.faceRangeOffsets.length - 1;
  var isFaceSelected = new Uint8Array(totalFaces);

  var numFacesSelected = 0;

  var totalVertexIndices = vertexIndices.length;
  for (var vertexIndex = 0; vertexIndex < totalVertexIndices; ++vertexIndex) {
    var currentVertex = vertexIndices[vertexIndex];
    var faceCount = valueAdjacency.getNumFacesForVertex(currentVertex);

    for (var f = 0; f < faceCount; ++f) {
      var faceIndex = valueAdjacency.getFaceForVertexId(currentVertex, f);
      if (isFaceSelected[faceIndex] === 0) {
        numFacesSelected++;
        isFaceSelected[faceIndex] = 1;
      }
    }
  }

  var faceIndices = new Uint32Array(numFacesSelected);

  var nextFaceIndex = 0;

  for (var _f2 = 0; _f2 < totalFaces; ++_f2) {
    if (isFaceSelected[_f2] === 1) {
      faceIndices[nextFaceIndex++] = _f2;
    }
  }

  return faceIndices;
}

function removeVerticesFromPolyMesh(mesh, vertexIndicesToRemove) {
  return removeFacesFromPolyMesh(mesh, convertVertexIndicesToFaceIndices(mesh, vertexIndicesToRemove));
}

var deleteComponentFunctions = {
  Face: removeFacesFromPolyMesh,
  Edge: removeEdgesFromPolyMesh,
  Vertex: removeVerticesFromPolyMesh
};

function deleteComponentFromPolyMesh(mesh, indices, componentType) {
  return deleteComponentFunctions[componentType](mesh, indices);
}

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = findBoundingBox;

var _three = __webpack_require__(0);

function findBoundingBox(positions) {
  var values = positions.values;
  var indices = positions.faceValueIndices;
  var boundingBox = new _three.Box3();

  var vertex = new _three.Vector3();
  for (var i = 0; i < indices.length; i++) {
    values.getAt(indices[i], vertex);
    boundingBox.expandByPoint(vertex);
  }
  return boundingBox;
}

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = findMinimalSpacing;

var _three = __webpack_require__(0);

function findMinimalSpacing(polyMesh, idx, indices, forward) {
  var nFaces = polyMesh.faceRangeOffsets.length - 1;

  var offset = new _three.Vector3(Infinity, Infinity, Infinity).multiplyScalar(forward ? 1 : -1),
      origin = new _three.Vector3(),
      direction = new _three.Vector3(forward ? 1 : -1, 0, 0),
      ray = new _three.Ray(origin, direction),
      intersectPoint = new _three.Vector3(),
      vecA = new _three.Vector3(),
      vecB = new _three.Vector3(),
      zero = new _three.Vector3(0, 0, 0);

  return indices.reduce(function (off, index) {
    polyMesh.positions.values.getAt(index, origin);
    ray.origin.copy(origin);

    for (var f = 0; f < nFaces; f++) {
      if (!forward && polyMesh.materialIds[f] !== idx - 1 || forward && polyMesh.materialIds[f] !== idx + 1) continue;

      var faceBegin = polyMesh.faceRangeOffsets[f];
      var faceEnd = polyMesh.faceRangeOffsets[f + 1];
      for (var a = faceEnd - 1, b = faceBegin; b < faceEnd; a = b++) {
        intersectPoint.set(0, 0, 0);
        var indexA = polyMesh.positions.faceValueIndices[a];
        var indexB = polyMesh.positions.faceValueIndices[b];

        polyMesh.positions.values.getAt(indexA, vecA);
        polyMesh.positions.values.getAt(indexB, vecB);

        var faceFound = !!ray.intersectTriangle(vecB, vecA, zero, false, intersectPoint);
        var edgeFound = false;

        if (!faceFound) {
          var side = new _three.Vector3().subVectors(vecB, vecA);
          var toRay = new _three.Vector3().subVectors(origin, vecA);
          var directionToSide = new _three.Vector3().crossVectors(side, toRay).dot(ray.direction);
          if (Math.abs(directionToSide) === 0) {
            var dist = ray.distanceSqToSegment(vecA, vecB, intersectPoint);
            edgeFound = dist === 0;
          }
        }

        if (faceFound || edgeFound) {
          intersectPoint.sub(origin);
          off[forward ? 'min' : 'max'](intersectPoint);
        }
      }
    }
    return off;
  }, offset);
}

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getCentroidByVertices;

var _three = __webpack_require__(0);

function getCentroidByVertices(polyMesh, vertexIndices, worldTransform) {
  var centroid = new _three.Vector3();

  var positions = polyMesh.positions.values;

  if (!polyMesh || positions.length < 1) {
    if (!polyMesh) {
      console.error('No PolyMesh passed to getCentroidByVertices');
    }

    if (worldTransform) {
      centroid.setFromMatrixPosition(worldTransform);
    }

    return centroid;
  }

  var currentVertex = new _three.Vector3();

  if (vertexIndices && vertexIndices.length > 0) {
    for (var _i = 0, _il = vertexIndices.length; _i < _il; _i++) {
      positions.getAt(vertexIndices[_i], currentVertex);
      centroid.add(currentVertex);
    }
    centroid.divideScalar(vertexIndices.length);
  } else {
    // No vertexIndices passes in, center for all vertices
    for (var i = 0, il = positions.length; i < il; i++) {
      positions.getAt(i, currentVertex);
      centroid.add(currentVertex);
    }
    centroid.divideScalar(positions.length);
  }

  if (worldTransform) {
    centroid.applyMatrix4(worldTransform);
  }

  return centroid;
}

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getSelectionIndicesFromWeights;
function getSelectionIndicesFromWeights(weights, softSelectionOnly) {
  var numSelectionIndices = 0;
  var numWeights = weights.length;

  for (var i = 0; i < numWeights; ++i) {
    if (weights[i] > 0 && (!softSelectionOnly || weights[i] !== 1)) {
      numSelectionIndices++;
    }
  }

  var selectionIndices = new Uint32Array(numSelectionIndices);
  var nextSelectionIndex = 0;

  for (var _i = 0; _i < numWeights; ++_i) {
    if (weights[_i] > 0 && (!softSelectionOnly || weights[_i] !== 1)) {
      selectionIndices[nextSelectionIndex++] = _i;
    }
  }

  return selectionIndices;
}

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getSoftSelection;

var _minimumVertexToSelectionDistances = __webpack_require__(436);

var _minimumVertexToSelectionDistances2 = _interopRequireDefault(_minimumVertexToSelectionDistances);

var _calculateFalloffWeights = __webpack_require__(234);

var _calculateFalloffWeights2 = _interopRequireDefault(_calculateFalloffWeights);

var _getSelectionIndicesFromWeights = __webpack_require__(433);

var _getSelectionIndicesFromWeights2 = _interopRequireDefault(_getSelectionIndicesFromWeights);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getSoftSelection(mesh, indices, falloffRadius, falloffCurve, softSelectionOnly) {
  var distances = (0, _minimumVertexToSelectionDistances2.default)(mesh, indices);
  var softSelectionWeights = (0, _calculateFalloffWeights2.default)(distances, falloffRadius, falloffCurve);
  var softSelectionIndices = (0, _getSelectionIndicesFromWeights2.default)(softSelectionWeights, softSelectionOnly);

  return { softSelectionIndices: softSelectionIndices, softSelectionWeights: softSelectionWeights };
}

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extrude_region;

var _three = __webpack_require__(0);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _ObjectBuffer = __webpack_require__(68);

var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _Normals = __webpack_require__(50);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
The Algorithm works as following::

1. Find Boundary Edges for the region.
2. Find Boundary Vertices, which will be inset later.
3. Inset the boundary vertices.
4. Create new inset faces.

Special Handling for vertices seperating multiple islands/regions.
*/

function extrude_region(mesh, insetType, faceSelection, distance, insetOffset, segments) {
  if (!faceSelection) {
    return mesh;
  }

  var selectedFaceList = faceSelection.indices;
  var selectedFaceCount = selectedFaceList.length;
  var segmentCount = segments ? Math.ceil(segments) : 1;

  if (selectedFaceCount === 0 || faceSelection.meaning !== 0) {
    return mesh;
  }

  var faceCount = mesh.faceRangeOffsets.length - 1;
  var faceRangeOffsets = mesh.faceRangeOffsets;
  var positionMap = mesh.positions;
  var positionFaceValueIndices = positionMap.faceValueIndices;
  var faceValueIndicesCount = positionFaceValueIndices.length;
  var positionValues = positionMap.values;
  var positionCount = positionValues.length;
  var positionEdgeVertexAdjacency = positionMap.edgeVertexAdjacency;

  var tmpVector1 = new _three.Vector3();
  var tmpVector2 = new _three.Vector3();
  var tmpVector3 = new _three.Vector3();

  function getFaceNormal(face, optionalResult) {
    var faceIndex = face;
    var faceBegin = faceRangeOffsets[faceIndex];
    var faceUntil = faceRangeOffsets[faceIndex + 1];
    var faceValuesCount = faceUntil - faceBegin;

    var index0 = positionFaceValueIndices[faceBegin];
    var index1 = positionFaceValueIndices[faceBegin + 1];
    var index2 = positionFaceValueIndices[faceBegin + 2];

    positionValues.getAt(index0, tmpVector1);
    positionValues.getAt(index1, tmpVector2);
    positionValues.getAt(index2, tmpVector3);

    tmpVector2.subVectors(tmpVector2, tmpVector1);
    tmpVector3.subVectors(tmpVector3, tmpVector1);

    var faceNormal = optionalResult === undefined ? new _three.Vector3() : optionalResult;
    faceNormal.crossVectors(tmpVector2, tmpVector3);

    return faceNormal;
  }

  // Tag/Identify Boundary Edges, by looping through the selected faces and incrementing the taggings.
  var visitedEdgeList = {};
  var boundaryVertices = {};
  var averageNormal = new _three.Vector3();

  for (var f = 0; f < selectedFaceCount; ++f) {
    var faceIndex = selectedFaceList[f];
    var faceBegin = faceRangeOffsets[faceIndex];
    var faceUntil = faceRangeOffsets[faceIndex + 1];
    var faceValuesCount = faceUntil - faceBegin;
    var normal = getFaceNormal(faceIndex);
    normal.normalize();
    averageNormal.add(normal);

    for (var fv = 0; fv < faceValuesCount; ++fv) {
      var currentPositionIndex = positionFaceValueIndices[faceBegin + fv % faceValuesCount];
      var nextPositionIndex = positionFaceValueIndices[faceBegin + (fv + 1) % faceValuesCount];

      var edgeId = positionEdgeVertexAdjacency.findEdgeId(currentPositionIndex, nextPositionIndex);

      positionValues.getAt(nextPositionIndex, tmpVector1);
      positionValues.getAt(currentPositionIndex, tmpVector2);

      var edgeDirection = new _three.Vector3();
      edgeDirection.subVectors(tmpVector2, tmpVector1);

      edgeDirection.crossVectors(edgeDirection, normal);
      edgeDirection.normalize();

      var edge = visitedEdgeList[edgeId];
      if (edge === undefined) {
        visitedEdgeList[edgeId] = {
          edgeId: edgeId,
          faceId: faceIndex,
          visitedEdgeCount: 1,
          normal: edgeDirection
        };
      } else {
        edge.visitedEdgeCount++;
      }
    }
  }

  averageNormal.normalize();

  /* Update the edge pairs at a given vertex. This function adds edge pairs at a
     given vertex, and adds/remove common edges. If at a vertex there are more
    edges than 1, and if they are not common between two seperate regions like Below,
    it adds the edge pair to that vertex.
       -------
      |     |
      |     |
      |-----|------|
            |      |
            /------|
   */
  function getCommonEdge(e1, e2, e3, e4) {
    var a = void 0,
        b = void 0;

    if (e1 === e3 || e1 === e4) {
      a = e1;
    }
    if (e2 === e3 || e2 === e4) {
      b = e2;
    }
    if (a !== undefined && b !== undefined // Both Edges are common
    ) return -1;

    if (a !== undefined) return a;

    if (b !== undefined) return b;
  }

  function updateEdgePairs(vertex, e1, e2, face) {
    var found = false;
    var edgePairs = vertex.edgePairs;

    for (var e = 0; e < edgePairs.length; e++) {
      var edgePair = edgePairs[e];
      var e1_ = edgePair.e1;
      var e2_ = edgePair.e2;

      var common = getCommonEdge(e1_, e2_, e1, e2);

      if (common !== undefined) {
        if (common === -1) {
          edgePairs.splice(e, 1);
        }
        var other = common === e1 ? e2 : e1;
        if (common === e1_) edgePair.e1 = other;
        if (common === e2_) edgePair.e2 = other;

        edgePair.faces.push(face);

        found = true;
        break;
      }
    }
    if (!found) {
      edgePairs.push({ e1: e1, e2: e2, faces: [face] });
    }
  }

  var boundaryEdgeCount = 0;
  // Find Boundary Vertices
  for (var _f = 0; _f < selectedFaceCount; ++_f) {
    var _faceIndex = selectedFaceList[_f];
    var _faceBegin = faceRangeOffsets[_faceIndex];
    var _faceUntil = faceRangeOffsets[_faceIndex + 1];
    var _faceValuesCount = _faceUntil - _faceBegin;

    for (var _fv = 0; _fv < _faceValuesCount; ++_fv) {
      var _currentPositionIndex = positionFaceValueIndices[_faceBegin + _fv % _faceValuesCount];
      var _nextPositionIndex = positionFaceValueIndices[_faceBegin + (_fv + 1) % _faceValuesCount];
      var tempIndex = _fv === 0 ? _faceValuesCount - 1 : _fv - 1;
      var previousPositionIndex = positionFaceValueIndices[_faceBegin + tempIndex % _faceValuesCount];

      var edgeIdA = positionEdgeVertexAdjacency.findEdgeId(_currentPositionIndex, _nextPositionIndex);

      var edgeIdB = positionEdgeVertexAdjacency.findEdgeId(_currentPositionIndex, previousPositionIndex);

      if (visitedEdgeList[edgeIdA].visitedEdgeCount === 1) boundaryEdgeCount++;

      var vertex = boundaryVertices[_currentPositionIndex];
      if (vertex === undefined) {
        // boundaryVertices[currentPositionIndex] = { vertexId: currentPositionIndex , edgePairs: [edgeIdA, edgeIdB], faces: [faceIndex], indices: [] };
        var edgePair = { e1: edgeIdA, e2: edgeIdB, faces: [_faceIndex] };
        boundaryVertices[_currentPositionIndex] = {
          vertexId: _currentPositionIndex,
          edgePairs: [edgePair]
        };
      } else {
        updateEdgePairs(vertex, edgeIdA, edgeIdB, _faceIndex);
      }
    }
  }
  // Remove Interior Vertices.
  var tempVertices = boundaryVertices;
  boundaryVertices = {};
  for (var key in tempVertices) {
    var _vertex = tempVertices[key];
    if (_vertex.edgePairs.length === 0) continue;

    boundaryVertices[key] = _vertex;
  }

  // Edge Reduction. This goes through a set of edges, and reduce them if there are common ones.
  function reduceEdges(edgePairs) {
    // for( let i = 0; i < edgePairs.length; i ++ )
    var start = 0;
    {
      for (var j = start + 1; j < edgePairs.length; j++) {
        var epA = edgePairs[start];
        var epB = edgePairs[j];
        var common = getCommonEdge(epA.e1, epA.e2, epB.e1, epB.e2);
        if (common !== undefined) {
          if (common === -1) {
            edgePairs.splice(start, 1);
            edgePairs.splice(j - 1, 1);
          } else {
            var other = common === epB.e1 ? epB.e2 : epB.e1;
            if (common === epA.e1) epA.e1 = other;
            if (common === epA.e2) epA.e2 = other;
            edgePairs.splice(j, 1);
          }
          j = start;
        }
        if (j === edgePairs.length - 1) {
          start++;
          j = start;
        }
      }
    }
  }

  for (var _key in boundaryVertices) {
    var _vertex2 = boundaryVertices[_key];
    var edgePairs = _vertex2.edgePairs;
    reduceEdges(edgePairs);
  }

  var result = [];

  var newFaceRangeOffsets = new Uint32Array(faceRangeOffsets.length + boundaryEdgeCount * segmentCount);
  var newPositionFaceValueIndices = new Uint32Array(faceValueIndicesCount + 4 * boundaryEdgeCount * segmentCount);

  // Find a sharing edge between two faces, if it exists.
  function getSharingEdge(faceA, faceB) {
    var faces = [faceA, faceB];
    var vertices = {};
    var sharedVertices = [];

    for (var _f2 = 0; _f2 < 2; ++_f2) {
      var _faceIndex2 = faces[_f2];
      var _faceBegin2 = faceRangeOffsets[_faceIndex2];
      var _faceUntil2 = faceRangeOffsets[_faceIndex2 + 1];
      var _faceValuesCount2 = _faceUntil2 - _faceBegin2;

      for (var _fv2 = 0; _fv2 < _faceValuesCount2; ++_fv2) {
        var _currentPositionIndex2 = positionFaceValueIndices[_faceBegin2 + _fv2 % _faceValuesCount2];
        var _vertex3 = vertices[_currentPositionIndex2];
        if (_vertex3 === undefined) {
          vertices[_currentPositionIndex2] = {
            vertexId: _currentPositionIndex2,
            visitedCount: 1
          };
        } else {
          _vertex3.visitedCount++;
          if (_vertex3.visitedCount > 1) {
            sharedVertices.push(_vertex3.vertexId);
          }
        }
      }
    }

    if (sharedVertices.length < 2) return;

    var edgeId = positionEdgeVertexAdjacency.findEdgeId(sharedVertices[0], sharedVertices[1]);
    return edgeId;
  }

  // Copy old positions
  var positionBuffer = new _ObjectBuffer2.default(_three.Vector3);
  for (var v = 0; v < positionCount; ++v) {
    positionValues.getAt(v, tmpVector1);
    positionBuffer.push(tmpVector1);
  }
  // Copy Old indices
  for (var _fv3 = 0; _fv3 < faceValueIndicesCount; ++_fv3) {
    newPositionFaceValueIndices[_fv3] = positionFaceValueIndices[_fv3];
  }
  // Copy Old faceRangeOffsets
  for (var _f3 = 0; _f3 < faceRangeOffsets.length; ++_f3) {
    newFaceRangeOffsets[_f3] = faceRangeOffsets[_f3];
  }

  // Calculate Split Vertices
  var index = positionCount;
  var useEvenOffset = true;

  var offsetSegment = insetOffset / segmentCount;
  var offset = 0;
  var numBoundaryVertices = 0;

  // Parabolic bevel function.
  var getOffset = function getOffset(t) {
    return distance * Math.sqrt(t);
  };

  // Find Inset Vertices
  for (var s = 0; s < segmentCount; ++s) {
    for (var _key2 in boundaryVertices) {
      var t = (s + 1) / segmentCount;
      var heightOffset = getOffset(t);

      var _vertex4 = boundaryVertices[_key2];

      var numEdgePairs = _vertex4.edgePairs.length;

      for (var i = 0; i < numEdgePairs; i++) {
        offset = offsetSegment * (s + 1);

        var vertexId = _vertex4.vertexId;

        var edgeA = _vertex4.edgePairs[i].e1;
        var edgeB = _vertex4.edgePairs[i].e2;

        var n1 = visitedEdgeList[edgeA].normal;
        var n2 = visitedEdgeList[edgeB].normal;

        tmpVector1.addVectors(n1, n2);
        tmpVector1.normalize();

        // make the offset more even.
        if (useEvenOffset) {
          var cosTheta = tmpVector1.dot(n1);
          offset = cosTheta !== 0 ? offset / cosTheta : offset;
        }

        // Find corresponding faces of the coinciding boundary edges
        var faceA = visitedEdgeList[edgeA].faceId;
        var faceB = visitedEdgeList[edgeB].faceId;

        // If the faces are different, we need to find the sharing edge, if it exists.
        if (faceA !== faceB) {
          var sharingEdge = getSharingEdge(faceA, faceB);

          if (sharingEdge !== undefined) {
            positionEdgeVertexAdjacency.getVerticesForEdge(sharingEdge, result);
            positionValues.getAt(result[0], tmpVector2);
            positionValues.getAt(result[1], tmpVector3);

            if (result[0] === vertexId) {
              tmpVector1.subVectors(tmpVector3, tmpVector2);
            } else {
              tmpVector1.subVectors(tmpVector2, tmpVector3);
            }
            tmpVector1.normalize();
          }
        }

        // Calculate Split Vertex position
        positionValues.getAt(vertexId, tmpVector2);
        var insetPosition = new _three.Vector3();
        insetPosition.copy(tmpVector2);
        insetPosition.addScaledVector(tmpVector1, offset);
        insetPosition.addScaledVector(averageNormal, heightOffset);

        positionBuffer.push(insetPosition); // Add new inset position

        if (_vertex4.edgePairs.length === 1) {
          // Vertex dosen't split
          _vertex4.edgePairs[0].vertexIndex = index;
        } else {
          // Vertex splits here
          if (s === segmentCount - 1) {
            _vertex4.edgePairs[i].vertexIndex = index;
          }
        }

        index++;
        numBoundaryVertices++;
      }
    }
  }

  index = faceValueIndicesCount;
  var faceCountIndex = faceRangeOffsets.length;
  numBoundaryVertices /= segmentCount;

  /* Find which split vertex index to use, given a face from a region.
     required for vertices at which there are more than 1 edge pairs.
  */
  function getVertexIndexForFace(vertex, face) {
    if (vertex.edgePairs.length == 1) {
      return vertex.edgePairs[0].vertexIndex;
    }

    var edgePairs = vertex.edgePairs;
    var index = -1;

    for (var _i = 0; _i < edgePairs.length; _i++) {
      var _edgePair = edgePairs[_i];
      var faces = _edgePair.faces;

      for (var j = 0; j < faces.length; j++) {
        if (face === faces[j]) {
          index = _edgePair.vertexIndex;
          return index;
        }
      }
    }

    return index;
  }

  // Create New Faces
  for (var _f4 = 0; _f4 < selectedFaceCount; ++_f4) {
    var _faceIndex3 = selectedFaceList[_f4];
    var _faceBegin3 = faceRangeOffsets[_faceIndex3];
    var _faceUntil3 = faceRangeOffsets[_faceIndex3 + 1];
    var _faceValuesCount3 = _faceUntil3 - _faceBegin3;

    for (var _s = 0; _s < segmentCount; ++_s) {
      for (var _fv4 = 0; _fv4 < _faceValuesCount3; ++_fv4) {
        var _currentPositionIndex3 = positionFaceValueIndices[_faceBegin3 + _fv4 % _faceValuesCount3];
        var _nextPositionIndex2 = positionFaceValueIndices[_faceBegin3 + (_fv4 + 1) % _faceValuesCount3];

        var vertexA = boundaryVertices[_currentPositionIndex3];
        var vertexB = boundaryVertices[_nextPositionIndex2];

        // The interior vertices must be extruded to the extrusion height
        if (vertexA === undefined) {
          positionBuffer.getAt(_currentPositionIndex3, tmpVector1);
          tmpVector1.addScaledVector(averageNormal, distance / _faceValuesCount3 / segmentCount);
          positionBuffer.setAt(_currentPositionIndex3, tmpVector1);
          continue;
        }

        var indexA = getVertexIndexForFace(vertexA, _faceIndex3);
        /* The original face is removed and is replaced by a new inset face.
           That means that the facerangeoffsets are the same, just the indices are changed
           to new values. Below is the index of the split vertex.*/
        newPositionFaceValueIndices[_faceBegin3 + _fv4 % _faceValuesCount3] = indexA;

        var _edgeId = positionEdgeVertexAdjacency.findEdgeId(_currentPositionIndex3, _nextPositionIndex2);

        var _edge = visitedEdgeList[_edgeId];

        if (_edge === undefined // No Edge found.
        ) continue;

        var visitedEdgeCount = _edge.visitedEdgeCount;

        if (visitedEdgeCount > 1 // Not a boundary
        ) continue;

        var indexB = getVertexIndexForFace(vertexB, _faceIndex3);

        // Form New Faces for edge formed by vertexA and vertexB
        if (_s === 0) {
          newPositionFaceValueIndices[index++] = _currentPositionIndex3;
          newPositionFaceValueIndices[index++] = _nextPositionIndex2;
          newPositionFaceValueIndices[index++] = indexB - (segmentCount - 1) * numBoundaryVertices;
          newPositionFaceValueIndices[index++] = indexA - (segmentCount - 1) * numBoundaryVertices;
        } else {
          newPositionFaceValueIndices[index++] = indexA - (segmentCount - _s) * numBoundaryVertices;
          newPositionFaceValueIndices[index++] = indexB - (segmentCount - _s) * numBoundaryVertices;
          newPositionFaceValueIndices[index++] = indexB - (segmentCount - _s - 1) * numBoundaryVertices;
          newPositionFaceValueIndices[index++] = indexA - (segmentCount - _s - 1) * numBoundaryVertices;
        }

        newFaceRangeOffsets[faceCountIndex] = newFaceRangeOffsets[faceCountIndex - 1] + 4;
        faceCountIndex++;
      }
    }
  }

  newFaceRangeOffsets[faceCountIndex] = newFaceRangeOffsets[faceCountIndex - 1] + 4;

  // Create new PolyMesh
  var newMesh = new _PolyMesh2.default();
  var newPositionValues = new _ObjectArrayView2.default(_three.Vector3, positionBuffer.length);
  newPositionValues.fromArray(positionBuffer.toArray());

  var newPositionMap = {
    faceRangeOffsets: newFaceRangeOffsets,
    faceValueIndices: newPositionFaceValueIndices,
    values: newPositionValues
  };

  newMesh.faceRangeOffsets = newFaceRangeOffsets;
  newMesh.positions = new _PolyMap2.default(newPositionMap);
  var newFaceValuesCount = newPositionFaceValueIndices.length;

  if (mesh.normalMap) {
    var normalMap = mesh.normalMap;
    var normalFaceValueIndices = normalMap.faceValueIndices;
    var normalValues = normalMap.values;
    var sharedNormalList = new Uint32Array(normalValues.length);

    for (var _i2 = 0; _i2 < normalFaceValueIndices.length; ++_i2) {
      sharedNormalList[normalFaceValueIndices[_i2]] += 1;
    }

    var newNormalFaceValueIndices = new Uint32Array(newFaceValuesCount);
    var normalIndex = normalValues.length;

    for (var _fv5 = 0; _fv5 < faceValueIndicesCount; ++_fv5) {
      newNormalFaceValueIndices[_fv5] = normalFaceValueIndices[_fv5];
    }

    for (var _fv6 = faceValueIndicesCount; _fv6 < newFaceValuesCount; ++_fv6) {
      newNormalFaceValueIndices[_fv6] = normalIndex++;
    }

    var newNormalValues = new _ObjectArrayView2.default(_three.Vector3, normalIndex);

    var newNormalMap = {
      faceRangeOffsets: newFaceRangeOffsets,
      faceValueIndices: newNormalFaceValueIndices,
      values: newNormalValues
    };

    newMesh.normalMap = new _PolyMap2.default(newNormalMap);
    newMesh.normalMap = (0, _Normals.recalculateNormalsFromConnectivity)(newMesh).normalMap;
  }

  if (mesh.uvMaps) {}

  return new _PolyMesh2.default(newMesh);
}

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = minimumVertexToSelectionDistances;

var _three = __webpack_require__(0);

function minimumVertexToSelectionDistances(mesh, selectionIndices) {
  var positions = mesh.positions.values;
  var positionsLength = positions.length;
  var selectionIndicesLength = selectionIndices.length;

  var minDistances = new Float32Array(positionsLength);

  var currentVertex = new _three.Vector3();
  var selectionVertex = new _three.Vector3();

  for (var i = 0; i < positionsLength; ++i) {
    var minDistance = Infinity;
    positions.getAt(i, currentVertex);

    for (var j = 0; j < selectionIndicesLength; ++j) {
      positions.getAt(selectionIndices[j], selectionVertex);
      minDistance = Math.min(minDistance, currentVertex.distanceTo(selectionVertex));
    }

    minDistances[i] = minDistance;
  }

  return minDistances;
}

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = polyMeshValidation;

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isVec3NaN = function isVec3NaN(v) {
  return isNaN(v.x) || isNaN(v.y) || isNaN(v.z);
};

var isVec3Zero = function isVec3Zero(v) {
  return v.length() === 0;
};

var isVec2NaN = function isVec2NaN(v) {
  return isNaN(v.x) || isNaN(v.y);
};

var validateValues = function validateValues(polyMapName, values, validationFunc) {
  //console.log( polyMapName, values.length );
  var temp = new values.type();
  var replacement = new values.type();
  for (var i = 0; i < values.length; i++) {
    values.getAt(i, temp);
    if (!validationFunc(temp)) {
      //console.log( "  badValue at " + i + " is ", temp );
      values.setAt(i, replacement);
    }
  }
};

function polyMeshValidation(mesh) {
  validateValues('positions', mesh.positions.values, function (v) {
    return !isVec3NaN(v);
  });

  if (mesh.normalMap) {
    validateValues('normalMap', mesh.normalMap.values, function (v) {
      return !isVec3NaN(v) && !isVec3Zero(v);
    });
  }

  if (mesh.uvMaps) {
    var uvMaps = new _ObjectsByName2.default();
    for (var i = 0; i < mesh.uvMaps.length; i++) {
      var name = mesh.uvMaps.namesByIndex[i];
      validateValues('uvMap[' + name + ']', mesh.uvMaps.byName[name].values, function (v) {
        return !isVec2NaN(v);
      });
    }
  }

  return mesh;
}

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = __webpack_require__(257);

var _map2 = _interopRequireDefault(_map);

exports.default = removeDuplicateIndices;

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _ObjectBuffer = __webpack_require__(68);

var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removeDuplicateIndices(polyMesh, withLogging) {
  var l = withLogging || false;

  var faceRangeOffsets = new Uint32Array(polyMesh.positions.faceRangeOffsets);
  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
  var normalFaceValueIndices = new Uint32Array(polyMesh.normalMap.faceValueIndices);

  var uvMapNames = [];
  var uvMapsNewIndices = [];
  if (polyMesh.uvMaps) {
    for (var i = 0; i < polyMesh.uvMaps.length; i++) {
      uvMapNames.push(polyMesh.uvMaps.namesByIndex[i]);
      uvMapsNewIndices.push(new Uint32Array(polyMesh.uvMaps.byName[uvMapNames[i]].faceValueIndices));
    }
  }

  var newIndicesMarker = 0;

  var previousFaceIndex = 0;
  var currentFaceIndex = 0;
  var currentFaceSize = 0;
  var newFaceSize = 0;

  //stores [index value, index];
  var uniqueIndicesMap = new _map2.default();

  //Check every face
  for (var _i = 1; _i < faceRangeOffsets.length; _i++) {
    currentFaceIndex = faceRangeOffsets[_i];
    currentFaceSize = currentFaceIndex - previousFaceIndex;
    newFaceSize = currentFaceSize;

    //check unique
    uniqueIndicesMap.clear();
    for (var j = 0; j < currentFaceSize; j++) {
      uniqueIndicesMap.set(faceValueIndices[previousFaceIndex + j], previousFaceIndex + j);
    }

    newFaceSize = uniqueIndicesMap.size;
    //special case face of size 1
    if (newFaceSize === 1) {
      if (l && currentFaceSize > 1) console.log('Face ' + _i + ' has only 1 unique value. Reducing to a point...');
      faceRangeOffsets[_i] = faceRangeOffsets[_i - 1] + 1;
      faceValueIndices[newIndicesMarker++] = faceValueIndices[previousFaceIndex];
    } else {
      if (l && currentFaceSize === 2) console.log('Face ' + _i + ' has only 2 unique values. Reducing to a line...');

      faceRangeOffsets[_i] = faceRangeOffsets[_i - 1] + newFaceSize;
      var entries = uniqueIndicesMap.entries();

      var element = void 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(entries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          element = _step.value;

          normalFaceValueIndices[newIndicesMarker] = normalFaceValueIndices[element[1]];
          for (var k = 0; k < uvMapsNewIndices.length; k++) {
            uvMapsNewIndices[k][newIndicesMarker] = uvMapsNewIndices[k][element[1]];
          }

          faceValueIndices[newIndicesMarker++] = element[0];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    previousFaceIndex = currentFaceIndex;
  }

  if (l) console.log('' + faceValueIndices.length + ' index values reduced to ' + newIndicesMarker + ', duplicates removed: ' + (faceValueIndices.length - newIndicesMarker));

  var newIndices = new Uint32Array(faceValueIndices.subarray(0, newIndicesMarker));
  var newNormalIndices = new Uint32Array(normalFaceValueIndices.subarray(0, newIndicesMarker));

  var positions = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: newIndices,
    values: polyMesh.positions.values
  });

  var meshObj = {};
  meshObj.positions = positions;
  meshObj.faceRangeOffsets = meshObj.positions.faceRangeOffsets;

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: meshObj.faceRangeOffsets,
    faceValueIndices: newNormalIndices,
    values: polyMesh.normalMap.values
  });
  meshObj.normalMap = normalMap;

  if (polyMesh.uvMaps) {
    var uvMaps = new _ObjectsByName2.default();
    for (var _i2 = 0; _i2 < polyMesh.uvMaps.length; _i2++) {
      var name = polyMesh.uvMaps.namesByIndex[_i2];
      var uvMap = new _PolyMap2.default({
        faceRangeOffsets: meshObj.faceRangeOffsets,
        faceValueIndices: uvMapsNewIndices[_i2],
        values: polyMesh.uvMaps.byName[name].values
      });
      uvMaps.set(name, uvMap);
    }

    meshObj.uvMaps = uvMaps;
  }

  meshObj.colorMaps = polyMesh.colorMaps;

  var results = new _PolyMesh2.default((0, _assign2.default)({}, polyMesh, meshObj));
  return results;
}

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeInvalidSurfaces;

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _removeUnusedValues = __webpack_require__(237);

var _removeUnusedValues2 = _interopRequireDefault(_removeUnusedValues);

var _applyFunctionToPolyMap = __webpack_require__(157);

var _applyFunctionToPolyMap2 = _interopRequireDefault(_applyFunctionToPolyMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removeInvalidSurfaces(polyMesh, withLogging) {
  //this algorithm assumes no duplicate indices
  //to remove those use removeDuplicateIndices first

  function removeInvalidSurfacesFromMap(polyMap, polyMapName, additionalArguments) {
    var l = additionalArguments.withLogging || false;

    var faceRangeOffsets = new Uint32Array(polyMap.faceRangeOffsets);
    var faceValueIndices = new Uint32Array(polyMap.faceValueIndices);
    var values = polyMap.values;

    var currentFaceIndex = 0;
    var previousFaceIndex = 0;
    var size = 0;

    var newFacesMarker = 1;
    var newIndicesMarker = 0;

    for (var i = 1; i < faceRangeOffsets.length; i++) {
      currentFaceIndex = faceRangeOffsets[i];
      size = currentFaceIndex - previousFaceIndex;

      if (size > 2) {
        //store face
        faceRangeOffsets[newFacesMarker] = faceRangeOffsets[newFacesMarker - 1] + size;
        newFacesMarker++;

        //store all the indices on that face
        for (var j = 0; j < size; j++) {
          faceValueIndices[newIndicesMarker++] = faceValueIndices[previousFaceIndex + j];
        }
      } else if (l) {
        console.log('Removed face ' + i + ' of size ' + size);
      }

      previousFaceIndex = currentFaceIndex;
    }

    var newFaceRangeOffsets = new Uint32Array(faceRangeOffsets.subarray(0, newFacesMarker));
    var newFaceValueIndices = new Uint32Array(faceValueIndices.subarray(0, newIndicesMarker));

    var resultMap = new _PolyMap2.default({
      faceRangeOffsets: newFaceRangeOffsets,
      faceValueIndices: newFaceValueIndices,
      values: values
    });
    return resultMap;
  }

  var args = { withLogging: withLogging };
  var resultMesh = (0, _applyFunctionToPolyMap2.default)(polyMesh, removeInvalidSurfacesFromMap, args);

  if (withLogging) console.log('' + (polyMesh.faceRangeOffsets.length - 1) + ' faces reduced to ' + (resultMesh.faceRangeOffsets.length - 1) + ', faces removed: ' + (polyMesh.faceRangeOffsets.length - resultMesh.faceRangeOffsets.length));

  return (0, _removeUnusedValues2.default)(resultMesh).topologyChanged(true);
}

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setNormalsFromSmoothingGroups;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _Normals = __webpack_require__(50);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function setNormalsFromSmoothingGroups(polyMesh, smoothingGroups) {
  if (!polyMesh || !smoothingGroups) return polyMesh;

  var faceRangeOffsets = polyMesh.faceRangeOffsets;
  var faceValueIndices = polyMesh.positions.faceValueIndices;
  var values = polyMesh.positions.values;
  var normalMapFaceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices.length);

  if (faceRangeOffsets.length - 1 !== smoothingGroups.length) {
    console.error('Number of smoothing groups does not match number of faces: ', faceRangeOffsets.length - 1, smoothingGroups.length);
    return polyMesh;
  }

  var valueAdjacency = polyMesh.positions.valueAdjacency;
  var faceFaceAdjacency = polyMesh.positions.faceFaceAdjacency;

  var normalIndex = 0;

  function setNormalIndex(vertexIndex, face, index) {
    var faceArray = [];
    for (var j = faceRangeOffsets[face]; j < faceRangeOffsets[face + 1]; j++) {
      faceArray.push(faceValueIndices[j]);
      if (faceValueIndices[j] === vertexIndex) {
        normalMapFaceValueIndices[j] = index;
        return;
      }
    }

    console.error('index ' + vertexIndex + ' is not on face ' + face, faceArray);
  }

  //for every vertex
  for (var i = 0; i < values.length; i++) {
    var numFacesOnVertex = valueAdjacency.getNumFacesForVertex(i);
    var facesOnVertex = [];
    var faceNormalMapping = [];

    //get faces on vertex
    for (var j = 0; j < numFacesOnVertex; j++) {
      facesOnVertex.push(valueAdjacency.getFaceForVertexId(i, j));
      faceNormalMapping.push(-1);
    }

    //for every face around vertex
    for (var _j = 0; _j < facesOnVertex.length; _j++) {
      if (faceNormalMapping[_j] > -1) continue;

      var startFace = facesOnVertex[_j];
      var startFaceAdjacentFaces = faceFaceAdjacency.adjacentFacesOnVertex(facesOnVertex[_j], i);

      var facesInGroup = [];
      facesInGroup.push(startFace);

      var current = startFace;
      var next = startFaceAdjacentFaces[0];
      var nextNext = -1;

      //walk around the left, and then the right
      for (var k = 0; k < startFaceAdjacentFaces.length; k++) {
        //walk around the faces around the vertex
        for (var f = 0; f < facesOnVertex.length; f++) {
          if (next === startFace || faceNormalMapping[facesOnVertex.indexOf(next)] > -1 || (smoothingGroups[current] & smoothingGroups[next]) === 0) {
            //full circle, already alocated or hard edge
            break;
          }
          //else face add to smoothing group
          facesInGroup.push(next);
          var nextAdjacentFaces = faceFaceAdjacency.adjacentFacesOnVertex(next, i);
          //edge found
          if (nextAdjacentFaces.length < 2) break;

          nextNext = nextAdjacentFaces[0] === current ? nextAdjacentFaces[1] : nextAdjacentFaces[0];
          current = next;
          next = nextNext;
        }

        //walk the other way on the next
        current = startFace;
        next = startFaceAdjacentFaces[1];
        nextNext = -1;
      }

      for (var _k = 0; _k < facesInGroup.length; _k++) {
        setNormalIndex(i, facesInGroup[_k], normalIndex);
        faceNormalMapping[facesOnVertex.indexOf(facesInGroup[_k])] = normalIndex;
      }

      if (facesInGroup.length > 0) normalIndex++;
    }
  }

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: polyMesh.faceRangeOffsets,
    faceValueIndices: normalMapFaceValueIndices,
    values: new _ObjectArrayView2.default(_three.Vector3, normalIndex)
  });

  var resultMesh = new _PolyMesh2.default(polyMesh);
  resultMesh.normalMap = normalMap;

  return (0, _Normals.recalculateNormalsFromConnectivity)(resultMesh);
}

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = shearPolyMesh;

var _three = __webpack_require__(0);

var _stringIndicesToArray = __webpack_require__(69);

var _stringIndicesToArray2 = _interopRequireDefault(_stringIndicesToArray);

var _Normals = __webpack_require__(50);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function shearPolyMesh(polyMesh, center, rotationDeg, shearFactor, vertexIndicesStr, updateNormals) {
  var oldPositions = polyMesh.positions.values;
  var newPositions = oldPositions.clone();

  var rotationRad = rotationDeg.clone().multiplyScalar(Math.PI / 180);
  var rotationEuler = new _three.Euler().setFromVector3(rotationRad, 'ZYX');
  var rotationMatrix = new _three.Matrix4().makeRotationFromEuler(rotationEuler);

  var planeNormal = new _three.Vector3(0, 0, 1);
  planeNormal.applyMatrix4(rotationMatrix);
  var planeConstant = center.dot(planeNormal);

  var shearDirection = new _three.Vector3(1, 0, 0); //default shear in positive x direction
  shearDirection.applyMatrix4(rotationMatrix); //positive x direction gets rotated according to chosen rotation

  var indices = (0, _stringIndicesToArray2.default)(vertexIndicesStr);
  var numOfIndices = void 0;
  if (indices.length) {
    numOfIndices = indices.length;
  } else {
    //if no vertex select, then we want to loop through all of them
    numOfIndices = oldPositions.length;
  }

  var position = new _three.Vector3();
  var movementVec = new _three.Vector3();
  var distanceToPlane = void 0;
  var index = void 0;
  for (var i = 0; i < numOfIndices; ++i) {
    if (indices.length) {
      index = indices[i];
    } else {
      index = i;
    }

    if (index >= oldPositions.length) {
      continue;
    }

    oldPositions.getAt(index, position);
    distanceToPlane = (position.dot(planeNormal) - planeConstant) / planeNormal.length();
    movementVec.copy(shearDirection);
    //move the position in the shear direction, based on distance to plane and shear factor
    position.add(movementVec.multiplyScalar(distanceToPlane * shearFactor));
    newPositions.setAt(index, position);
  }

  var newPolyMap = new _PolyMap2.default(_PolyMaps2.default.resolveMap(polyMesh, 'positions'));
  newPolyMap.values = newPositions;
  var newObject = (0, _assign2.default)({}, polyMesh, { positions: newPolyMap });
  polyMesh = (0, _Normals.recalculateNormalsFromConnectivity)(new _PolyMesh2.default(newObject));

  return polyMesh;
}

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sortFacesByAxis;

var _three = __webpack_require__(0);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _applyFunctionToPolyMap = __webpack_require__(157);

var _applyFunctionToPolyMap2 = _interopRequireDefault(_applyFunctionToPolyMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sortFacesByAxis(polyMesh, axis, withLogging) {
  function reorderFacesOnPolymap(polyMap, polyMapName, additionalArguments) {
    var newFaceRangeOffsets = additionalArguments.newFaceRangeOffsets;
    var reMapping = additionalArguments.reMapping;

    var faceRangeOffsets = polyMap.faceRangeOffsets;
    var faceValueIndices = polyMap.faceValueIndices;
    var newFaceValueIndices = new Uint32Array(faceValueIndices.length);
    var newFaceValueIndicesMarker = 0;

    for (var i = 0; i < reMapping.length; i++) {
      for (var j = faceRangeOffsets[reMapping[i]]; j < faceRangeOffsets[reMapping[i] + 1]; j++) {
        newFaceValueIndices[newFaceValueIndicesMarker++] = faceValueIndices[j];
      }
    }

    var newPolyMap = new _PolyMap2.default({
      faceRangeOffsets: newFaceRangeOffsets,
      faceValueIndices: newFaceValueIndices,
      values: polyMap.values
    });

    return newPolyMap;
  }

  var l = withLogging || false;
  if (!axis || !polyMesh) return polyMesh;
  if (axis.x === 0 && axis.y === 0 && axis.z === 0) return polyMesh;

  var faceRangeOffsets = polyMesh.faceRangeOffsets;
  var newFaceRangeOffsets = new Uint32Array(polyMesh.faceRangeOffsets.length);
  var faceValueIndices = new Uint32Array(polyMesh.positions.faceValueIndices);
  var values = polyMesh.positions.values;

  //create a mapping for the faces (0, 1, 2, 3, 4...)
  var faces = [];
  var faceDistances = [];

  var centroid = new _three.Vector3();
  var tempValue = new _three.Vector3();

  for (var i = 0; i < faceRangeOffsets.length - 1; i++) {
    faces[i] = i;

    var faceStart = faceRangeOffsets[i];
    var faceEnd = faceRangeOffsets[i + 1];

    centroid.set(0, 0, 0);
    for (var j = faceStart; j < faceEnd; j++) {
      values.getAt(faceValueIndices[j], tempValue);
      centroid.add(tempValue);
    }

    centroid.multiplyScalar(1 / (faceEnd - faceStart));

    //projection of v1 and v2 on camera axis compare magnitudes
    faceDistances[i] = centroid.dot(axis);
  }

  //sort the face mapping by the values of their indices
  faces.sort(function (a, b) {
    return faceDistances[b] - faceDistances[a];
  });

  for (var _i = 0; _i < faces.length; _i++) {
    newFaceRangeOffsets[_i + 1] = newFaceRangeOffsets[_i] + (faceRangeOffsets[faces[_i] + 1] - faceRangeOffsets[faces[_i]]);
  }

  if (l) {
    //print out all the faces to compare old and new
    console.log('Face List [old][new]:');
    for (var _i2 = 0; _i2 < faces.length; _i2++) {
      var face = [];
      var newFace = [];
      for (var _j = faceRangeOffsets[_i2]; _j < faceRangeOffsets[_i2 + 1]; _j++) {
        face.push(faceValueIndices[_j]);
      }

      for (var _j2 = faceRangeOffsets[faces[_i2]]; _j2 < faceRangeOffsets[faces[_i2] + 1]; _j2++) {
        newFace.push(faceValueIndices[_j2]);
      }

      console.log(face, newFace);
    }
  }

  var args = { newFaceRangeOffsets: newFaceRangeOffsets, reMapping: faces };
  return (0, _applyFunctionToPolyMap2.default)(polyMesh, reorderFacesOnPolymap, args).topologyChanged();
}

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = stretchPolyMesh;

var _three = __webpack_require__(0);

var _ = __webpack_require__(161);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stretchPolyMesh(mesh, axis, margin, stretchDistance) {
  var boundingBox = mesh.boundingBox;
  var min = boundingBox.min[axis];
  var max = boundingBox.max[axis];
  var boundingBoxLength = max - min;

  var newMargin = margin > boundingBoxLength / 2 ? boundingBoxLength / 2 : margin;
  var stretchBoxLength = boundingBoxLength - 2 * newMargin;
  var scaleFactor = (stretchBoxLength + 2 * stretchDistance) / stretchBoxLength;

  var scale = new _three.Vector3(1, 1, 1);
  scale[axis] = scaleFactor;
  var stretchTranslation = new _three.Matrix4().makeScale(scale.x, scale.y, scale.z);

  var positions = _.PolyMaps.resolveMap(mesh, 'positions');
  var newMapValues = positions.values.clone();
  var vertexPosition = new _three.Vector3();

  for (var i = 0; i < newMapValues.length; i += 1) {
    positions.values.getAt(i, vertexPosition);
    if (vertexPosition[axis] < min + newMargin) {
      vertexPosition[axis] -= stretchDistance;
    } else if (vertexPosition[axis] >= max - newMargin) {
      vertexPosition[axis] += stretchDistance;
    } else {
      vertexPosition.applyMatrix4(stretchTranslation);
    }
    newMapValues.setAt(i, vertexPosition);
  }

  var newPolyMap = new _.PolyMap((0, _assign2.default)({}, positions, { values: newMapValues }));
  var newObject = (0, _assign2.default)({}, mesh, { positions: newPolyMap });

  return new _.PolyMesh(newObject);
}

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = subdivision;

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _polyMeshValidation = __webpack_require__(437);

var _polyMeshValidation2 = _interopRequireDefault(_polyMeshValidation);

var _removeDuplicateNormals = __webpack_require__(159);

var _removeDuplicateNormals2 = _interopRequireDefault(_removeDuplicateNormals);

var _three = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// based on theory given on pages 623-624 of "Real-Time Rendering"
var subdividePolyMap = function subdividePolyMap(polyMap, newFaceRangeOffsets, faceEdgeCreases, faceValueCorners) {
  var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;
  var valueAdjacency = polyMap.valueAdjacency;
  var faceEdgeAdjacency = polyMap.faceEdgeAdjacency;
  /*
  if(!faceEdgeAdjacency.checkValidity()){
    throw 'This polymap contains an invalid surface and cannot be subdivided. Edge Adjacency will fail.';
  }//*/

  var values = polyMap.values;
  var valueType = values.type;
  var numValues = values.length;
  var faceRangeOffsets = polyMap.faceRangeOffsets;
  var numFaces = faceRangeOffsets.length - 1;
  var faceValueIndices = polyMap.faceValueIndices;
  var numEdges = edgeVertexAdjacency.getNumEdges();
  var numNewFaces = faceValueIndices.length;

  var vertexCorners = new Uint8Array(polyMap.values.length);
  for (var i = 0; i < faceValueCorners.length; i++) {
    vertexCorners[faceValueIndices[i]] = faceValueCorners[i];
  }

  if (!newFaceRangeOffsets) {
    newFaceRangeOffsets = new Uint32Array(numNewFaces + 1);
    for (var f = 0; f < newFaceRangeOffsets.length; f++) {
      newFaceRangeOffsets[f] = f * 4;
    }
  }

  var numNewFaceValueIndices = numNewFaces * 4;
  var newFaceValueIndices = new Uint32Array(numNewFaceValueIndices);

  // pre allocate all new vertices
  //    updated vertices (V) + edge centroids (E) + face centroids (V)
  var edgeOffset = numValues;
  var faceOffset = edgeOffset + numEdges;
  var numNewValues = numValues + numEdges + numFaces;
  var newValues = new _ObjectArrayView2.default(valueType, numNewValues);

  var valueEdgeValence = new Uint8Array(numValues);
  var valueFaceValence = new Uint8Array(numValues);
  var edgeFaceValence = new Uint8Array(numEdges);
  var edgeUnique = new Uint8Array(numEdges);

  var tempFaceCentroid = new valueType();
  var tempValue = new valueType();
  var tempNextValue = new valueType();
  var tempEdgeCentroid = new valueType();
  var tempConnectedValue = new valueType();
  var tempConnectedFace = new valueType();

  var nf = 0;

  var edgeCreases = new Uint8Array(numEdges);
  var valueCreases = new Uint8Array(numValues);

  for (var _f = 0; _f < numFaces; _f++) {
    var faceBegin = faceRangeOffsets[_f];
    var faceUntil = faceRangeOffsets[_f + 1];
    var numFaceValues = faceUntil - faceBegin;

    var vNext = faceValueIndices[faceBegin];
    var vNextNext = faceValueIndices[faceBegin + 1 % numFaceValues];

    var eNext = edgeVertexAdjacency.findEdgeId(vNext, vNextNext);

    // calculate face centroid
    tempFaceCentroid.multiplyScalar(0.0);

    for (var fv = 0; fv < numFaceValues; fv++) {
      var v = vNext;
      vNext = vNextNext;
      vNextNext = faceValueIndices[faceBegin + (fv + 2) % numFaceValues];

      var e = eNext;
      eNext = edgeVertexAdjacency.findEdgeId(vNext, vNextNext);

      edgeFaceValence[e]++;
      valueFaceValence[v]++;

      // is this the first time processing this edge
      if (edgeUnique[e] === 0) {
        edgeUnique[e] = 1;

        valueEdgeValence[v]++;
        valueEdgeValence[vNext]++;

        if (faceEdgeCreases[faceBegin + fv]) {
          edgeCreases[e] = 1;
          valueCreases[v]++;
          valueCreases[vNext]++;
        }
      }

      values.getAt(v, tempValue);
      tempFaceCentroid.add(tempValue);

      newFaceValueIndices[nf++] = edgeOffset + e;
      newFaceValueIndices[nf++] = vNext;
      newFaceValueIndices[nf++] = edgeOffset + eNext;
      newFaceValueIndices[nf++] = faceOffset + _f;
    }

    tempFaceCentroid.multiplyScalar(1.0 / numFaceValues);
    newValues.setAt(faceOffset + _f, tempFaceCentroid);
  }
  // create new edges
  for (var _e = 0; _e < numEdges; _e++) {
    var _v = edgeVertexAdjacency.edgeVertices[_e * 2];
    var _vNext = edgeVertexAdjacency.edgeVertices[_e * 2 + 1];

    values.getAt(_v, tempEdgeCentroid);
    values.getAt(_vNext, tempValue);
    tempEdgeCentroid.add(tempValue);
    var numNeighbors = 2;

    var edgeFaceCount = faceEdgeAdjacency.edgeFaceCounts[_e];

    if (!edgeCreases[_e] && edgeFaceCount === 2) {
      //if the edge contains 2 corners do not average with face
      //this was here before making changes to fix steelcase models, might break other scenes by removing
      //if (!(vertexCorners[v] && vertexCorners[vNext])) {

      for (var ef = 0; ef < edgeFaceCount; ef++) {
        var _f2 = faceEdgeAdjacency.edgeFaceIndices[_e * 2 + ef];
        newValues.getAt(faceOffset + _f2, tempValue);
        tempEdgeCentroid.add(tempValue);
        numNeighbors++;
      }
      //}
    }

    tempEdgeCentroid.multiplyScalar(1.0 / numNeighbors);

    newValues.setAt(edgeOffset + _e, tempEdgeCentroid);
  }

  var useBoundaryValues = true;

  // create new values
  for (var _v2 = 0; _v2 < numValues; _v2++) {
    values.getAt(_v2, tempNextValue);
    var boundaryValue = valueEdgeValence[_v2] !== valueFaceValence[_v2];

    if (valueEdgeValence[_v2] !== 0 && vertexCorners[_v2] < 1) {
      // sum of connected vertices.
      var valueBegin = valueAdjacency.valueEdgeOffsets[_v2];
      var valueUntil = valueAdjacency.valueEdgeOffsets[_v2 + 1];
      var numValueEdges = valueUntil - valueBegin;

      tempConnectedValue.multiplyScalar(0.0);
      var numConnectedValues = 0;

      if (useBoundaryValues && boundaryValue || valueCreases[_v2]) {
        for (var ve = 0; ve < numValueEdges; ve++) {
          var _e2 = valueAdjacency.valueEdgeIndices[valueBegin + ve];
          if (edgeCreases[_e2]) {
            var vOther = edgeVertexAdjacency.edgeVertices[_e2 * 2];
            if (vOther === _v2) {
              vOther = edgeVertexAdjacency.edgeVertices[_e2 * 2 + 1];
            }

            values.getAt(vOther, tempValue);
            tempConnectedValue.add(tempValue);
            numConnectedValues++;
          }
        }

        tempNextValue.multiplyScalar(0.75).add(tempConnectedValue.multiplyScalar(0.25 / numConnectedValues));
      } else {
        for (var _ve = 0; _ve < numValueEdges; _ve++) {
          var _e3 = valueAdjacency.valueEdgeIndices[valueBegin + _ve];
          var _vOther = edgeVertexAdjacency.edgeVertices[_e3 * 2];
          if (_vOther === _v2) {
            _vOther = edgeVertexAdjacency.edgeVertices[_e3 * 2 + 1];
          }

          values.getAt(_vOther, tempValue);
          tempConnectedValue.add(tempValue);
          numConnectedValues++;
        }

        tempConnectedValue.multiplyScalar(1 / (numConnectedValues * numConnectedValues));

        var valueBeginF = valueAdjacency.valueFaceOffsets[_v2];
        var valueUntilF = valueAdjacency.valueFaceOffsets[_v2 + 1];
        var numValueFacesF = valueUntilF - valueBeginF;

        tempConnectedFace.multiplyScalar(0.0);
        var numConnectedFaces = 0;

        for (var vf = 0; vf < numValueFacesF; vf++) {
          var _f3 = valueAdjacency.valueFaceIndices[valueBeginF + vf];
          newValues.getAt(faceOffset + _f3, tempValue);
          tempConnectedFace.add(tempValue);
          numConnectedFaces++;
        }

        tempConnectedFace.multiplyScalar(1 / (numConnectedFaces * numConnectedFaces));

        tempNextValue.multiplyScalar((numConnectedFaces - 2) / numConnectedFaces);
        tempNextValue.add(tempConnectedValue);
        tempNextValue.add(tempConnectedFace);
      }
    }

    newValues.setAt(_v2, tempNextValue);
  }

  var pm = {
    faceRangeOffsets: newFaceRangeOffsets,
    faceValueIndices: newFaceValueIndices,
    values: newValues
  };

  return new _PolyMap2.default(pm);
};

var getFaceEdgeCreases = function getFaceEdgeCreases(polyMap, faceEdgeCreases) {
  var faceEdgeAdjacency = polyMap.faceEdgeAdjacency;

  for (var fe = 0; fe < faceEdgeAdjacency.faceEdgeIndices.length; fe++) {
    var edgeIndex = faceEdgeAdjacency.faceEdgeIndices[fe];
    faceEdgeCreases[fe] = faceEdgeAdjacency.edgeFaceCounts[edgeIndex] !== 2 ? 1 : 0;
  }
};

var getValueCorners = function getValueCorners(polyMap, faceEdgeCreases) {
  var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;

  //converted to track indices that are corners instead of values
  var faceValueCorners = new Uint8Array(polyMap.faceValueIndices.length);
  var valueCreaseEdgeCount = new Uint8Array(polyMap.values.length);
  var valueEdgeCount = new Uint8Array(polyMap.values.length);
  var edgeProcessed = new Uint8Array(edgeVertexAdjacency.getNumEdges());

  for (var f = 0; f < polyMap.faceRangeOffsets.length - 1; f++) {
    var faceBegin = polyMap.faceRangeOffsets[f];
    var faceUntil = polyMap.faceRangeOffsets[f + 1];
    var numFaceValues = faceUntil - faceBegin;

    var vNext = polyMap.faceValueIndices[faceBegin];

    for (var fv = 0; fv < numFaceValues; fv++) {
      var v = vNext;
      vNext = polyMap.faceValueIndices[faceBegin + (fv + 1) % numFaceValues];

      var e = edgeVertexAdjacency.findEdgeId(v, vNext);
      if (edgeProcessed[e] === 0) {
        edgeProcessed[e] = 1;

        if (faceEdgeCreases[faceBegin + fv]) {
          valueCreaseEdgeCount[v]++;
          valueCreaseEdgeCount[vNext]++;
        }
        valueEdgeCount[v]++;
        valueEdgeCount[vNext]++;
      }
    }
  }

  for (var i = 0; i < faceValueCorners.length; i++) {
    var valueIndex = polyMap.faceValueIndices[i];
    if (valueCreaseEdgeCount[valueIndex] > 2 || valueCreaseEdgeCount[valueIndex] - valueEdgeCount[valueIndex] === 0) {
      faceValueCorners[i] = 1;
    }
  }

  return faceValueCorners;
};

function subdivision(mesh, smoothByMaterialIds) {
  var polyMesh = (0, _polyMeshValidation2.default)(mesh);
  var faceEdgeCreases = new Uint8Array(polyMesh.positions.faceValueIndices.length);

  if (polyMesh.normalMap) {
    getFaceEdgeCreases(polyMesh.normalMap, faceEdgeCreases);
  }

  if (polyMesh.edgeCreaseWeights) {
    var faceEdgeAdjacency = polyMesh.positions.faceEdgeAdjacency;
    for (var fe = 0; fe < faceEdgeAdjacency.faceEdgeIndices.length; fe++) {
      var edgeIndex = faceEdgeAdjacency.faceEdgeIndices[fe];
      faceEdgeCreases[fe] = faceEdgeCreases[fe] || (polyMesh.edgeCreaseWeights[edgeIndex] > 0 ? 1 : 0);
    }
  }

  if (smoothByMaterialIds && polyMesh.materialIds) {
    var _faceEdgeAdjacency = polyMesh.positions.faceEdgeAdjacency;

    for (var _fe = 0; _fe < _faceEdgeAdjacency.faceEdgeIndices.length; _fe++) {
      var _edgeIndex = _faceEdgeAdjacency.faceEdgeIndices[_fe];
      if (_faceEdgeAdjacency.getNumFacesForEdgeId(_edgeIndex) === 2 && polyMesh.materialIds[_faceEdgeAdjacency.getFaceForEdgeId(_edgeIndex, 0)] !== polyMesh.materialIds[_faceEdgeAdjacency.getFaceForEdgeId(_edgeIndex, 1)]) {
        faceEdgeCreases[_fe] += 1;
      }
    }
  }

  var faceValueCorners = getValueCorners(polyMesh.positions, faceEdgeCreases);
  var results = new _PolyMesh2.default();

  results.positions = subdividePolyMap(polyMesh.positions, null, faceEdgeCreases, faceValueCorners);
  results.faceRangeOffsets = results.positions.faceRangeOffsets;

  if (polyMesh.normalMap) {
    results.normalMap = subdividePolyMap(polyMesh.normalMap, results.faceRangeOffsets, faceEdgeCreases, faceValueCorners);
  }

  if (polyMesh.tangentMap) {
    var tempVector4 = new _three.Vector4();
    var tempVector3 = new _three.Vector3();
    var tangentEdgeCreases = new Uint8Array(polyMesh.tangentMap.faceValueIndices.length);
    getFaceEdgeCreases(polyMesh.tangentMap, tangentEdgeCreases);

    for (var j = 0; j < faceEdgeCreases.length; j++) {
      tangentEdgeCreases[j] = tangentEdgeCreases[j] || faceEdgeCreases[j];
    }

    var tangentFaceValueCorners = getValueCorners(polyMesh.tangentMap, tangentEdgeCreases);

    for (var _j = 0; _j < tangentFaceValueCorners.length; _j++) {
      tangentFaceValueCorners[_j] = tangentFaceValueCorners[_j] || faceValueCorners[_j];
    }

    var newTangentMap = subdividePolyMap(polyMesh.tangentMap, results.faceRangeOffsets, tangentEdgeCreases, tangentFaceValueCorners);
    var newTangentValues = newTangentMap.values;

    for (var v = 0; v < newTangentValues.length; ++v) {
      newTangentValues.getAt(v, tempVector4);
      tempVector3.copy(tempVector4);
      tempVector3.normalize();
      tempVector4.x = tempVector3.x;
      tempVector4.y = tempVector3.y;
      tempVector4.z = tempVector3.z;

      if (tempVector4.w >= 0) {
        tempVector4.w = 1;
      } else {
        tempVector4.w = -1;
      }

      newTangentValues.setAt(v, tempVector4);
    }

    results.tangentMap = newTangentMap;
  }

  if (polyMesh.uvMaps) {
    var uvMaps = new _ObjectsByName2.default();
    for (var i = 0; i < polyMesh.uvMaps.length; i++) {
      var name = polyMesh.uvMaps.namesByIndex[i];
      var uvEdgeCreases = new Uint8Array(polyMesh.uvMaps.byName[name].faceValueIndices.length);
      getFaceEdgeCreases(polyMesh.uvMaps.byName[name], uvEdgeCreases);

      for (var _j2 = 0; _j2 < faceEdgeCreases.length; _j2++) {
        uvEdgeCreases[_j2] = uvEdgeCreases[_j2] || faceEdgeCreases[_j2];
      }

      var uvFaceValueCorners = getValueCorners(polyMesh.uvMaps.byName[name], uvEdgeCreases);

      for (var _j3 = 0; _j3 < uvFaceValueCorners.length; _j3++) {
        uvFaceValueCorners[_j3] = uvFaceValueCorners[_j3] || faceValueCorners[_j3];
      }

      uvMaps.set(name, subdividePolyMap(polyMesh.uvMaps.byName[name], results.faceRangeOffsets, uvEdgeCreases, uvFaceValueCorners));
    }

    results.uvMaps = uvMaps;
  }

  results.topologyChanged();
  var finalMesh = new _PolyMesh2.default(results);
  return finalMesh;
}

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mirrorPolyMesh;

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _mergePolyMeshes = __webpack_require__(103);

var _mergePolyMeshes2 = _interopRequireDefault(_mergePolyMeshes);

var _slicePolyMesh = __webpack_require__(238);

var _slicePolyMesh2 = _interopRequireDefault(_slicePolyMesh);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var invertIndices = function invertFaceValueIndices(polyMap) {
  var faceRangeOffsets = polyMap.faceRangeOffsets;
  var numFaces = faceRangeOffsets.length - 1;
  var faceValueIndices = polyMap.faceValueIndices;
  var numFaceValueIndices = faceValueIndices.length;
  var newFaceValueIndices = new Uint32Array(numFaceValueIndices);

  for (var f = 0; f < numFaces; ++f) {
    var faceBegin = faceRangeOffsets[f];
    var faceUntil = faceRangeOffsets[f + 1];
    var numFaceValues = faceUntil - faceBegin;

    for (var fv = 0; fv < numFaceValues; ++fv) {
      newFaceValueIndices[faceBegin + fv] = faceValueIndices[faceUntil - fv - 1];
    }
  }

  var pm = {
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: newFaceValueIndices,
    values: polyMap.values
  };

  return new _PolyMap2.default(pm);
};

var reflectValues = function reflectPositionOrNormalValues(polyMap, plane, isNormal) {
  var values = polyMap.values;
  var valueType = values.type;
  var numValues = values.length;
  var newValues = new _ObjectArrayView2.default(valueType, numValues);

  var tempVertex = new valueType();
  var tempNormal = new valueType();

  for (var v = 0; v < numValues; ++v) {
    values.getAt(v, tempVertex);
    var orthogonalDistance = plane.distanceToPoint(tempVertex);
    tempNormal.copy(plane.normal);

    if (!isNormal) {
      tempNormal.multiplyScalar(orthogonalDistance * -2);
      tempVertex.add(tempNormal);
      newValues.setAt(v, tempVertex);
    } else {
      tempVertex.reflect(tempNormal);
      newValues.setAt(v, tempVertex);
    }
  }

  var pm = {
    faceRangeOffsets: polyMap.faceRangeOffsets,
    faceValueIndices: polyMap.faceValueIndices,
    values: newValues
  };

  return new _PolyMap2.default(pm);
};

function mirrorPolyMesh(mesh, plane, optionalCopy, optionalSlice) {
  // does a flip on slice to be consistent with V1
  var polyMesh = optionalSlice ? new _PolyMesh2.default((0, _slicePolyMesh2.default)(mesh, plane, false, true)) : mesh;
  var result = new _PolyMesh2.default();

  //Invert indices for all map types
  var positions = polyMesh.positions;
  result.positions = invertIndices(positions);
  result.faceRangeOffsets = positions.faceRangeOffsets;

  if (polyMesh.normalMap) {
    var normals = polyMesh.normalMap;
    result.normalMap = invertIndices(normals);
  }

  if (polyMesh.uvMaps) {
    var uvMaps = new _ObjectsByName2.default();
    for (var i = 0; i < polyMesh.uvMaps.length; i++) {
      var name = polyMesh.uvMaps.namesByIndex[i];
      uvMaps.set(name, invertIndices(polyMesh.uvMaps.byName[name]));
    }

    result.uvMaps = uvMaps;
  }

  //Reflect values of position and normal map
  var newPositions = result.positions;
  result.positions = reflectValues(newPositions, plane, false);

  if (result.normalMap) {
    var newNormals = result.normalMap;
    result.normalMap = reflectValues(newNormals, plane, true);
  }

  if (optionalCopy || optionalSlice) {
    var mergeList = [result, polyMesh];
    var _finalMesh = (0, _mergePolyMeshes2.default)(mergeList, null, null);
    return _finalMesh;
  }

  var finalMesh = new _PolyMesh2.default(result);

  return finalMesh;
}

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = tessellate;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectBuffer = __webpack_require__(68);

var _ObjectBuffer2 = _interopRequireDefault(_ObjectBuffer);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _Tessellate = __webpack_require__(225);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function tessellatePolyMap(polyMap, selectedFaceList, selectedEdgeList, tessellationType, positionMapAdjacency, positionMap, optionalFaceRangeOffsets) {
  var positionFaceValueIndices = positionMap.faceValueIndices;
  var edgeVertexAdjacency = polyMap.edgeVertexAdjacency;
  var faceRangeOffsets = polyMap.faceRangeOffsets;
  var faceCount = faceRangeOffsets.length - 1;
  var faceValueIndices = polyMap.faceValueIndices;
  var values = polyMap.values;
  var valueType = values.type;

  var visitedEdgeList = new Uint32Array(edgeVertexAdjacency.getNumEdges());
  var newFaceRangeOffsets = new Uint32Array(faceRangeOffsets.length * 4);
  var newFaceSelection = new Uint8Array(faceRangeOffsets.length * 4);
  var newFaceValueIndices = new Uint32Array(faceValueIndices.length * 4);
  var newValues = new _ObjectBuffer2.default(valueType);
  var faceCentroidVector = new valueType();
  var edgeCentroidVector = new valueType();
  var vectorA = new valueType();
  var vectorB = new valueType();
  var tempVector = new valueType();

  var faceIndex = 0;
  var faceValueIndex = 0;
  var valueIndex = 0;
  var faceCentroidIndex = 0;
  var valueCount = 0;
  newFaceRangeOffsets[faceIndex++] = 0;

  for (var v = 0; v < values.length; ++v) {
    values.getAt(v, vectorA);
    newValues.push(vectorA);
    ++valueCount;
  }

  if (tessellationType === _Tessellate.TessellationTypes.vertex) {
    for (var f = 0; f < faceCount; ++f) {
      var faceBegin = faceRangeOffsets[f];
      var faceUntil = faceRangeOffsets[f + 1];
      var faceValueCount = faceUntil - faceBegin;

      var nextValue = faceValueIndices[faceBegin];
      var nextNextValue = faceValueIndices[faceBegin + 1];

      if (selectedFaceList[f] === _Tessellate.TessellateConstants.SELECTED) {
        faceCentroidVector.set(0, 0, 0);
        faceCentroidIndex = newValues.push(faceCentroidVector) - 1;
        ++valueCount;
      }

      for (var fv = 0; fv < faceValueCount; ++fv) {
        var currentValue = nextValue;
        nextValue = nextNextValue;
        nextNextValue = faceValueIndices[faceBegin + (fv + 2) % faceValueCount];

        newFaceValueIndices[faceValueIndex++] = currentValue;

        if (selectedFaceList[f] === _Tessellate.TessellateConstants.SELECTED) {
          values.getAt(currentValue, tempVector);
          faceCentroidVector.add(tempVector);
          newFaceValueIndices[faceValueIndex++] = nextValue;
          newFaceValueIndices[faceValueIndex++] = faceCentroidIndex;
          newFaceSelection[faceIndex - 1] = _Tessellate.TessellateConstants.SELECTED;
          newFaceRangeOffsets[faceIndex++] = faceValueIndex;
        }
      }

      if (selectedFaceList[f] === _Tessellate.TessellateConstants.SELECTED) {
        faceCentroidVector.multiplyScalar(1 / faceValueCount);
        newValues.setAt(faceCentroidIndex, faceCentroidVector);
      }

      if (selectedFaceList[f] !== _Tessellate.TessellateConstants.SELECTED) {
        newFaceRangeOffsets[faceIndex++] = faceValueIndex;
      }
    }
  } else {
    for (var _f = 0; _f < faceCount; ++_f) {
      var _faceBegin = faceRangeOffsets[_f];
      var _faceUntil = faceRangeOffsets[_f + 1];
      var _faceValueCount = _faceUntil - _faceBegin;

      if (selectedFaceList[_f] === _Tessellate.TessellateConstants.SELECTED) {
        faceCentroidVector.set(0, 0, 0);
        faceCentroidIndex = newValues.push(faceCentroidVector) - 1;
        ++valueCount;
      }

      var nextIndex = _faceBegin;
      var nextNextIndex = _faceBegin + 1;

      for (var _fv = 0; _fv < _faceValueCount; ++_fv) {
        var currentIndex = nextIndex;
        nextIndex = nextNextIndex;
        nextNextIndex = _faceBegin + (_fv + 2) % _faceValueCount;
        var _currentValue = faceValueIndices[currentIndex];
        var _nextValue = faceValueIndices[nextIndex];
        var currentPositionValue = positionFaceValueIndices[currentIndex];
        var nextPositionValue = positionFaceValueIndices[nextIndex];

        var currentEdgeId = edgeVertexAdjacency.findEdgeId(_currentValue, _nextValue);
        var positionEdgeId = positionMapAdjacency.findEdgeId(currentPositionValue, nextPositionValue);
        newFaceValueIndices[faceValueIndex++] = _currentValue;

        if (selectedFaceList[_f] === _Tessellate.TessellateConstants.SELECTED) {
          values.getAt(_currentValue, tempVector);
          faceCentroidVector.add(tempVector);
          var previousValue = faceValueIndices[_faceBegin + (_fv + _faceValueCount - 1) % _faceValueCount];
          var previousEdgeId = edgeVertexAdjacency.findEdgeId(previousValue, _currentValue);
          if (visitedEdgeList[currentEdgeId] === _Tessellate.TessellateConstants.UNPROCESSED) {
            values.getAt(_currentValue, vectorA);
            values.getAt(_nextValue, vectorB);
            edgeCentroidVector.addVectors(vectorA, vectorB);
            edgeCentroidVector.multiplyScalar(0.5);
            valueIndex = newValues.push(edgeCentroidVector) - 1;
            visitedEdgeList[currentEdgeId] = valueIndex + 1;
            newFaceValueIndices[faceValueIndex++] = valueIndex;
            ++valueCount;
          } else {
            valueIndex = visitedEdgeList[currentEdgeId] - 1;
            newFaceValueIndices[faceValueIndex++] = valueIndex;
          }

          newFaceValueIndices[faceValueIndex++] = faceCentroidIndex;

          if (visitedEdgeList[previousEdgeId] === _Tessellate.TessellateConstants.UNPROCESSED) {
            values.getAt(previousValue, vectorA);
            values.getAt(_currentValue, vectorB);
            edgeCentroidVector.addVectors(vectorA, vectorB);
            edgeCentroidVector.multiplyScalar(0.5);
            valueIndex = newValues.push(edgeCentroidVector) - 1;
            visitedEdgeList[previousEdgeId] = valueIndex + 1;
            newFaceValueIndices[faceValueIndex++] = valueIndex;
            ++valueCount;
          } else {
            valueIndex = visitedEdgeList[previousEdgeId] - 1;
            newFaceValueIndices[faceValueIndex++] = valueIndex;
          }

          newFaceSelection[faceIndex - 1] = _Tessellate.TessellateConstants.SELECTED;
          newFaceRangeOffsets[faceIndex++] = faceValueIndex;
        }

        if (selectedFaceList[_f] !== _Tessellate.TessellateConstants.SELECTED) {
          if (selectedEdgeList[positionEdgeId] === _Tessellate.TessellateConstants.SELECTED) {
            if (visitedEdgeList[currentEdgeId] === _Tessellate.TessellateConstants.UNPROCESSED) {
              values.getAt(_currentValue, vectorA);
              values.getAt(_nextValue, vectorB);
              edgeCentroidVector.addVectors(vectorA, vectorB);
              edgeCentroidVector.multiplyScalar(0.5);
              valueIndex = newValues.push(edgeCentroidVector) - 1;
              visitedEdgeList[currentEdgeId] = valueIndex + 1;
              newFaceValueIndices[faceValueIndex++] = valueIndex;
              ++valueCount;
            } else {
              valueIndex = visitedEdgeList[currentEdgeId] - 1;
              newFaceValueIndices[faceValueIndex++] = valueIndex;
            }
          }
        }
      }

      if (selectedFaceList[_f] === _Tessellate.TessellateConstants.SELECTED) {
        faceCentroidVector.multiplyScalar(1 / _faceValueCount);
        newValues.setAt(faceCentroidIndex, faceCentroidVector);
      }

      if (selectedFaceList[_f] !== _Tessellate.TessellateConstants.SELECTED) {
        newFaceRangeOffsets[faceIndex++] = faceValueIndex;
      }
    }
  }

  var resultFaceRangeOffsets = optionalFaceRangeOffsets ? optionalFaceRangeOffsets : new Uint32Array(faceIndex);
  var resultFaceSelection = new Uint8Array(faceIndex);
  var resultFaceValueIndices = new Uint32Array(faceValueIndex);
  var resultValues = new _ObjectArrayView2.default(valueType, valueCount + 1);

  for (var _f2 = 0; _f2 < faceIndex; ++_f2) {
    resultFaceSelection[_f2] = newFaceSelection[_f2];

    if (!optionalFaceRangeOffsets) {
      resultFaceRangeOffsets[_f2] = newFaceRangeOffsets[_f2];
    }
  }

  for (var _fv2 = 0; _fv2 < faceValueIndex; ++_fv2) {
    resultFaceValueIndices[_fv2] = newFaceValueIndices[_fv2];
  }

  for (var _v = 0; _v < valueCount + 1; ++_v) {
    newValues.getAt(_v, tempVector);

    if (valueType === _three.Vector3 && optionalFaceRangeOffsets) {
      tempVector.normalize();
    }

    resultValues.setAt(_v, tempVector);
  }

  var resultMap = {
    faceRangeOffsets: resultFaceRangeOffsets,
    faceValueIndices: resultFaceValueIndices,
    values: resultValues
  };

  if (!optionalFaceRangeOffsets) {
    var MapAndSelection = {
      polyMap: new _PolyMap2.default(resultMap),
      selection: resultFaceSelection
    };
    return MapAndSelection;
  } else {
    return new _PolyMap2.default(resultMap);
  }
}

function tessellatePolyMesh(meshAndSelection, tessellationType) {
  var mesh = meshAndSelection.polyMesh;
  var selectedFaceList = meshAndSelection.selection;
  var resultMesh = new _PolyMesh2.default();
  var faceRangeOffsets = mesh.faceRangeOffsets;
  var positionMap = mesh.positions;
  var positionFaceValueIndices = positionMap.faceValueIndices;
  var positionMapAdjacency = positionMap.edgeVertexAdjacency;
  var selectedEdgeList = new Uint8Array(positionMapAdjacency.getNumEdges());

  for (var f = 0; f < selectedFaceList.length; ++f) {
    if (selectedFaceList[f] === _Tessellate.TessellateConstants.SELECTED) {
      var faceBegin = faceRangeOffsets[f];
      var faceUntil = faceRangeOffsets[f + 1];
      var faceValuesCount = faceUntil - faceBegin;

      var nextValue = positionFaceValueIndices[faceBegin];
      var nextNextValue = positionFaceValueIndices[faceBegin + 1];

      for (var fv = 0; fv < faceValuesCount; ++fv) {
        var currentValue = nextValue;
        nextValue = nextNextValue;
        nextNextValue = positionFaceValueIndices[faceBegin + (fv + 2) % faceValuesCount];
        var edgeId = positionMapAdjacency.findEdgeId(currentValue, nextValue);

        selectedEdgeList[edgeId] = _Tessellate.TessellateConstants.SELECTED;
      }
    }
  }

  var PositionAndFaceSelection = tessellatePolyMap(positionMap, selectedFaceList, selectedEdgeList, tessellationType, positionMapAdjacency, positionMap);

  resultMesh.positions = PositionAndFaceSelection.polyMap;
  resultMesh.faceRangeOffsets = resultMesh.positions.faceRangeOffsets;

  if (mesh.normalMap) {
    resultMesh.normalMap = tessellatePolyMap(mesh.normalMap, selectedFaceList, selectedEdgeList, tessellationType, positionMapAdjacency, positionMap, resultMesh.faceRangeOffsets);
  }

  if (mesh.uvMaps) {
    var uvMaps = new _ObjectsByName2.default();
    for (var i = 0; i < mesh.uvMaps.length; ++i) {
      var name = mesh.uvMaps.namesByIndex[i];
      uvMaps.set(name, tessellatePolyMap(mesh.uvMaps.byName[name], selectedFaceList, selectedEdgeList, tessellationType, positionMapAdjacency, positionMap, resultMesh.faceRangeOffsets));
    }

    resultMesh.uvMaps = uvMaps;
  }

  var MeshAndSelection = {
    polyMesh: new _PolyMesh2.default(resultMesh),
    selection: PositionAndFaceSelection.selection
  };
  return MeshAndSelection;
}

function tessellate(mesh, selectedFaceList, tessellationType, iterations) {
  var MeshAndSelection = {
    polyMesh: mesh,
    selection: selectedFaceList
  };

  for (var i = 0; i < iterations; ++i) {
    var newMeshAndSelection = tessellatePolyMesh(MeshAndSelection, tessellationType);
    MeshAndSelection.polyMesh = newMeshAndSelection.polyMesh;
    MeshAndSelection.selection = newMeshAndSelection.selection;
  }

  //not sure if necessary to create new PolyMesh here
  return new _PolyMesh2.default(MeshAndSelection.polyMesh);
}

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Box;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _removeDuplicateValues = __webpack_require__(160);

var _removeDuplicateValues2 = _interopRequireDefault(_removeDuplicateValues);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Box(width, height, depth, widthSegments, heightSegments, depthSegments) {
  widthSegments = Math.floor(widthSegments) || 1;
  heightSegments = Math.floor(heightSegments) || 1;
  depthSegments = Math.floor(depthSegments) || 1;

  var faceRangeOffsets = new Uint32Array(widthSegments * heightSegments * 2 + widthSegments * depthSegments * 2 + heightSegments * depthSegments * 2 + 1); //number of faces
  var faceValueIndices = new Uint32Array((widthSegments * heightSegments * 2 + widthSegments * depthSegments * 2 + heightSegments * depthSegments * 2) * 4); //number of faces*4
  var values = new _ObjectArrayView2.default(_three.Vector3, (widthSegments + 1) * (heightSegments + 1) * 2 + (widthSegments + 1) * (depthSegments + 1) * 2 + (heightSegments + 1) * (depthSegments + 1) * 2);
  var normals = new _ObjectArrayView2.default(_three.Vector3, (widthSegments + 1) * (heightSegments + 1) * 2 + (widthSegments + 1) * (depthSegments + 1) * 2 + (heightSegments + 1) * (depthSegments + 1) * 2);
  var uvValues = new _ObjectArrayView2.default(_three.Vector2, (widthSegments + 1) * (heightSegments + 1) * 2 + (widthSegments + 1) * (depthSegments + 1) * 2 + (heightSegments + 1) * (depthSegments + 1) * 2);

  var segment_width = width / widthSegments;
  var segment_height = height / heightSegments;
  var segment_depth = depth / depthSegments;

  var width_half = width / 2;
  var height_half = height / 2;
  var depth_half = depth / 2;

  var ix = void 0,
      iy = void 0,
      iz = void 0;
  var indOffset = 0;

  var newValue = new _three.Vector3();
  var newNormal = new _three.Vector3();
  var newUV = new _three.Vector2();

  //push utility for faceValueIndices
  var indLengthMarker = 0;
  function pushInd(value) {
    faceValueIndices[indLengthMarker] = value;
    indLengthMarker++;
  }

  //populate FaceRangeOffsets
  for (iz = 0, ix = 0; iz < faceRangeOffsets.length; iz++, ix += 4) {
    faceRangeOffsets[iz] = ix; //0 4 8 12 16 20 ...
  }

  //front and back
  for (iz = 0; iz < 2; iz++) {
    //do twice, one for each face
    for (iy = 0; iy < heightSegments; iy++) {
      for (ix = 0; ix < widthSegments; ix++) {
        pushInd(indOffset + iy * (widthSegments + 1) + ix);
        pushInd(indOffset + iy * (widthSegments + 1) + ix + 1);
        pushInd(indOffset + (iy + 1) * (widthSegments + 1) + ix + 1);
        pushInd(indOffset + (iy + 1) * (widthSegments + 1) + ix);
      }
    }

    indOffset += (widthSegments + 1) * (heightSegments + 1);
  }

  //top and bottom face
  for (iy = 0; iy < 2; iy++) {
    //do twice, one for each face
    for (ix = 0; ix < widthSegments; ix++) {
      for (iz = 0; iz < depthSegments; iz++) {
        pushInd(indOffset + ix * (depthSegments + 1) + iz);
        pushInd(indOffset + ix * (depthSegments + 1) + iz + 1);
        pushInd(indOffset + (ix + 1) * (depthSegments + 1) + iz + 1);
        pushInd(indOffset + (ix + 1) * (depthSegments + 1) + iz);
      }
    }

    indOffset += (widthSegments + 1) * (depthSegments + 1);
  }

  //left and right face
  for (ix = 0; ix < 2; ix++) {
    //do twice, one for each face
    for (iz = 0; iz < depthSegments; iz++) {
      for (iy = 0; iy < heightSegments; iy++) {
        pushInd(indOffset + iz * (heightSegments + 1) + iy);
        pushInd(indOffset + iz * (heightSegments + 1) + iy + 1);
        pushInd(indOffset + (iz + 1) * (heightSegments + 1) + iy + 1);
        pushInd(indOffset + (iz + 1) * (heightSegments + 1) + iy);
      }
    }

    indOffset += (depthSegments + 1) * (heightSegments + 1);
  }

  //push utility for faceValueIndices
  var valLengthMarker = 0;
  function pushVal(value) {
    values.setAt(valLengthMarker, value);
    valLengthMarker++;
  }

  //push utility for uv's and normals
  var uv_normLengthMarker = 0;
  function push_uv_norm(uv, norm) {
    uvValues.setAt(uv_normLengthMarker, uv);
    normals.setAt(uv_normLengthMarker, norm);
    uv_normLengthMarker++;
  }

  //populate values, normals, and uv values
  //front and back
  for (iz = -1; iz < 2; iz += 2) {
    //do twice for each side with -1 for first and +1 for second
    for (iy = 0; iy < heightSegments + 1; iy++) {
      //calculate y coord
      var y = iy * segment_height - height_half;

      for (ix = 0; ix < widthSegments + 1; ix++) {
        //calculate x coord
        var x = -iz * ix * segment_width + iz * width_half;

        //set value
        newValue.set(x, y, -1 * iz * depth_half);
        pushVal(newValue);

        //set normal
        newNormal.set(0, 0, -1 * iz);

        //set uv value
        newUV.set(ix / widthSegments, iy / heightSegments);
        push_uv_norm(newUV, newNormal);
      }
    }
  }

  //top and bottom
  for (iy = -1; iy < 2; iy += 2) {
    //do twice for each side with -1 for first and +1 for second
    for (ix = 0; ix < widthSegments + 1; ix++) {
      //calculate z coord
      var _x = ix * segment_width - width_half;

      for (iz = 0; iz < depthSegments + 1; iz++) {
        //calculate x coord
        var z = -iy * iz * segment_depth + iy * depth_half;

        //set value
        newValue.set(_x, -1 * iy * height_half, z);
        pushVal(newValue);

        //set normal
        newNormal.set(0, -1 * iy, 0);

        //set uv value
        newUV.set(ix / widthSegments, (depthSegments - iz) / depthSegments);
        push_uv_norm(newUV, newNormal);
      }
    }
  }

  //left and right
  for (ix = -1; ix < 2; ix += 2) {
    //do twice for each side with -1 for first and +1 for second
    for (iz = 0; iz < depthSegments + 1; iz++) {
      //calculate y coord
      var _z = -1 * ix * iz * segment_depth + ix * depth_half;

      for (iy = 0; iy < heightSegments + 1; iy++) {
        //calculate z coord
        var _y = iy * segment_height - height_half;

        //set value
        newValue.set(-1 * ix * width_half, _y, _z);
        pushVal(newValue);

        //set normal
        newNormal.set(-1 * ix, 0, 0);

        //set uv value
        newUV.set((depthSegments - iz) / depthSegments, iy / heightSegments);
        push_uv_norm(newUV, newNormal);
      }
    }
  }

  var positionsMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: values
  });

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: normals
  });

  var uvMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: uvValues
  });

  var uvMapsByName = new _ObjectsByName2.default();
  uvMapsByName.set('default', uvMap);

  var meshObj = {
    faceRangeOffsets: faceRangeOffsets,
    positions: positionsMap,
    normalMap: normalMap,
    uvMaps: uvMapsByName,
    colorMaps: new _ObjectsByName2.default()
  };
  var polyMesh = new _PolyMesh2.default(meshObj);

  return (0, _removeDuplicateValues2.default)(polyMesh);
}

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Capsule;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _CapsuleLathe = __webpack_require__(449);

var _CapsuleLathe2 = _interopRequireDefault(_CapsuleLathe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Capsule(radius, height, radialSegments, heightSegments, thetaStart, thetaLength) {
  radius = radius !== undefined ? radius : 20;
  height = height !== undefined ? height : 100;

  radialSegments = Math.max(1, Math.floor(radialSegments || 8));
  heightSegments = Math.max(1, Math.floor(heightSegments || 8));

  thetaStart = _three.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
  thetaLength = _three.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);

  var heightSegmentLength = height / heightSegments;
  var halfHeight = height / 2;
  var inverseRadialSegments = 1 / radialSegments;

  var pt = new _three.Vector3();
  var normPt = new _three.Vector3();
  var hemisphereSegments = heightSegments < 3 ? 2 : heightSegments;
  var inverseHemisphereSegments = 1 / hemisphereSegments;

  var points = new _ObjectArrayView2.default(_three.Vector3, heightSegments + 1 + (hemisphereSegments + 1) * 2);
  var norms = new _ObjectArrayView2.default(_three.Vector3, heightSegments + 1 + (hemisphereSegments + 1) * 2);
  //top
  for (var i = 0, il = hemisphereSegments; i <= il; i++) {
    var theta = Math.PI - i * (Math.PI / 2) * inverseHemisphereSegments;
    pt.set(0, -radius * Math.cos(theta) + halfHeight, radius * Math.sin(theta));

    normPt.set(0, -Math.cos(theta), Math.sin(theta));

    points.setAt(i, pt);
    norms.setAt(i, normPt.normalize());
  }

  //body
  normPt.set(0, 0, 1);
  for (var _i = 0, _il = heightSegments; _i <= _il; _i++) {
    pt.set(0, halfHeight - _i * heightSegmentLength, radius);
    points.setAt(_i + hemisphereSegments + 1, pt);
    norms.setAt(_i + hemisphereSegments + 1, normPt);
  }

  //bottom
  for (var _i2 = 0, _il2 = hemisphereSegments; _i2 <= _il2; _i2++) {
    var _theta = Math.PI / 2 - _i2 * (Math.PI / 2) * inverseHemisphereSegments;
    pt.set(0, -radius * Math.cos(_theta) - halfHeight, radius * Math.sin(_theta));

    normPt.set(0, -Math.cos(_theta), Math.sin(_theta));

    points.setAt(_i2 + hemisphereSegments + heightSegments + 2, pt);
    norms.setAt(_i2 + hemisphereSegments + heightSegments + 2, normPt.normalize());
  }

  var latheSegments = radialSegments < 3 ? 3 : radialSegments;
  return (0, _CapsuleLathe2.default)(points, norms, hemisphereSegments, latheSegments, thetaStart, thetaLength);
}

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CapsuleLathe;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _cleanPolyMesh = __webpack_require__(102);

var _cleanPolyMesh2 = _interopRequireDefault(_cleanPolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CapsuleLathe(srcPositions, srcNormals, capSegments, segments, phiStart, phiLength) {
  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;

  //assumes one normal per point
  var positions = new _ObjectArrayView2.default(_three.Vector3, (segments + 1) * srcPositions.length);
  var normals = new _ObjectArrayView2.default(_three.Vector3, (segments + 1) * srcNormals.length);
  var positionCounter = 0;
  var faceRangeOffsets = new Uint32Array(segments * (srcPositions.length - 1) + 1); //number of faces
  var faceValueIndices = new Uint32Array(segments * (srcPositions.length - 1) * 4); //number of faces*4
  var uvValues = new _ObjectArrayView2.default(_three.Vector2, (segments + 1) * srcPositions.length);
  var uvCounter = 0;

  var bodySegments = srcPositions.length - (capSegments + 1) * 2 - 1;
  var inverseBodySegments = 1.0 / bodySegments;
  var inverseSegments = 1.0 / segments;

  faceRangeOffsets[0] = 0;
  var faceCounter = 1;

  var tempUV = new _three.Vector2();
  var vertex = new _three.Vector3();
  var normal = new _three.Vector3();

  var rotationMatrix4 = new _three.Matrix4();
  var normalMatrix3 = new _three.Matrix3();

  for (var i = 0, il = segments; i <= il; i++) {
    var phi = phiStart + i * inverseSegments * phiLength;
    rotationMatrix4.makeRotationY(phi);
    normalMatrix3.getNormalMatrix(rotationMatrix4);

    for (var j = 0, jl = srcPositions.length; j < jl; j++) {
      srcPositions.getAt(j, vertex);
      srcNormals.getAt(j, normal);

      vertex.applyMatrix4(rotationMatrix4);
      normal.applyMatrix3(normalMatrix3);

      positions.setAt(positionCounter, vertex);
      normals.setAt(positionCounter++, normal);
    }
  }

  // Create UVs
  for (var _i = 0, _il = segments; _i <= _il; _i++) {
    var u = _i * inverseSegments;
    //top
    for (var _j = 0, _jl = capSegments + 1; _j < _jl; _j++) {
      var v = 1 - _j / capSegments;
      tempUV.set(u, v);
      uvValues.setAt(uvCounter++, tempUV);
    }
    //body
    for (var _j2 = 0, _jl2 = bodySegments + 1; _j2 < _jl2; _j2++) {
      var _v = 1 - _j2 * inverseBodySegments;
      tempUV.set(u, _v);
      uvValues.setAt(uvCounter++, tempUV);
    }
    //bottom
    for (var _j3 = 0, _jl3 = capSegments + 1; _j3 < _jl3; _j3++) {
      var _v2 = 1 - _j3 / capSegments;
      tempUV.set(u, _v2);
      uvValues.setAt(uvCounter++, tempUV);
    }
  }

  var positionsLen = srcPositions.length;
  var indCounter = 0;
  for (var _i2 = 0, _il2 = segments; _i2 < _il2; _i2++) {
    for (var _j4 = 0, _jl4 = srcPositions.length - 1; _j4 < _jl4; _j4++) {
      var base = _j4 + positionsLen * _i2;
      var a = base;
      var b = base + positionsLen;
      var c = base + 1 + positionsLen;
      var d = base + 1;

      faceValueIndices[indCounter++] = d;
      faceValueIndices[indCounter++] = c;
      faceValueIndices[indCounter++] = b;
      faceValueIndices[indCounter++] = a;
      faceRangeOffsets[faceCounter++] = indCounter;
    }
  }

  var positionsMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: positions
  });

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: normals
  });

  var uvMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: uvValues
  });

  var uvMapsByName = new _ObjectsByName2.default();
  var name = 'default';
  uvMapsByName.set(name, uvMap);

  var polyMesh = new _PolyMesh2.default();
  polyMesh.faceRangeOffsets = positionsMap.faceRangeOffsets;
  polyMesh.positions = positionsMap;
  polyMesh.normalMap = normalMap;
  polyMesh.uvMaps = uvMapsByName;

  return (0, _cleanPolyMesh2.default)(new _PolyMesh2.default(polyMesh));
  //return new PolyMesh( new PolyMesh( polyMesh ) );
}

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CrossSectionLathe;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _cleanPolyMesh = __webpack_require__(102);

var _cleanPolyMesh2 = _interopRequireDefault(_cleanPolyMesh);

var _Normals = __webpack_require__(50);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getAlpha(phi, startAngle, endAngle) {
  //keep all angles between 0 and 360
  phi = phi % (2 * Math.PI);
  var denominator = void 0;
  var numerator = void 0;
  denominator = (endAngle - startAngle) % (2 * Math.PI);
  if (denominator < 0) {
    denominator += 2 * Math.PI;
  }
  numerator = (phi - startAngle) % (2 * Math.PI);
  if (numerator < 0) {
    numerator += 2 * Math.PI;
  }

  if (denominator < 0.00001) {
    return 0;
  }

  return numerator / denominator;
}

function interpolate(interpolationType, vecA, vecB, alpha, optionalResult) {
  if (!optionalResult) {
    optionalResult = new _three.Vector3();
  }

  if (interpolationType === 1) {
    //Smooth Step
    alpha = -alpha * alpha * (2 * alpha - 3);
  }
  optionalResult.lerpVectors(vecA, vecB, alpha);

  return optionalResult;
}

function CrossSectionLathe(crossSections, radius, segments, phiStart, phiLength, interpolationType) {
  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;

  //we assume the passed meshes only have 1 face, and use it to loop through positions in counter-clockwise order
  var positionsLength = crossSections[0].mesh.faceRangeOffsets[1];

  var newPositions = new _ObjectArrayView2.default(_three.Vector3, (segments + 1) * positionsLength);
  var faceRangeOffsets = new Uint32Array(segments * positionsLength + 1); //number of faces
  var faceValueIndices = new Uint32Array(segments * positionsLength * 4); //number of faces*4
  var newNormals = new _ObjectArrayView2.default(_three.Vector3, faceValueIndices.length);
  var uvValues = new _ObjectArrayView2.default(_three.Vector2, faceValueIndices.length);
  var uvFaceValueIndices = new Uint32Array(faceValueIndices.length);

  //find starting interval of cross sections based on phiStart
  var indexA = void 0;
  var indexB = void 0;
  var intervalFound = false;
  for (var i = 0; i < crossSections.length - 1; ++i) {
    indexA = i;
    indexB = (i + 1) % crossSections.length;
    if (phiStart >= crossSections[indexA].locationAngle && phiStart < crossSections[indexB].locationAngle) {
      intervalFound = true;
      break;
    }
  }
  //if starting interval not found, phiStart  must be between last and first cross section
  if (!intervalFound) {
    indexA = crossSections.length - 1;
    indexB = 0;
  }

  var inversePositionsLength = 1.0 / positionsLength;
  var inverseSegments = 1.0 / segments;

  var meshAPos = void 0;
  var meshBPos = void 0;
  var tempUV = new _three.Vector2();
  var tempPosA = new _three.Vector3();
  var tempPosB = new _three.Vector3();
  var interpPos = new _three.Vector3();

  var rotationMat4 = new _three.Matrix4();

  var valuesCounter = 0;

  for (var _i = 0; _i <= segments; _i++) {
    var phi = phiStart + _i * inverseSegments * phiLength;
    rotationMat4.makeRotationY(phi);

    var alpha = getAlpha(phi, crossSections[indexA].locationAngle, crossSections[indexB].locationAngle);
    //alpha > 1 means we need to look at next interval of cross sections
    while (alpha > 1) {
      indexA = indexB;
      indexB = (indexB + 1) % crossSections.length;
      alpha = getAlpha(phi, crossSections[indexA].locationAngle, crossSections[indexB].locationAngle);
    }

    for (var j = 0; j < positionsLength; j++) {
      meshAPos = crossSections[indexA].mesh.positions;
      meshBPos = crossSections[indexB].mesh.positions;
      meshAPos.values.getAt(meshAPos.faceValueIndices[j], tempPosA);
      meshBPos.values.getAt(meshBPos.faceValueIndices[j], tempPosB);
      interpolate(interpolationType, tempPosA, tempPosB, alpha, interpPos);
      interpPos.x += radius;
      interpPos.applyMatrix4(rotationMat4);

      newPositions.setAt(valuesCounter++, interpPos);
    }
  }

  faceRangeOffsets[0] = 0;
  var faceCounter = 1;
  var indCounter = 0;
  var uvCounter = 0;
  for (var _i2 = 0; _i2 < segments; _i2++) {
    for (var _j = 0; _j < positionsLength; _j++) {
      var base = _j + positionsLength * _i2;
      var a = base;
      var b = base + positionsLength;
      //when j === positionsLength-1, we are creating the face that closes the generated 'tube'
      // (must loop back to first position in current segment)
      if (_j === positionsLength - 1) {
        base -= positionsLength;
      }
      var c = base + 1 + positionsLength;
      var d = base + 1;

      faceValueIndices[indCounter++] = a;
      faceValueIndices[indCounter++] = b;
      faceValueIndices[indCounter++] = c;
      faceValueIndices[indCounter++] = d;
      faceRangeOffsets[faceCounter++] = indCounter;

      var u0 = _i2 * inverseSegments;
      var v0 = _j * inversePositionsLength;
      var u1 = u0 + inverseSegments;
      var v1 = v0 + inversePositionsLength;

      tempUV.set(u0, v0);
      uvValues.setAt(uvCounter, tempUV);
      tempUV.set(u1, v0);
      uvValues.setAt(uvCounter + 1, tempUV);
      tempUV.set(u1, v1);
      uvValues.setAt(uvCounter + 2, tempUV);
      tempUV.set(u0, v1);
      uvValues.setAt(uvCounter + 3, tempUV);

      uvFaceValueIndices[uvCounter] = uvCounter++;
      uvFaceValueIndices[uvCounter] = uvCounter++;
      uvFaceValueIndices[uvCounter] = uvCounter++;
      uvFaceValueIndices[uvCounter] = uvCounter++;
    }
  }

  var positionsMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: newPositions
  });

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: newNormals
  });

  var uvMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: uvFaceValueIndices,
    values: uvValues
  });

  var uvMapsByName = new _ObjectsByName2.default();
  var name = 'default';
  uvMapsByName.set(name, uvMap);

  var polyMesh = new _PolyMesh2.default();
  polyMesh.faceRangeOffsets = positionsMap.faceRangeOffsets;
  polyMesh.positions = positionsMap;
  polyMesh.normalMap = normalMap;
  polyMesh.uvMaps = uvMapsByName;

  return (0, _Normals.recalculateNormalsFromConnectivity)((0, _cleanPolyMesh2.default)(polyMesh));
}

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CylinderLathe;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _cleanPolyMesh = __webpack_require__(102);

var _cleanPolyMesh2 = _interopRequireDefault(_cleanPolyMesh);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CylinderLathe(srcPositions, srcNormals, segments, phiStart, phiLength, openEnded) {
  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;

  //assumes one normal per point
  var newPositions = new _ObjectArrayView2.default(_three.Vector3, (segments + 1) * srcPositions.length);
  var normals = new _ObjectArrayView2.default(_three.Vector3, (segments + 1) * srcNormals.length);
  var positionCounter = 0;
  var faceRangeOffsets = new Uint32Array(segments * (srcPositions.length - 1) + 1); //number of faces
  var faceValueIndices = new Uint32Array(segments * (srcPositions.length - 1) * 4); //number of faces*4
  var uvValues = new _ObjectArrayView2.default(_three.Vector2, (segments + 1) * srcPositions.length);
  var uvCounter = 0;

  var inversePointLength = openEnded ? 1.0 / (srcPositions.length - 1) : 1.0 / (srcPositions.length - 5);
  var inverseSegments = 1.0 / segments;

  faceRangeOffsets[0] = 0;
  var faceCounter = 1;

  var tempUV = new _three.Vector2();
  var vertex = new _three.Vector3();
  var normal = new _three.Vector3();

  var rotationMatrix4 = new _three.Matrix4().identity();
  var normalMatrix3 = new _three.Matrix3().identity();

  for (var i = 0, il = segments; i <= il; i++) {
    var phi = phiStart + i * inverseSegments * phiLength;
    rotationMatrix4.makeRotationY(phi);
    normalMatrix3.getNormalMatrix(rotationMatrix4);

    for (var j = 0, jl = srcPositions.length; j < jl; j++) {
      srcPositions.getAt(j, vertex);
      srcNormals.getAt(j, normal);

      vertex.applyMatrix4(rotationMatrix4);
      normal.applyMatrix3(normalMatrix3);

      newPositions.setAt(positionCounter, vertex);
      normals.setAt(positionCounter++, normal);
    }
  }
  // Create UVs
  for (var _i = 0, _il = segments; _i <= _il; _i++) {
    var u = _i * inverseSegments;
    //bottom
    if (!openEnded) {
      for (var _j = 0, _jl = 2; _j < _jl; _j++) {
        var v = _j;
        if (v === 0) tempUV.set(0, v);else tempUV.set(u, v);
        uvValues.setAt(uvCounter++, tempUV);
      }
    }
    //body
    for (var _j2 = 0, _jl2 = openEnded ? srcPositions.length : srcPositions.length - 4; _j2 < _jl2; _j2++) {
      var _v = _j2 * inversePointLength;
      tempUV.set(u, _v);
      uvValues.setAt(uvCounter++, tempUV);
    }
    //top
    if (!openEnded) {
      for (var _j3 = 0, _jl3 = 2; _j3 < _jl3; _j3++) {
        var _v2 = _j3;
        if (_v2 === 1) tempUV.set(0, _v2);else tempUV.set(u, _v2);
        uvValues.setAt(uvCounter++, tempUV);
      }
    }
  }

  var positionsLen = srcPositions.length;
  var indCounter = 0;
  for (var _i2 = 0, _il2 = segments; _i2 < _il2; _i2++) {
    for (var _j4 = 0, _jl4 = srcPositions.length - 1; _j4 < _jl4; _j4++) {
      var base = _j4 + positionsLen * _i2;
      var a = base;
      var b = base + positionsLen;
      var c = base + 1 + positionsLen;
      var d = base + 1;

      faceValueIndices[indCounter++] = a;
      faceValueIndices[indCounter++] = b;
      faceValueIndices[indCounter++] = c;
      faceValueIndices[indCounter++] = d;
      faceRangeOffsets[faceCounter++] = indCounter;
    }
  }

  var positionsMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: newPositions
  });

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: normals
  });

  var uvMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: uvValues
  });

  var uvMapsByName = new _ObjectsByName2.default();
  var name = 'default';
  uvMapsByName.set(name, uvMap);

  var polyMesh = new _PolyMesh2.default();
  polyMesh.faceRangeOffsets = positionsMap.faceRangeOffsets;
  polyMesh.positions = positionsMap;
  polyMesh.normalMap = normalMap;
  polyMesh.uvMaps = uvMapsByName;

  return (0, _cleanPolyMesh2.default)(new _PolyMesh2.default(polyMesh));
  //return new PolyMesh( new PolyMesh( polyMesh ) );
}

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Disk;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _Lathe = __webpack_require__(125);

var _Lathe2 = _interopRequireDefault(_Lathe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Disk(radius, segments, thetaStart, thetaLength) {
  radius = radius || 50;

  segments = Math.max(1, Math.floor(segments || 8));
  var segmentLength = radius / segments;

  thetaStart = _three.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
  thetaLength = _three.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);

  var points = new _ObjectArrayView2.default(_three.Vector3, segments + 1);
  var norms = new _ObjectArrayView2.default(_three.Vector3, segments + 1);
  var normPt = new _three.Vector3(0, 1, 0);
  var pt = new _three.Vector3();

  for (var i = 0, il = segments; i <= il; i++) {
    pt.set(radius - i * segmentLength, 0, 0);

    points.setAt(i, pt);
    norms.setAt(i, normPt);
  }

  var latheSegments = segments < 3 ? 3 : segments;
  return (0, _Lathe2.default)(points, norms, latheSegments, thetaStart, thetaLength);
}

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Plane;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ObjectsByName = __webpack_require__(18);

var _ObjectsByName2 = _interopRequireDefault(_ObjectsByName);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Plane(width, height, widthSegments, heightSegments) {
  widthSegments = Math.floor(widthSegments);
  heightSegments = Math.floor(heightSegments);

  var faceRangeOffsets = new Uint32Array(widthSegments * heightSegments + 1);
  var faceValueIndices = new Uint32Array(widthSegments * heightSegments * 4);
  var values = new _ObjectArrayView2.default(_three.Vector3, (widthSegments + 1) * (heightSegments + 1));
  var normals = new _ObjectArrayView2.default(_three.Vector3, (widthSegments + 1) * (heightSegments + 1));
  var uvValues = new _ObjectArrayView2.default(_three.Vector2, (widthSegments + 1) * (heightSegments + 1));

  var segment_width = width / widthSegments;
  var segment_height = height / heightSegments;

  var width_half = width / 2;
  var height_half = height / 2;

  var iz = void 0,
      ix = void 0;

  var newValue = new _three.Vector3();
  var newNormal = new _three.Vector3(0, 1, 0);
  var newUV = new _three.Vector2();

  //populate FaceRangeOffsets
  for (iz = 0, ix = 0; iz < faceRangeOffsets.length; iz++, ix += 4) {
    faceRangeOffsets[iz] = ix; //0 4 8 12 16 20 ...
  }

  //populate faceValueIndices
  for (iz = 0; iz < heightSegments; iz++) {
    for (ix = 0; ix < widthSegments; ix++) {
      faceValueIndices[(iz * widthSegments + ix) * 4] = iz * (widthSegments + 1) + ix;
      faceValueIndices[(iz * widthSegments + ix) * 4 + 1] = iz * (widthSegments + 1) + ix + 1;
      faceValueIndices[(iz * widthSegments + ix) * 4 + 2] = (iz + 1) * (widthSegments + 1) + ix + 1;
      faceValueIndices[(iz * widthSegments + ix) * 4 + 3] = (iz + 1) * (widthSegments + 1) + ix;
    }
  }

  //populate values, normals, and uv values
  for (iz = 0; iz < heightSegments + 1; iz++) {
    //calculate z coord
    var z = iz * segment_height - height_half;

    for (ix = 0; ix < widthSegments + 1; ix++) {
      //calculate x coord
      var x = ix * segment_width - width_half;

      //set value
      newValue.set(x, 0, -z);
      values.setAt(iz * (widthSegments + 1) + ix, newValue);

      //set normal
      normals.setAt(iz * (widthSegments + 1) + ix, newNormal);

      //set uv value
      newUV.set(ix / widthSegments, iz / heightSegments);
      uvValues.setAt(iz * (widthSegments + 1) + ix, newUV);
    }
  }

  var positionsMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: values
  });

  var normalMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: normals
  });

  var uvMap = new _PolyMap2.default({
    faceRangeOffsets: faceRangeOffsets,
    faceValueIndices: faceValueIndices,
    values: uvValues
  });

  var uvMapsByName = new _ObjectsByName2.default();
  var name = 'default';
  uvMapsByName.set(name, uvMap);

  var meshObj = {
    faceRangeOffsets: faceRangeOffsets,
    positions: positionsMap,
    normalMap: normalMap,
    uvMaps: uvMapsByName,
    colorMaps: new _ObjectsByName2.default()
  };

  var polyMesh = new _PolyMesh2.default(meshObj);
  return polyMesh;
}

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RevolveReferenceMesh;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _Lathe = __webpack_require__(125);

var _Lathe2 = _interopRequireDefault(_Lathe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function RevolveReferenceMesh(refMesh, segments, phiStart, phiLength, latheToWorldTransform, refMeshToWorld) {
  if (!refMesh) {
    return null;
  }

  phiStart = phiStart * Math.PI / 180;
  phiLength = phiLength * Math.PI / 180;
  var meshToLatheTransform = new _three.Matrix4().getInverse(latheToWorldTransform, true).multiply(refMeshToWorld);

  var positions = refMesh.positions;
  var values = positions.values;
  var numValues = values.length;
  var faceRangeOffsets = positions.faceRangeOffsets;
  var faceValueIndices = positions.faceValueIndices;
  var tempPositionValues = new _ObjectArrayView2.default(_three.Vector3, numValues);

  var newRefMeshPositions = new _ObjectArrayView2.default(_three.Vector3, numValues + 1);
  var newRefMeshNormals = new _ObjectArrayView2.default(_three.Vector3, numValues + 1);

  var tempVector3 = new _three.Vector3();
  var edge1 = new _three.Vector3();
  var edge2 = new _three.Vector3();

  var faceBegin = faceRangeOffsets[0];
  var faceUntil = faceRangeOffsets[1];

  for (var fv = faceBegin; fv < faceUntil; ++fv) {
    var currVal = faceValueIndices[fv];
    values.getAt(currVal, tempVector3);
    tempPositionValues.setAt(fv, tempVector3);
  }

  //transform positions to lathe object space
  //the last position is equal to the first position since lathe does not connect the first and last with an edge
  for (var i = 0; i <= numValues; ++i) {
    tempPositionValues.getAt(i % numValues, tempVector3);
    tempVector3.applyMatrix4(meshToLatheTransform);
    newRefMeshPositions.setAt(i, tempVector3);
  }

  //calculate the face normal, eventually used to create vertex normals
  //the loop continues until we find three non-colinear positions
  var faceNormal = new _three.Vector3();
  for (var _i = 0; faceNormal.length() < 0.000001 && _i < numValues - 2; ++_i) {
    edge1 = newRefMeshPositions.getAt(_i + 1).clone().sub(newRefMeshPositions.getAt(_i));
    edge2 = newRefMeshPositions.getAt(_i + 2).clone().sub(newRefMeshPositions.getAt(_i + 1));
    faceNormal.crossVectors(edge1, edge2);
  }

  var vertex1 = new _three.Vector3();
  var vertex2 = new _three.Vector3();
  var vertex3 = new _three.Vector3();
  var vertexNormal = new _three.Vector3();
  //walks along the edges and calculate normals
  for (var _i2 = 0; _i2 < numValues + 1; ++_i2) {
    //look at position at index i - 1, i, i + 1 in a circular manner
    newRefMeshPositions.getAt((_i2 - 1 + newRefMeshPositions.length) % newRefMeshPositions.length, vertex1);
    newRefMeshPositions.getAt(_i2, vertex2);
    newRefMeshPositions.getAt((_i2 + 1) % newRefMeshPositions.length, vertex3);
    edge1.subVectors(vertex2, vertex1);
    edge2.subVectors(vertex3, vertex2);

    //the normals of the edges incident on position i
    edge1.cross(faceNormal);
    edge2.cross(faceNormal);

    vertexNormal.addVectors(edge1, edge2).normalize();
    newRefMeshNormals.setAt(_i2, vertexNormal);
  }

  return (0, _Lathe2.default)(newRefMeshPositions, newRefMeshNormals, segments, phiStart, phiLength);
}

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RevolveReferenceSegment;

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _bendPolyMesh = __webpack_require__(158);

var _bendPolyMesh2 = _interopRequireDefault(_bendPolyMesh);

var _mergePolyMeshes = __webpack_require__(103);

var _mergePolyMeshes2 = _interopRequireDefault(_mergePolyMeshes);

var _createMeshArray2 = __webpack_require__(235);

var _createMeshArray3 = _interopRequireDefault(_createMeshArray2);

var _three = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEG_TO_RAD = Math.PI / 180;

RevolveReferenceSegment.AxisTypes = {
  X: 0,
  Y: 1,
  Z: 2
};

function RevolveReferenceSegment(segmentMesh, axis, repeats, radius, revolutionAngle, spacingAngle) {
  var rotationPerSegmentDeg = revolutionAngle / repeats;
  var bendPerSegmentDeg = rotationPerSegmentDeg - spacingAngle;
  var bentSegmentMesh = bendSegment(segmentMesh, axis, bendPerSegmentDeg, radius);

  var rotationVec3 = new _three.Vector3();
  rotationVec3.setComponent(axis, rotationPerSegmentDeg * DEG_TO_RAD);
  var rotation = new _three.Quaternion().setFromEuler(new _three.Euler().setFromVector3(rotationVec3, 'ZYX'));

  var _createMeshArray = (0, _createMeshArray3.default)(bentSegmentMesh, repeats, new _three.Vector3(), rotation, new _three.Vector3(1, 1, 1)),
      meshArray = _createMeshArray.meshArray,
      transforms = _createMeshArray.transforms;

  var mergedMesh = (0, _mergePolyMeshes2.default)(meshArray, transforms);

  return mergedMesh;
}

function bendSegment(segmentMesh, axis, bendAngleDeg, radius) {
  //must clone positions as they change
  var clonedPositionsValues = segmentMesh.positions.values.clone();
  var clonedPositionsMap = new _PolyMap2.default(segmentMesh.positions, {
    values: clonedPositionsValues
  });
  segmentMesh = new _PolyMesh2.default(segmentMesh, { positions: clonedPositionsMap });

  var bendInfo = getBendInfo(axis, bendAngleDeg);

  var boundingBox = segmentMesh.boundingBox;
  var axisLength = boundingBox.max.getComponent(bendInfo.scaleAxis) - boundingBox.min.getComponent(bendInfo.scaleAxis);
  var axisScale = radius * bendAngleDeg * DEG_TO_RAD / axisLength;
  var scaleVec3 = new _three.Vector3(1, 1, 1);
  scaleVec3.setComponent(bendInfo.scaleAxis, axisScale);
  var scaleMat4 = new _three.Matrix4().scale(scaleVec3);
  var positionValues = segmentMesh.positions.values;
  var position = new _three.Vector3();
  for (var i = 0; i < positionValues.length; ++i) {
    positionValues.getAt(i, position);
    position.applyMatrix4(scaleMat4);
    positionValues.setAt(i, position);
  }

  segmentMesh = (0, _bendPolyMesh2.default)(segmentMesh, bendInfo.bendAxis + 1, bendInfo.bendAngleDeg, new _three.Vector3(), new _three.Vector3(), false);

  //move segment to correct radius
  var translationVec3 = new _three.Vector3();
  translationVec3.setComponent(bendInfo.translateAxis, radius);
  positionValues = segmentMesh.positions.values;
  for (var _i = 0; _i < positionValues.length; ++_i) {
    positionValues.getAt(_i, position);
    position.add(translationVec3);
    positionValues.setAt(_i, position);
  }

  return segmentMesh;
}

function getBendInfo(axis, bendAngleDeg) {
  var bendInfo = {};
  //these values are based on Bend Deformer's default behaviours
  switch (axis) {
    case RevolveReferenceSegment.AxisTypes.X:
      bendInfo.bendAxis = 0;
      bendInfo.scaleAxis = 1;
      bendInfo.translateAxis = 2;
      bendInfo.bendAngleDeg = bendAngleDeg;
      break;
    case RevolveReferenceSegment.AxisTypes.Z:
      bendInfo.bendAxis = 2;
      bendInfo.scaleAxis = 1;
      bendInfo.translateAxis = 0;
      bendInfo.bendAngleDeg = -bendAngleDeg;
      break;
    default:
      //Y is default
      bendInfo.bendAxis = 1;
      bendInfo.scaleAxis = 2;
      bendInfo.translateAxis = 0;
      bendInfo.bendAngleDeg = -bendAngleDeg;
      break;
  }
  return bendInfo;
}

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Sphere;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _Lathe = __webpack_require__(125);

var _Lathe2 = _interopRequireDefault(_Lathe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Sphere(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  radius = radius || 50;

  widthSegments = Math.max(3, Math.floor(widthSegments || 8));
  heightSegments = Math.max(2, Math.floor(heightSegments || 6));

  phiStart = _three.Math.clamp(phiStart || 0, 0, Math.PI * 2);
  phiLength = _three.Math.clamp(phiLength || Math.PI * 2, 0, Math.PI * 2 - phiStart);

  thetaStart = _three.Math.clamp(thetaStart || 0, 0, Math.PI);
  thetaLength = _three.Math.clamp(thetaLength || Math.PI, 0, Math.PI - thetaStart);

  var inverseHeightSegments = 1.0 / heightSegments;
  var points = new _ObjectArrayView2.default(_three.Vector3, heightSegments + 1);
  var norms = new _ObjectArrayView2.default(_three.Vector3, heightSegments + 1);
  var pt = new _three.Vector3();

  for (var i = 0, il = heightSegments; i <= il; i++) {
    var theta = thetaStart + i * inverseHeightSegments * thetaLength;

    pt.set(radius * Math.sin(theta), -radius * Math.cos(theta), 0);

    points.setAt(i, pt);
    norms.setAt(i, pt.normalize());
  }

  return (0, _Lathe2.default)(points, norms, widthSegments, phiStart, phiLength);
}

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Torus;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _Lathe = __webpack_require__(125);

var _Lathe2 = _interopRequireDefault(_Lathe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Torus(radius, tube, radialSegments, tubularSegments, phiStart, phiLength, thetaStart, thetaLength) {
  radialSegments = Math.floor(radialSegments) || 1;
  tubularSegments = Math.floor(tubularSegments) || 1;

  radius = radius || 100;
  tube = tube || 40;

  radialSegments = Math.max(radialSegments || 8, 3);
  tubularSegments = Math.max(tubularSegments || 6, 3);

  phiStart = _three.Math.clamp(phiStart || 0, 0, Math.PI * 2);
  phiLength = _three.Math.clamp(phiLength || Math.PI * 2, 0, Math.PI * 2 - phiStart);

  thetaStart = _three.Math.clamp(thetaStart || 0, 0, Math.PI * 2);
  thetaLength = _three.Math.clamp(thetaLength || Math.PI * 2, 0, Math.PI * 2 - thetaStart);

  var inverseTubularSegments = 1.0 / tubularSegments;
  var points = new _ObjectArrayView2.default(_three.Vector3, tubularSegments + 1);
  var norms = new _ObjectArrayView2.default(_three.Vector3, tubularSegments + 1);
  var pt = new _three.Vector3();
  var normPt = new _three.Vector3();

  for (var i = 0, il = tubularSegments; i <= il; i++) {
    var theta = thetaStart + i * inverseTubularSegments * thetaLength;

    pt.set(radius + tube * Math.cos(theta), tube * Math.sin(theta), 0);

    normPt.set(Math.cos(theta), Math.sin(theta), 0);

    points.setAt(i, pt);
    norms.setAt(i, normPt.normalize());
  }

  return (0, _Lathe2.default)(points, norms, radialSegments, phiStart, phiLength);
}

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Exporter;

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ScalarArrayView = __webpack_require__(156);

var _ScalarArrayView2 = _interopRequireDefault(_ScalarArrayView);

var _IndexMappings = __webpack_require__(124);

var _IndexMappings2 = _interopRequireDefault(_IndexMappings);

var _RenderIndexing = __webpack_require__(419);

var _RenderIndexing2 = _interopRequireDefault(_RenderIndexing);

var _EarCutTriangulation = __webpack_require__(230);

var _EarCutTriangulation2 = _interopRequireDefault(_EarCutTriangulation);

var _SimpleFanTriangulation = __webpack_require__(420);

var _SimpleFanTriangulation2 = _interopRequireDefault(_SimpleFanTriangulation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Exporter(polyMesh) {
  this.mesh = polyMesh;

  this.triangulation = null;
  this.renderIndexing = null;
}

Exporter.prototype = {
  constructor: Exporter,

  reindexForRendering: function reindexForRendering(optionalMapIdWhitelist) {
    if (this.triangulation !== null) throw Error('Reindex must come before triangulation!');

    this.renderIndexing = new _RenderIndexing2.default(this.mesh, optionalMapIdWhitelist);

    return this;
  },

  triangulate: function triangulate(optionalTriangulationType) {
    var triangulationType = optionalTriangulationType || _EarCutTriangulation2.default;

    this.triangulation = new triangulationType(this.mesh, this.renderIndexing);

    return this;
  },

  getNumFaces: function getNumFaces() {
    var triangulation = this.triangulation;

    return triangulation === null ? this.mesh.getNumFaces() : triangulation.numTriangles;
  },

  getNumFaceVertices: function getNumFaceVertices() {
    return this.triangulation === null ? this.mesh.getNumFaceVertices() : this.getNumFaces() * 3;
  },

  getNumMapValues: function getNumMapValues(mapId) {
    var renderIndexing = this.renderIndexing;

    return renderIndexing !== null ? renderIndexing.numVertices : this.mesh.getMapById(mapId).values.length;
  },

  getFaceArities: function getFaceArities(optionalArrayOrType, optionalOffset, optionalStride) {
    if (this.triangulation !== null) throw Error('No face arity export for triangular meshes!');

    var result = new _ScalarArrayView2.default(this.getNumFaces(), optionalArrayOrType, optionalOffset, optionalStride),
        offsets = this.mesh.faceRangeOffsets,
        nOffsets = offsets.length;

    if (nOffsets > 1) {
      var prevOffset = offsets[0];

      for (var i = 1; i !== nOffsets; ++i) {
        var offset = offsets[i];
        result.setAt(i - 1, offset - prevOffset);
        prevOffset = offset;
      }
    }

    return result.data;
  },

  getMaterialIds: function getMaterialIds(optionalArrayOrType, optionalOffset, optionalStride) {
    var result = null,
        source = this.mesh.materialIDs;

    if (source === null) return null;

    if (this.triangulation === null) {
      var offset = optionalOffset || 0,
          stride = optionalStride || 1,
          arrayOrType = optionalArrayOrType || source.data.constructor;

      if (offset === 0 && stride === 1 && arrayOrType === source.data.constructor) return source;

      result = new _ScalarArrayView2.default(source.length, arrayOrType, offset, stride);

      result.fromArray(source);
    } else {
      this.triangulation.translateMaterialIds(source, result);
    }

    return result.data;
  },

  getMapValues: function getMapValues(mapId, optionalArrayOrType, optionalOffset, optionalStride) {
    var result = null,
        renderIndexing = this.renderIndexing,
        source = this.mesh.getMapById(mapId).values,
        type = source.type,
        offset = optionalOffset || 0,
        stride = optionalStride || type.InstanceScalarSize,
        arrayOrType = optionalArrayOrType || source.data.constructor;

    if (renderIndexing === null && offset === 0 && stride === type.InstanceScalarSize && arrayOrType === source.data.constructor) result = source;else {
      // compatible format, just expose the data

      var length = renderIndexing === null ? source.length : renderIndexing.numVertices;

      result = this._offsetObjects(type, length, arrayOrType, offset, stride);

      if (renderIndexing !== null) {
        renderIndexing.getMapValues(mapId, result);
      } else {
        result.fromArray(source.data);
      }
    }

    return result.data;
  },
  getGroups: function getGroups() {
    var triangulation = this.triangulation;
    var result = triangulation.groups;
    return result;
  },
  getMapIndices: function getMapIndices(mapId, optionalArrayOrType, optionalOffset, optionalStride) {
    var result = null,
        renderIndexing = this.renderIndexing,
        triangulation = this.triangulation,
        source = renderIndexing !== null ? renderIndexing.renderIndices : this.mesh.getMapById(mapId).faceValueIndices;

    if (triangulation === null) {
      var offset = optionalOffset || 0,
          stride = optionalStride || 1,
          arrayOrType = optionalArrayOrType || source.constructor;

      if (offset === 0 && stride === 1 && arrayOrType === source.constructor) return source;

      result = new _ScalarArrayView2.default(source.length, arrayOrType, offset, stride);

      result.fromArray(source);
    } else {
      result = new _ScalarArrayView2.default(this.triangulation.numTriangles * 3, optionalArrayOrType, optionalOffset, optionalStride);

      triangulation.translateIndices(source, result);
    }

    return result.data;
  },

  getUnindexedMapValues: function getUnindexedMapValues(mapId, allowTriangulation, optionalArrayOrType, optionalOffset, optionalStride) {
    var result = null,
        polyMap = this.mesh.getMapById(mapId),
        values = polyMap.values,
        valueType = values.type,
        indices = polyMap.faceValueIndices,
        triangulation = this.triangulation;

    if (!allowTriangulation || triangulation === null) {
      result = this._offsetObjects(valueType, indices.length, optionalArrayOrType || values.data.constructor, optionalOffset, optionalStride);

      var temp = values.newRangeArray(1);

      for (var i = 0, n = indices.length; i !== n; ++i) {
        result.arrayToRange(values.rangeToArray(indices[i], 1, temp), i, 1);
      }
    } else {
      result = this._offsetObjects(valueType, triangulation.numTriangles * 3, optionalArrayOrType || values.data.constructor, optionalOffset, optionalStride);

      triangulation.translateToUnindexedValues(values, result, indices);
    }

    return result.data;
  },

  getTriangulatingIndices: function getTriangulatingIndices(optionalArrayOrType, optionalOffset, optionalStride) {
    var triangulation = this.triangulation;

    if (triangulation === null) return null;

    var result = new _ScalarArrayView2.default(this.getNumFaceVertices(), optionalArrayOrType, optionalOffset, optionalStride),
        nFaceVertices = this.getNumFaceVertices(),
        identityMap = _IndexMappings2.default.identityForReading(nFaceVertices);

    triangulation.translateIndices(identityMap, result);

    return result.data;
  },

  _offsetObjects: function _offsetObjects(type, length, arrayOrType, optionalOffset, optionalStride) {
    var offset = optionalOffset || 0,
        stride = optionalStride || type.InstanceScalarSize,
        offsetLength = offset / stride | 0,
        minArrayLength = (offsetLength + length) * stride,
        array = _Arrays2.default.maybeCreate(arrayOrType, minArrayLength),
        offsetView = offset === 0 ? array : array.subarray(offset);

    return new _ObjectArrayView2.default(type, null, offsetView, stride);
  }
};

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Importer;

var _three = __webpack_require__(0);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _ScalarArrayView = __webpack_require__(156);

var _ScalarArrayView2 = _interopRequireDefault(_ScalarArrayView);

var _Arrays = __webpack_require__(34);

var _Arrays2 = _interopRequireDefault(_Arrays);

var _PolyMaps = __webpack_require__(31);

var _PolyMaps2 = _interopRequireDefault(_PolyMaps);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

var _PolyMesh = __webpack_require__(5);

var _PolyMesh2 = _interopRequireDefault(_PolyMesh);

var _BlendShapeData = __webpack_require__(231);

var _BlendShapeData2 = _interopRequireDefault(_BlendShapeData);

var _Skinning = __webpack_require__(421);

var _Skinning2 = _interopRequireDefault(_Skinning);

var _ImportConversions = __webpack_require__(418);

var _ImportConversions2 = _interopRequireDefault(_ImportConversions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Importer() {
  this.defaultFaceArity = 3; // triangles
  this.collapsePositions = true; // re-index positions
  this.collapseMapValues = true; // join equal map values at the same vertex

  this.faceArities = null;
  this.materialIds = null;

  this.mapIds = [];
  this.mapValues = {};
  this.mapIndices = {};

  this.skinning = null;
  this.creases = null;
}

Importer.prototype = {
  constructor: Importer,

  setFaceArities: function setFaceArities(array, optionalNumberOfElements, optionalOffset, optionalStride) {
    this.faceArities = new _ScalarArrayView2.default(optionalNumberOfElements || null, array, optionalOffset, optionalStride);

    return this;
  },

  setMaterialIds: function setMaterialIds(materialIds) {
    for (var i = 0; i < materialIds.length; i++) {
      //only add to the polymesh if array contains a non zero value
      if (materialIds[i] > 0) {
        this.materialIds = materialIds;
        break;
      }
    }

    return this;
  },

  setMapValues: function setMapValues(mapId, array, optionalNumberOfElements, optionalOffset, optionalStride) {
    var id = _PolyMaps2.default.checkId(mapId);
    var ids = this.mapIds;

    if (ids.indexOf(id) === -1) ids.push(id);

    this.mapValues[id] = new _ObjectArrayView2.default(_PolyMaps2.default.getTypeInfo(_PolyMaps2.default.getAnchorName(mapId)).ElementType, optionalNumberOfElements || null, !optionalOffset ? array : array.subarray(optionalOffset), optionalStride);

    return this;
  },

  setMapIndices: function setMapIndices(mapId, array, optionalNumberOfElements, optionalOffset, optionalStride) {
    this.mapIndices[_PolyMaps2.default.checkId(mapId)] = new _ScalarArrayView2.default(optionalNumberOfElements || null, array, optionalOffset, optionalStride);

    return this;
  },

  initializeBlendShape: function initializeBlendShape() {
    this.blendShapes = {};

    return this;
  },

  setBlendShapes: function setBlendShapes(name, positions, normals, weights) {
    this.blendShapes[name] = new _BlendShapeData2.default(new _ObjectArrayView2.default(_three.Vector3, null, positions), !!normals ? new _ObjectArrayView2.default(_three.Vector3, null, normals) : null, !!weights ? new _ScalarArrayView2.default(weights.length, weights) : null);
    return this;
  },

  setSkinning: function setSkinning(positionSkinRange, skinWeights, skinBoneIndices, poseSkinToPoseBoneTransform) {
    this.skinning = {};

    this.skinning.positionSkinRange = positionSkinRange;
    this.skinning.skinWeights = skinWeights;
    this.skinning.skinBoneIndices = skinBoneIndices;

    this.skinning.poseSkinToPoseBoneTransform = new _ObjectArrayView2.default(_three.Matrix4, null, poseSkinToPoseBoneTransform);

    return this;
  },

  setCreases: function setCreases(weights, edges) {
    this.creases = { weights: weights, edges: edges };
  },

  toMeshAndClear: function toMeshAndClear() {
    var mapIds = this.mapIds;
    var mapValueData = this.mapValues;
    var mapIndexData = this.mapIndices;

    var positionMapId = _PolyMaps2.default.IdPositions;
    var positions = mapValueData[positionMapId];

    var faceArities = this.faceArities;
    var materialIds = this.materialIds;

    if (!positions) throw Error('No positions!');

    var positionIndices = mapIndexData[positionMapId] || null;

    var nFaceVertices = positionIndices ? positionIndices.length : positions.length;

    var faceOffsets = null;
    //  -----------

    if (faceArities === null) {
      var fixedArity = this.defaultFaceArity;
      var nFaces = nFaceVertices / fixedArity | 0;

      faceArities = new Uint32Array(nFaces + 1).fill(fixedArity, 1);
    } else {
      faceArities = faceArities.toArray(Uint32Array, 1);
    }

    // Here faceOffsets contains the face arities after a zero at index 0,
    // their accumulation yields the offsets (including length sentinel):
    faceOffsets = _Arrays2.default.accumulate(faceArities); // (in-place)

    for (var i = 0; i !== mapIds.length; ++i) {
      // avoid aliasing with the map indices in case it's the same array

      var mapId = mapIds[i];
      if (mapId === positionMapId) continue;

      var mapIndexView = mapIndexData[mapId];

      if (mapIndexView !== undefined) mapIndexView.forceRepack(Uint32Array);
    }

    var indices = null;
    if (this.collapsePositions) {
      // re-index values
      if (positionIndices !== null) indices = positionIndices.repack(Uint32Array).data;

      positions = _ImportConversions2.default.collapsePositions(positions, indices);
    } else if (positionIndices !== null) {
      // use given indices as-is
      indices = positionIndices.repack(Uint32Array).data;
    }

    var mesh = _PolyMesh2.default.fromData(faceOffsets, positions, indices, materialIds);

    for (var _i = 0; _i !== mapIds.length; ++_i) {
      var _mapId = mapIds[_i];
      if (_mapId === positionMapId) continue;

      var _mapIndexView = mapIndexData[_mapId];
      var mapValueView = mapValueData[_mapId];

      var polyMap = _PolyMap2.default.fromData(faceOffsets, _mapIndexView.data, mapValueView);

      if (this.collapseMapValues) {
        _ImportConversions2.default.collapseMapVertexValues(mesh, polyMap);

        polyMap.compactValues();
      }

      _PolyMaps2.default.assignMap(mesh, _mapId, polyMap);
    }

    if (this.skinning) mesh.skinning = new _Skinning2.default(this.skinning);

    if (this.creases) {
      var _creases = this.creases,
          weights = _creases.weights,
          edges = _creases.edges;
      // if edges array exists, need to calculate edge indices from the vertex pairs

      if (edges) {
        // generate edge indices from vertex pairs
        var edgeVertexAdjacency = mesh.positions.edgeVertexAdjacency;
        var edgeWeights = new Float32Array(edgeVertexAdjacency.getNumEdges());
        for (var _i2 = 0, e = 0; _i2 < edges.length; _i2 += 2, e++) {
          edgeWeights[edgeVertexAdjacency.findEdgeId(edges[_i2], edges[_i2 + 1])] = weights[e];
        }

        mesh.edgeCreaseWeights = edgeWeights;
      } else mesh.edgeCreaseWeights = weights; // no edges array, assume weight index = edge index
    }

    Importer.call(this); // re-run constructor to clear state

    if (this.blendShapes) {
      mesh.blendShapes = this.blendShapes;
    }

    return mesh;
  }
};

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Renormalizer;

var _three = __webpack_require__(0);

var _BitSet = __webpack_require__(155);

var _BitSet2 = _interopRequireDefault(_BitSet);

var _ObjectArrayView = __webpack_require__(3);

var _ObjectArrayView2 = _interopRequireDefault(_ObjectArrayView);

var _PolyMap = __webpack_require__(6);

var _PolyMap2 = _interopRequireDefault(_PolyMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Renormalizer(newMesh) {
  this.mesh = newMesh;
  this.dirtyFaces = new _BitSet2.default(newMesh.getNumFaces());
  this.areaWeighted = true;
  this.needNewNormalMap = true;
  this.needNewNormalValues = true;

  newMesh.positions.updateInverseIndex();
}

Renormalizer.prototype = {
  constructor: Renormalizer,

  markPositionsDirty: function markPositionsDirty(positionIndices) {
    var dirtyFaces = this.dirtyFaces,
        positions = this.mesh.positions,
        faceIndexOffsets = positions.valueFaceIndexOffsets,
        positionFaceIndices = positions.valueFaceIndices;

    for (var i = 0, n = positionIndices.length; i !== n; ++i) {
      var positionIndex = positionIndices[i];

      dirtyFaces.includeFromArray(positionFaceIndices, faceIndexOffsets[positionIndex], faceIndexOffsets[positionIndex + 1]);
    }
  },

  updateMesh: function updateMesh() {
    var mesh = this.mesh,
        dirtyFaces = this.dirtyFaces,
        areaWeighted = this.areaWeighted,
        nFaces = dirtyFaces.length,
        positionsMap = mesh.positions,
        positions = positionsMap.values,
        indices = positionsMap.faceValueIndices,
        faceNormalCache = new _ObjectArrayView2.default(_three.Vector3, nFaces),
        cachedFaceNormals = new _BitSet2.default(nFaces),
        vertexNormal = new _three.Vector3(),
        faceNormal = new _three.Vector3(),
        b = new _three.Vector3(),
        ba = new _three.Vector3(),
        faceOffsets = mesh.faceRangeOffsets,
        normalMap = this.ownNormalMap().updateInverseIndex(),
        normals = normalMap.values,
        faceIndices = normalMap.valueFaceIndices,
        faceIndexOffsets = normalMap.valueFaceIndexOffsets,
        facesBegin = faceIndexOffsets[0];

    for (var i = 0, n = normals.length; i !== n; ++i) {
      var facesUntil = faceIndexOffsets[i + 1];

      if (dirtyFaces.containsAnyIn(faceIndices, facesBegin, facesUntil)) {
        vertexNormal.setScalar(0);

        for (var j = facesBegin; j !== facesUntil; ++j) {
          vertexNormal.add(calculateFaceNormal(faceIndices[j]));
        }normals.setAt(i, vertexNormal.normalize());
      }

      facesBegin = facesUntil;
    }

    return mesh;

    function calculateFaceNormal(faceIndex) {
      if (cachedFaceNormals.contains(faceIndex)) {
        faceNormalCache.getAt(faceIndex, faceNormal);
      } else {
        var vertsBegin = faceOffsets[faceIndex],
            vertsUntil = faceOffsets[faceIndex + 1];

        if (vertsUntil - vertsBegin >= 3) {
          var bc = faceNormal;

          positions.getAt(indices[vertsBegin], b);

          positions.getAt(indices[vertsUntil - 1], ba).sub(b);
          positions.getAt(indices[vertsBegin + 1], bc).sub(b);

          bc.cross(ba);

          if (!areaWeighted) faceNormal.normalize();
        } else {
          faceNormal.setScalar(0);
        }

        faceNormalCache.setAt(faceIndex, faceNormal);
        cachedFaceNormals.include(faceIndex);
      }

      return faceNormal;
    }
  },

  ownNormalMap: function ownNormalMap() {
    var mesh = this.mesh,
        normalMap = mesh.normalMap;

    if (this.needNewNormalMap) mesh.normalMap = normalMap = new _PolyMap2.default(normalMap);

    if (this.needNewNormalValues) normalMap.values = normalMap.values.clone();

    return normalMap;
  }
};

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.getScreenPositionNormalAlpha = getScreenPositionNormalAlpha;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _scene = __webpack_require__(7);

var _player = __webpack_require__(8);

var _getProjectionMatrix = __webpack_require__(105);

var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getScreenPositionNormal(nodeWorldMatrix, cameraWorldMatrix, cameraProjection, localDirection) {
  var cameraInverseWorldMatrix = new THREE.Matrix4().getInverse(cameraWorldMatrix);

  var combinedCameraSpaceMatrix = new THREE.Matrix4().multiply(cameraInverseWorldMatrix).multiply(nodeWorldMatrix);
  var combinedProjectionMatrix = new THREE.Matrix4().multiply(cameraProjection).multiply(cameraInverseWorldMatrix).multiply(nodeWorldMatrix);

  var nodeLocalPosition = new THREE.Vector3(0, 0, 0);
  var nodeLocalDirectionOffset = localDirection;

  var nodeCameraPosition = nodeLocalPosition.clone().applyMatrix4(combinedCameraSpaceMatrix);
  var nodeCameraDirectionOffset = nodeLocalDirectionOffset.clone().applyMatrix4(combinedCameraSpaceMatrix);

  var nodeCameraNormal = new THREE.Vector3().subVectors(nodeCameraDirectionOffset, nodeCameraPosition).normalize();

  var nodeScreenPosition = nodeLocalPosition.clone().applyMatrix4(combinedProjectionMatrix);
  nodeScreenPosition.addScalar(1.0).multiplyScalar(0.5);

  return {
    position: nodeScreenPosition,
    normal: nodeCameraNormal
  };
}

function getScreenPositionNormalAlpha(id, calcDirection, directionAxis, directionTarget) {
  return function (store) {
    var nodeWorldTransform = (0, _scene.getWorldTransform)(store, id);
    var cameraId = (0, _player.getCamera)(store);
    var cameraPlug = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });

    var cameraWorldTransform = (0, _scene.getWorldTransform)(store, cameraId);
    if (!cameraWorldTransform) return {};

    var cameraProjection = (0, _getProjectionMatrix2.default)(cameraPlug);
    var positionNormal = getScreenPositionNormal(nodeWorldTransform, cameraWorldTransform, cameraProjection, getDirection(store, id, calcDirection, directionAxis, directionTarget));

    var annotation = (0, _scene.get)(store, { id: id, evalPlug: 'Annotation' });

    var alpha = 1.0;

    // mis-spelled visibility property.
    if (annotation.limitVisilibility) {
      var visibilityAngle = Math.min(annotation.visibilityAngle * 0.5, 180);
      var cameraWorldDirection = new THREE.Vector3(0, 0, -1);
      var dotResult = cameraWorldDirection.dot(positionNormal.normal);

      var theta = THREE.Math.radToDeg(Math.acos(cameraWorldDirection.dot(positionNormal.normal)));

      if (theta > visibilityAngle) {
        alpha = 0.0;
      } else if (theta > visibilityAngle * 0.75) {
        alpha = (visibilityAngle - theta) / (visibilityAngle * 0.25);
      }
    }

    return (0, _assign2.default)({ alpha: alpha }, positionNormal);
  };
}

function getDirection(store, id, calcDirection, directionAxis, directionTarget) {
  var direction = null;
  if (calcDirection) {
    var targetPosition = new THREE.Vector3(0, 0, 0);
    if (directionTarget) {
      targetPosition = new THREE.Vector3().setFromMatrixPosition((0, _scene.getWorldTransform)(store, directionTarget));
    }
    var currentTransform = (0, _scene.getWorldTransform)(store, id);
    var currentPosition = new THREE.Vector3().setFromMatrixPosition(currentTransform);
    direction = targetPosition.clone().sub(currentPosition).normalize();
    var inverseWorldMatrix = new THREE.Matrix4();
    inverseWorldMatrix.getInverse(currentTransform);
    direction.applyMatrix4(inverseWorldMatrix).normalize();
  } else {
    direction = new THREE.Vector3();
    direction[directionAxis] = -1;
  }

  return direction;
}

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLight = createLight;
exports.updateLight = updateLight;
exports.initAutoShadow = initAutoShadow;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _lightHelpers = __webpack_require__(482);

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var initialLightDefaults = {
  castShadow: true,
  color: { r: 1, g: 1, b: 1 },
  intensity: 0.85,
  lightType: 'DirectionalLight',
  radius: 0,
  shadowBias: 0,
  shadowCameraSize: 1.7321,
  shadowDarkness: 0.1,
  shadowFarClip: 40,
  shadowFrustumColor: { r: 1, g: 1, b: 1 },
  shadowNearClip: 10,
  shadowSize: 1024,
  showShadowCamera: false
};

function createLight(data, scene, visible, helpersRoot) {
  var type = data.lightType;
  var objectsRoot = scene.getObjectByName('Objects');
  switch (type) {
    case 'DirectionalLight':
      var directionalLight = new THREE.DirectionalLight(data.color.getHex(), data.intensity, data.decayExponent);
      directionalLight.visible = visible;
      directionalLight.target.position.set(0, 0, -1);
      directionalLight.target.updateMatrix();
      directionalLight.add(directionalLight.target);

      updateLight(data, directionalLight, objectsRoot);
      //if(__BROWSER__ && window.editor) createLightHelpers(scene, data, directionalLight, helpersRoot);
      return directionalLight;

    case 'PointLight':
      var pointLight = new THREE.PointLight(data.color.getHex(), data.intensity, data.distance);
      pointLight.visible = visible;
      updateLight(data, pointLight);
      return pointLight;

    case 'SpotLight':
      var spotLight = new THREE.SpotLight(data.color.getHex(), data.intensity, data.distance, data.coneAngle * Math.PI / 180, data.coneFalloff / 100, data.decayExponent);
      spotLight.visible = visible;
      spotLight.target.position.set(0, 0, -1);
      spotLight.target.updateMatrix();
      spotLight.add(spotLight.target);

      updateLight(data, spotLight, objectsRoot);
      //if(__BROWSER__ && window.editor) createLightHelpers(scene, data, spotLight, helpersRoot);
      return spotLight;

    case 'HemisphereLight':
      var hemisphereLight = new THREE.HemisphereLight(data.color.getHex(), data.gndColor.getHex(), data.intensity);
      hemisphereLight.rotateZ(-Math.PI / 2);
      var hemiLightHelper = new THREE.Object3D();
      hemiLightHelper.add(hemisphereLight);
      hemiLightHelper.visible = visible;
      updateLight(data, hemisphereLight, objectsRoot);

      //if(__BROWSER__ && window.editor) createLightHelpers(data, hemisphereLight, helpersRoot);
      return hemiLightHelper;

    case 'AreaLight':
      // Not sure why THREE.RectAreaLight doesn't work properly
      // const areaLight = new THREE.RectAreaLight(data.color.getHex(), data.intensity / 2, data.width * 2, data.height * 2);// double size,
      // areaLight.position.set(0, 0, 0);
      // areaLight.rotateY(Math.PI);
      // const areaLightHelper = new THREE.Object3D();
      // areaLightHelper.add(areaLight);
      // //TO DO: shadow
      // return areaLightHelper;
      // DO NOT SUPPORT AREALIGHT
      return;
    default:
      //throw new Error('Unknown light type: ' + type);
      console.warn('Unknown light type: ' + type);
      return;
  }
}

function updateLight(data, light, objectsRoot) {
  light.intensity = data.intensity;
  light.color.copy(data.color);

  //console.log( "lightData", data.shadowSize );

  switch (data.lightType) {
    case 'DirectionalLight':
      light.shadow.camera.left = -data.shadowCameraSize;
      light.shadow.camera.right = data.shadowCameraSize;
      light.shadow.camera.top = data.shadowCameraSize;
      light.shadow.camera.bottom = -data.shadowCameraSize;
      light.shadow.spreadAngle = THREE.Math.DEG2RAD * data.sourceAngle;
      break;

    case 'PointLight':
      light.distance = data.distance;
      light.angle = THREE.Math.DEG2RAD * data.coneAngle;
      light.penumbra = THREE.Math.DEG2RAD * data.coneFalloff;
      light.decay = data.decayExponent;
      light.shadow.radius = data.radius;
      break;

    case 'SpotLight':
      light.distance = data.distance;
      light.angle = THREE.Math.DEG2RAD * data.coneAngle;
      light.penumbra = THREE.Math.DEG2RAD * data.coneFalloff;
      light.decay = data.decayExponent;
      light.shadow.radius = data.radius;

      break;

    case 'HemisphereLight':
      light.groundColor.copy(data.gndColor);
      break;

    case 'AreaLight':
      break;

    default:
      //throw new Error('Unknown light type: ' + type);
      console.warn('Unknown light type: ' + type);
      break;
  }

  if (light.shadow) {
    light.castShadow = data.shadow;
    light.shadow.bias = data.shadowBias;
    light.shadow.mapSize.width = data.shadowSize;
    light.shadow.mapSize.height = data.shadowSize;

    light.autoShadow = data.autoShadow;

    var autoShadow = light.autoShadow && light.updateShadow;
    if (autoShadow) {
      // auto shadow calculation needs all meshes
      light.updateShadow(objectsRoot);
    } else {
      light.shadow.virtualPosition = undefined;
      light.shadow.camera.near = data.shadowNearClip;
      light.shadow.camera.far = data.shadowFarClip;
    }

    if (light.shadow.update) {
      light.shadow.update(light);
    }
  }
}

function initAutoShadow(scene) {
  if (!scene) return;
  var objectsRoot = scene.getObjectByName('Objects');
  if (!objectsRoot || !objectsRoot.traverseVisible) return;
  objectsRoot.traverseVisible(function (object) {
    if (object.isLight && object.autoShadow && object.updateShadow) {
      object.updateShadow(objectsRoot);
    }
  });
}
// Debug light and shadow    sourceAngle: { label: 'Source Angle', type: 'Number', defaultValue: 0.0, step: 0.1, minValue: 0, maxValue: 20 },

function createLightHelpers(scene, data, light, helpersRoot) {
  //create light helper
  if (light.type === 'DirectionalLight') light.lightHelper = new _lightHelpers.DirectionalLightHelper(light, 100);
  if (light.type === 'SpotLight') {
    light.lightHelper = new THREE.SpotLightHelper(light);
    scene.add(light.lightHelper);
  }
  //if (light.type === "HemisphereLight") light.lighthelper = new THREE.HemisphereLightHelper(light, 10);
  helpersRoot[light.type + 'Helper'] = light.lightHelper;
  //create light shadow helper
  if (light.shadow) {
    light.shadowHelper = new THREE.CameraHelper(light.shadow.camera);
    helpersRoot[light.type + 'ShadowHelper'] = light.shadowHelper;
    scene.add(light.shadowHelper);
  }
}

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.initManipulators = initManipulators;

var _claraFlyd = __webpack_require__(486);

var _claraFlyd2 = _interopRequireDefault(_claraFlyd);

var _transducers = __webpack_require__(484);

var _three = __webpack_require__(0);

var _scene = __webpack_require__(7);

var _player = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mapStream(el, eventName, fn) {
  var stream = _claraFlyd2.default.stream();
  el.addEventListener(eventName, stream);
  return fn ? _claraFlyd2.default.map(fn, stream) : stream;
}

function transduceStream(el, eventName, fn) {
  var stream = _claraFlyd2.default.stream();
  el.addEventListener(eventName, stream);
  return _claraFlyd2.default.transduce(fn, stream);
}

function isSingleTouch(e) {
  return e.touches && e.touches.length === 1;
}

function isDoubleTouch(e) {
  return e.touches && e.touches.length === 2;
}

function addMomentum(toStream, endStream) {
  var momentumStream = _claraFlyd2.default.stream()(0);

  var result = _claraFlyd2.default.combine(function (to, momentum) {
    return to.end() ? momentum() : to();
  }, [toStream, momentumStream]);

  var decay = 1;

  _claraFlyd2.default.on(function () {
    var timer = every(1000 / 60);
    var momentumStart = new Date();
    var momentumDecay = 0.2;
    if (!toStream()) {
      return momentumStream.end(true);
    }

    var _toStream = toStream(),
        deltaX = _toStream.deltaX,
        deltaY = _toStream.deltaY;

    _claraFlyd2.default.map(function (i) {
      if (decay <= 0.005) {
        momentumStream.end(true);
        timer.end(true);
      } else {
        decay = Math.exp(-(1 - momentumDecay) * 10 * (Date.now() - momentumStart) / 1000);
        //console.log('decay: ', decay, deltaX, deltaY);
        momentumStream({ deltaX: deltaX * decay, deltaY: deltaY * decay });
      }
    }, timer);
  }, toStream.end);

  return result;
}

function initManipulators(store, translator, el) {
  var playerEl = el.parentNode.parentNode;
  var offset = { x: 0, y: 0 };
  var rect = { width: 0, height: 0 };
  var commands = [];
  var hasEvents = {};

  var dragging = false;
  var draggingTool = void 0;
  var lastMousedown = false;

  function resize(newRect) {
    var playerRect = playerEl.getBoundingClientRect();
    offset = {
      x: playerRect.left + window.pageXOffset, // account for div offset + scroll
      y: playerRect.top + window.pageYOffset // account for div offset + scroll
    };
    rect = newRect;
  }

  function touchLastMove(ev) {
    if (dragging) dragging.lastMove = new Date();
    return ev;
  }

  function callTool(which) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return function (ev) {
      if (!hasEvents[which]) return;

      var command, tool, result;

      for (var i = commands.length - 1; i >= 0; i--) {
        command = commands[i];
        tool = command.tool;

        if (!command.enabled || !tool[which]) continue;

        result = tool[which].call(command, ev);

        if (options.findFirst) {
          if (result !== false) break;
        } else if (!options.doAll) {
          if (result === false) break;
        }
      }

      return result;
    };
  }

  function toCoords(ev) {
    // Calling preventDefault on 'mousedown' prevents the 'mouseup' event from firing when inside
    // an iframe. No reason to call preventDefault on these events, so don't.

    return {
      rect: rect,
      clientX: ev.clientX - offset.x + window.pageXOffset, // account for div offset + scroll
      clientY: ev.clientY - offset.y + window.pageYOffset, // account for div offset + scroll
      deltaX: ev.movementX,
      deltaY: ev.movementY,
      originalEvent: ev,
      which: ev.which,
      altKey: ev.altKey,
      ctrlKey: ev.ctrlKey,
      metaKey: ev.metaKey,
      shiftKey: ev.shiftKey
    };
  }

  function toMouseEvent(e) {
    if (!e.touches || !e.touches.length) return e;
    var el = e.srcElement || e.target;
    var elRect = el.getBoundingClientRect();
    return {
      which: 1,
      rect: rect,
      clientX: e.touches[0].clientX - elRect.left, // touchEvent clientX/Y already account for scroll
      clientY: e.touches[0].clientY - elRect.top, // touchEvent clientX/Y already account for scroll
      isTouch: true,
      originalEvent: e
    };
  }

  _claraFlyd2.default.on(callTool('dragenter'), mapStream(el, 'dragenter'));
  _claraFlyd2.default.on(callTool('dragover'), mapStream(el, 'dragover'));
  _claraFlyd2.default.on(callTool('dragleave'), mapStream(el, 'dragleave'));
  _claraFlyd2.default.on(callTool('dblclick'), mapStream(el, 'dblclick'));

  var keysdown = {};
  _claraFlyd2.default.on(function (kd) {
    if (!keysdown[kd.key]) {
      callTool('keydown')(kd);
      keysdown[kd.key] = setInterval(function () {
        return callTool('keyheld')(kd);
      }, 17);
    }
  }, mapStream(el, 'keydown'));

  _claraFlyd2.default.on(function (ku) {
    if (keysdown[ku.key]) {
      clearInterval(keysdown[ku.key]);
      delete keysdown[ku.key];
    }

    callTool('keyup')(ku);
  }, mapStream(el, 'keyup'));

  var clickStream = mapStream(el, 'click', toCoords);
  var mousedownStream = mapStream(el, 'mousedown', toCoords);
  var mousemoveStream = mapStream(el, 'mousemove', toCoords);
  var mouseupStream = mapStream(window, 'mouseup', toCoords);
  var moveStream = _claraFlyd2.default.stream();
  var dragStream = _claraFlyd2.default.stream();

  var touchstartStream = transduceStream(el, 'touchstart', (0, _transducers.compose)((0, _transducers.filter)(isSingleTouch), (0, _transducers.map)(toMouseEvent)));
  var touchendStream = mapStream(el, 'touchend', toMouseEvent);

  _claraFlyd2.default.on(function (md) {
    md.originalEvent.target.focus();
    callTool('mousedown')(md);
    lastMousedown = { start: new Date(), event: md };

    draggingTool = callTool('drag', { findFirst: true })(md);
    if (!draggingTool) return;

    dragging = { lastMove: new Date() };

    var clientX = null;
    var clientY = null;

    function toDeltaCoords(ev) {
      ev.preventDefault();
      var newEv = {
        rect: rect,
        clientX: ev.clientX - offset.x,
        clientY: ev.clientY - offset.y,
        originalEvent: ev,
        which: ev.which,
        altKey: ev.altKey,
        ctrlKey: ev.ctrlKey,
        metaKey: ev.metaKey,
        shiftKey: ev.shiftKey
      };
      if (ev.movementX === undefined) {
        newEv.deltaX = clientX === null ? 0 : ev.clientX - clientX;
        newEv.deltaY = clientX === null ? 0 : ev.clientY - clientY;
      } else {
        newEv.deltaX = ev.movementX;
        newEv.deltaY = ev.movementY;
      }
      clientX = ev.clientX;
      clientY = ev.clientY;
      return newEv;
    }

    moveStream = transduceStream(window, 'mousemove', (0, _transducers.compose)((0, _transducers.map)(touchLastMove), (0, _transducers.map)(toDeltaCoords)));

    dragStream.end(true);
    dragStream = draggingTool.momentum ? addMomentum(moveStream, mouseupStream) : moveStream;
    dragStream.map(draggingTool.handle);
  }, mousedownStream);

  _claraFlyd2.default.on(function (ts) {
    callTool('mousedown')(ts);
    lastMousedown = { start: new Date(), event: ts };

    draggingTool = callTool('drag', { findFirst: true })(ts);
    if (!draggingTool) return;

    dragging = { lastMove: new Date() };

    var clientX = ts.clientX,
        clientY = ts.clientY;


    function toDelta(e) {
      // The default for drag is to call 'preventDefault', so the page doesn't get
      // scrolled. Setting 'allowDefault: true' in the tool will put the responsibility
      // on the tool itself to call preventDefault if desired.
      if (!draggingTool.allowDefault) e.originalEvent.preventDefault();

      var newE = (0, _assign2.default)(e, {
        deltaX: e.clientX - clientX,
        deltaY: e.clientY - clientY
      });
      clientX = e.clientX;
      clientY = e.clientY;
      return newE;
    }

    moveStream = transduceStream(el, 'touchmove', (0, _transducers.compose)((0, _transducers.filter)(isSingleTouch), (0, _transducers.map)(touchLastMove), (0, _transducers.map)(toMouseEvent), (0, _transducers.map)(toDelta)));

    dragStream.end(true);
    dragStream = draggingTool.momentum ? addMomentum(moveStream, touchendStream) : moveStream;
    dragStream.map(draggingTool.handle);
  }, touchstartStream);

  var endingStream = _claraFlyd2.default.merge(touchendStream, mouseupStream);

  _claraFlyd2.default.on(function (mu) {
    if (dragging) {
      moveStream.end(true);
      if (draggingTool.end) draggingTool.end();
      // End momentum if last mousemove event is gt 200ms from mouseup.
      if (new Date() - dragging.lastMove > 200) {
        dragStream.end(true);
      }
    }

    //console.log('mu', new Date() - lastMousedown.start, lastMousedown.event, mu, muX, muY);

    callTool('mouseup')(mu);

    if (lastMousedown && new Date() - lastMousedown.start < 300) {
      var muX = Math.abs(mu.clientX - lastMousedown.event.clientX);
      var muY = Math.abs(mu.clientY - lastMousedown.event.clientY);

      if (isNaN(muX)) {
        callTool('click')(lastMousedown.event);
      } else if (muX <= 5 && muY <= 5) {
        callTool('click')(mu);
      }
    }

    dragging = false;
    lastMousedown = false;
  }, endingStream);

  _claraFlyd2.default.on(callTool('hover'), _claraFlyd2.default.transduce((0, _transducers.filter)(function () {
    return !dragging && hasEvents['hover'];
  }), mousemoveStream));

  //flyd.map((scroll) => {
  //  console.log('scroll?', scroll);
  var scrollHandler = callTool('scroll');
  mapStream(el, 'wheel', function (ev) {
    if (hasEvents['scroll']) {
      ev.preventDefault();
      var altScrollDelta = Math.abs(ev.deltaY) > 100 ? 200 : 10;
      scrollHandler({
        delta: -ev.deltaY / (Math.abs(ev.wheelDelta) || altScrollDelta),
        originalEvent: ev
      });
    }
  });

  function extractTouches(e) {
    e.preventDefault();
    return {
      a: { x: e.touches[0].clientX, y: e.touches[0].clientY },
      b: { x: e.touches[1].clientX, y: e.touches[1].clientY }
    };
  }

  var zoom = flatMap(function (ts) {
    var f = ts;
    var moveStream = transduceStream(el, 'touchmove', (0, _transducers.compose)((0, _transducers.filter)(isDoubleTouch), (0, _transducers.map)(extractTouches), (0, _transducers.map)(function (g) {
      var result = {
        pinchX: g.b.x - f.b.x - (g.a.x - f.a.x),
        pinchY: f.a.y - g.a.y - (f.b.y - g.b.y),
        dragX: (g.a.x - f.a.x + (g.b.x - f.b.x)) / 2,
        dragY: (g.a.y - f.a.y + (g.b.y - f.b.y)) / 2,
        a: g.a,
        b: g.b
      };
      f = g;
      return result;
    })));
    _claraFlyd2.default.endsOn(touchendStream, moveStream);
    return moveStream;
  }, transduceStream(el, 'touchstart', (0, _transducers.compose)((0, _transducers.filter)(isDoubleTouch), (0, _transducers.map)(extractTouches))));

  _claraFlyd2.default.on(function (z) {
    var pinchX = z.pinchX,
        pinchY = z.pinchY,
        dragX = z.dragX,
        dragY = z.dragY,
        a = z.a,
        b = z.b;

    if (Math.abs(pinchX) + Math.abs(pinchY) > Math.abs(dragX) + Math.abs(dragY)) {
      // pinch
      callTool('pinch')({
        deltaX: a.x > b.x ? -pinchX : pinchX,
        deltaY: a.y > b.y ? pinchY : -pinchY
      });
    } else {
      // swipe
      callTool('swipe')({ deltaX: dragX, deltaY: dragY });
    }
  }, zoom);

  function controllerUpdate() {
    var vrControls = translator.externals.vrControls;
    var controllers = translator.externals.controllers;

    if (!vrControls || !controllers || !hasEvents['controllerupdate']) return;

    var controllerStates = controllers.filter(function (c) {
      c.update();
      return !!c.getGamepad();
    }).map(function (controller) {
      var gp = controller.getGamepad();

      var position = controller.position.clone();
      var orientation = controller.quaternion.clone();

      position.applyQuaternion(vrControls.rotationalOffset).add(vrControls.offset);
      orientation.premultiply(vrControls.rotationalOffset);

      return {
        id: gp.id,
        index: gp.index,
        position: position,
        orientation: orientation,
        buttons: gp.buttons,
        axes: gp.axes
      };
    });

    if (controllerStates.length) callTool('controllerupdate')({ states: controllerStates });
    return controllerStates;
  }

  var controllerNodeOver = {};

  function controllerQuery(controllers) {
    if (!hasEvents['nodeenter'] && !hasEvents['nodeleave']) return;
    var controllerRays = controllers.map(function (ctr) {
      var direction = new _three.Vector3(0, 0, -1).applyQuaternion(ctr.orientation);
      return new _three.Ray(ctr.position, direction);
    });

    var nodeBoxes = (0, _scene.filter)(store, {
      plug: 'Properties',
      properties: { interactive: true }
    }).map(function (path) {
      return { id: path[0], box: (0, _scene.getNodeBoundingBox)(store, path[0]) };
    });

    var interactions = controllerRays.map(function (ray, index) {
      var intersection = nodeBoxes.reduce(function (closest, info) {
        var point = ray.intersectBox(info.box);
        var d = point ? point.distanceTo(ray.origin) : Infinity;
        return d < closest.distance ? { id: info.id, distance: d } : closest;
      }, { id: null, distance: Infinity });
      return { index: index, nodeId: intersection.id };
    });

    interactions.forEach(function (inter) {
      var controller = controllers[inter.index];
      var key = controller.id + controller.index;
      var oldNode = controllerNodeOver[key];
      if (inter.nodeId !== oldNode) {
        if (oldNode) callTool('nodeleave')(oldNode);
        if (inter.nodeId) callTool('nodeenter')(inter.nodeId);
        controllerNodeOver[key] = inter.nodeId;
      }
    });
  }

  var lastCenterNode = void 0;
  function centerQuery() {
    if (!hasEvents['nodeenter'] && !hasEvents['nodeleave']) return;

    var hitNode = (0, _player.filterInteractiveBoxesFromCenter)(store)[0];
    if (hitNode !== lastCenterNode) {
      if (lastCenterNode) callTool('nodeleave')(lastCenterNode);
      if (hitNode) callTool('nodeenter')(hitNode);
      lastCenterNode = hitNode;
    }
  }

  var tenfps = every(100);
  var throttledMousemoveStream = sampleOn(tenfps, mousemoveStream);
  var mousemoveChanged = isChanged();

  var lastNodeOver = void 0;

  _claraFlyd2.default.on(function (mm) {
    if (!hasEvents['nodeenter'] && !hasEvents['nodeleave']) return;
    if (!mousemoveChanged(mm)) return;

    var node = (0, _player.filterInteractiveBoxesFromPosition)(store, mm)[0];
    if (node !== lastNodeOver) {
      if (lastNodeOver) callTool('nodeleave')(lastNodeOver);
      if (node) callTool('nodeenter')(node);
      lastNodeOver = node;
    }
  }, throttledMousemoveStream);

  return {
    resize: resize,
    frameUpdate: function frameUpdate(renderMode) {
      var controllers = controllerUpdate();
      if (controllers && controllers.length) {
        controllerQuery(controllers);
      } else if (renderMode === _player.RENDER_MODES.vr) {
        //This will ensure node enter/leave events work in cardboard
        centerQuery();
      }
    },
    updateTools: function updateTools(newCommands) {
      commands = newCommands;
      hasEvents = {};

      commands.forEach(function (command) {
        (0, _keys2.default)(command.tool).forEach(function (k) {
          return hasEvents[k] = true;
        });
      });
    }
  };
}

function every(dur) {
  var s = _claraFlyd2.default.stream();
  var target = Date.now();
  function timer() {
    if (s.end()) return;
    var now = Date.now();
    target += dur;
    s(now);
    setTimeout(timer, target - now);
  }

  timer();
  return s;
}

function flatMap(f, s) {
  return _claraFlyd2.default.combine(function (s, own) {
    _claraFlyd2.default.map(own, f(s()));
  }, [s]);
}

function isChanged() {
  var last = void 0;
  return function (now) {
    if (now === last) return false;
    last = now;
    return true;
  };
}

function sampleOn(s1, s2) {
  return _claraFlyd2.default.combine(function () {
    return s2();
  }, [s1]);
}

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.fetchHDRSourceData = fetchHDRSourceData;
exports.getCubeMapTexture = getCubeMapTexture;
exports.getTextureImage = getTextureImage;
exports.assignTexture = assignTexture;
exports.primitiveToMaterial = primitiveToMaterial;

var _runtimeInfo = __webpack_require__(56);

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _assets = __webpack_require__(33);

var _sceneGraph = __webpack_require__(10);

var _asset = __webpack_require__(243);

var _ThreeExport = __webpack_require__(242);

var _ThreeExport2 = _interopRequireDefault(_ThreeExport);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Fetches and parses hdr file buffer into usage image texture data
 *
 * @param {any} store
 * @param {any} image
 * @returns {Object} rgbe hdr data of form {width, height, data, header, gamma, exposure, format, type}
 */
function fetchHDRSourceData(store, image) {
  var id = image.hdrSource;
  if (!id) return null;
  var hdrBuffer = (0, _assets.getOrFetchBinary)(id)(store);
  if (!hdrBuffer) return null;
  var hdrArrayBuffer = new Uint8Array(hdrBuffer);
  var rgbeImageData = new THREE.RGBELoader()._parser(hdrArrayBuffer);
  return rgbeImageData;
}

function renderEnvNeedsHDR() {
  return !true || _runtimeInfo.isIOS || _runtimeInfo.isIE;
}

// headless-gl, IE and iOS browsers cause color quantization in our hdr.png's, so use original HDR instead
var preferHDRSource = renderEnvNeedsHDR();

function checkTextureCache(store, id, image) {
  var textures = store.getTranslator().textureCache;
  var cachedImage = textures[id] && textures[id].image;

  if (cachedImage && (image ? cachedImage._v === image._v : true)) {
    return textures[id].value;
  }
  return null;
}

function cacheTexture(store, id, image, value) {
  var textures = store.getTranslator().textureCache;

  if (textures[id]) {
    textures[id].value.dispose();
  }
  textures[id] = { image: image, value: value };
  return value;
}

function getCubeMapTexture(store, renderer, image, textureCubeOnly, allowHDR) {
  var maps = image.maps,
      nodeId = image.nodeId;


  var texture = checkTextureCache(store, nodeId, image);
  if (texture) return texture;

  // CubeMap must have all 6 images set to be valid
  if (!maps) return null;
  for (var i = 0; i < maps.length; i++) {
    if (!maps[i]) return null;
  }

  var useHDR = false;
  var useHDRSource = false;
  if (allowHDR && maps[0].preferHDR) useHDR = true;
  if (useHDR && preferHDRSource && maps[0].hdrSource) useHDRSource = true;

  var images = maps.map(function (imgPrimitive) {
    var img = checkTextureCache(store, imgPrimitive.nodeId, imgPrimitive);
    if (img) return img;

    var fetchImage = useHDRSource ? fetchHDRSourceData : _asset.fetchTextureImage;
    img = fetchImage(store, imgPrimitive, true);

    // if hdr data, need to construct DataTexture in place of normal Image
    if (img && useHDRSource) {
      var dataTexture = new THREE.DataTexture(img.data, img.width, img.height);
      dataTexture.encoding = THREE.RGBEEncoding;
      dataTexture.generateMipmaps = false;
      dataTexture.type = THREE.UnsignedByteType;
      dataTexture.minFilter = THREE.NearestFilter;
      dataTexture.magFilter = THREE.NearestFilter;
      dataTexture.format = THREE.RGBEFormat;
      img = dataTexture;
      cacheTexture(store, imgPrimitive.nodeId, imgPrimitive, img);
    }

    return img;
  });

  // console.log( "getCubeMapTexture early exit, as all images are not available.");
  if (images.filter(function (img) {
    return !!img;
  }).length !== images.length) return null;

  var textureCube = new THREE.CubeTexture();

  // CubeTexure supports images as either instances of HTMLImageElement (for url-accessible image
  // elements) or THREE.DataTexture (for raw image data, such as our hdr source)
  textureCube.images = images;

  textureCube.flipY = false;

  if (useHDR) {
    textureCube.encoding = useHDRSource ? THREE.RGBEEncoding : maps[0].hdrEncoding;
    //textureCube.generateMipmaps = false;
  }
  textureCube.needsUpdate = true;
  if (textureCubeOnly) return cacheTexture(store, nodeId, image, textureCube);

  var pmremFilter = useHDRSource ? THREE.NearestFilter : THREE.LinearFilter;

  // console.log( "Creating PMREMGenerator()");
  var pmremGenerator = new THREE.PMREMGenerator(textureCube, 20);
  pmremGenerator.update(renderer);

  pmremGenerator.cubeLods[0].texture.magFilter = pmremFilter;
  pmremGenerator.cubeLods[0].texture.minFilter = pmremFilter;

  // console.log( "Creating PMREMCubeUVPacker()");
  var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker(pmremGenerator.cubeLods);
  pmremCubeUVPacker.update(renderer);

  pmremCubeUVPacker.CubeUVRenderTarget.texture.magFilter = pmremFilter;
  pmremCubeUVPacker.CubeUVRenderTarget.texture.minFilter = pmremFilter;

  // console.log( "PMREM Creation Done.");

  return cacheTexture(store, nodeId, image, pmremCubeUVPacker.CubeUVRenderTarget.texture);
}

function getTextureImage(store, image) {
  if (!image) return;
  var nodeId = image.nodeId;

  if (!checkTextureCache(store, nodeId, image)) {
    if (image.maps) {
      image.maps.forEach(function (map) {
        return (0, _asset.fetchTextureImage)(store, map);
      });
    } else {
      (0, _asset.fetchTextureImage)(store, image);
    }
  }
}

/*
 * Modifies the map being passed in.
 */
function assignTexture(store, renderer, image, optionalThreemap, slot) {
  if (!image) {
    if (optionalThreemap) optionalThreemap.texture = null;
    return null;
  }

  // Only use hdr for maps that represent light sources. Not others, since we don't want to
  // *reflect* more than 1 light intensity. Note: Apparently hdr 'lightMap' not yet supported in
  // ThreeJS, so don't include it here (yet).
  var allowHDR = slot === 'envMap' || slot === 'emissiveMap';

  if (image.maps) {
    return getCubeMapTexture(store, renderer, image, false, allowHDR);
  }

  var useHDR = false;
  var useHDRSource = false;
  if (allowHDR && image.preferHDR) useHDR = true;
  if (useHDR && preferHDRSource && image.hdrSource) useHDRSource = true;

  var uvOptions = (0, _assign2.default)({}, image);
  var nodeId = image.nodeId;
  var texture = checkTextureCache(store, nodeId, image);

  if (!texture) {
    texture = useHDRSource ? new THREE.DataTexture() : new THREE.Texture();
    texture.meta = { nodeId: nodeId };
    if (image.canvasOperations) {
      texture.meta.source = 'canvas operator';
      var ops = image.canvasOperations;

      var oldTexture = checkTextureCache(store, image.nodeId);
      var oldCanvas = oldTexture && oldTexture.image;

      // We don't currently cache the canvas itself on the server (oldTexture.image is not a canvas
      // in that case and breaks screenshot), and only really care about re- use in the browser anyway.
      var canvas = true && oldCanvas || store.createCanvas(image.width, image.height);
      var context = canvas.getContext('2d');
      context.clearRect(0, 0, canvas.width, canvas.height);

      var ok = ops.reduce(function (ok, op) {
        context.save();
        var ret = ok && op(context, store, canvas);
        context.restore();
        return ret;
      }, true);

      if (ok) {
        if (false) {
          texture = new THREE.Texture(context.getImageData(0, 0, canvas.width, canvas.height));
        } else {
          texture.image = canvas;
        }
      }
    } else {
      texture.meta.source = 'image fetch';
      var fetchImage = useHDRSource ? fetchHDRSourceData : _asset.fetchTextureImage;
      texture.image = fetchImage(store, image);
    }

    if (!texture.image) {
      if (optionalThreemap) optionalThreemap.texture = null;
      return null;
    }

    texture.transparent = true;

    var textureWraps = {
      0: THREE.ClampToEdgeWrapping,
      1: THREE.RepeatWrapping,
      2: THREE.MirroredRepeatWrapping
    };

    texture.wrapS = textureWraps[uvOptions.wrapU];
    texture.wrapT = textureWraps[uvOptions.wrapV];

    texture.generateMipmaps = useHDR ? false : uvOptions.generateMipMaps;
    texture.anisotropy = texture.generateMipmaps ? 16 : 1;
    texture.magFilter = useHDRSource ? THREE.NearestFilter : uvOptions.magFilter;
    texture.minFilter = useHDRSource ? THREE.NearestFilter : uvOptions.minFilter;
    texture.encoding = useHDR ? userHDRSource ? THREE.RGBEEncoding : uvOptions.hdrEncoding : THREE.sRGBEncoding;

    if (THREE.Math.nearestPowerOfTwo(texture.image.width) !== texture.image.width || THREE.Math.nearestPowerOfTwo(texture.image.height) !== texture.image.height) {
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.generateMipmaps = false;
      texture.anisotropy = 1;
      texture.anisotropy = 1;
      texture.magFilter = useHDRSource ? THREE.NearestFilter : THREE.LinearFilter;
      texture.minFilter = useHDRSource ? THREE.NearestFilter : THREE.LinearFilter;
    }

    texture.needsUpdate = true;
    if (optionalThreemap && optionalThreemap.texture) optionalThreemap.texture.dispose();
    cacheTexture(store, nodeId, image, texture);
  }

  if (!optionalThreemap) {
    return texture;
  }

  optionalThreemap.texture = texture;

  optionalThreemap.uvTransform = true;
  optionalThreemap.uvOffset = new THREE.Vector2(uvOptions.uOffset, uvOptions.vOffset);
  optionalThreemap.uvRepeat = new THREE.Vector2(uvOptions.uTile, uvOptions.vTile);

  optionalThreemap.texelTransform = true;
  optionalThreemap.texelInvert = uvOptions.invert;

  // convert gain, gainPivot, brightness into just gain, brightness
  // simplification of ( a - p ) * g + b --> a * g + ( b - p * g )
  var brightnessGainPivot = uvOptions.brightness - uvOptions.gain * uvOptions.gainPivot;
  optionalThreemap.texelScale = uvOptions.gain;
  optionalThreemap.texelOffset = brightnessGainPivot;

  return optionalThreemap;
}

var initialStandardDefaults = {
  side: 2,
  emissive: { r: 0, g: 0, b: 0 },
  ambient: { r: 0, g: 0, b: 0 },
  vertexColors: 0,
  opacity: 1,
  transparent: false,
  specular: { r: 1, g: 1, b: 1 },
  normalScale: { x: 1, y: 1 },
  envMap: null,
  combine: 0,
  color: { r: 0.1803921568627451, g: 0.4, b: 0.8274509803921568 },
  metal: false,
  gloss: false,
  reflectivity: 1,
  refractionRatio: 0.98,
  shininess: 50
};

function primitiveToMaterial(store, renderer, data, previousMaterial, extraOptions) {
  var material = previousMaterial && previousMaterial instanceof THREE.MeshPhysicalMaterial ? previousMaterial : new THREE.MeshPhysicalMaterial({});

  var envMap = null;

  if (!data) return material;

  if (data.type === 'MultiID') {
    var mats = [];
    for (var i = 0; i < 30; i++) {
      var oldMaterial = previousMaterial && previousMaterial.materials && previousMaterial.materials[i];
      if (data['material' + i]) {
        mats.push(primitiveToMaterial(store, renderer, data['material' + i], oldMaterial));
      } else {
        var defaultColor = { defaultColor: data.defaultColor };
        mats.push(primitiveToMaterial(store, renderer, defaultColor, oldMaterial));
      }
    }
    material = new THREE.MultiMaterial(mats);
    return material;
  }

  if (data.type === 'GemMaterial') {
    var isNewMaterial = !(previousMaterial && previousMaterial instanceof THREE.ShaderMaterial);

    // check if there's a gemstone
    var gemstoneMeshNode = (0, _sceneGraph.getEvalSceneGraph)(store).evaluatedNodes[data.gemstone];

    // check if there's a new environment map
    envMap = data.environment && data.environment.environmentMap;
    var envMapTexture = envMap && assignTexture(store, renderer, envMap.specularCubeMap, new THREE.MaterialMap(), 'envMap');

    // no gemstone or environment map, let default to a physical material with the transmissive color
    if (!gemstoneMeshNode || !envMapTexture) {
      material.color = data.transmissive;
      return material;
    }

    // check if the gemstone normal map is already there
    var hasUpdatedGeometry = false;
    var normalMapTextureAndGeometry = checkTextureCache(store, data.gemstone, gemstoneMeshNode);
    if (!normalMapTextureAndGeometry) {
      var mesh = gemstoneMeshNode.PolyMesh.mesh;
      var indexingMode = renderer.extensions.get('OES_element_index_uint') ? _ThreeExport2.default.CompactIndices : _ThreeExport2.default.NoIndices;
      var bufferInfo = mesh && _ThreeExport2.default.exportBufferGeometry(mesh, indexingMode, false, mesh.tangentMap, null, null, null, null);

      if (bufferInfo) {
        bufferInfo.geometry.computeBoundingSphere();
        var normalMapTexture = new THREE.NormalCubeMapBaker(renderer, bufferInfo.geometry, true).texture;

        normalMapTextureAndGeometry = {
          texture: normalMapTexture,
          geometry: bufferInfo.geometry,
          dispose: function dispose() {}
        };
        cacheTexture(store, data.gemstone, { _v: gemstoneMeshNode._v }, // don't need to store whole node, all that is needed is a version for later comparison
        normalMapTextureAndGeometry);
        hasUpdatedGeometry = true;
      }
    }

    if (!normalMapTextureAndGeometry) {
      material.color = data.transmissive;
      return material;
    }

    var gemMaterial = null;
    if (isNewMaterial) {
      gemMaterial = new THREE.ShaderMaterial(THREE.GeometricRefractionShader);
      gemMaterial.uniforms = THREE.UniformsUtils.clone(THREE.GeometricRefractionShader.uniforms);
      gemMaterial.defines = (0, _assign2.default)({}, THREE.GeometricRefractionShader.defines);

      // set constants
      gemMaterial.transparent = true;
      gemMaterial.premultipliedAlpha = true;
      gemMaterial.side = THREE.FrontSide;
    } else {
      gemMaterial = previousMaterial;
    }

    // set the uniforms
    gemMaterial.uniforms.absorption.value.set(1.0 - data.transmissive.r, 1.0 - data.transmissive.g, 1.0 - data.transmissive.b);

    gemMaterial.uniforms.sphereSquish.value.copy(data.squishFactor);
    gemMaterial.uniforms.normalCubeMap.value = normalMapTextureAndGeometry.texture;
    gemMaterial.uniforms.gemIOR.value = data.ior;
    gemMaterial.uniforms.spectrumSpread.value = data.spectrumSpread;
    gemMaterial.uniforms.boostFactor.value = data.boostFactor;
    gemMaterial.uniforms.envMap.value = envMapTexture;
    gemMaterial.envMap = envMapTexture;

    // environment map intensity
    var envMapIntensity = envMap.intensity !== undefined ? envMap.intensity : 1.0;
    gemMaterial.uniforms.envMapIntensity.value = envMapIntensity;
    gemMaterial.envMapIntensity = envMapIntensity;

    // let update the bounding sphere uniform
    gemMaterial.uniforms.boundingSphere.value.set(normalMapTextureAndGeometry.geometry.boundingSphere.center.x, normalMapTextureAndGeometry.geometry.boundingSphere.center.y, normalMapTextureAndGeometry.geometry.boundingSphere.center.z, normalMapTextureAndGeometry.geometry.boundingSphere.radius);

    if (gemMaterial.defines['NUM_BOUNCES'] !== data.bounces) {
      gemMaterial.defines['NUM_BOUNCES'] = data.bounces;
      gemMaterial.needsUpdate = true;
    }

    // update the sparkles
    var sparklePass = extraOptions && extraOptions.sparklePass;
    if (sparklePass) {
      var sparkleCount = data.enableSparkles ? data.sparkleCount : 0;

      if (extraOptions.nodeInfo.visible && extraOptions.nodeInfo.type == 'Mesh' && (hasUpdatedGeometry || gemMaterial.sparkleCount !== sparkleCount)) {
        sparklePass.removeGemstone(extraOptions.nodeInfo);

        if (sparkleCount) {
          sparklePass.addGemstone(normalMapTextureAndGeometry.geometry, extraOptions.nodeInfo, sparkleCount);
        }

        // update the sparkle count
        gemMaterial.sparkleCount = sparkleCount;
      }
    }
    return gemMaterial;
  }

  if (data.defaultColor) {
    material.color = data.defaultColor;
    return material;
  }

  if (!data.baseColor) {
    if (data.diffuseColor) material.color = data.diffuseColor;
    return material;
  }

  //name mapping
  //three.js: clara.io
  var propertyMap = {
    color: 'baseColor',
    aoMapIntensity: 'aoMapIntensity',
    //ambient: 'ambientColor2',
    bumpScale: 'bumpScale',
    emissive: 'emissiveColor',
    falloff: 'baseFalloff',
    falloffColor: 'baseFalloffColor',
    metalness: 'metallic',
    roughness: 'roughness',
    clearCoat: 'clearCoat',
    clearCoatRoughness: 'clearCoatRoughness',
    opacity: 'opacityFactor', // opacityMap and opacityColor are not supported in Three.js
    falloffOpacity: 'opacityFalloffFactor',
    //specular: 'specularColor',
    //translucency: 'translucencyColor',
    transparent: 'baseMapTransparent',
    anisotropy: 'anisotropy',
    anisotropyRotation: 'anisotropyRotation'
  };

  var keys = ['depthTest', 'depthWrite'];

  //name mapping
  //three.js: clara.io
  var imageMaps = {
    map: 'baseMap',
    bumpMap: 'bumpMap',
    aoMap: 'aoMap',
    emissiveMap: 'emissiveMap',
    lightMap: 'lightMap',
    metalnessMap: 'metallicMap',
    normalMap: 'normalMap',
    alphaMap: 'opacityMap',
    roughnessMap: 'roughnessMap',
    falloffMap: 'baseFalloffMap',
    falloffAlphaMap: 'opacityFalloffMap',
    anisotropyMap: 'anisotropyMap',
    anisotropyRotationMap: 'anisotropyRotationMap'
  };

  function updateTexture(image, slot) {
    var mapTex = assignTexture(store, renderer, image, material[slot] || new THREE.MaterialMap(), slot);
    if (mapTex && !material[slot]) material[slot] = mapTex;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(imageMaps)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var image = _step.value;

      updateTexture(data[imageMaps[image]], image + 'Slot');
    }

    //must be after updateTexture
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(propertyMap)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var to = _step2.value;

      material[to] = data[propertyMap[to]];
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = (0, _getIterator3.default)(keys), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var key = _step3.value;

      material[key] = data[key];
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (data.emissiveScale) {
    material.emissive = material.emissive.clone();
    material.emissive.multiplyScalar(data.emissiveScale);
  }

  material.transparent = material.opacity < 1.0 || !!data.opacityMap || data.baseMapTransparent || data.opacityFalloffFactor < 1.0 || !!data.opacityFalloffMap;

  var specular = data.specularColor;
  material.reflectivity = (specular.r + specular.g + specular.b) * 0.33333;
  material.clearCoat *= 0.25;
  material.normalScale.x = (data.normalRedFlip ? -1 : 1) * data.normalFactor;
  material.normalScale.y = (data.normalGreenFlip ? -1 : 1) * data.normalFactor;

  material.blending = THREE.NormalBlending;
  material.premultipliedAlpha = true;
  material.side = material.transparent ? previousMaterial ? previousMaterial.side : THREE.DoubleSide : THREE.DoubleSide;

  envMap = data.environment && data.environment.environmentMap;
  if (envMap) {
    updateTexture(envMap.specularCubeMap, 'envMap');
    material.envMapIntensity = envMap.intensity !== undefined ? envMap.intensity : 1.0;
  }

  material.needsUpdate = true;

  return material;
}

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

exports.polyMeshToBufferGeometry = polyMeshToBufferGeometry;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function flattenBuffer(klass, elementBuffer, numElementsPerValue, indicesBuffer) {
  var flattenedBuffer = new klass(indicesBuffer.length * numElementsPerValue);

  var sourceIndex, destIndex;
  for (var v = 0; v < indicesBuffer.length; v++) {
    sourceIndex = indicesBuffer[v] * numElementsPerValue;
    destIndex = v * numElementsPerValue;
    for (var e = 0; e < numElementsPerValue; e++) {
      flattenedBuffer[destIndex + e] = elementBuffer[sourceIndex + e];
    }
  }

  return new THREE.BufferAttribute(flattenedBuffer, numElementsPerValue);
}

function polyMeshToBufferGeometry(_ref) {
  var faces = _ref.faces,
      positions = _ref.positions,
      normalMap = _ref.normalMap,
      uvs = _ref.uvs;

  var geom = new THREE.BufferGeometry();

  geom.addAttribute('position', flattenBuffer(Float32Array, positions, 3, faces));

  if (normalMap) {
    geom.addAttribute('normal', flattenBuffer(Float32Array, normalMap.values, 3, normalMap.faces)); //normalMap.faces.length));
  }

  if (uvs) {
    var uvNames = (0, _keys2.default)(uvs);
    uvNames.sort();

    // uv
    if (uvNames.length >= 1) {
      var uvMap = uvs[uvNames[0]];
      geom.addAttribute('uv', flattenBuffer(Float32Array, uvMap.values, 2, uvMap.faces)); // uvMap.faces.length));
    }

    // uv2
    if (uvNames.length >= 2) {
      var uvMap = uvs[uvNames[1]];
      geom.addAttribute('uv2', flattenBuffer(Float32Array, uvMap.values, 2, uvMap.faces)); //uvMap.faces.length));
    }
  }

  return geom;
}

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = configurator;

var _sceneIO = __webpack_require__(20);

var _configuration = __webpack_require__(98);

function configurator(store, translator) {
  return {
    label: 'Configure',
    enabled: true,
    active: false,
    display: {
      playerTools: false
    },
    options: {},

    activate: function activate() {
      var forms = (0, _configuration.getForms)(store);
      var configurator = (0, _configuration.getConfigurator)(store);
      store.dispatch((0, _configuration.initConfigurator)({
        panel: true,
        form: configurator && configurator.form || (forms.length ? forms[0].name : true)
      }));
    },

    deactivate: function deactivate() {
      return store.dispatch((0, _configuration.initConfigurator)({ panel: false }));
    }
  };
}

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

exports.default = firstPersonMode;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _three2 = __webpack_require__(0);

var _camera = __webpack_require__(126);

var _decompose = __webpack_require__(51);

var _decompose2 = _interopRequireDefault(_decompose);

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

var _updateCameraLookAtTarget = __webpack_require__(71);

var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

var _getTargetWorldMatrix = __webpack_require__(59);

var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

var _sceneGraph = __webpack_require__(10);

var _getOrbitAttrs = __webpack_require__(104);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tan = Math.tan,
    cos = Math.cos,
    atan = Math.atan,
    acos = Math.acos,
    min = Math.min,
    max = Math.max,
    pow = Math.pow,
    PI = Math.PI,
    sqrt = Math.sqrt;


var directionKeys = {
  w: 'FORWARD',
  a: 'LEFT',
  s: 'BACKWARD',
  d: 'RIGHT',
  ArrowUp: 'FORWARD',
  ArrowLeft: 'LEFT',
  ArrowDown: 'BACKWARD',
  ArrowRight: 'RIGHT'
};

var directions = {
  FORWARD: ['y', 1],
  BACKWARD: ['y', -1],
  LEFT: ['x', -1],
  RIGHT: ['x', 1]
};

var SPEED = 0.2;
var EASING_TIME = 2000;

function firstPersonMode(store, translator) {
  var oldOrbitMode = null;
  var velocity = new _three2.Vector3(0, 0, 0);
  var axes = { x: 0, y: 0, z: 0 };
  var easingStart = void 0,
      easingTimer = void 0;
  var directionRay = new THREE.Raycaster(new _three2.Vector3(0, 1, 0), velocity, 0, 0.8);
  var positionRay = new THREE.Raycaster(new _three2.Vector3(0, 1, 0), new _three2.Vector3(0, -1, 0), 0, 2);
  function setVelocity(axis, factor) {
    axes[axis] += factor;
    velocity = new _three2.Vector3(axes.x, axes.y, axes.z).normalize().multiplyScalar(SPEED);
  }

  function updateVelocity() {
    easingTimer = Date.now() - easingStart;
    easingTimer = min(1, max(0.00001, easingTimer / EASING_TIME));
    var easedSpeed = -(easingTimer - 1) * (easingTimer - 1) + 1;
    velocity.normalize().multiplyScalar(SPEED * easedSpeed);
  }

  function detectCollision(currentPosition, direction) {
    directionRay.ray.origin.x = currentPosition.x;
    directionRay.ray.origin.z = currentPosition.z;
    directionRay.ray.direction = direction;
    var intersects = directionRay.intersectObjects(translator.scene.getObjectByName('Objects').children, true);
    if (intersects.length) return false;
    return true;
  }

  function detectWalkable(store, currentPosition, movement) {
    var meshes = (0, _scene.filter)(store, {
      type: 'PolyMesh',
      plug: 'Properties',
      properties: { walkableInVR: true }
    });
    positionRay.ray.origin.x = currentPosition.x + movement.x;
    positionRay.ray.origin.z = currentPosition.z + movement.z;
    var floor = [];
    meshes.forEach(function (path) {
      var id = path[0];
      var object = translator.getThreeObject(id);
      if (object) floor.push(object);
    });
    var intersects = positionRay.intersectObjects(floor);
    if (intersects.length) return true;
    return false;
  }

  return {
    name: 'firstPersonMode',
    active: false,
    enabled: true,
    options: {
      movementMode: 'fly',
      keyboardEnabled: true
    },
    display: {
      playerTools: false
    },

    heldKeys: [],

    tool: {
      keydown: function keydown(ev) {
        var direction = directionKeys[ev.key];
        if (direction && this.active) {
          this.heldKeys.push(ev.key);

          var _directions$direction = (0, _slicedToArray3.default)(directions[direction], 2),
              axis = _directions$direction[0],
              factor = _directions$direction[1];

          if (this.heldKeys.length <= 1) easingStart = Date.now();
          setVelocity(axis, factor);
        }
      },

      keyup: function keyup(ev) {
        var direction = directionKeys[ev.key];
        if (direction && this.active) {
          var idx = this.heldKeys.indexOf(ev.key);
          this.heldKeys.splice(idx, 1);

          var _directions$direction2 = (0, _slicedToArray3.default)(directions[direction], 2),
              axis = _directions$direction2[0],
              factor = _directions$direction2[1];

          setVelocity(axis, -factor);
        }
      },

      keyheld: function keyheld(ev) {
        var firstKey = this.heldKeys[0];
        if (ev.key === firstKey && this.options.keyboardEnabled) {
          updateVelocity();
          var curPos = translator.externals.vrControls.offset;

          var movement = firstPersonMovement(store, velocity, this.options.movementMode);
          if (detectCollision(curPos, movement) && detectWalkable(store, curPos, movement)) {
            if (movement && translator.externals.vrControls) {
              translator.externals.vrControls.offset.add(movement);

              var cameraId = (0, _player.getCamera)(store);
              var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
              var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
              var cameraData = (0, _scene.get)(store, {
                id: cameraId,
                evalPlug: 'Camera'
              });

              var cameraPosition = new _three2.Vector3();
              var targetPosition = new _three2.Vector3();
              cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
              targetPosition.setFromMatrixPosition(targetWorldMatrix);

              cameraPosition.add(movement);
              targetPosition.add(movement);

              cameraWorldMatrix.setPosition(cameraPosition);
              targetWorldMatrix.setPosition(targetPosition);

              (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);

              store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
              if (!(0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' }).target) {
                store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
              }
            }
          }
        }
      }
    },

    activate: function activate() {
      var cameraId = (0, _player.getCamera)(store);
      if (!oldOrbitMode) oldOrbitMode = (0, _getOrbitAttrs.getOrbitMode)(store, cameraId);
      store.dispatch((0, _getOrbitAttrs.setOrbitMode)(store, cameraId, 'firstPerson'));
    },

    deactivate: function deactivate() {
      store.dispatch((0, _getOrbitAttrs.setOrbitMode)(store, (0, _player.getCamera)(store), oldOrbitMode));
      oldOrbitMode = null;
    }
  };
}

var UP_POSITION = new _three2.Vector3(0, 1, 0);

function firstPersonMovement(store, direction, movementMode) {
  var cameraId = (0, _player.getCamera)(store);
  var cameraWorldMatrix = (0, _player.getCameraWorldTransform)(store);
  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });

  if (targetWorldMatrix && cameraWorldMatrix && cameraData.upPosition) {
    var cameraPosition = new _three2.Vector3();
    var targetPosition = new _three2.Vector3();
    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
    targetPosition.setFromMatrixPosition(targetWorldMatrix);

    var forward = new _three2.Vector3().subVectors(targetPosition, cameraPosition).normalize();
    if (movementMode === 'plane') forward.projectOnPlane(UP_POSITION).normalize();

    var right = new _three2.Vector3().crossVectors(forward, UP_POSITION).normalize();

    var movement = new _three2.Vector3().addScaledVector(forward, direction.y).addScaledVector(right, direction.x);
    if (movement.y < -cameraPosition.y && (0, _getOrbitAttrs.getConstrainCameraY)(store, cameraId)) movement.y = -cameraPosition.y;

    return movement;
  }
}

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fullscreen;

var _player = __webpack_require__(8);

var _commands = __webpack_require__(43);

var _runtimeInfo = __webpack_require__(56);

function fullscreen(store, translator) {
  return {
    enabled: !_runtimeInfo.isIOS,
    display: true,
    options: {},

    isActive: _player.isFullscreen,

    activate: function activate() {
      var playerEl = store.getIn(['player', 'playerElement']);
      ['requestFullscreen', 'webkitRequestFullscreen', 'mozRequestFullScreen', 'msRequestFullscreen'].forEach(function (fn) {
        if (playerEl[fn]) return playerEl[fn]();
      });

      store.dispatch((0, _commands.updateCommands)(['vrSettings'], { enabled: false })); /* FIX: we should decouple tools from each other */
      store.dispatch((0, _player.setFullscreen)(true));
    },

    deactivate: function deactivate() {
      ['exitFullscreen', 'webkitExitFullscreen', 'mozCancelFullScreen', 'msExitFullscreen'].forEach(function (fn) {
        if (document[fn]) return document[fn]();
      });

      store.dispatch((0, _commands.undoUpdateCommand)('vrSettings')); /* FIX: we should decouple tools from each other */
      store.dispatch((0, _player.setFullscreen)(false));
    }
  };
}

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = home;

var _three = __webpack_require__(0);

var _scene = __webpack_require__(7);

var _player = __webpack_require__(8);

var _sceneGraph = __webpack_require__(10);

var _sceneIO = __webpack_require__(20);

var _camera = __webpack_require__(126);

var _setMatrixOnNode = __webpack_require__(127);

var _setMatrixOnNode2 = _interopRequireDefault(_setMatrixOnNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function home(store, translator) {
  return {
    label: 'Home',
    enabled: true,
    display: {
      playerTools: true
    },
    options: {},

    execute: function execute() {
      var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });

      var targetTransform = void 0;
      if (playerData.orbitTarget) {
        targetTransform = (0, _scene.getWorldTransform)(store, playerData.orbitTarget);
      } else {
        var bbCenter = translator.getNodeListBoundingBox([(0, _sceneIO.getSceneId)(store)]).getCenter();
        if (isNaN(bbCenter.x) || isNaN(bbCenter.y) || isNaN(bbCenter.z)) bbCenter.set(0, 0, 0);
        targetTransform = new _three.Matrix4().setPosition(bbCenter);
      }
      (0, _setMatrixOnNode2.default)(store, _sceneGraph.virtualTargetId, targetTransform);

      (0, _camera.initCamera)(store, true, playerData && playerData.camera);
    }
  };
}

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _tools;

var _orbit = __webpack_require__(248);

var _orbit2 = _interopRequireDefault(_orbit);

var _pan = __webpack_require__(472);

var _pan2 = _interopRequireDefault(_pan);

var _zoom = __webpack_require__(251);

var _zoom2 = _interopRequireDefault(_zoom);

var _nodeMove = __webpack_require__(245);

var _nodeMove2 = _interopRequireDefault(_nodeMove);

var _nodeRotate = __webpack_require__(246);

var _nodeRotate2 = _interopRequireDefault(_nodeRotate);

var _nodeScale = __webpack_require__(247);

var _nodeScale2 = _interopRequireDefault(_nodeScale);

var _nodeManipulate = __webpack_require__(471);

var _nodeManipulate2 = _interopRequireDefault(_nodeManipulate);

var _select = __webpack_require__(474);

var _select2 = _interopRequireDefault(_select);

var _fullscreen = __webpack_require__(468);

var _fullscreen2 = _interopRequireDefault(_fullscreen);

var _home = __webpack_require__(469);

var _home2 = _interopRequireDefault(_home);

var _snapshot = __webpack_require__(475);

var _snapshot2 = _interopRequireDefault(_snapshot);

var _firstPersonMode = __webpack_require__(467);

var _firstPersonMode2 = _interopRequireDefault(_firstPersonMode);

var _primitives = __webpack_require__(473);

var _primitives2 = _interopRequireDefault(_primitives);

var _configurator = __webpack_require__(466);

var _configurator2 = _interopRequireDefault(_configurator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tools = (_tools = {
  orbit: _orbit2.default,
  pan: _pan2.default,
  zoom: _zoom2.default,
  home: _home2.default,
  select: _select2.default,
  nodeMove: _nodeMove2.default,
  nodeRotate: _nodeRotate2.default,
  nodeScale: _nodeScale2.default,
  nodeManipulate: _nodeManipulate2.default
}, (0, _defineProperty3.default)(_tools, 'select', _select2.default), (0, _defineProperty3.default)(_tools, 'fullscreen', _fullscreen2.default), (0, _defineProperty3.default)(_tools, 'snapshot', _snapshot2.default), (0, _defineProperty3.default)(_tools, 'firstPersonMode', _firstPersonMode2.default), (0, _defineProperty3.default)(_tools, 'configurator', _configurator2.default), _tools);

(0, _assign2.default)(tools, _primitives2.default);

exports.default = tools;

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nodeManipulate;

var _nodeMove = __webpack_require__(245);

var _nodeScale = __webpack_require__(247);

var _nodeRotate = __webpack_require__(246);

function nodeManipulate(store, translator) {
  var activeAxis = false;

  return {
    //    label: 'Manipulate Node',
    enabled: true,
    display: {
      playerTools: false
    },

    options: {
      displayGizmo: true,
      mode: 'free',
      plane: {
        normal: { x: 0, y: 1, z: 0 },
        constant: 0
      }
    },

    tool: {
      /*
      hover: function (ev) {
        if (!this.active) return;
        activeAxis = highlightAxis(translator, ev, activeAxis);
      },
      */

      drag: function drag(ev) {
        if (!this.active) return false;
        if (ev.which == 1) {
          var self = this;
          return {
            momentum: !activeAxis,
            handle: function handle(ev) {
              switch (self.options.mode) {
                case 'plane':
                  (0, _nodeMove.moveNodeOnPlane)(store, ev.deltaX, ev.deltaY, self.options.plane);
                  break;
                case 'objects':
                  (0, _nodeMove.moveNodeOnObjects)(store, ev.clientX, ev.clientY, self.options.objects);
                  break;
                default:
                  (0, _nodeMove.moveNodeFree)(store, ev.deltaX, ev.deltaY, activeAxis);
                  break;
              }
            }
          };
        } else if (ev.which == 3) {
          return {
            momentum: !activeAxis,
            handle: function handle(ev) {
              (0, _nodeRotate.rotateNode)(store, ev.deltaX, ev.deltaY, activeAxis);
            }
          };
        }
      }, //drag

      scroll: function scroll(ev) {
        if (!this.active) return;
        (0, _nodeScale.scaleNode)(store, ev, activeAxis);
      }
    } //tool
  }; //return
}

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pan;

var _three = __webpack_require__(0);

var _decompose = __webpack_require__(51);

var _decompose2 = _interopRequireDefault(_decompose);

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

var _sceneGraph = __webpack_require__(10);

var _updateCameraLookAtTarget = __webpack_require__(71);

var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

var _getProjectionMatrix = __webpack_require__(105);

var _getProjectionMatrix2 = _interopRequireDefault(_getProjectionMatrix);

var _getTargetWorldMatrix = __webpack_require__(59);

var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

var _getOrbitAttrs = __webpack_require__(104);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tan = Math.tan,
    cos = Math.cos,
    atan = Math.atan,
    acos = Math.acos,
    min = Math.min,
    max = Math.max,
    pow = Math.pow,
    PI = Math.PI,
    sqrt = Math.sqrt;


var cameraProjectMatrix = new _three.Matrix4();
var cameraUnprojectMatrix = new _three.Matrix4();
var ndcReferencePoint = new _three.Vector3();
var worldRelative = new _three.Vector3();
var deltaReferencePoint = new _three.Vector3();
var referencePoint = new _three.Vector3();
var translationMatrix = new _three.Matrix4();

var cameraPosition = new _three.Vector3();
var targetPosition = new _three.Vector3();
var offset = new _three.Vector3();

function pan(store, translator) {
  function move(_ref) {
    var deltaX = _ref.deltaX,
        deltaY = _ref.deltaY;

    var zoom = 1;
    if (true) zoom = window.devicePixelRatio;
    updatePan(store, new _three.Vector2(deltaX / zoom, deltaY / zoom));
  }

  return {
    label: 'Pan',
    enabled: true,
    display: {
      playerTools: true
    },
    options: {},

    tool: {
      drag: function drag(ev) {
        if (!this.active && ev.which !== 2 && ev.which !== 3 && !ev.shiftKey) return false;

        return {
          momentum: true,
          handle: function handle(ev) {
            move(ev);
          }
        };
      },

      swipe: function swipe(ev) {
        move(ev);
      }
    }
  };
}

function updatePan(store, mouseDelta) {
  var cameraId = (0, _player.getCamera)(store);
  var cameraData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
  var playerData = (0, _scene.get)(store, { scene: true, evalPlug: 'Player' });
  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store, cameraId);
  var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, cameraId);
  var rect = (0, _player.getRect)(store);
  var projectionMatrix = (0, _getProjectionMatrix2.default)((0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' }));

  // convert mouse delta into relative delta in NDC.
  var relativeDelta = new _three.Vector2().copy(mouseDelta).divide(rect).multiplyScalar(2.0);
  relativeDelta.x *= -1;

  var invCameraWorldMatrix = new _three.Matrix4().getInverse(cameraWorldMatrix, true);
  cameraProjectMatrix.copy(projectionMatrix).multiply(invCameraWorldMatrix);

  ndcReferencePoint.setFromMatrixPosition(targetWorldMatrix).applyMatrix4(cameraProjectMatrix);
  cameraUnprojectMatrix.getInverse(cameraProjectMatrix, true);

  referencePoint.set(0, 0, ndcReferencePoint.z).applyMatrix4(cameraUnprojectMatrix);
  deltaReferencePoint.set(relativeDelta.x, relativeDelta.y, ndcReferencePoint.z).applyMatrix4(cameraUnprojectMatrix);

  // ensure that NDC has the same layout as mouseDelta coordinate space
  worldRelative.copy(deltaReferencePoint).sub(referencePoint);
  //bounding box constraining
  if (cameraData.radiusConstraint && worldRelative.length() > 0) {
    var _cameraData$radiusCon = cameraData.radiusConstraint,
        maxBoundingSphere = _cameraData$radiusCon.maxBoundingSphere,
        minBoundingSphere = _cameraData$radiusCon.minBoundingSphere;

    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
    targetPosition.setFromMatrixPosition(targetWorldMatrix);

    var directionNorm = new _three.Vector3().copy(worldRelative).normalize();
    var camRay = new _three.Ray(cameraPosition, directionNorm);
    var targRay = new _three.Ray(targetPosition, directionNorm);

    var targHit = targRay.intersectSphere(minBoundingSphere).sub(targetPosition).length() - 0.001;

    var inCamHit = camRay.intersectSphere(minBoundingSphere);
    if (inCamHit) inCamHit = inCamHit.sub(cameraPosition).length() - 0.001;else inCamHit = Infinity;

    var outCamHit = maxBoundingSphere.radius === Infinity ? Infinity : camRay.intersectSphere(maxBoundingSphere).sub(cameraPosition).length() - 0.001;

    var moveLength = Math.min(worldRelative.length(), targHit, inCamHit, outCamHit);
    worldRelative.normalize().multiplyScalar(moveLength);
  }

  translationMatrix.makeTranslation(worldRelative.x, worldRelative.y, worldRelative.z);
  offset.addVectors(cameraData.offset, worldRelative);
  cameraData.offset = offset;

  targetWorldMatrix.multiplyMatrices(translationMatrix, targetWorldMatrix);
  cameraWorldMatrix.multiplyMatrices(translationMatrix, cameraWorldMatrix);

  if ((0, _getOrbitAttrs.getConstrainCameraY)(store, cameraId) && (0, _getOrbitAttrs.getOrbitMode)(store, cameraId) !== 'trackball') {
    cameraPosition.setFromMatrixPosition(cameraWorldMatrix);
    targetPosition.setFromMatrixPosition(targetWorldMatrix);

    if (cameraPosition.y < 0) {
      targetPosition.y -= cameraPosition.y;
      cameraPosition.y = 0;
    }

    targetWorldMatrix.setPosition(targetPosition);
    cameraWorldMatrix.setPosition(cameraPosition);
  }

  (0, _updateCameraLookAtTarget2.default)(cameraWorldMatrix, targetWorldMatrix, cameraData.upPosition);

  store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(cameraWorldMatrix)));
  store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
  //store.dispatch(merge([cameraId, 'Camera', 0], {offset}));
}

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _scene = __webpack_require__(7);

var _selection = __webpack_require__(45);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var primitives = {};

var operators = {
  PolyMesh: ['Box', 'Capsule', 'Cone', 'Cylinder', 'Disk', 'Plane', 'Sphere', 'Torus'],
  Light: ['DirectionalLight', 'SpotLight', 'PointLight', 'HemisphereLight', 'AreaLight']
};

(0, _keys2.default)(operators).forEach(function (primitive) {
  operators[primitive].forEach(function (op) {
    primitives[primitive + op] = function (store, translator) {
      return {
        label: 'Create ' + op,
        enabled: true,
        display: {
          primitives: true
        },
        options: {
          operator: op,
          primitive: primitive
        },

        execute: function execute() {
          var objectsId = (0, _scene.find)(store, { type: 'Objects' });
          if (!objectsId) return;
          store.dispatch((0, _scene.addNode)({
            type: primitive,
            name: op,
            parent: objectsId,
            plugs: (0, _defineProperty3.default)({}, primitive, [[op, {}]])
          })).then(function (nodeId) {
            store.dispatch((0, _selection.selectNode)(nodeId));
          });
        }
      };
    };
  });
});

exports.default = primitives;

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = select;

var _player = __webpack_require__(8);

var _selection = __webpack_require__(45);

function select(store, translator) {
  return {
    label: 'Select',
    enabled: true,
    display: {
      playerTools: false,
      editorTools: true
    },
    options: {},

    tool: {
      click: function click(ev) {
        var nodes = (0, _player.filterNodesFromPosition)(store, ev);
        if (nodes.length) store.dispatch((0, _selection.selectNode)(nodes[0]));
      },

      drag: function drag(ev) {
        if (ev.which !== 1 || !this.active) return false;

        return {
          momentum: false,

          handle: function handle(ev) {
            //console.log('drag select', ev.deltaX, ev.deltaY);
          }
        };
      }
    }
  };
}

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = snapshot;

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

var _three = __webpack_require__(244);

/**
 * Take a snapshot of the current canvas and save it as png
 * @public
 * @param {} [optionalNodeList] An array of selected node Id
*/
function snapshot(store, translator) {
  return {
    label: 'Snapshot',
    enabled: true,
    display: {
      playerTools: false
    },
    options: {
      dataType: 'image' // image||blob||dataURL
    },
    execute: function execute() {
      var command = store.getIn(['commands', 'all'])['snapshot'];
      var three = (0, _player.getThree)(store);
      var composer = translator.composer;
      var currentCameraId = (0, _player.getCamera)(store);
      var cameraId = null;
      if (command.options.camera) {
        cameraId = (0, _scene.find)(store, { name: command.options.camera });
        if (cameraId) {
          store.dispatch((0, _player.setCamera)(cameraId));
          store.getEvaluatedTranslator();
          translator.resize();
        }
      }
      translator.renderQualityControl(_three.QUALITY_MODE.LOW);
      composer.render();
      var url = translator.renderer.domElement.toDataURL();
      if (command.options.camera) store.dispatch((0, _player.setCamera)(currentCameraId));
      if (command.options.dataType === 'dataURL') {
        return url;
      } else if (command.options.dataType === 'blob') {
        return canvasToBlob(url);
      }
      return saveData(canvasToBlob(url), 'screenshot.png');
    }
  };
}

function canvasToBlob(shot) {
  function dataURLtoBlob(dataurl) {
    var arr = dataurl.split(','),
        mime = arr[0].match(/:(.*?);/)[1],
        bstr = atob(arr[1]),
        n = bstr.length,
        u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], { type: mime });
  }

  return dataURLtoBlob(shot);
}

function saveData(blob, fileName) {
  var url = window.URL.createObjectURL(blob);
  var download = document.createElement('a');
  document.body.appendChild(download);
  download.style = 'display: none';
  download.href = url;
  download.download = fileName;
  download.click();
  window.URL.revokeObjectURL(url);
}

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cameraControl;

var _commands = __webpack_require__(43);

function cameraControl(store) {
  var tools = (0, _commands.getCommands)(store);
  var active = false;
  ['orbit', 'pan', 'zoom'].forEach(function (tool) {
    active = active || tools[tool] && tools[tool].active;
  });
  return active;
}

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = __webpack_require__(49);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

exports.default = function (store, translator) {
  var vrEffect = void 0,
      vrDisplay = void 0,
      vrReticle = void 0,
      vrFloor = void 0,
      vrGrid = void 0,
      vrControls = void 0,
      vrMode = void 0,
      hasExternalDisplay = void 0,
      oculusController = void 0,
      controllerHandler = void 0,
      matchToCamera = void 0,
      mobileNavHandler = void 0,
      orbitDistance = void 0,
      threeVrCamera = void 0,
      firstPersonActive = void 0,
      prevMoveMode = void 0,
      controllersAdded = false,
      prevHandlers = false,
      prevKeyboard = false,
      prevUserHeightFeet = 5,
      prevUserHeightInches = 11,
      fetchError = {};

  var controllerRoots = {};

  translator.externals.controllers = [['OpenVR Gamepad', 0], ['OpenVR Gamepad', 1], ['Daydream Controller'], ['Oculus Touch (Left)'], ['Oculus Touch (Right)']].map(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        id = _ref2[0],
        index = _ref2[1];

    return new THREE.VRController(id, index);
  });

  var scene = translator.scene;
  var camera = translator.camera;

  //let vrCapable = false;
  if (true && !_runtimeInfo.isIE) {
    window.navigator.getVRDisplays().then(function (displays) {
      if (!displays.length) return;
      hasExternalDisplay = displays[0].capabilities.hasExternalDisplay;
      vrDisplay = displays[0];
    });
  }

  function controllerNavHandle(manipulatorsObject) {
    return function (ev) {
      vrReticle.highlight(store, false);
      if (vrReticle.state !== 'active' || (0, _player.shouldDisplayVrSettings)(store)) return;
      var pos = vrReticle.getReticlePosition().clone(); //.getReticlePosition().clone();
      pos.y = 0;
      var destination = pos.add(manipulatorsObject.position);
      var cameraWorldMatrix = (0, _scene.getWorldTransform)(store, (0, _player.getCamera)(store));
      var devPos = new THREE.Vector3().setFromMatrixPosition(cameraWorldMatrix); //threeVrCamera.position.clone();
      var rotationalInverse = vrControls.rotationalOffset.clone().inverse();
      devPos.sub(vrControls.offset); //.applyQuaternion(rotationalInverse);
      destination.sub(devPos);
      destination.y = 0;
      vrControls.setOffset(destination);
    };
  }

  function navHandle(manipulatorsObject) {
    return function (ev) {
      vrReticle.highlight(store, false);
      if (vrReticle.state !== 'active' || (0, _player.shouldDisplayVrSettings)(store)) return;

      var cameraId = (0, _player.getCamera)(store);
      var pos = vrReticle.getReticlePosition().clone();
      pos.y = 0;
      manipulatorsObject.position.add(pos);
      manipulatorsObject.updateMatrix();
      var newCameraPosition = manipulatorsObject.position.clone();
      vrControls.setOffset(newCameraPosition);
      //store.dispatch(merge([cameraId, 'Transform', 0], decompose(newCameraPosition)));
    };
  }

  function highlightReticle() {
    vrReticle.highlight(store, true);
  }

  function addHandlers(manipObject) {
    window.addEventListener('touchstart', highlightReticle);
    window.addEventListener('thumbpaddown', highlightReticle);

    mobileNavHandler = navHandle(manipObject);
    window.addEventListener('touchend', mobileNavHandler);

    controllerHandler = controllerNavHandle(manipObject);
    window.addEventListener('thumbpadup', controllerHandler);
  }

  function removeHandlers() {
    window.removeEventListener('touchstart', highlightReticle);
    window.removeEventListener('touchend', mobileNavHandler);
    window.removeEventListener('thumbpadup', controllerHandler);
    window.addEventListener('thumbpaddown', highlightReticle);
    mobileNavHandler = null;
    controllerHandler = null;
  }

  function enableFirstPerson() {
    store.dispatch((0, _commands.activateCommand)('firstPersonMode'));
    store.dispatch((0, _commands.setCommandOptions)('firstPersonMode', { movementMode: 'plane' }));
  }

  function disableFirstPerson() {
    store.dispatch((0, _commands.deactivateCommand)('firstPersonMode'));
    store.dispatch((0, _commands.setCommandOptions)('firstPersonMode', { movementMode: prevMoveMode }));
  }

  function updateController(controller) {
    var key = controller.id + controller.index;
    var controllerMoveRoot = controllerRoots[key];
    //console.log(controllerMoveRoot, __CONTROLLER_SCENE_IDS__[controller.id]);
    if (!controllerMoveRoot && {}[controller.id]) {
      var controllerId = (0, _scene.find)(store, {
        from: { id: {}[controller.id] },
        name: 'IMPORT_NULL'
      });
      if (controllerId) {
        var moveRef = (0, _scene.find)(store, {
          from: { id: controllerId },
          name: 'CONTROLLER_ROOT'
        });
        var controllerNodes = (0, _scene.filter)(store, { from: { id: controllerId } });
        store.dispatch((0, _sceneGraph.clone)(controllerNodes, (0, _defineProperty3.default)({}, controllerId, _sceneGraph.controllerRootId), { cloneDependencies: true })).then(function (nodeMap) {
          //store.dispatch(setAll({from:{id:controllerRootId}, plug:'Properties', property:'visible'}, false));
          controllerRoots[key] = nodeMap[moveRef];
        });
      } else if (!fetchError[controller.id]) {
        console.log('try fetch');
        store.dispatch((0, _sceneIO.fetch)({}[controller.id], null, {
          ignoreErrorMessage: true
        })).catch(function (err) {
          return fetchError[controller.id] = true;
        });
      }
    } else if (controllerMoveRoot) {
      //store.dispatch(setAll({from:{id:controllerMoveRoot}, plug:'Properties', property:'visible'}, true));

      store.dispatch((0, _scene.set)({
        id: controllerMoveRoot,
        plug: 'Transform',
        property: 'translation'
      }, controller.position));

      var euler = new THREE.Euler().setFromQuaternion(controller.orientation, 'ZYX');
      store.dispatch((0, _scene.set)({ id: controllerMoveRoot, plug: 'Transform', property: 'rotation' }, euler.toVector3().multiplyScalar(180 / Math.PI)));
    }
    if (vrReticle) vrReticle.update(store, controller);
  }

  return {
    label: 'VR mode',
    activeLabel: 'Exit VR Mode',

    enabled: true,
    display: {
      playerTools: false
    },
    options: {
      planeEnabled: false,
      navigationEnabled: true,
      keyboardEnabled: true,
      userHeightFeet: 5,
      userHeightInches: 11
    },

    isActive: _player.isVRMode,

    widget: {
      draw: function draw(manipulatorsObject) {
        if (vrMode !== 'orbit') {
          vrReticle = new _reticle2.default(store, threeVrCamera, manipulatorsObject);
          var meshes = (0, _scene.filter)(store, {
            type: 'PolyMesh',
            plug: 'Properties',
            properties: { walkableInVR: true }
          });
          meshes.forEach(function (path) {
            var id = path[0];
            var object = translator.getThreeObject(id);
            if (object) vrReticle.addCollider(object);
          });
        }

        prevHandlers = this.options.navigationEnabled;
        if (this.options.navigationEnabled && vrMode !== 'orbit') addHandlers(manipulatorsObject);
      },

      remove: function remove(manipulatorsObject) {
        if (this.options.navigationEnabled && vrMode !== 'orbit') removeHandlers();
      },

      position: function position(manipulatorsObject) {
        if (prevHandlers !== this.options.navigationEnabled && vrMode !== 'orbit') {
          if (this.options.navigationEnabled) {
            addHandlers(manipulatorsObject);
          } else {
            removeHandlers(manipulatorsObject);
          }
          prevHandlers = this.options.navigationEnabled;
        }

        if (prevKeyboard !== this.options.keyboardEnabled) {
          this.options.keyboardEnabled && vrMode == 'firstperson' ? enableFirstPerson() : disableFirstPerson();
          prevKeyboard = this.options.keyboardEnabled;
        }

        if (vrControls) {
          vrControls.update();
          manipulatorsObject.position.copy(vrControls.offset);
        }

        if (threeVrCamera) {
          if (vrMode === 'orbit') {
            // force the distance of the camera for the orbit
            threeVrCamera.position.set(0, 0, orbitDistance);
          }
          threeVrCamera.updateMatrix();
          matchToCamera(store, threeVrCamera);
        }

        var gamepads = navigator.getGamepads();
        var hasDaydream = (0, _keys2.default)(gamepads).find(function (idx) {
          return gamepads[idx] && gamepads[idx].id === 'Daydream Controller';
        });

        if (hasExternalDisplay && oculusController) {
          oculusController.update();
        } else if (vrReticle && !hasDaydream) {
          vrReticle.update(store);
        }

        //if(controllerFound) manipulatorsObject.add(vrReticle.dot);
        //else manipulatorsObject.remove(vrReticle.dot);

        var downVector = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        var clampedY = Math.min(downVector.y, 0);
        var opacity = 1 - Math.sqrt(1 - clampedY * clampedY);
        if (this.options.planeEnabled) vrFloor.material.opacity = opacity;
        //vrGrid.material.opacity = opacity;
        var roundX = Math.round(2 * manipulatorsObject.position.x) / 2 - manipulatorsObject.position.x;
        var roundZ = Math.round(2 * manipulatorsObject.position.z) / 2 - manipulatorsObject.position.z;
        //vrGrid.position.set(roundX, 0 ,roundZ);
        manipulatorsObject.updateMatrix();
      }
    },

    tool: {
      controllerupdate: function controllerupdate(ev) {
        ev.states.forEach(updateController);
      }
    },

    activate: function activate() {
      var _this = this;

      var translator = store.getTranslator();
      vrMode = (0, _scene.get)(store, {
        scene: true,
        evalPlug: 'Player',
        property: 'vrMode'
      });
      if (vrMode !== 'orbit') {
        firstPersonActive = (0, _commands.isCommandActive)(store, 'firstPersonMode');
        matchToCamera = firstPersonMatchToCamera;
      } else {
        matchToCamera = orbitMatchToCamera;
      }

      if (vrDisplay) {
        vrEffect = new THREE.VREffect(translator.renderer);
        vrEffect.setVRDisplay(vrDisplay);
        translator.externals.vrEffect = vrEffect;

        if (!vrDisplay.capabilities.canPresent) return;

        return vrEffect.requestPresent().then(function () {
          prevMoveMode = (0, _commands.getCommands)(store).firstPersonMode.options.movementMode;
          if (firstPersonActive) {
            if (_this.options.keyboardEnabled && vrMode == 'firstperson') enableFirstPerson();else disableFirstPerson();
          }
          prevKeyboard = _this.options.keyboardEnabled;

          return store.dispatch((0, _player.useVrCamera)(true));
        }).then(function () {
          var cameraId = (0, _player.getCamera)(store);
          var cameraPosition = new THREE.Vector3().setFromMatrixPosition((0, _scene.getWorldTransform)(store, cameraId));
          cameraPosition.y = 0;

          var targetPosition = new THREE.Vector3().setFromMatrixPosition((0, _getTargetWorldMatrix2.default)(store, cameraId)).sub(cameraPosition);
          targetPosition.y = 0;
          targetPosition.normalize();
          var lookDirection = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), targetPosition);

          threeVrCamera = translator.camera.clone();

          if (vrMode === 'orbit') {
            var boundingSphere = (0, _player.getBoundingBox)(store).getBoundingSphere();

            // object to be the target (center of the scene) and parent of the camera
            var targetObject = new THREE.Object3D();
            targetObject.position.copy(boundingSphere.center);
            targetObject.add(threeVrCamera);
            targetObject.updateMatrixWorld(true);

            // compute the camera distance from its parent
            orbitDistance = boundingSphere.radius / Math.sin(threeVrCamera.fov * Math.PI / 360.0);
          }

          vrControls = new _vrControlsWrapper2.default(threeVrCamera);
          var heightMeters = (_this.options.userHeightFeet + _this.options.userHeightInches / 12) / 3.2808;
          vrControls.setUserHeight(heightMeters);

          vrControls.setOffset(cameraPosition);
          vrControls.setRotationalOffset(lookDirection);

          translator.externals.vrControls = vrControls;
          vrControls.setStanding(true);
          vrControls.resetPose(); // zero orientation controls

          vrControls.update();
          threeVrCamera.updateMatrix();
          matchToCamera(store, threeVrCamera);

          if (vrMode !== 'orbit' && hasExternalDisplay) {
            oculusController = new THREE.VRController('Oculus Remote'); //new THREE.OculusController( 0 );
          }
          translator.externals.controllers.forEach(function (ctr) {
            ctr.standingMatrix = vrControls.getStandingMatrix();
          });

          store.dispatch((0, _player.setRenderMode)(_player.RENDER_MODES.vr));
          store.setRequestAnimationFrame(vrDisplay.requestAnimationFrame, vrDisplay);

          return vrDisplay;
        }).catch(function (err) {
          console.log('Error Activating VR');
          throw err;
        });
      }
    },

    deactivate: function deactivate() {
      var translator = store.getTranslator();

      if (vrDisplay.isPresenting) vrEffect.exitPresent();
      store.setRequestAnimationFrame();

      if (!firstPersonActive) disableFirstPerson();

      store.dispatch((0, _player.setRenderMode)(_player.RENDER_MODES.normal));
      //this.options.icon = 'vrMode';

      store.dispatch((0, _player.useVrCamera)(false));

      threeVrCamera = null;
      vrControls = null;

      if (hasExternalDisplay) {
        oculusController = null;
      }

      (0, _scene.filter)(store, { from: { id: _sceneGraph.controllerRootId } }).forEach(function (id) {
        store.dispatch((0, _sceneGraph.deleteNode)(id));
      });

      if (vrReticle) vrReticle.removeAllColliders();
      translator.renderer.setScissorTest(false);
      //vrElements.children = [];
      //scene.remove(vrElements);
    }
  };
};

var _runtimeInfo = __webpack_require__(56);

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

__webpack_require__(709);

var _reticle = __webpack_require__(483);

var _reticle2 = _interopRequireDefault(_reticle);

var _player = __webpack_require__(8);

var _commands = __webpack_require__(43);

var _decompose = __webpack_require__(51);

var _decompose2 = _interopRequireDefault(_decompose);

var _getTargetWorldMatrix = __webpack_require__(59);

var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

var _updateCameraLookAtTarget = __webpack_require__(71);

var _updateCameraLookAtTarget2 = _interopRequireDefault(_updateCameraLookAtTarget);

var _sceneGraph = __webpack_require__(10);

var _scene = __webpack_require__(7);

var _sceneIO = __webpack_require__(20);

var _vrControlsWrapper = __webpack_require__(253);

var _vrControlsWrapper2 = _interopRequireDefault(_vrControlsWrapper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import '../utils/oculusController';
//import '../utils/daydreamController';

if (true) {
  window.WebVRConfig.CARDBOARD_UI_DISABLED = true;
  window.WebVRConfig.ROTATE_INSTRUCTIONS_DISABLED = true;
  window.WebVRConfig.BUFFER_SCALE = 1.0;
}

function floorGrid() {
  // Materials
  var mat = new THREE.LineBasicMaterial({
    color: 0x00ffff,
    linewidth: 1,
    depthTest: true,
    depthWrite: false
  });
  mat.transparent = false;

  var lineGeometry = new THREE.BufferGeometry();
  var positions = new Float32Array(80 * 2 * 3);

  var i = 0;
  for (var j = 0; j < 40; j++) {
    var x = j * 0.5 - 10;

    positions[i * 6 + 0] = x;
    positions[i * 6 + 1] = 0;
    positions[i * 6 + 2] = -10;
    positions[i * 6 + 3 + 0] = x;
    positions[i * 6 + 3 + 1] = 0;
    positions[i * 6 + 3 + 2] = 10;

    i++;
  }

  for (var _j = 0; _j < 40; _j++) {
    var z = _j * 0.5 - 10;

    positions[i * 6 + 0] = -10;
    positions[i * 6 + 1] = 0;
    positions[i * 6 + 2] = z;
    positions[i * 6 + 3 + 0] = 10;
    positions[i * 6 + 3 + 1] = 0;
    positions[i * 6 + 3 + 2] = z;

    i++;
  }

  lineGeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));

  var mesh = new THREE.LineSegments(lineGeometry, mat);
  mesh.mode = THREE.LineSegments;
  //mesh.position.set(0,0.1,0);

  return mesh;
}

function firstPersonMatchToCamera(store, threeCamera) {
  var cameraId = (0, _player.getCamera)(store);
  var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store);
  var targetPosition = new THREE.Vector3().setFromMatrixPosition(targetWorldMatrix);

  var length = targetPosition.sub(threeCamera.position).length();
  targetPosition.set(0, 0, -length).applyQuaternion(threeCamera.quaternion).add(threeCamera.position);
  var upPosition = new THREE.Vector3(0, 1, 0).applyQuaternion(threeCamera.quaternion);

  targetWorldMatrix.setPosition(targetPosition);
  var camData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
  camData.upPosition = upPosition;
  store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(threeCamera.matrix.clone())));
  if (!(0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' }).target) {
    store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
  }
}

function orbitMatchToCamera(store, threeCamera) {
  var cameraId = (0, _player.getCamera)(store);
  var length = threeCamera.position.length(); // away from the parent (target)

  // rotate around its local origin
  var newCameraPosition = new THREE.Vector3(0, 0, length).applyQuaternion(threeCamera.quaternion);
  var upPosition = new THREE.Vector3(0, 1, 0).applyQuaternion(threeCamera.quaternion);

  threeCamera.position.copy(newCameraPosition);
  threeCamera.updateMatrixWorld(true);

  var camData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
  camData.upPosition = upPosition;
  store.dispatch((0, _sceneGraph.merge)([cameraId, 'Transform', 0], (0, _decompose2.default)(threeCamera.matrixWorld.clone())));
}

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (store, translator) {
  var vrCapable = false;
  var skipInterstitial = true;
  var hasExternalDisplay = false;
  if (true && !_runtimeInfo.isIE) {
    window.navigator.getVRDisplays().then(function (displays) {
      if (!displays.length) return;
      var deviceCapable = _runtimeInfo.isIOS || _runtimeInfo.isAndroidTablet;

      vrCapable = displays[0].capabilities.canPresent && !deviceCapable;
      hasExternalDisplay = displays[0].capabilities.hasExternalDisplay;
      store.dispatch((0, _commands.updateCommand)('vrSettings', { enabled: vrCapable }));
    });
  }

  return {
    label: 'VR settings',
    activeLabel: 'Exit VR Mode',

    enabled: vrCapable,
    display: {
      playerTools: true
    },
    options: {},

    isActive: _player.shouldDisplayVrSettings,

    activate: function activate() {
      this.options.icon = 'exit';
      store.dispatch((0, _commands.updateCommands)(_commands.MOUSE_CONTROLS, { enabled: false })); /* FIX: we should decouple tools from each other */

      if (hasExternalDisplay || skipInterstitial) {
        store.dispatch((0, _commands.activateCommand)('vrMode')); /* FIX: we should decouple tools from each other */
      } else {
        store.dispatch((0, _player.displayVrSettings)(true));
      }
    },

    deactivate: function deactivate() {
      this.options.icon = 'vrSettings';
      store.dispatch((0, _commands.undoUpdateCommands)(_commands.MOUSE_CONTROLS)); /* FIX: we should decouple tools from each other */
      store.dispatch((0, _commands.deactivateCommand)('vrMode')); /* FIX: we should decouple tools from each other */
    }
  };
};

var _runtimeInfo = __webpack_require__(56);

var _commands = __webpack_require__(43);

var _player = __webpack_require__(8);

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixOn = setMatrixOn;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var rotationFactor = 3.14 / 180;

// Set transalation, rotation, scale on Object3D
function setTRS(object3d, t, r, s) {
  object3d.position.set(t.x, t.y, t.z);
  object3d.rotation.set(r.x, r.y, r.z, 'ZYX');
  object3d.scale.set(s.x, s.y, s.z);
}

function setTRSDegrees(object3d, t, r, s) {
  object3d.position.set(t.x, t.y, t.z);
  object3d.rotation.set(r.x * rotationFactor, r.y * rotationFactor, r.z * rotationFactor, 'ZYX');
  object3d.scale.set(s.x, s.y, s.z);
}

/* Apply matrix4 to threejs node.
 */
function setMatrixOn(object3d, matrix4) {
  var translation = new THREE.Vector3();
  var rotQuat = new THREE.Quaternion();
  var scale = new THREE.Vector3();
  matrix4.decompose(translation, rotQuat, scale);
  var rotation = new THREE.Vector3().copy(new THREE.Euler().setFromQuaternion(rotQuat, 'ZYX'));
  setTRS(object3d, translation, rotation, scale);
}

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(24);

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.createTranslator = createTranslator;

var _sceneIO = __webpack_require__(20);

var _sceneGraph = __webpack_require__(10);

var _animation = __webpack_require__(67);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultNodeFilter = function defaultNodeFilter(n) {
  return true;
};

var defaultFns = {
  onLoad: function onLoad() {},
  postTranslate: function postTranslate() {},
  handleStateChanges: function handleStateChanges() {}
};

function createTranslator(store, initTranslator, context) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var api = {};
  var translator = initTranslator(store, context, api);
  var nodeFilter = defaultNodeFilter;
  var forceFetchAssets = options.forceFetchAssets;

  var view = null;
  var player = store.get('player');

  var translatedSceneId = void 0;

  var translatedVersion = null;
  var translatedNodes = {};
  var renderingMode = store.getIn(['player', 'renderingMode']);
  var vrDisplay = void 0;

  function translateNodes(sceneId) {
    var sceneGraph = (0, _sceneGraph.getEvalSceneGraph)(store, { forceFetchAssets: forceFetchAssets });

    if (translatedVersion === sceneGraph._ev) return 0;

    var newTranslatedNodes = {};

    //console.log('translate from', translatedVersion, 'to', sceneGraph._ev); //, translatedNodes);

    var numUpdated = 0;

    function translateNode(id) {
      var node = sceneGraph.nodes[id];
      if (!node) return;
      var result = sceneGraph.evaluatedNodes[id];
      var translated = translatedNodes[id];

      if (!translated || translated._v !== result._v || translated._ev !== result._ev) {
        //console.log('translate: ', translatedNodes[id], {_v: result._v, _ev: result._ev}, node.name);
        translator.translate(id, result, node);
        numUpdated += 1;
      }

      newTranslatedNodes[id] = { _v: result._v, _ev: result._ev };

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(node.children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var childId = _step.value;

          translateNode(childId);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    translateNode(sceneId);

    if (sceneGraph.nodes[_sceneGraph.virtualCameraId]) translateNode(_sceneGraph.virtualCameraId);
    if (sceneGraph.nodes[_sceneGraph.vrCameraId]) translateNode(_sceneGraph.vrCameraId);
    if (sceneGraph.nodes[_sceneGraph.controllerRootId]) translateNode(_sceneGraph.controllerRootId);

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(translatedNodes)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var id = _step2.value;

        if (!newTranslatedNodes[id]) {
          translator.deleteNode(id);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    translatedNodes = newTranslatedNodes;
    translatedVersion = sceneGraph._ev;

    return numUpdated;
  }

  function doUpdate() {}

  function reset() {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(translatedNodes)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var id = _step3.value;

        translator.deleteNode(id);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    translator.reset();

    translatedVersion = null;
    translatedNodes = {};
    translatedSceneId = null;
  }

  return (0, _assign2.default)({}, defaultFns, translator, {
    reset: reset,

    update: function update() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var sceneId = (0, _sceneIO.getSceneId)(store);
      var scenePhase = (0, _sceneIO.getScenePhase)(store);
      if (!sceneId) {
        translatedSceneId = null;
        return;
      }

      if (sceneId !== translatedSceneId || scenePhase < _sceneIO.SCENE_PHASES.RENDERING) {
        reset();
        translatedSceneId = sceneId;
      }

      // console.log('translator do update');
      var numUpdated = translateNodes(sceneId);
      //console.log('numUpdated: ', numUpdated);
      var rendering = scenePhase >= _sceneIO.SCENE_PHASES.RENDERING;
      var preloaded = scenePhase >= _sceneIO.SCENE_PHASES.PRELOADING;
      var loaded = scenePhase >= _sceneIO.SCENE_PHASES.LOADED;
      var rendered = scenePhase >= _sceneIO.SCENE_PHASES.RENDERED;

      //console.log('numUpdated', numUpdated, 'assetsLoaded', areAssetsLoaded(store), 'rendering', rendering, 'preloaded', preloaded, 'loaded', loaded);

      if (!rendering && numUpdated) {
        store.dispatch((0, _sceneIO.markRenderingScene)());
      }

      if (loaded && !rendered) {
        store.dispatch((0, _sceneIO.markRenderedScene)());
      }
      if (false) console.log('translator', 'rendered', rendered, 'loaded', loaded, 'preloaded', preloaded, 'assetsLoaded', (0, _sceneIO.areAssetsLoaded)(store));

      if (!loaded && preloaded && (0, _sceneIO.areAssetsLoaded)(store)) {
        var ready = translator.onLoad();
        if (ready) store.dispatch((0, _sceneIO.markLoaded)());
      }

      if (!preloaded && (0, _sceneIO.areAssetsPreloaded)(store)) {
        store.dispatch((0, _sceneIO.markPreloaded)());
      }

      if (preloaded) translator.postTranslate();

      store.dispatch((0, _animation.incrementTime)());
    }
  });
}

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = enableDeviceTracking;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _player = __webpack_require__(8);

var _scene = __webpack_require__(7);

var _sceneGraph = __webpack_require__(10);

var _decompose = __webpack_require__(51);

var _decompose2 = _interopRequireDefault(_decompose);

var _getTargetWorldMatrix = __webpack_require__(59);

var _getTargetWorldMatrix2 = _interopRequireDefault(_getTargetWorldMatrix);

var _vrControlsWrapper = __webpack_require__(253);

var _vrControlsWrapper2 = _interopRequireDefault(_vrControlsWrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function enableDeviceTracking(store, externals) {
  var dummyCamera = new THREE.Camera();
  var vrControls = new _vrControlsWrapper2.default(dummyCamera);
  externals.vrControls = vrControls;

  function orientHandle() {
    if (vrControls) vrControls.update();
    dummyCamera.updateMatrix();
    matchToCamera(dummyCamera);
  }

  function matchToCamera(threeCamera) {
    var cameraId = (0, _player.getCamera)(store);
    var targetWorldMatrix = (0, _getTargetWorldMatrix2.default)(store);
    var targetPosition = new THREE.Vector3().setFromMatrixPosition(targetWorldMatrix);

    var length = targetPosition.sub(threeCamera.position).length();
    targetPosition.set(0, 0, -length).applyQuaternion(threeCamera.quaternion).add(threeCamera.position);
    var upPosition = new THREE.Vector3(0, 1, 0).applyQuaternion(threeCamera.quaternion);

    targetWorldMatrix.setPosition(targetPosition);
    var camData = (0, _scene.get)(store, { id: cameraId, evalPlug: 'Camera' });
    camData.upPosition = upPosition;
    store.dispatch((0, _sceneGraph.set)([cameraId, 'Transform', 0, 'rotation'], (0, _decompose2.default)(threeCamera.matrix.clone()).rotation));
    if (!(0, _scene.get)(store, { id: cameraId, evalPlug: 'Transform' }).target) {
      store.dispatch((0, _sceneGraph.merge)([_sceneGraph.virtualTargetId, 'Transform', 0], (0, _decompose2.default)(targetWorldMatrix)));
    }
  }

  if (true) window.addEventListener('deviceorientation', orientHandle);
  return orientHandle;
}

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _create = __webpack_require__(48);

var _create2 = _interopRequireDefault(_create);

exports.DirectionalLightHelper = DirectionalLightHelper;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ArrowHelper(light, length, hex, headLength, headWidth) {
  // dir is assumed to be normalized

  THREE.Object3D.call(this);
  this.className = 'ArrowHelper';
  this.light = light;

  if (hex === undefined) hex = 0xffffff;
  if (length === undefined) length = 1;
  if (headLength === undefined) headLength = 0.2 * length;
  if (headWidth === undefined) headWidth = 0.2 * headLength;

  //this.position.set(this.light.position.x, this.light.position.y, this.light.position.z);

  var cylinderGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.5, 10, 1);
  var coneGeometry = new THREE.CylinderGeometry(0, 0.5, 0.5, 5, 1);

  this.cylinder1 = new THREE.Mesh(cylinderGeometry, new THREE.MeshBasicMaterial({ color: hex }));
  this.cylinder1.matrixAutoUpdate = false;
  this.add(this.cylinder1);

  this.cone1 = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({ color: hex }));
  this.cone1.matrixAutoUpdate = false;
  this.add(this.cone1);

  this.setLength(length, headLength, headWidth);

  this.update();
}

ArrowHelper.prototype = (0, _create2.default)(THREE.Object3D.prototype);

ArrowHelper.prototype.update = function () {
  var axis = new THREE.Vector3();
  var radians = void 0;
  return function () {
    var dir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.light.quaternion);
    // dir is assumed to be normalized

    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      axis.set(dir.z, 0, -dir.x).normalize();

      radians = Math.acos(dir.y);

      this.quaternion.setFromAxisAngle(axis, radians);
      //this.position.set(this.light.position.x, this.light.position.y, this.light.position.z);
    }
  };
}();

ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
  if (headLength === undefined) headLength = 0.2 * length;
  if (headWidth === undefined) headWidth = 0.2 * headLength;

  this.cylinder1.scale.set(headWidth, length, headWidth);
  this.cylinder1.updateMatrix();

  this.cone1.scale.set(headWidth, headLength, headWidth);
  this.cone1.position.y = length / 4;
  this.cone1.updateMatrix();
};

ArrowHelper.prototype.setColor = function (hex) {
  this.cylinder1.material.color.setHex(hex);
  this.cone1.material.color.setHex(hex);
};

function DirectionalLightHelper(light, size) {
  THREE.Object3D.call(this);
  this.isHelper = true;
  this.light = light;
  this.light.updateMatrixWorld();

  this.arrow = new ArrowHelper(this.light, size);
  this.add(this.arrow);
  this.update();
}

DirectionalLightHelper.prototype = (0, _create2.default)(THREE.Object3D.prototype);

DirectionalLightHelper.prototype.update = function () {
  return function () {
    this.position.set(this.light.position.x, this.light.position.y, this.light.position.z);
    this.arrow.update();
  };
}();

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(19);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

exports.default = Reticle;

var _three = __webpack_require__(15);

var THREE = _interopRequireWildcard(_three);

var _sceneIO = __webpack_require__(20);

var _scene = __webpack_require__(7);

var _sceneGraph = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var reticleSceneId = {}['VR Reticle'];
var groundNormal = new THREE.Vector3(0, 1, 0);
var reticleState = {
  ACTIVE: 'active',
  INACTIVE: 'inactive',
  DISABLED: 'disalbed'
};

function Reticle(store, camera, manipulatorsObject) {
  this.state = reticleState.INACTIVE;
  this.stateChanged = false;
  this.colliders = [];
  this.position = null;
  this.camera = camera;
  this.manipulatorsObject = manipulatorsObject;
  this.error = null;

  var self = this;
  if (!this.reticleMoveRoot && !this.error) {
    var moveRef = void 0,
        reticleMaterialId = void 0,
        reticleId = void 0,
        disableId = void 0;
    store.dispatch((0, _sceneIO.fetch)(reticleSceneId, null, { ignoreErrorMessage: true })).then(function () {
      var reticleImportId = (0, _scene.find)(store, {
        from: { id: reticleSceneId },
        name: 'IMPORT_NULL'
      });
      reticleId = (0, _scene.find)(store, {
        from: { id: reticleSceneId },
        name: 'RETICLE'
      });
      disableId = (0, _scene.find)(store, {
        from: { id: reticleSceneId },
        name: 'DISABLE'
      });
      reticleMaterialId = (0, _scene.find)(store, {
        from: { id: reticleSceneId },
        name: 'RETICLE_MATERIAL'
      });
      moveRef = (0, _scene.find)(store, {
        from: { id: reticleImportId },
        name: 'RETICLE_ROOT'
      });
      var reticleNodes = (0, _scene.filter)(store, { from: { id: reticleImportId } });

      return store.dispatch((0, _sceneGraph.clone)(reticleNodes, (0, _defineProperty3.default)({}, reticleImportId, _sceneGraph.controllerRootId), { cloneDependencies: true }));
    }).then(function (nodeMap) {
      self.reticleMoveRoot = nodeMap[moveRef];
      self.reticleMaterialId = nodeMap[reticleMaterialId];
      self.reticleId = nodeMap[reticleId];
      self.disableId = nodeMap[disableId];
      self.changeVisibility(store);
    }).catch(function (err) {
      self.error = err;
    });
  }
}

Reticle.prototype = {
  constructor: Reticle,

  getReticlePosition: function getReticlePosition() {
    return this.position;
  },

  addCollider: function addCollider(threeObject) {
    this.colliders.push(threeObject);
  },

  removeCollider: function removeCollider(threeObject) {
    var index = this.colliders.indexOf(threeObject);
    if (index > -1) {
      this.colliders.splice(index, 1);
    }
  },

  removeAllColliders: function removeAllColliders() {
    this.colliders = [];
  },

  getIntersects: function getIntersects(controller) {
    var direction = new THREE.Vector3();
    var position = new THREE.Vector3();
    if (controller) {
      direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.orientation);
      position = controller.position;
    } else {
      this.camera.getWorldDirection(direction);
      position = this.camera.position;
    }

    var ray = new THREE.Raycaster(position, direction);
    return ray.intersectObjects(this.colliders);
  },

  highlight: function highlight(store, enabled) {
    if (enabled) {
      store.dispatch((0, _scene.set)({
        id: this.reticleMaterialId,
        plug: 'Material',
        property: 'emissiveColor'
      }, { r: 0, g: 1, b: 0 }));
    } else {
      store.dispatch((0, _scene.set)({
        id: this.reticleMaterialId,
        plug: 'Material',
        property: 'emissiveColor'
      }, { r: 0.6, g: 0.6, b: 0.6 }));
    }
  },

  changeVisibility: function changeVisibility(store) {
    if (this.state === reticleState.ACTIVE) {
      store.dispatch((0, _scene.set)({ id: this.reticleId, plug: 'Properties', property: 'visible' }, true));
      store.dispatch((0, _scene.set)({ id: this.disableId, plug: 'Properties', property: 'visible' }, false));
    } else if (this.state === reticleState.INACTIVE) {
      store.dispatch((0, _scene.set)({ id: this.reticleId, plug: 'Properties', property: 'visible' }, false));
      store.dispatch((0, _scene.set)({ id: this.disableId, plug: 'Properties', property: 'visible' }, true));
    } else if (this.state === reticleState.DISABLED) {
      store.dispatch((0, _scene.set)({ id: this.reticleId, plug: 'Properties', property: 'visible' }, false));
      store.dispatch((0, _scene.set)({ id: this.disableId, plug: 'Properties', property: 'visible' }, false));
    }
  },

  update: function update(store, controller) {
    if (!this.camera) return;

    var intersects = this.getIntersects(controller);

    if (intersects[0]) {
      //save the new hit object and time
      this.position = intersects[0].point;
      if (this.reticleMoveRoot) store.dispatch((0, _scene.set)({
        id: this.reticleMoveRoot,
        plug: 'Transform',
        property: 'translation'
      }, intersects[0].point));
      var rotation = (0, _scene.get)(store, {
        id: this.reticleMoveRoot,
        plug: 'Transform',
        property: 'rotation'
      });
      if (this.reticleMoveRoot) store.dispatch((0, _scene.set)({
        id: this.reticleMoveRoot,
        plug: 'Transform',
        property: 'rotation'
      }, { x: rotation.x, y: rotation.y - 4, z: rotation.z }));
      if (this.manipulatorsObject.position) {
        this.position.sub(this.manipulatorsObject.position);
      }
      var faceNormal = intersects[0].face.normal;

      if (faceNormal.dot(groundNormal) !== 1) {
        if (this.state !== reticleState.INACTIVE) this.stateChanged = true;
        this.state = reticleState.INACTIVE;
      } else {
        if (this.state !== reticleState.ACTIVE) this.stateChanged = true;
        this.state = reticleState.ACTIVE;
      }
    } else {
      if (this.state !== reticleState.DISABLED) this.stateChanged = true;
      this.state = reticleState.DISABLED;
    }

    if (this.stateChanged && this.reticleId && this.disableId) {
      this.changeVisibility(store);
      this.stateChanged = false;
    }
  }
};

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = map;
exports.filter = filter;
exports.compose = compose;
function Map(f, xform) {
  this.xform = xform;
  this.f = f;
}

Map.prototype['@@transducer/init'] = function () {
  return this.xform['@@transducer/init']();
};

Map.prototype['@@transducer/result'] = function (v) {
  return this.xform['@@transducer/result'](v);
};

Map.prototype['@@transducer/step'] = function (res, input) {
  return this.xform['@@transducer/step'](res, this.f(input));
};

function Filter(f, xform) {
  this.xform = xform;
  this.f = f;
}

Filter.prototype['@@transducer/init'] = function () {
  return this.xform['@@transducer/init']();
};

Filter.prototype['@@transducer/result'] = function (v) {
  return this.xform['@@transducer/result'](v);
};

Filter.prototype['@@transducer/step'] = function (res, input) {
  if (this.f(input)) {
    return this.xform['@@transducer/step'](res, input);
  }
  return res;
};

function map(f) {
  return function (xform) {
    return new Map(f, xform);
  };
}

function filter(f) {
  return function (xform) {
    return new Filter(f, xform);
  };
}

function compose() {
  var funcs = Array.prototype.slice.call(arguments);
  return function (r) {
    var value = r;
    for (var i = funcs.length - 1; i >= 0; i--) {
      value = funcs[i](value);
    }
    return value;
  };
}

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = omit;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * return a copy of obj without keys
 */
function omit(keys, obj) {
  var result = (0, _assign2.default)({}, obj);
  keys.forEach(function (k) {
    return delete result[k];
  });
  return result;
}

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ramdaCurryN = __webpack_require__(489);

var _ramdaCurryN2 = _interopRequireDefault(_ramdaCurryN);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

'use strict';

function isFunction(obj) {
  return !!(obj && obj.constructor && obj.call && obj.apply);
}

// Globals
var toUpdate = [];
var inStream;

// Library functions use self callback to accept (null, undefined) update triggers.
function map(f, s) {
  return combine(function (s, self) {
    self(f(s.val));
  }, [s]);
}

function on(f, s) {
  return combine(function (s) {
    f(s.val);
  }, [s]);
}

function boundMap(f) {
  return map(f, this);
}

var scan = (0, _ramdaCurryN2.default)(3, function (f, acc, s) {
  var ns = combine(function (s, self) {
    self(acc = f(acc, s.val));
  }, [s]);
  if (!ns.hasVal) ns(acc);
  return ns;
});

var merge = (0, _ramdaCurryN2.default)(2, function (s1, s2) {
  var s = immediate(combine(function (s1, s2, self, changed) {
    if (changed[0]) {
      self(changed[0]());
    } else if (s1.hasVal) {
      self(s1.val);
    } else if (s2.hasVal) {
      self(s2.val);
    }
  }, [s1, s2]));
  endsOn(combine(function () {
    return true;
  }, [s1.end, s2.end]), s);
  return s;
});

function ap(s2) {
  var s1 = this;
  return combine(function (s1, s2, self) {
    self(s1.val(s2.val));
  }, [s1, s2]);
}

function initialDepsNotMet(stream) {
  stream.depsMet = stream.deps.every(function (s) {
    return s.hasVal;
  });
  return !stream.depsMet;
}

function updateStream(s) {
  if (s.depsMet !== true && initialDepsNotMet(s) || s.end !== undefined && s.end.val === true) return;
  if (inStream !== undefined) {
    toUpdate.push(s);
    return;
  }
  inStream = s;
  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;
  var returnVal = s.fn.apply(s.fn, s.fnArgs);
  if (returnVal !== undefined) {
    s(returnVal);
  }
  inStream = undefined;
  if (s.depsChanged !== undefined) s.depsChanged = [];
  s.shouldUpdate = false;
  if (flushing === false) flushUpdate();
}

var order = [];
var orderNextIdx = -1;

function findDeps(s) {
  var i,
      listeners = s.listeners;
  if (s.queued === false) {
    s.queued = true;
    for (i = 0; i < listeners.length; ++i) {
      findDeps(listeners[i]);
    }
    order[++orderNextIdx] = s;
  }
}

function updateDeps(s) {
  var i,
      o,
      list,
      listeners = s.listeners;
  for (i = 0; i < listeners.length; ++i) {
    list = listeners[i];
    if (list.end === s) {
      endStream(list);
    } else {
      if (list.depsChanged !== undefined) list.depsChanged.push(s);
      list.shouldUpdate = true;
      findDeps(list);
    }
  }
  for (; orderNextIdx >= 0; --orderNextIdx) {
    o = order[orderNextIdx];
    if (o.shouldUpdate === true) updateStream(o);
    o.queued = false;
  }
}

var flushing = false;

function flushUpdate() {
  flushing = true;
  while (toUpdate.length > 0) {
    var s = toUpdate.shift();
    if (s.vals.length > 0) s.val = s.vals.shift();
    updateDeps(s);
  }
  flushing = false;
}

function isStream(stream) {
  return isFunction(stream) && 'hasVal' in stream;
}

function streamToString() {
  return 'stream(' + this.val + ')';
}

function updateStreamValue(s, n) {
  if (n !== undefined && n !== null && isFunction(n.then)) {
    n.then(s);
    return;
  }
  s.val = n;
  s.hasVal = true;
  if (inStream === undefined) {
    flushing = true;
    updateDeps(s);
    if (toUpdate.length > 0) flushUpdate();else flushing = false;
  } else if (inStream === s) {
    markListeners(s, s.listeners);
  } else {
    s.vals.push(n);
    toUpdate.push(s);
  }
}

function markListeners(s, lists) {
  var i, list;
  for (i = 0; i < lists.length; ++i) {
    list = lists[i];
    if (list.end !== s) {
      if (list.depsChanged !== undefined) {
        list.depsChanged.push(s);
      }
      list.shouldUpdate = true;
    } else {
      endStream(list);
    }
  }
}

function createStream() {
  function s(n) {
    return arguments.length > 0 ? (updateStreamValue(s, n), s) : s.val;
  }
  s.hasVal = false;
  s.val = undefined;
  s.vals = [];
  s.listeners = [];
  s.queued = false;
  s.end = undefined;

  s.map = boundMap;
  s.ap = ap;
  s.of = stream;
  s.toString = streamToString;

  return s;
}

function addListeners(deps, s) {
  for (var i = 0; i < deps.length; ++i) {
    deps[i].listeners.push(s);
  }
}

function createDependentStream(deps, fn) {
  var s = createStream();
  s.fn = fn;
  s.deps = deps;
  s.depsMet = false;
  s.depsChanged = deps.length > 0 ? [] : undefined;
  s.shouldUpdate = false;
  addListeners(deps, s);
  return s;
}

function immediate(s) {
  if (s.depsMet === false) {
    s.depsMet = true;
    updateStream(s);
  }
  return s;
}

function removeListener(s, listeners) {
  var idx = listeners.indexOf(s);
  listeners[idx] = listeners[listeners.length - 1];
  listeners.length--;
}

function detachDeps(s) {
  for (var i = 0; i < s.deps.length; ++i) {
    removeListener(s, s.deps[i].listeners);
  }
  s.deps.length = 0;
}

function endStream(s) {
  if (s.deps !== undefined) detachDeps(s);
  if (s.end !== undefined) detachDeps(s.end);
}

function endsOn(endS, s) {
  detachDeps(s.end);
  endS.listeners.push(s.end);
  s.end.deps.push(endS);
  return s;
}

function trueFn() {
  return true;
}

function stream(initialValue) {
  var endStream = createDependentStream([], trueFn);
  var s = createStream();
  s.end = endStream;
  s.fnArgs = [];
  endStream.listeners.push(s);
  if (arguments.length > 0) s(initialValue);
  return s;
}

function combine(fn, streams) {
  var i, s, deps, depEndStreams;
  var endStream = createDependentStream([], trueFn);
  deps = [];
  depEndStreams = [];
  for (i = 0; i < streams.length; ++i) {
    if (streams[i] !== undefined) {
      deps.push(streams[i]);
      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);
    }
  }
  s = createDependentStream(deps, fn);
  s.depsChanged = [];
  s.fnArgs = s.deps.concat([s, s.depsChanged]);
  s.end = endStream;
  endStream.listeners.push(s);
  addListeners(depEndStreams, endStream);
  endStream.deps = depEndStreams;
  updateStream(s);
  return s;
}

var transduce = (0, _ramdaCurryN2.default)(2, function (xform, source) {
  xform = xform(new StreamTransformer());
  return combine(function (source, self) {
    var res = xform['@@transducer/step'](undefined, source.val);
    if (res && res['@@transducer/reduced'] === true) {
      self.end(true);
      return res['@@transducer/value'];
    } else {
      return res;
    }
  }, [source]);
});

function StreamTransformer() {}
StreamTransformer.prototype['@@transducer/init'] = function () {};
StreamTransformer.prototype['@@transducer/result'] = function () {};
StreamTransformer.prototype['@@transducer/step'] = function (s, v) {
  return v;
};

exports.default = {
  stream: stream,
  combine: (0, _ramdaCurryN2.default)(2, combine),
  isStream: isStream,
  transduce: transduce,
  merge: merge,
  scan: scan,
  endsOn: endsOn,
  map: (0, _ramdaCurryN2.default)(2, map),
  on: (0, _ramdaCurryN2.default)(2, on),
  curryN: _ramdaCurryN2.default,
  immediate: immediate
};

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = eventEmitter;
// Fork of: https://github.com/scottcorgan/tiny-emitter

/**
 * Event Emitter
 * @mixin
 * @public
 */
function eventEmitter() {
  var e = {};

  /**
   *
   * Subscribe to an event.
   *
   * @param {string} name
   * @param {function} callback
   * @param {any} [context]
   * @public
   * @instance
   * @memberof eventEmitter
   */
  function on(name, callback, context) {
    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: context
    });
    return this;
  }

  /**
   *
   * Subscribe to an event only once.
   *
   * @param {string} name
   * @param {function} callback
   * @param {any} [context]
   * @memberof eventEmitter
   * @instance
   * @public
   */
  function once(name, callback, context) {
    function listener() {
      off(name, listener);
      callback.apply(context, arguments);
    }

    listener._ = callback;

    return on(name, listener, context);
  }

  /**
   *
   * Emit an event
   *
   * @param {string} name
   * @param {any} ...rest arguments for the event
   * @memberof eventEmitter
   * @instance
   * @public
   */
  function emit(name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = (e[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  }

  /**
   * Unsubscribe from an event or all events.
   * If no callback is provided, it unsubscribes all callback from this event.
   *
   * @param {string} name
   * @param {function} callback
   * @memberof eventEmitter
   * @instance
   * @public
   */
  function off(name, callback) {
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
      }
    }

    liveEvents.length ? e[name] = liveEvents : delete e[name];

    return this;
  }

  return { on: on, once: once, emit: emit, off: off };
}

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//From Repository: https://github.com/jcmellado/js-lzma
/*
Copyright (c) 2011 Juan Mellado
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
References:
- "LZMA SDK" by Igor Pavlov
  http://www.7-zip.org/sdk.html
*/

var LZMA = LZMA || {};

LZMA.OutWindow = function () {
  this._windowSize = 0;
};

LZMA.OutWindow.prototype.create = function (windowSize) {
  if (!this._buffer || this._windowSize !== windowSize) {
    this._buffer = [];
  }
  this._windowSize = windowSize;
  this._pos = 0;
  this._streamPos = 0;
};

LZMA.OutWindow.prototype.flush = function () {
  var size = this._pos - this._streamPos;
  if (size !== 0) {
    while (size--) {
      this._stream.writeByte(this._buffer[this._streamPos++]);
    }
    if (this._pos >= this._windowSize) {
      this._pos = 0;
    }
    this._streamPos = this._pos;
  }
};

LZMA.OutWindow.prototype.releaseStream = function () {
  this.flush();
  this._stream = null;
};

LZMA.OutWindow.prototype.setStream = function (stream) {
  this.releaseStream();
  this._stream = stream;
};

LZMA.OutWindow.prototype.init = function (solid) {
  if (!solid) {
    this._streamPos = 0;
    this._pos = 0;
  }
};

LZMA.OutWindow.prototype.copyBlock = function (distance, len) {
  var pos = this._pos - distance - 1;
  if (pos < 0) {
    pos += this._windowSize;
  }
  while (len--) {
    if (pos >= this._windowSize) {
      pos = 0;
    }
    this._buffer[this._pos++] = this._buffer[pos++];
    if (this._pos >= this._windowSize) {
      this.flush();
    }
  }
};

LZMA.OutWindow.prototype.putByte = function (b) {
  this._buffer[this._pos++] = b;
  if (this._pos >= this._windowSize) {
    this.flush();
  }
};

LZMA.OutWindow.prototype.getByte = function (distance) {
  var pos = this._pos - distance - 1;
  if (pos < 0) {
    pos += this._windowSize;
  }
  return this._buffer[pos];
};

LZMA.RangeDecoder = function () {};

LZMA.RangeDecoder.prototype.setStream = function (stream) {
  this._stream = stream;
};

LZMA.RangeDecoder.prototype.releaseStream = function () {
  this._stream = null;
};

LZMA.RangeDecoder.prototype.init = function () {
  var i = 5;

  this._code = 0;
  this._range = -1;

  while (i--) {
    this._code = this._code << 8 | this._stream.readByte();
  }
};

LZMA.RangeDecoder.prototype.decodeDirectBits = function (numTotalBits) {
  var result = 0,
      i = numTotalBits,
      t;

  while (i--) {
    this._range >>>= 1;
    t = this._code - this._range >>> 31;
    this._code -= this._range & t - 1;
    result = result << 1 | 1 - t;

    if ((this._range & 0xff000000) === 0) {
      this._code = this._code << 8 | this._stream.readByte();
      this._range <<= 8;
    }
  }

  return result;
};

LZMA.RangeDecoder.prototype.decodeBit = function (probs, index) {
  var prob = probs[index],
      newBound = (this._range >>> 11) * prob;

  if ((this._code ^ 0x80000000) < (newBound ^ 0x80000000)) {
    this._range = newBound;
    probs[index] += 2048 - prob >>> 5;
    if ((this._range & 0xff000000) === 0) {
      this._code = this._code << 8 | this._stream.readByte();
      this._range <<= 8;
    }
    return 0;
  }

  this._range -= newBound;
  this._code -= newBound;
  probs[index] -= prob >>> 5;
  if ((this._range & 0xff000000) === 0) {
    this._code = this._code << 8 | this._stream.readByte();
    this._range <<= 8;
  }
  return 1;
};

LZMA.initBitModels = function (probs, len) {
  while (len--) {
    probs[len] = 1024;
  }
};

LZMA.BitTreeDecoder = function (numBitLevels) {
  this._models = [];
  this._numBitLevels = numBitLevels;
};

LZMA.BitTreeDecoder.prototype.init = function () {
  LZMA.initBitModels(this._models, 1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.decode = function (rangeDecoder) {
  var m = 1,
      i = this._numBitLevels;

  while (i--) {
    m = m << 1 | rangeDecoder.decodeBit(this._models, m);
  }
  return m - (1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.reverseDecode = function (rangeDecoder) {
  var m = 1,
      symbol = 0,
      i = 0,
      bit;

  for (; i < this._numBitLevels; ++i) {
    bit = rangeDecoder.decodeBit(this._models, m);
    m = m << 1 | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.reverseDecode2 = function (models, startIndex, rangeDecoder, numBitLevels) {
  var m = 1,
      symbol = 0,
      i = 0,
      bit;

  for (; i < numBitLevels; ++i) {
    bit = rangeDecoder.decodeBit(models, startIndex + m);
    m = m << 1 | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.LenDecoder = function () {
  this._choice = [];
  this._lowCoder = [];
  this._midCoder = [];
  this._highCoder = new LZMA.BitTreeDecoder(8);
  this._numPosStates = 0;
};

LZMA.LenDecoder.prototype.create = function (numPosStates) {
  for (; this._numPosStates < numPosStates; ++this._numPosStates) {
    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
  }
};

LZMA.LenDecoder.prototype.init = function () {
  var i = this._numPosStates;
  LZMA.initBitModels(this._choice, 2);
  while (i--) {
    this._lowCoder[i].init();
    this._midCoder[i].init();
  }
  this._highCoder.init();
};

LZMA.LenDecoder.prototype.decode = function (rangeDecoder, posState) {
  if (rangeDecoder.decodeBit(this._choice, 0) === 0) {
    return this._lowCoder[posState].decode(rangeDecoder);
  }
  if (rangeDecoder.decodeBit(this._choice, 1) === 0) {
    return 8 + this._midCoder[posState].decode(rangeDecoder);
  }
  return 16 + this._highCoder.decode(rangeDecoder);
};

LZMA.Decoder2 = function () {
  this._decoders = [];
};

LZMA.Decoder2.prototype.init = function () {
  LZMA.initBitModels(this._decoders, 0x300);
};

LZMA.Decoder2.prototype.decodeNormal = function (rangeDecoder) {
  var symbol = 1;

  do {
    symbol = symbol << 1 | rangeDecoder.decodeBit(this._decoders, symbol);
  } while (symbol < 0x100);

  return symbol & 0xff;
};

LZMA.Decoder2.prototype.decodeWithMatchByte = function (rangeDecoder, matchByte) {
  var symbol = 1,
      matchBit,
      bit;

  do {
    matchBit = matchByte >> 7 & 1;
    matchByte <<= 1;
    bit = rangeDecoder.decodeBit(this._decoders, (1 + matchBit << 8) + symbol);
    symbol = symbol << 1 | bit;
    if (matchBit !== bit) {
      while (symbol < 0x100) {
        symbol = symbol << 1 | rangeDecoder.decodeBit(this._decoders, symbol);
      }
      break;
    }
  } while (symbol < 0x100);

  return symbol & 0xff;
};

LZMA.LiteralDecoder = function () {};

LZMA.LiteralDecoder.prototype.create = function (numPosBits, numPrevBits) {
  var i;

  if (this._coders && this._numPrevBits === numPrevBits && this._numPosBits === numPosBits) {
    return;
  }
  this._numPosBits = numPosBits;
  this._posMask = (1 << numPosBits) - 1;
  this._numPrevBits = numPrevBits;

  this._coders = [];

  i = 1 << this._numPrevBits + this._numPosBits;
  while (i--) {
    this._coders[i] = new LZMA.Decoder2();
  }
};

LZMA.LiteralDecoder.prototype.init = function () {
  var i = 1 << this._numPrevBits + this._numPosBits;
  while (i--) {
    this._coders[i].init();
  }
};

LZMA.LiteralDecoder.prototype.getDecoder = function (pos, prevByte) {
  return this._coders[((pos & this._posMask) << this._numPrevBits) + ((prevByte & 0xff) >>> 8 - this._numPrevBits)];
};

LZMA.Decoder = function () {
  this._outWindow = new LZMA.OutWindow();
  this._rangeDecoder = new LZMA.RangeDecoder();
  this._isMatchDecoders = [];
  this._isRepDecoders = [];
  this._isRepG0Decoders = [];
  this._isRepG1Decoders = [];
  this._isRepG2Decoders = [];
  this._isRep0LongDecoders = [];
  this._posSlotDecoder = [];
  this._posDecoders = [];
  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);
  this._lenDecoder = new LZMA.LenDecoder();
  this._repLenDecoder = new LZMA.LenDecoder();
  this._literalDecoder = new LZMA.LiteralDecoder();
  this._dictionarySize = -1;
  this._dictionarySizeCheck = -1;

  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);
};

LZMA.Decoder.prototype.setDictionarySize = function (dictionarySize) {
  if (dictionarySize < 0) {
    return false;
  }
  if (this._dictionarySize !== dictionarySize) {
    this._dictionarySize = dictionarySize;
    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);
    this._outWindow.create(Math.max(this._dictionarySizeCheck, 4096));
  }
  return true;
};

LZMA.Decoder.prototype.setLcLpPb = function (lc, lp, pb) {
  var numPosStates = 1 << pb;

  if (lc > 8 || lp > 4 || pb > 4) {
    return false;
  }

  this._literalDecoder.create(lp, lc);

  this._lenDecoder.create(numPosStates);
  this._repLenDecoder.create(numPosStates);
  this._posStateMask = numPosStates - 1;

  return true;
};

LZMA.Decoder.prototype.init = function () {
  var i = 4;

  this._outWindow.init(false);

  LZMA.initBitModels(this._isMatchDecoders, 192);
  LZMA.initBitModels(this._isRep0LongDecoders, 192);
  LZMA.initBitModels(this._isRepDecoders, 12);
  LZMA.initBitModels(this._isRepG0Decoders, 12);
  LZMA.initBitModels(this._isRepG1Decoders, 12);
  LZMA.initBitModels(this._isRepG2Decoders, 12);
  LZMA.initBitModels(this._posDecoders, 114);

  this._literalDecoder.init();

  while (i--) {
    this._posSlotDecoder[i].init();
  }

  this._lenDecoder.init();
  this._repLenDecoder.init();
  this._posAlignDecoder.init();
  this._rangeDecoder.init();
};

LZMA.Decoder.prototype.decode = function (inStream, outStream, outSize) {
  var state = 0,
      rep0 = 0,
      rep1 = 0,
      rep2 = 0,
      rep3 = 0,
      nowPos64 = 0,
      prevByte = 0,
      posState,
      decoder2,
      len,
      distance,
      posSlot,
      numDirectBits;

  this._rangeDecoder.setStream(inStream);
  this._outWindow.setStream(outStream);

  this.init();

  while (outSize < 0 || nowPos64 < outSize) {
    posState = nowPos64 & this._posStateMask;

    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0) {
      decoder2 = this._literalDecoder.getDecoder(nowPos64++, prevByte);

      if (state >= 7) {
        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0));
      } else {
        prevByte = decoder2.decodeNormal(this._rangeDecoder);
      }
      this._outWindow.putByte(prevByte);

      state = state < 4 ? 0 : state - (state < 10 ? 3 : 6);
    } else {
      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1) {
        len = 0;
        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0) {
          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0) {
            state = state < 7 ? 9 : 11;
            len = 1;
          }
        } else {
          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0) {
            distance = rep1;
          } else {
            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0) {
              distance = rep2;
            } else {
              distance = rep3;
              rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
        }
        if (len === 0) {
          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);
          state = state < 7 ? 8 : 11;
        }
      } else {
        rep3 = rep2;
        rep2 = rep1;
        rep1 = rep0;

        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);
        state = state < 7 ? 7 : 10;

        posSlot = this._posSlotDecoder[len <= 5 ? len - 2 : 3].decode(this._rangeDecoder);
        if (posSlot >= 4) {
          numDirectBits = (posSlot >> 1) - 1;
          rep0 = (2 | posSlot & 1) << numDirectBits;

          if (posSlot < 14) {
            rep0 += LZMA.reverseDecode2(this._posDecoders, rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);
          } else {
            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;
            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);
            if (rep0 < 0) {
              if (rep0 === -1) {
                break;
              }
              return false;
            }
          }
        } else {
          rep0 = posSlot;
        }
      }

      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck) {
        return false;
      }

      this._outWindow.copyBlock(rep0, len);
      nowPos64 += len;
      prevByte = this._outWindow.getByte(0);
    }
  }

  this._outWindow.flush();
  this._outWindow.releaseStream();
  this._rangeDecoder.releaseStream();

  return true;
};

LZMA.Decoder.prototype.setDecoderProperties = function (properties) {
  var value, lc, lp, pb, dictionarySize;

  if (properties.size < 5) {
    return false;
  }

  value = properties.readByte();
  lc = value % 9;
  value = ~~(value / 9);
  lp = value % 5;
  pb = ~~(value / 5);

  if (!this.setLcLpPb(lc, lp, pb)) {
    return false;
  }

  dictionarySize = properties.readByte();
  dictionarySize |= properties.readByte() << 8;
  dictionarySize |= properties.readByte() << 16;
  dictionarySize += properties.readByte() * 16777216;

  return this.setDictionarySize(dictionarySize);
};

LZMA.decompress = function (properties, inStream, outStream, outSize) {
  var decoder = new LZMA.Decoder();

  if (!decoder.setDecoderProperties(properties)) {
    throw 'Incorrect stream properties';
  }

  if (!decoder.decode(inStream, outStream, outSize)) {
    throw 'Error in data stream';
  }

  return true;
};

LZMA.decompressFile = function (inStream, outStream) {
  var decoder = new LZMA.Decoder(),
      outSize;

  if (!decoder.setDecoderProperties(inStream)) {
    throw 'Incorrect stream properties';
  }

  outSize = inStream.readByte();
  outSize |= inStream.readByte() << 8;
  outSize |= inStream.readByte() << 16;
  outSize += inStream.readByte() * 16777216;

  inStream.readByte();
  inStream.readByte();
  inStream.readByte();
  inStream.readByte();

  if (!decoder.decode(inStream, outStream, outSize)) {
    throw 'Error in data stream';
  }

  return true;
};

//export default LZMA;
module.exports = LZMA;

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// jshint unused:vars

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(38);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _arity = function _arity(n, fn) {
  // jshint unused:vars
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };
    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
};

var _isPlaceholder = function _isPlaceholder(a) {
  return a != null && (typeof a === 'undefined' ? 'undefined' : (0, _typeof3.default)(a)) === 'object' && a['@@functional/placeholder'] === true;
};

/**
     * Optimized internal one-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
var _curry1 = function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
};

/**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
var _curry2 = function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
          return fn(a, _b);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
};

/**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @param {Array} received An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
var _curryN = function _curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
  };
};

/**
     * Returns a curried equivalent of the provided function, with the specified
     * arity. The curried function has two unusual capabilities. First, its
     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`, the
     * following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      var sumArgs = (...args) => R.sum(args);
     *
     *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
var curryN = _curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }
  return _arity(length, _curryN(length, [], fn));
});

exports.default = curryN;

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__(47);

var _stringify2 = _interopRequireDefault(_stringify);

var _apiBase = __webpack_require__(254);

var _apiBase2 = _interopRequireDefault(_apiBase);

var _opentype = __webpack_require__(210);

var opentype = _interopRequireWildcard(_opentype);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fetchNext(url, urls, success, failure, _ref) {
  var contentType = _ref.contentType,
      method = _ref.method,
      body = _ref.body,
      onReadyStateChange = _ref.onReadyStateChange,
      withCredentials = _ref.withCredentials,
      responseURL = _ref.responseURL;

  function tryNext(err) {
    if (urls.length) {
      return fetchNext(urls[0], urls.slice(1), success, failure, {
        contentType: contentType,
        method: method,
        body: body
      });
    } else {
      var errorResponse = {
        status: err.status,
        err: err,
        message: err.message
      };
      if (contentType === 'json') {
        try {
          errorResponse.body = JSON.parse(err.response);
        } catch (e) {}
      }
      failure(errorResponse);
    }
  }

  if (contentType === 'img') {
    var img = new Image();
    img.crossOrigin = 'anonymous'; // don't send cookies, but do send Origin: header
    img.addEventListener('load', function (e) {
      success(img);
    });
    img.addEventListener('error', tryNext);
    img.src = url; //s.shift();
  } else if (contentType === 'font') {
    opentype.load(url, function (err, font) {
      if (err) return failure(err);
      success(font);
    });
  } else if (contentType === 'external') {
    // This will need to use JSONP in some fashion (either dynamic function,
    // or some sort of global plugin namespace in order to work, since
    // CORS prevents us from just loading the file via xhr
    throw new Error('External Script support not allowed in the browser');
  } else {
    var request = new XMLHttpRequest();
    var requestMethod = method || 'GET';
    request.withCredentials = withCredentials || requestMethod !== 'GET';
    request.open(requestMethod, url, true);
    if (body && !(body instanceof FormData)) {
      request.setRequestHeader('Content-Type', 'application/json');
      if (typeof body !== 'string') body = (0, _stringify2.default)(body);
    }

    if (contentType === 'binary') request.responseType = 'arraybuffer';
    if (onReadyStateChange) {
      request.onreadystatechange = function () {
        onReadyStateChange(request);
      };
    }
    request.onload = function (xhr) {
      var response = request.response;

      if (request.status >= 200 && request.status < 400 || request.status === 0 && request.response // file: url
      ) {
          if (contentType === 'json') response = JSON.parse(response);
          success(response);
          if (responseURL && request.responseURL) responseURL(request.responseURL);
        } else {
        tryNext(request);
      }
    };

    request.onerror = tryNext;
    request.send(body);
  }
}

var callApi = (0, _apiBase2.default)(fetchNext);

exports.default = callApi;

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.default = bindActionCreatorsAndSelectors;

var _mapObjIndexed = __webpack_require__(106);

var _mapObjIndexed2 = _interopRequireDefault(_mapObjIndexed);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function bindActionCreators(dispatch, actionCreators) {
  return (0, _mapObjIndexed2.default)(function (actionCreator) {
    return function () {
      return dispatch(actionCreator.apply(undefined, arguments));
    };
  }, actionCreators);
}

function bindSelectors(store, selectors) {
  return (0, _mapObjIndexed2.default)(function (selector) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return selector.apply(undefined, [store].concat(args));
    };
  }, selectors);
}

/**
 * Iterate over modules,
 */
function bindActionCreatorsAndSelectors(store, modules) {
  return (0, _mapObjIndexed2.default)(function (module, moduleName) {
    return (0, _assign2.default)({}, bindActionCreators(store.dispatch, module.actions), bindSelectors(store, module.selectors));
  }, modules);
}

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(4);

var _keys2 = _interopRequireDefault(_keys);

exports.default = function (reducers) {
  var keys = (0, _keys2.default)(reducers);

  var defaultState = keys.reduce(function (state, key) {
    return state.set(key, reducers[key]());
  }, (0, _immutable.Map)());

  return function reducer() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;
    var action = arguments[1];
    var createEvent = arguments[2];
    var trackEvent = arguments[3];

    return keys.reduce(function (state, key) {
      var previousStateForKey = state.get(key);
      var nextStateForKey = reducers[key](previousStateForKey, action, state, createEvent, trackEvent);
      if (false) {
        if (!nextStateForKey) {
          throw new Error('Reducer: ' + key + ' failed to return state');
        }
      }

      return (0, _immutable.is)(previousStateForKey, nextStateForKey) ? state : state.set(key, nextStateForKey);
    }, state);
  };
};

var _immutable = __webpack_require__(32);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildStore;

var _createReducer = __webpack_require__(492);

var _createReducer2 = _interopRequireDefault(_createReducer);

var _createStore = __webpack_require__(128);

var _createStore2 = _interopRequireDefault(_createStore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildStore(reducers, middleware) {
  var reducer = (0, _createReducer2.default)(reducers);
  var store = (0, _createStore2.default)(reducer);
  store.dispatch = middleware(store);
  return store;
}

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(38);

var _typeof3 = _interopRequireDefault(_typeof2);

exports.default = isPromise;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isPromise(value) {
  if (value !== null && (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object') {
    return typeof value.then === 'function';
  }
}

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withFilter = withFilter;
exports.toJSON = toJSON;
exports.fromJSON = fromJSON;

var _transitJs = __webpack_require__(698);

var _transitJs2 = _interopRequireDefault(_transitJs);

var _immutable = __webpack_require__(32);

var _immutable2 = _interopRequireDefault(_immutable);

var _atob = __webpack_require__(319);

var _atob2 = _interopRequireDefault(_atob);

var _btoa = __webpack_require__(507);

var _btoa2 = _interopRequireDefault(_btoa);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Modified from:
// https://github.com/thomasboyt/transit-immutable-js/blob/records-support/index.js

// With changes:
//  * Records can't simply be serialized with 'toJS', since
//    records may contain other composite types.
//  * Serialize with array for efficiency.
//  * Build records into an object first instead of using 'asMutable',
//    due to weird bug with 'id' containing records.

function createReader() {
  return _transitJs2.default.reader('json', {
    mapBuilder: {
      init: function init() {
        return {};
      },

      add: function add(m, k, v) {
        m[k] = v;
        return m;
      },

      finalize: function finalize(m) {
        return m;
      }
    },
    handlers: {
      iM: function iM(v) {
        var o = {};
        for (var i = 0; i < v.length; i += 2) {
          o[v[i]] = v[i + 1];
        }

        return new _immutable2.default.Map(o);
      },

      iL: function iL(v) {
        return _immutable2.default.List(v);
      },

      f32: function f32(v) {
        var str = (0, _atob2.default)(v);
        var len = str.length;
        var bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
          bytes[i] = str.charCodeAt(i);
        }
        return new Float32Array(bytes.buffer);
      }
    }
  });
}

function withFilter(predicate) {
  var filteredWriter = createWriter(predicate, []);
  return {
    toJSON: function toJSON(data) {
      return filteredWriter.write(data);
    },

    fromJSON: fromJSON
  };
}

function createWriter(predicate) {
  var handlers = _transitJs2.default.map([_immutable2.default.Map, _transitJs2.default.makeWriteHandler({
    tag: function tag() {
      return 'iM';
    },

    rep: function rep(m) {
      var i = 0,
          a = new Array(2 * m.size);
      if (predicate) {
        m = m.filter(predicate);
      }

      m.forEach(function (v, k) {
        a[i++] = k;
        a[i++] = v;
      });

      return a;
    }
  }), _immutable2.default.List, _transitJs2.default.makeWriteHandler({
    tag: function tag() {
      return 'iL';
    },

    rep: function rep(v) {
      if (predicate) {
        v = v.filter(predicate);
      }

      return v.toArray();
    }
  }), Function, _transitJs2.default.makeWriteHandler({
    tag: function tag() {
      return '_';
    },

    rep: function rep() {
      return null;
    }
  }), Float32Array, _transitJs2.default.makeWriteHandler({
    tag: function tag() {
      return 'f32';
    },

    rep: function rep(v) {
      var binary = '';
      var bytes = new Uint8Array(v.buffer);
      var len = bytes.byteLength;
      for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return (0, _btoa2.default)(binary);
    }
  })]);

  return _transitJs2.default.writer('json', {
    handlers: handlers
  });
}

var reader = createReader([]);
var writer = createWriter(false, []);

function toJSON(data) {
  return writer.write(data);
}

function fromJSON(data) {
  return reader.read(data);
}

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(2);

var _assign2 = _interopRequireDefault(_assign);

exports.lzmaDecompressor = lzmaDecompressor;

var _runtimeInfo = __webpack_require__(56);

var _runtimeInfo2 = _interopRequireDefault(_runtimeInfo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LZMA = __webpack_require__(488);

var LZMARaw = '\n//From Repository: https://github.com/jcmellado/js-lzma\n/*\nCopyright (c) 2011 Juan Mellado\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/*\nReferences:\n- "LZMA SDK" by Igor Pavlov\n  http://www.7-zip.org/sdk.html\n*/\n\nvar LZMA = LZMA || {};\n\nLZMA.OutWindow = function(){\n  this._windowSize = 0;\n};\n\nLZMA.OutWindow.prototype.create = function(windowSize){\n  if ( (!this._buffer) || (this._windowSize !== windowSize) ){\n    this._buffer = [];\n  }\n  this._windowSize = windowSize;\n  this._pos = 0;\n  this._streamPos = 0;\n};\n\nLZMA.OutWindow.prototype.flush = function(){\n  var size = this._pos - this._streamPos;\n  if (size !== 0){\n    while(size --){\n      this._stream.writeByte(this._buffer[this._streamPos ++]);\n    }\n    if (this._pos >= this._windowSize){\n      this._pos = 0;\n    }\n    this._streamPos = this._pos;\n  }\n};\n\nLZMA.OutWindow.prototype.releaseStream = function(){\n  this.flush();\n  this._stream = null;\n};\n\nLZMA.OutWindow.prototype.setStream = function(stream){\n  this.releaseStream();\n  this._stream = stream;\n};\n\nLZMA.OutWindow.prototype.init = function(solid){\n  if (!solid){\n    this._streamPos = 0;\n    this._pos = 0;\n  }\n};\n\nLZMA.OutWindow.prototype.copyBlock = function(distance, len){\n  var pos = this._pos - distance - 1;\n  if (pos < 0){\n    pos += this._windowSize;\n  }\n  while(len --){\n    if (pos >= this._windowSize){\n      pos = 0;\n    }\n    this._buffer[this._pos ++] = this._buffer[pos ++];\n    if (this._pos >= this._windowSize){\n      this.flush();\n    }\n  }\n};\n\nLZMA.OutWindow.prototype.putByte = function(b){\n  this._buffer[this._pos ++] = b;\n  if (this._pos >= this._windowSize){\n    this.flush();\n  }\n};\n\nLZMA.OutWindow.prototype.getByte = function(distance){\n  var pos = this._pos - distance - 1;\n  if (pos < 0){\n    pos += this._windowSize;\n  }\n  return this._buffer[pos];\n};\n\nLZMA.RangeDecoder = function(){\n};\n\nLZMA.RangeDecoder.prototype.setStream = function(stream){\n  this._stream = stream;\n};\n\nLZMA.RangeDecoder.prototype.releaseStream = function(){\n  this._stream = null;\n};\n\nLZMA.RangeDecoder.prototype.init = function(){\n  var i = 5;\n\n  this._code = 0;\n  this._range = -1;\n\n  while(i --){\n    this._code = (this._code << 8) | this._stream.readByte();\n  }\n};\n\nLZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){\n  var result = 0, i = numTotalBits, t;\n\n  while(i --){\n    this._range >>>= 1;\n    t = (this._code - this._range) >>> 31;\n    this._code -= this._range & (t - 1);\n    result = (result << 1) | (1 - t);\n\n    if ( (this._range & 0xff000000) === 0){\n      this._code = (this._code << 8) | this._stream.readByte();\n      this._range <<= 8;\n    }\n  }\n\n  return result;\n};\n\nLZMA.RangeDecoder.prototype.decodeBit = function(probs, index){\n  var prob = probs[index],\n      newBound = (this._range >>> 11) * prob;\n\n  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){\n    this._range = newBound;\n    probs[index] += (2048 - prob) >>> 5;\n    if ( (this._range & 0xff000000) === 0){\n      this._code = (this._code << 8) | this._stream.readByte();\n      this._range <<= 8;\n    }\n    return 0;\n  }\n\n  this._range -= newBound;\n  this._code -= newBound;\n  probs[index] -= prob >>> 5;\n  if ( (this._range & 0xff000000) === 0){\n    this._code = (this._code << 8) | this._stream.readByte();\n    this._range <<= 8;\n  }\n  return 1;\n};\n\nLZMA.initBitModels = function(probs, len){\n  while(len --){\n    probs[len] = 1024;\n  }\n};\n\nLZMA.BitTreeDecoder = function(numBitLevels){\n  this._models = [];\n  this._numBitLevels = numBitLevels;\n};\n\nLZMA.BitTreeDecoder.prototype.init = function(){\n  LZMA.initBitModels(this._models, 1 << this._numBitLevels);\n};\n\nLZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){\n  var m = 1, i = this._numBitLevels;\n\n  while(i --){\n    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);\n  }\n  return m - (1 << this._numBitLevels);\n};\n\nLZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){\n  var m = 1, symbol = 0, i = 0, bit;\n\n  for (; i < this._numBitLevels; ++ i){\n    bit = rangeDecoder.decodeBit(this._models, m);\n    m = (m << 1) | bit;\n    symbol |= bit << i;\n  }\n  return symbol;\n};\n\nLZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){\n  var m = 1, symbol = 0, i = 0, bit;\n\n  for (; i < numBitLevels; ++ i){\n    bit = rangeDecoder.decodeBit(models, startIndex + m);\n    m = (m << 1) | bit;\n    symbol |= bit << i;\n  }\n  return symbol;\n};\n\nLZMA.LenDecoder = function(){\n  this._choice = [];\n  this._lowCoder = [];\n  this._midCoder = [];\n  this._highCoder = new LZMA.BitTreeDecoder(8);\n  this._numPosStates = 0;\n};\n\nLZMA.LenDecoder.prototype.create = function(numPosStates){\n  for (; this._numPosStates < numPosStates; ++ this._numPosStates){\n    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n  }\n};\n\nLZMA.LenDecoder.prototype.init = function(){\n  var i = this._numPosStates;\n  LZMA.initBitModels(this._choice, 2);\n  while(i --){\n    this._lowCoder[i].init();\n    this._midCoder[i].init();\n  }\n  this._highCoder.init();\n};\n\nLZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){\n  if (rangeDecoder.decodeBit(this._choice, 0) === 0){\n    return this._lowCoder[posState].decode(rangeDecoder);\n  }\n  if (rangeDecoder.decodeBit(this._choice, 1) === 0){\n    return 8 + this._midCoder[posState].decode(rangeDecoder);\n  }\n  return 16 + this._highCoder.decode(rangeDecoder);\n};\n\nLZMA.Decoder2 = function(){\n  this._decoders = [];\n};\n\nLZMA.Decoder2.prototype.init = function(){\n  LZMA.initBitModels(this._decoders, 0x300);\n};\n\nLZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){\n  var symbol = 1;\n\n  do{\n    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n  }while(symbol < 0x100);\n\n  return symbol & 0xff;\n};\n\nLZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){\n  var symbol = 1, matchBit, bit;\n\n  do{\n    matchBit = (matchByte >> 7) & 1;\n    matchByte <<= 1;\n    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);\n    symbol = (symbol << 1) | bit;\n    if (matchBit !== bit){\n      while(symbol < 0x100){\n        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n      }\n      break;\n    }\n  }while(symbol < 0x100);\n\n  return symbol & 0xff;\n};\n\nLZMA.LiteralDecoder = function(){\n};\n\nLZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){\n  var i;\n\n  if (this._coders\n    && (this._numPrevBits === numPrevBits)\n    && (this._numPosBits === numPosBits) ){\n    return;\n  }\n  this._numPosBits = numPosBits;\n  this._posMask = (1 << numPosBits) - 1;\n  this._numPrevBits = numPrevBits;\n\n  this._coders = [];\n\n  i = 1 << (this._numPrevBits + this._numPosBits);\n  while(i --){\n    this._coders[i] = new LZMA.Decoder2();\n  }\n};\n\nLZMA.LiteralDecoder.prototype.init = function(){\n  var i = 1 << (this._numPrevBits + this._numPosBits);\n  while(i --){\n    this._coders[i].init();\n  }\n};\n\nLZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){\n  return this._coders[( (pos & this._posMask) << this._numPrevBits)\n    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];\n};\n\nLZMA.Decoder = function(){\n  this._outWindow = new LZMA.OutWindow();\n  this._rangeDecoder = new LZMA.RangeDecoder();\n  this._isMatchDecoders = [];\n  this._isRepDecoders = [];\n  this._isRepG0Decoders = [];\n  this._isRepG1Decoders = [];\n  this._isRepG2Decoders = [];\n  this._isRep0LongDecoders = [];\n  this._posSlotDecoder = [];\n  this._posDecoders = [];\n  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);\n  this._lenDecoder = new LZMA.LenDecoder();\n  this._repLenDecoder = new LZMA.LenDecoder();\n  this._literalDecoder = new LZMA.LiteralDecoder();\n  this._dictionarySize = -1;\n  this._dictionarySizeCheck = -1;\n\n  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);\n  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);\n};\n\nLZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){\n  if (dictionarySize < 0){\n    return false;\n  }\n  if (this._dictionarySize !== dictionarySize){\n    this._dictionarySize = dictionarySize;\n    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);\n    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );\n  }\n  return true;\n};\n\nLZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){\n  var numPosStates = 1 << pb;\n\n  if (lc > 8 || lp > 4 || pb > 4){\n    return false;\n  }\n\n  this._literalDecoder.create(lp, lc);\n\n  this._lenDecoder.create(numPosStates);\n  this._repLenDecoder.create(numPosStates);\n  this._posStateMask = numPosStates - 1;\n\n  return true;\n};\n\nLZMA.Decoder.prototype.init = function(){\n  var i = 4;\n\n  this._outWindow.init(false);\n\n  LZMA.initBitModels(this._isMatchDecoders, 192);\n  LZMA.initBitModels(this._isRep0LongDecoders, 192);\n  LZMA.initBitModels(this._isRepDecoders, 12);\n  LZMA.initBitModels(this._isRepG0Decoders, 12);\n  LZMA.initBitModels(this._isRepG1Decoders, 12);\n  LZMA.initBitModels(this._isRepG2Decoders, 12);\n  LZMA.initBitModels(this._posDecoders, 114);\n\n  this._literalDecoder.init();\n\n  while(i --){\n    this._posSlotDecoder[i].init();\n  }\n\n  this._lenDecoder.init();\n  this._repLenDecoder.init();\n  this._posAlignDecoder.init();\n  this._rangeDecoder.init();\n};\n\nLZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){\n  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,\n      posState, decoder2, len, distance, posSlot, numDirectBits;\n\n  this._rangeDecoder.setStream(inStream);\n  this._outWindow.setStream(outStream);\n\n  this.init();\n\n  while(outSize < 0 || nowPos64 < outSize){\n    posState = nowPos64 & this._posStateMask;\n\n    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){\n      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);\n\n      if (state >= 7){\n        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );\n      }else{\n        prevByte = decoder2.decodeNormal(this._rangeDecoder);\n      }\n      this._outWindow.putByte(prevByte);\n\n      state = state < 4? 0: state - (state < 10? 3: 6);\n\n    }else{\n\n      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){\n        len = 0;\n        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){\n          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){\n            state = state < 7? 9: 11;\n            len = 1;\n          }\n        }else{\n          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){\n            distance = rep1;\n          }else{\n            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){\n              distance = rep2;\n            }else{\n              distance = rep3;\n              rep3 = rep2;\n            }\n            rep2 = rep1;\n          }\n          rep1 = rep0;\n          rep0 = distance;\n        }\n        if (len === 0){\n          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);\n          state = state < 7? 8: 11;\n        }\n      }else{\n        rep3 = rep2;\n        rep2 = rep1;\n        rep1 = rep0;\n\n        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);\n        state = state < 7? 7: 10;\n\n        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);\n        if (posSlot >= 4){\n\n          numDirectBits = (posSlot >> 1) - 1;\n          rep0 = (2 | (posSlot & 1) ) << numDirectBits;\n\n          if (posSlot < 14){\n            rep0 += LZMA.reverseDecode2(this._posDecoders,\n                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);\n          }else{\n            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;\n            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);\n            if (rep0 < 0){\n              if (rep0 === -1){\n                break;\n              }\n              return false;\n            }\n          }\n        }else{\n          rep0 = posSlot;\n        }\n      }\n\n      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){\n        return false;\n      }\n\n      this._outWindow.copyBlock(rep0, len);\n      nowPos64 += len;\n      prevByte = this._outWindow.getByte(0);\n    }\n  }\n\n  this._outWindow.flush();\n  this._outWindow.releaseStream();\n  this._rangeDecoder.releaseStream();\n\n  return true;\n};\n\nLZMA.Decoder.prototype.setDecoderProperties = function(properties){\n  var value, lc, lp, pb, dictionarySize;\n\n  if (properties.size < 5){\n    return false;\n  }\n\n  value = properties.readByte();\n  lc = value % 9;\n  value = ~~(value / 9);\n  lp = value % 5;\n  pb = ~~(value / 5);\n\n  if ( !this.setLcLpPb(lc, lp, pb) ){\n    return false;\n  }\n\n  dictionarySize = properties.readByte();\n  dictionarySize |= properties.readByte() << 8;\n  dictionarySize |= properties.readByte() << 16;\n  dictionarySize += properties.readByte() * 16777216;\n\n  return this.setDictionarySize(dictionarySize);\n};\n\nLZMA.decompress = function(properties, inStream, outStream, outSize){\n  var decoder = new LZMA.Decoder();\n\n  if ( !decoder.setDecoderProperties(properties) ){\n    throw "Incorrect stream properties";\n  }\n\n  if ( !decoder.decode(inStream, outStream, outSize) ){\n    throw "Error in data stream";\n  }\n\n  return true;\n};\n\nLZMA.decompressFile = function(inStream, outStream){\n  var decoder = new LZMA.Decoder(), outSize;\n\n  if ( !decoder.setDecoderProperties(inStream) ){\n    throw "Incorrect stream properties";\n  }\n\n  outSize = inStream.readByte();\n  outSize |= inStream.readByte() << 8;\n  outSize |= inStream.readByte() << 16;\n  outSize += inStream.readByte() * 16777216;\n\n  inStream.readByte();\n  inStream.readByte();\n  inStream.readByte();\n  inStream.readByte();\n\n  if ( !decoder.decode(inStream, outStream, outSize) ){\n    throw "Error in data stream";\n  }\n\n  return true;\n};\n\n//export default LZMA;\n\n\n';

var LZMAWorker = '\nfunction decompressBuffer(buffer){\n  var inStream = {\n    data: new Uint8Array(buffer),\n    offset: 0,\n    readByte: function() {\n      return this.data[this.offset++]\n    },\n  }\n  var outStream = {\n    data:[],\n    offset: 0,\n    writeByte: function(val) {\n      this.data[this.offset++] = val\n    },\n  }\n  LZMA.decompressFile(inStream, outStream);\n  var uintGeomArray = new Uint8Array(outStream.data);\n  return uintGeomArray.buffer;\n}\n\nself.onmessage = function( event ) {\n  if(event.data===\'CLOSE\') {\n    self.close();\n    return;\n  }\n\n  try {\n    var decompBuffer = decompressBuffer(event.data.buffer);\n    self.postMessage({type:\'SUCCESS\', buffer:decompBuffer, meta:event.data.meta});\n  } catch(e) {\n    self.postMessage({type:\'FAILURE\', error:e, meta:event.data.meta});\n  }\n\n};\n';
var workerQueue = [];
var workerPool = [];

var workerBlob = void 0;
try {
  workerBlob = new Blob([LZMARaw, LZMAWorker], {
    type: 'application/javascript'
  });
} catch (e) {
  // Backwards-compatibility
  if (true) {
    window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
    workerBlob = new BlobBuilder();
    workerBlob.append(LZMARaw);
    workerBlob.append(LZMAWorker);
    workerBlob = workerBlob.getBlob();
  }
}

var workerLimit =  true ? Math.max(window.navigator.hardwareConcurrency - 1, 1) : 0;

function requeueWorker(idx) {
  if (workerQueue.length > 0) {
    var toBeDecompressed = workerQueue.shift();
    toBeDecompressed.meta.idx = idx;
    workerPool[idx].postMessage(toBeDecompressed);
  } else {
    workerPool[idx].postMessage('CLOSE');
    delete workerPool[idx];
  }
}

function lzmaDecompressor(response, meta, onSuccessEnd, onFailure) {
  var freeWorkerIndex = -1;
  var numWorkers = workerPool.length;

  for (var i = 0; i < numWorkers; i++) {
    if (!workerPool[i]) {
      freeWorkerIndex = i;
      break;
    }
  }

  if (workerQueue.length > 0 || typeof Worker !== 'undefined' && Worker && numWorkers >= workerLimit && freeWorkerIndex === -1) {
    workerQueue.push({
      buffer: response,
      meta: meta
    });
  } else {
    if (typeof Worker !== 'undefined' && Worker && _runtimeInfo2.default.name !== 'safari') {
      var lzmaWorker = new Worker(URL.createObjectURL(workerBlob));
      var index = freeWorkerIndex === -1 ? workerPool.length : freeWorkerIndex;
      lzmaWorker.onmessage = function (event) {
        if (event.data.type === 'SUCCESS') {
          onSuccessEnd(event.data.buffer, event.data.meta);
          requeueWorker(event.data.meta.idx);
        } else {
          onFailure(event.data.error, event.data.meta);
        }
      };

      lzmaWorker.postMessage({
        buffer: response,
        meta: (0, _assign2.default)({}, meta, { idx: index })
      });
      workerPool[index] = lzmaWorker;
    } else {
      var inStream = {
        data: new Uint8Array(response),
        offset: 0,
        readByte: function readByte() {
          return this.data[this.offset++];
        }
      };
      var outStream = {
        data: [],
        offset: 0,
        writeByte: function writeByte(val) {
          this.data[this.offset++] = val;
        }
      };
      try {
        LZMA.decompressFile(inStream, outStream);
        var uintGeomArray = new Uint8Array(outStream.data);
        onSuccessEnd(uintGeomArray.buffer, meta);
      } catch (e) {
        onFailure(e);
      }
    }
  }
}

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(508), __esModule: true };

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(510), __esModule: true };

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(513), __esModule: true };

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(518), __esModule: true };

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(526), __esModule: true };

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(529), __esModule: true };

/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(530), __esModule: true };

/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(531), __esModule: true };

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(532), __esModule: true };

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {(function () {
  "use strict";

  function btoa(str) {
    var buffer
      ;

    if (str instanceof Buffer) {
      buffer = str;
    } else {
      buffer = new Buffer(str.toString(), 'binary');
    }

    return buffer.toString('base64');
  }

  module.exports = btoa;
}());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(99).Buffer))

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(84);
__webpack_require__(554);
module.exports = __webpack_require__(9).Array.from;


/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(85);
__webpack_require__(84);
module.exports = __webpack_require__(552);


/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(85);
__webpack_require__(84);
module.exports = __webpack_require__(553);


/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(9);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(139);
__webpack_require__(84);
__webpack_require__(85);
__webpack_require__(556);
__webpack_require__(576);
__webpack_require__(575);
__webpack_require__(574);
module.exports = __webpack_require__(9).Map;


/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(557);
module.exports = __webpack_require__(9).Math.log2;


/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(558);
module.exports = __webpack_require__(9).Math.sign;


/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(559);
module.exports = __webpack_require__(9).Math.trunc;


/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(560);
module.exports = Math.pow(2, -52);


/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(561);
module.exports = __webpack_require__(9).Number.isInteger;


/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(562);
module.exports = 0x1fffffffffffff;


/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(563);
module.exports = __webpack_require__(9).Object.assign;


/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(564);
var $Object = __webpack_require__(9).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(565);
var $Object = __webpack_require__(9).Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};


/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(566);
var $Object = __webpack_require__(9).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(567);
module.exports = __webpack_require__(9).Object.freeze;


/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(568);
module.exports = __webpack_require__(9).Object.getPrototypeOf;


/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(569);
module.exports = __webpack_require__(9).Object.keys;


/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(570);
module.exports = __webpack_require__(9).Object.preventExtensions;


/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(577);
module.exports = __webpack_require__(9).Object.values;


/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(139);
__webpack_require__(84);
__webpack_require__(85);
__webpack_require__(571);
__webpack_require__(578);
__webpack_require__(579);
module.exports = __webpack_require__(9).Promise;


/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(584);
module.exports = __webpack_require__(9).setImmediate;


/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(572);
__webpack_require__(139);
__webpack_require__(580);
__webpack_require__(581);
module.exports = __webpack_require__(9).Symbol;


/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(84);
__webpack_require__(85);
module.exports = __webpack_require__(182).f('iterator');


/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(139);
__webpack_require__(85);
__webpack_require__(573);
__webpack_require__(583);
__webpack_require__(582);
module.exports = __webpack_require__(9).WeakMap;


/***/ }),
/* 533 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(80);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(65);
var toLength = __webpack_require__(136);
var toAbsoluteIndex = __webpack_require__(551);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(27);
var isArray = __webpack_require__(266);
var SPECIES = __webpack_require__(25)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(536);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(41).f;
var create = __webpack_require__(134);
var redefineAll = __webpack_require__(135);
var ctx = __webpack_require__(57);
var anInstance = __webpack_require__(131);
var forOf = __webpack_require__(80);
var $iterDefine = __webpack_require__(172);
var step = __webpack_require__(269);
var setSpecies = __webpack_require__(279);
var DESCRIPTORS = __webpack_require__(40);
var fastKey = __webpack_require__(72).fastKey;
var validate = __webpack_require__(138);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(132);
var from = __webpack_require__(534);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(135);
var getWeak = __webpack_require__(72).getWeak;
var anObject = __webpack_require__(44);
var isObject = __webpack_require__(27);
var anInstance = __webpack_require__(131);
var forOf = __webpack_require__(80);
var createArrayMethod = __webpack_require__(167);
var $has = __webpack_require__(61);
var validate = __webpack_require__(138);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(41);
var createDesc = __webpack_require__(110);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(82);
var gOPS = __webpack_require__(174);
var pIE = __webpack_require__(109);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 543 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(27);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(134);
var descriptor = __webpack_require__(110);
var setToStringTag = __webpack_require__(111);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(62)(IteratorPrototype, __webpack_require__(25)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 546 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(29);
var macrotask = __webpack_require__(178).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(108)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(65);
var gOPN = __webpack_require__(272).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(82);
var toIObject = __webpack_require__(65);
var isEnum = __webpack_require__(109).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(179);
var defined = __webpack_require__(168);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(179);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(44);
var get = __webpack_require__(183);
module.exports = __webpack_require__(9).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(132);
var ITERATOR = __webpack_require__(25)('iterator');
var Iterators = __webpack_require__(81);
module.exports = __webpack_require__(9).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(57);
var $export = __webpack_require__(11);
var toObject = __webpack_require__(83);
var call = __webpack_require__(267);
var isArrayIter = __webpack_require__(265);
var toLength = __webpack_require__(136);
var createProperty = __webpack_require__(541);
var getIterFn = __webpack_require__(183);

$export($export.S + $export.F * !__webpack_require__(268)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(533);
var step = __webpack_require__(269);
var Iterators = __webpack_require__(81);
var toIObject = __webpack_require__(65);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(172)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(538);
var validate = __webpack_require__(138);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(262)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(11);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(11);

$export($export.S, 'Math', { sign: __webpack_require__(546) });


/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(11);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(11);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(11);

$export($export.S, 'Number', { isInteger: __webpack_require__(544) });


/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(11);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(11);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(270) });


/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(11);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(134) });


/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(11);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(40), 'Object', { defineProperties: __webpack_require__(271) });


/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(11);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(40), 'Object', { defineProperty: __webpack_require__(41).f });


/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(27);
var meta = __webpack_require__(72).onFreeze;

__webpack_require__(120)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(83);
var $getPrototypeOf = __webpack_require__(273);

__webpack_require__(120)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(83);
var $keys = __webpack_require__(82);

__webpack_require__(120)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(27);
var meta = __webpack_require__(72).onFreeze;

__webpack_require__(120)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});


/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(133);
var global = __webpack_require__(29);
var ctx = __webpack_require__(57);
var classof = __webpack_require__(132);
var $export = __webpack_require__(11);
var isObject = __webpack_require__(27);
var aFunction = __webpack_require__(107);
var anInstance = __webpack_require__(131);
var forOf = __webpack_require__(80);
var speciesConstructor = __webpack_require__(280);
var task = __webpack_require__(178).set;
var microtask = __webpack_require__(547)();
var newPromiseCapabilityModule = __webpack_require__(173);
var perform = __webpack_require__(275);
var promiseResolve = __webpack_require__(276);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(25)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(135)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(111)($Promise, PROMISE);
__webpack_require__(279)(PROMISE);
Wrapper = __webpack_require__(9)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(268)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(29);
var has = __webpack_require__(61);
var DESCRIPTORS = __webpack_require__(40);
var $export = __webpack_require__(11);
var redefine = __webpack_require__(175);
var META = __webpack_require__(72).KEY;
var $fails = __webpack_require__(60);
var shared = __webpack_require__(177);
var setToStringTag = __webpack_require__(111);
var uid = __webpack_require__(137);
var wks = __webpack_require__(25);
var wksExt = __webpack_require__(182);
var wksDefine = __webpack_require__(181);
var enumKeys = __webpack_require__(542);
var isArray = __webpack_require__(266);
var anObject = __webpack_require__(44);
var toIObject = __webpack_require__(65);
var toPrimitive = __webpack_require__(180);
var createDesc = __webpack_require__(110);
var _create = __webpack_require__(134);
var gOPNExt = __webpack_require__(548);
var $GOPD = __webpack_require__(318);
var $DP = __webpack_require__(41);
var $keys = __webpack_require__(82);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(272).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(109).f = $propertyIsEnumerable;
  __webpack_require__(174).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(133)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(62)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each = __webpack_require__(167)(0);
var redefine = __webpack_require__(175);
var meta = __webpack_require__(72);
var assign = __webpack_require__(270);
var weak = __webpack_require__(540);
var isObject = __webpack_require__(27);
var fails = __webpack_require__(60);
var validate = __webpack_require__(138);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(262)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(277)('Map');


/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(278)('Map');


/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(11);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(539)('Map') });


/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(11);
var $values = __webpack_require__(549)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(11);
var core = __webpack_require__(9);
var global = __webpack_require__(29);
var speciesConstructor = __webpack_require__(280);
var promiseResolve = __webpack_require__(276);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(11);
var newPromiseCapability = __webpack_require__(173);
var perform = __webpack_require__(275);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(181)('asyncIterator');


/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(181)('observable');


/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(277)('WeakMap');


/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(278)('WeakMap');


/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(11);
var $task = __webpack_require__(178);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(14);
var isArray = __webpack_require__(287);
var SPECIES = __webpack_require__(16)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(585);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(73);
var isObject = __webpack_require__(14);
var invoke = __webpack_require__(286);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(91);
var gOPS = __webpack_require__(144);
var pIE = __webpack_require__(118);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(12);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(14);
var setPrototypeOf = __webpack_require__(195).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(115);
var descriptor = __webpack_require__(75);
var setToStringTag = __webpack_require__(93);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(42)(IteratorPrototype, __webpack_require__(16)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(194);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(13);
var macrotask = __webpack_require__(200).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(88)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(26);
var anObject = __webpack_require__(12);
var getKeys = __webpack_require__(91);

module.exports = __webpack_require__(35) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(53);
var gOPN = __webpack_require__(116).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 596 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(12);
var isObject = __webpack_require__(14);
var newPromiseCapability = __webpack_require__(294);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 598 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(76);
var defined = __webpack_require__(74);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(13);
var core = __webpack_require__(113);
var LIBRARY = __webpack_require__(90);
var wksExt = __webpack_require__(303);
var defineProperty = __webpack_require__(26).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(1);

$export($export.P, 'Array', { copyWithin: __webpack_require__(281) });

__webpack_require__(86)('copyWithin');


/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(1);

$export($export.P, 'Array', { fill: __webpack_require__(184) });

__webpack_require__(86)('fill');


/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(1);
var $find = __webpack_require__(112)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(86)(KEY);


/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(1);
var $find = __webpack_require__(112)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(86)(KEY);


/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(52);
var $export = __webpack_require__(1);
var toObject = __webpack_require__(77);
var call = __webpack_require__(290);
var isArrayIter = __webpack_require__(192);
var toLength = __webpack_require__(30);
var createProperty = __webpack_require__(187);
var getIterFn = __webpack_require__(202);

$export($export.S + $export.F * !__webpack_require__(143)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(1);
var createProperty = __webpack_require__(187);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(21)(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(26).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(35) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(282);
var validate = __webpack_require__(95);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(140)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(1);
var log1p = __webpack_require__(293);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(1);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(1);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(1);
var sign = __webpack_require__(194);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(1);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(1);
var $expm1 = __webpack_require__(193);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', { fround: __webpack_require__(592) });


/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(1);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(1);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(21)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', { log1p: __webpack_require__(293) });


/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', { sign: __webpack_require__(194) });


/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(1);
var expm1 = __webpack_require__(193);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(21)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(1);
var expm1 = __webpack_require__(193);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(1);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(1);
var _isFinite = __webpack_require__(13).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(1);

$export($export.S, 'Number', { isInteger: __webpack_require__(288) });


/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(1);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(1);
var isInteger = __webpack_require__(288);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(1);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(1);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 633 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(1);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(295) });


/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(1);
$export($export.S, 'Object', { is: __webpack_require__(598) });


/***/ }),
/* 635 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(1);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(195).set });


/***/ }),
/* 636 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(90);
var global = __webpack_require__(13);
var ctx = __webpack_require__(52);
var classof = __webpack_require__(186);
var $export = __webpack_require__(1);
var isObject = __webpack_require__(14);
var aFunction = __webpack_require__(73);
var anInstance = __webpack_require__(87);
var forOf = __webpack_require__(142);
var speciesConstructor = __webpack_require__(198);
var task = __webpack_require__(200).set;
var microtask = __webpack_require__(593)();
var newPromiseCapabilityModule = __webpack_require__(294);
var perform = __webpack_require__(596);
var promiseResolve = __webpack_require__(597);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(16)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(92)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(93)($Promise, PROMISE);
__webpack_require__(145)(PROMISE);
Wrapper = __webpack_require__(113)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(143)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 637 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(1);
var aFunction = __webpack_require__(73);
var anObject = __webpack_require__(12);
var rApply = (__webpack_require__(13).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(21)(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),
/* 638 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(1);
var create = __webpack_require__(115);
var aFunction = __webpack_require__(73);
var anObject = __webpack_require__(12);
var isObject = __webpack_require__(14);
var fails = __webpack_require__(21);
var bind = __webpack_require__(587);
var rConstruct = (__webpack_require__(13).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(26);
var $export = __webpack_require__(1);
var anObject = __webpack_require__(12);
var toPrimitive = __webpack_require__(119);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(21)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 640 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(1);
var gOPD = __webpack_require__(63).f;
var anObject = __webpack_require__(12);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(63);
var $export = __webpack_require__(1);
var anObject = __webpack_require__(12);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(1);
var getProto = __webpack_require__(117);
var anObject = __webpack_require__(12);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),
/* 643 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(63);
var getPrototypeOf = __webpack_require__(117);
var has = __webpack_require__(36);
var $export = __webpack_require__(1);
var isObject = __webpack_require__(14);
var anObject = __webpack_require__(12);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(1);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),
/* 645 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(1);
var anObject = __webpack_require__(12);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),
/* 646 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(1);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(298) });


/***/ }),
/* 647 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(1);
var anObject = __webpack_require__(12);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 648 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(1);
var setProto = __webpack_require__(195);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 649 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(26);
var gOPD = __webpack_require__(63);
var getPrototypeOf = __webpack_require__(117);
var has = __webpack_require__(36);
var $export = __webpack_require__(1);
var createDesc = __webpack_require__(75);
var anObject = __webpack_require__(12);
var isObject = __webpack_require__(14);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 650 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(35) && /./g.flags != 'g') __webpack_require__(26).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(589)
});


/***/ }),
/* 651 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(141)('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});


/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(141)('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});


/***/ }),
/* 653 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(141)('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});


/***/ }),
/* 654 */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(141)('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = __webpack_require__(289);
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});


/***/ }),
/* 655 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(282);
var validate = __webpack_require__(95);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(140)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 656 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(1);
var $at = __webpack_require__(599)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 657 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(1);
var toLength = __webpack_require__(30);
var context = __webpack_require__(199);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(190)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),
/* 658 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var toAbsoluteIndex = __webpack_require__(94);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),
/* 659 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(1);
var context = __webpack_require__(199);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(190)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 660 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var toIObject = __webpack_require__(53);
var toLength = __webpack_require__(30);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),
/* 661 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(300)
});


/***/ }),
/* 662 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(1);
var toLength = __webpack_require__(30);
var context = __webpack_require__(199);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(190)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),
/* 663 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(13);
var has = __webpack_require__(36);
var DESCRIPTORS = __webpack_require__(35);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(64);
var META = __webpack_require__(114).KEY;
var $fails = __webpack_require__(21);
var shared = __webpack_require__(197);
var setToStringTag = __webpack_require__(93);
var uid = __webpack_require__(78);
var wks = __webpack_require__(16);
var wksExt = __webpack_require__(303);
var wksDefine = __webpack_require__(600);
var enumKeys = __webpack_require__(588);
var isArray = __webpack_require__(287);
var anObject = __webpack_require__(12);
var toIObject = __webpack_require__(53);
var toPrimitive = __webpack_require__(119);
var createDesc = __webpack_require__(75);
var _create = __webpack_require__(115);
var gOPNExt = __webpack_require__(595);
var $GOPD = __webpack_require__(63);
var $DP = __webpack_require__(26);
var $keys = __webpack_require__(91);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(116).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(118).f = $propertyIsEnumerable;
  __webpack_require__(144).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(90)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(42)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 664 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(1);
var $typed = __webpack_require__(201);
var buffer = __webpack_require__(302);
var anObject = __webpack_require__(12);
var toAbsoluteIndex = __webpack_require__(94);
var toLength = __webpack_require__(30);
var isObject = __webpack_require__(14);
var ArrayBuffer = __webpack_require__(13).ArrayBuffer;
var speciesConstructor = __webpack_require__(198);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(21)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(145)(ARRAY_BUFFER);


/***/ }),
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 666 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 667 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 668 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 669 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 670 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 671 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 672 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 673 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(54)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),
/* 674 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each = __webpack_require__(112)(0);
var redefine = __webpack_require__(64);
var meta = __webpack_require__(114);
var assign = __webpack_require__(295);
var weak = __webpack_require__(283);
var isObject = __webpack_require__(14);
var fails = __webpack_require__(21);
var validate = __webpack_require__(95);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(140)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 675 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(283);
var validate = __webpack_require__(95);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(140)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),
/* 676 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(1);
var $includes = __webpack_require__(185)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(86)('includes');


/***/ }),
/* 677 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(1);
var $entries = __webpack_require__(297)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),
/* 678 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(1);
var ownKeys = __webpack_require__(298);
var toIObject = __webpack_require__(53);
var gOPD = __webpack_require__(63);
var createProperty = __webpack_require__(187);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),
/* 679 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(1);
var $values = __webpack_require__(297)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),
/* 680 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(1);
var $pad = __webpack_require__(299);

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),
/* 681 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(1);
var $pad = __webpack_require__(299);

$export($export.P, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),
/* 682 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(203);
var getKeys = __webpack_require__(91);
var redefine = __webpack_require__(64);
var global = __webpack_require__(13);
var hide = __webpack_require__(42);
var Iterators = __webpack_require__(89);
var wks = __webpack_require__(16);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),
/* 683 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(1);
var $task = __webpack_require__(200);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),
/* 684 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(13);
var $export = __webpack_require__(1);
var navigator = global.navigator;
var slice = [].slice;
var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),
/* 685 */
/***/ (function(module, exports, __webpack_require__) {

var detectBrowser = __webpack_require__(686);

var agent;

if (typeof navigator !== 'undefined' && navigator) {
  agent = navigator.userAgent;
}

module.exports = detectBrowser(agent);


/***/ }),
/* 686 */
/***/ (function(module, exports) {

module.exports = function detectBrowser(userAgentString) {
  if (!userAgentString) return null;

  var browsers = [
    [ 'edge', /Edge\/([0-9\._]+)/ ],
    [ 'yandexbrowser', /YaBrowser\/([0-9\._]+)/ ],
    [ 'vivaldi', /Vivaldi\/([0-9\.]+)/ ],
    [ 'kakaotalk', /KAKAOTALK\s([0-9\.]+)/ ],
    [ 'chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/ ],
    [ 'crios', /CriOS\/([0-9\.]+)(:?\s|$)/ ],
    [ 'firefox', /Firefox\/([0-9\.]+)(?:\s|$)/ ],
    [ 'fxios', /FxiOS\/([0-9\.]+)/ ],
    [ 'opera', /Opera\/([0-9\.]+)(?:\s|$)/ ],
    [ 'opera', /OPR\/([0-9\.]+)(:?\s|$)$/ ],
    [ 'ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/ ],
    [ 'ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/ ],
    [ 'ie', /MSIE\s(7\.0)/ ],
    [ 'bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/ ],
    [ 'android', /Android\s([0-9\.]+)/ ],
    [ 'ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/ ],
    [ 'safari', /Version\/([0-9\._]+).*Safari/ ]
  ];

  return browsers.map(function (rule) {
      if (rule[1].test(userAgentString)) {
          var match = rule[1].exec(userAgentString);
          var version = match && match[1].split(/[._]/).slice(0,3);

          if (version && version.length < 3) {
              Array.prototype.push.apply(version, (version.length == 1) ? [0, 0] : [0]);
          }

          return {
              name: rule[0],
              version: version.join('.')
          };
      }
  }).filter(Boolean).shift();
};


/***/ }),
/* 687 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 688 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 689 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(146)))

/***/ }),
/* 690 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strictUriEncode = __webpack_require__(695);

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str) {
	if (typeof str !== 'string') {
		return {};
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return {};
	}

	return str.split('&').reduce(function (ret, param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		key = decodeURIComponent(key);

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		if (!ret.hasOwnProperty(key)) {
			ret[key] = val;
		} else if (Array.isArray(ret[key])) {
			ret[key].push(val);
		} else {
			ret[key] = [ret[key], val];
		}

		return ret;
	}, {});
};

exports.stringify = function (obj) {
	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return key;
		}

		if (Array.isArray(val)) {
			return val.slice().sort().map(function (val2) {
				return strictUriEncode(key) + '=' + strictUriEncode(val2);
			}).join('&');
		}

		return strictUriEncode(key) + '=' + strictUriEncode(val);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};


/***/ }),
/* 691 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))

/***/ }),
/* 692 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,r){if(true)module.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{var t=r();for(var n in t)("object"==typeof exports?exports:e)[n]=t[n]}}(this,function(){return function(e){function r(n){if(t[n])return t[n].exports;var o=t[n]={exports:{},id:n,loaded:!1};return e[n].call(o.exports,o,o.exports,r),o.loaded=!0,o.exports}var t={};return r.m=e,r.c=t,r.p="",r(0)}([function(e,r,t){e.exports=t(1)},function(e,r,t){"use strict";function n(){var e="undefined"==typeof JSON?{}:JSON;o.setupJSON(e)}var o=t(2),i=t(3);n();var a=window._rollbarConfig,s=a&&a.globalAlias||"Rollbar",u=window[s]&&"undefined"!=typeof window[s].shimId;!u&&a?o.wrapper.init(a):(window.Rollbar=o.wrapper,window.RollbarNotifier=i.Notifier),e.exports=o.wrapper},function(e,r,t){"use strict";function n(e,r,t){!t[4]&&window._rollbarWrappedError&&(t[4]=window._rollbarWrappedError,window._rollbarWrappedError=null),e.uncaughtError.apply(e,t),r&&r.apply(window,t)}function o(e,r){if(r.hasOwnProperty&&r.hasOwnProperty("addEventListener")){var t=r.addEventListener;r.addEventListener=function(r,n,o){t.call(this,r,e.wrap(n),o)};var n=r.removeEventListener;r.removeEventListener=function(e,r,t){n.call(this,e,r&&r._wrapped||r,t)}}}var i=t(3),a=t(8),s=i.Notifier;window._rollbarWrappedError=null;var u={};u.init=function(e,r){var t=new s(r);if(t.configure(e),e.captureUncaught){var i;r&&a.isType(r._rollbarOldOnError,"function")?i=r._rollbarOldOnError:window.onerror&&!window.onerror.belongsToShim&&(i=window.onerror),window.onerror=function(){var e=Array.prototype.slice.call(arguments,0);n(t,i,e)};var u,c,l=["EventTarget","Window","Node","ApplicationCache","AudioTrackList","ChannelMergerNode","CryptoOperation","EventSource","FileReader","HTMLUnknownElement","IDBDatabase","IDBRequest","IDBTransaction","KeyOperation","MediaController","MessagePort","ModalWindow","Notification","SVGElementInstance","Screen","TextTrack","TextTrackCue","TextTrackList","WebSocket","WebSocketWorker","Worker","XMLHttpRequest","XMLHttpRequestEventTarget","XMLHttpRequestUpload"];for(u=0;u<l.length;++u)c=l[u],window[c]&&window[c].prototype&&o(t,window[c].prototype)}return e.captureUnhandledRejections&&(r&&a.isType(r._unhandledRejectionHandler,"function")&&window.removeEventListener("unhandledrejection",r._unhandledRejectionHandler),t._unhandledRejectionHandler=function(e){var r=e.reason,n=e.promise,o=e.detail;!r&&o&&(r=o.reason,n=o.promise),t.unhandledRejection(r,n)},window.addEventListener("unhandledrejection",t._unhandledRejectionHandler)),window.Rollbar=t,s.processPayloads(),t},e.exports={wrapper:u,setupJSON:i.setupJSON}},function(e,r,t){"use strict";function n(e){E=e,w.setupJSON(e),v.setupJSON(e)}function o(e,r){return function(){var t=r||this;try{return e.apply(t,arguments)}catch(e){v.consoleError("[Rollbar]:",e)}}}function i(){h||(h=setTimeout(f,1e3))}function a(){return _}function s(e){_=_||this;var r="https://"+s.DEFAULT_ENDPOINT;this.options={enabled:!0,endpoint:r,environment:"production",scrubFields:g([],s.DEFAULT_SCRUB_FIELDS),checkIgnore:null,logLevel:s.DEFAULT_LOG_LEVEL,reportLevel:s.DEFAULT_REPORT_LEVEL,uncaughtErrorLevel:s.DEFAULT_UNCAUGHT_ERROR_LEVEL,payload:{}},this.lastError=null,this.plugins={},this.parentNotifier=e,e&&(e.hasOwnProperty("shimId")?e.notifier=this:this.configure(e.options))}function u(e){window._rollbarPayloadQueue.push(e),i()}function c(e){return o(function(){var r=this._getLogArgs(arguments);return this._log(e||r.level||this.options.logLevel||s.DEFAULT_LOG_LEVEL,r.message,r.err,r.custom,r.callback)})}function l(e,r){e||(e=r?E.stringify(r):"");var t={body:e};return r&&(t.extra=g(!0,{},r)),{message:t}}function p(e,r,t){var n=m.guessErrorClass(r.message),o=r.name||n[0],i=n[1],a={exception:{class:o,message:i}};if(e&&(a.exception.description=e||"uncaught exception"),r.stack){var s,u,c,p,f,d,h,w;for(a.frames=[],h=0;h<r.stack.length;++h)s=r.stack[h],u={filename:s.url?v.sanitizeUrl(s.url):"(unknown)",lineno:s.line||null,method:s.func&&"?"!==s.func?s.func:"[anonymous]",colno:s.column},c=p=f=null,d=s.context?s.context.length:0,d&&(w=Math.floor(d/2),p=s.context.slice(0,w),c=s.context[w],f=s.context.slice(w)),c&&(u.code=c),(p||f)&&(u.context={},p&&p.length&&(u.context.pre=p),f&&f.length&&(u.context.post=f)),s.args&&(u.args=s.args),a.frames.push(u);return a.frames.reverse(),t&&(a.extra=g(!0,{},t)),{trace:a}}return l(o+": "+i,t)}function f(){var e;try{for(;e=window._rollbarPayloadQueue.shift();)d(e)}finally{h=void 0}}function d(e){var r=e.endpointUrl,t=e.accessToken,n=e.payload,o=e.callback||function(){},i=(new Date).getTime();i-L>=6e4&&(L=i,R=0);var a=window._globalRollbarOptions.maxItems,c=window._globalRollbarOptions.itemsPerMinute,l=function(){return!n.ignoreRateLimit&&a>=1&&T>=a},p=function(){return!n.ignoreRateLimit&&c>=1&&R>=c};return l()?void o(new Error(a+" max items reached")):p()?void o(new Error(c+" items per minute reached")):(T++,R++,l()&&_._log(_.options.uncaughtErrorLevel,"maxItems has been hit. Ignoring errors for the remainder of the current page load.",null,{maxItems:a},null,!1,!0),n.ignoreRateLimit&&delete n.ignoreRateLimit,void y.post(r,t,n,function(r,t){return r?(r instanceof b&&(e.callback=function(){},setTimeout(function(){u(e)},s.RETRY_DELAY)),o(r)):o(null,t)}))}var h,g=t(4),m=t(5),v=t(8),w=t(11),y=w.XHR,b=w.ConnectionError,E=null;s.NOTIFIER_VERSION="1.9.4",s.DEFAULT_ENDPOINT="api.rollbar.com/api/1/",s.DEFAULT_SCRUB_FIELDS=["pw","pass","passwd","password","secret","confirm_password","confirmPassword","password_confirmation","passwordConfirmation","access_token","accessToken","secret_key","secretKey","secretToken"],s.DEFAULT_LOG_LEVEL="debug",s.DEFAULT_REPORT_LEVEL="debug",s.DEFAULT_UNCAUGHT_ERROR_LEVEL="error",s.DEFAULT_ITEMS_PER_MIN=60,s.DEFAULT_MAX_ITEMS=0,s.LEVELS={debug:0,info:1,warning:2,error:3,critical:4},s.RETRY_DELAY=1e4,window._rollbarPayloadQueue=window._rollbarPayloadQueue||[],window._globalRollbarOptions={startTime:(new Date).getTime(),maxItems:s.DEFAULT_MAX_ITEMS,itemsPerMinute:s.DEFAULT_ITEMS_PER_MIN};var _,x=s.prototype;x._getLogArgs=function(e){for(var r,t,n,i,a,u,c=this.options.logLevel||s.DEFAULT_LOG_LEVEL,l=[],p=0;p<e.length;++p)u=e[p],a=v.typeName(u),"string"===a?r?l.push(u):r=u:"function"===a?i=o(u,this):"date"===a?l.push(u):"error"===a||u instanceof Error||"undefined"!=typeof DOMException&&u instanceof DOMException?t?l.push(u):t=u:"object"!==a&&"array"!==a||(n?l.push(u):n=u);return l.length&&(n=n||{},n.extraArgs=l),{level:c,message:r,err:t,custom:n,callback:i}},x._route=function(e){var r=this.options.endpoint,t=/\/$/.test(r),n=/^\//.test(e);return t&&n?e=e.substring(1):t||n||(e="/"+e),r+e},x._processShimQueue=function(e){for(var r,t,n,o,i,a,u,c={};t=e.shift();)r=t.shim,n=t.method,o=t.args,i=r.parentShim,u=c[r.shimId],u||(i?(a=c[i.shimId],u=new s(a)):u=this,c[r.shimId]=u),u[n]&&v.isType(u[n],"function")&&u[n].apply(u,o)},x._buildPayload=function(e,r,t,n,o){var i=this.options.accessToken,a=this.options.environment,u=g(!0,{},this.options.payload),c=v.uuid4();if(void 0===s.LEVELS[r])throw new Error("Invalid level");if(!t&&!n&&!o)throw new Error("No message, stack info or custom data");var l={environment:a,endpoint:this.options.endpoint,uuid:c,level:r,platform:"browser",framework:"browser-js",language:"javascript",body:this._buildBody(t,n,o),request:{url:window.location.href,query_string:window.location.search,user_ip:"$remote_ip"},client:{runtime_ms:e.getTime()-window._globalRollbarOptions.startTime,timestamp:Math.round(e.getTime()/1e3),javascript:{browser:window.navigator.userAgent,language:window.navigator.language,cookie_enabled:window.navigator.cookieEnabled,screen:{width:window.screen.width,height:window.screen.height},plugins:this._getBrowserPlugins()}},server:{},notifier:{name:"rollbar-browser-js",version:s.NOTIFIER_VERSION}};u.body&&delete u.body;var p={access_token:i,data:g(!0,l,u)};return this._scrub(p.data),p},x._buildBody=function(e,r,t){var n;return n=r?p(e,r,t):l(e,t)},x._getBrowserPlugins=function(){if(!this._browserPlugins){var e,r,t=window.navigator.plugins||[],n=t.length,o=[];for(r=0;r<n;++r)e=t[r],o.push({name:e.name,description:e.description});this._browserPlugins=o}return this._browserPlugins},x._scrub=function(e){function r(e,r,t,n,o,i){return r+v.redact(i)}function t(e){var t;if(v.isType(e,"string"))for(t=0;t<s.length;++t)e=e.replace(s[t],r);return e}function n(e,r){var t;for(t=0;t<a.length;++t)if(a[t].test(e)){r=v.redact(r);break}return r}function o(e,r){var o=n(e,r);return o===r?t(o):o}var i=this.options.scrubFields,a=this._getScrubFieldRegexs(i),s=this._getScrubQueryParamRegexs(i);return v.traverse(e,o),e},x._getScrubFieldRegexs=function(e){for(var r,t=[],n=0;n<e.length;++n)r="\\[?(%5[bB])?"+e[n]+"\\[?(%5[bB])?\\]?(%5[dD])?",t.push(new RegExp(r,"i"));return t},x._getScrubQueryParamRegexs=function(e){for(var r,t=[],n=0;n<e.length;++n)r="\\[?(%5[bB])?"+e[n]+"\\[?(%5[bB])?\\]?(%5[dD])?",t.push(new RegExp("("+r+"=)([^&\\n]+)","igm"));return t},x._urlIsWhitelisted=function(e){var r,t,n,o,i,a,s,u,c,l;try{if(r=this.options.hostWhiteList,t=e&&e.data&&e.data.body&&e.data.body.trace,!r||0===r.length)return!0;if(!t)return!0;for(s=r.length,i=t.frames.length,c=0;c<i;c++){if(n=t.frames[c],o=n.filename,!v.isType(o,"string"))return!0;for(l=0;l<s;l++)if(a=r[l],u=new RegExp(a),u.test(o))return!0}}catch(e){return this.configure({hostWhiteList:null}),v.consoleError("[Rollbar]: Error while reading your configuration's hostWhiteList option. Removing custom hostWhiteList.",e),!0}return!1},x._messageIsIgnored=function(e){var r,t,n,o,i,a,s,u,c;try{if(i=!1,n=this.options.ignoredMessages,!n||0===n.length)return!1;if(s=e&&e.data&&e.data.body,u=s&&s.trace&&s.trace.exception&&s.trace.exception.message,c=s&&s.message&&s.message.body,r=u||c,!r)return!1;for(o=n.length,t=0;t<o&&(a=new RegExp(n[t],"gi"),!(i=a.test(r)));t++);}catch(e){this.configure({ignoredMessages:null}),v.consoleError("[Rollbar]: Error while reading your configuration's ignoredMessages option. Removing custom ignoredMessages.")}return i},x._enqueuePayload=function(e,r,t,n){var o={callback:n,accessToken:this.options.accessToken,endpointUrl:this._route("item/"),payload:e},i=function(){if(n){var e="This item was not sent to Rollbar because it was ignored. This can happen if a custom checkIgnore() function was used or if the item's level was less than the notifier' reportLevel. See https://rollbar.com/docs/notifier/rollbar.js/configuration for more details.";n(null,{err:0,result:{id:null,uuid:null,message:e}})}};if(this._internalCheckIgnore(r,t,e))return void i();try{if(v.isType(this.options.checkIgnore,"function")&&this.options.checkIgnore(r,t,e))return void i()}catch(e){this.configure({checkIgnore:null}),v.consoleError("[Rollbar]: Error while calling custom checkIgnore() function. Removing custom checkIgnore().",e)}if(this._urlIsWhitelisted(e)&&!this._messageIsIgnored(e)){if(this.options.verbose){if(e.data&&e.data.body&&e.data.body.trace){var a=e.data.body.trace,s=a.exception.message;v.consoleError("[Rollbar]: ",s)}v.consoleInfo("[Rollbar]: ",o)}v.isType(this.options.logFunction,"function")&&this.options.logFunction(o);try{v.isType(this.options.transform,"function")&&this.options.transform(e)}catch(e){this.configure({transform:null}),v.consoleError("[Rollbar]: Error while calling custom transform() function. Removing custom transform().",e)}this.options.enabled&&u(o)}},x._internalCheckIgnore=function(e,r,t){var n=r[0],o=s.LEVELS[n]||0,i=s.LEVELS[this.options.reportLevel]||0;if(o<i)return!0;var a=this.options?this.options.plugins:{};if(a&&a.jquery&&a.jquery.ignoreAjaxErrors)try{return!!t.data.body.message.extra.isAjax}catch(e){return!1}return!1},x._log=function(e,r,t,n,o,i,a){var s=null;if(t)try{if(s=t._savedStackTrace?t._savedStackTrace:m.parse(t),t===this.lastError)return;this.lastError=t}catch(e){v.consoleError("[Rollbar]: Error while parsing the error object.",e),r=t.message||t.description||r||String(t),t=null}var u=this._buildPayload(new Date,e,r,s,n);return a&&(u.ignoreRateLimit=!0),this._enqueuePayload(u,!!i,[e,r,t,n],o),{uuid:u.data.uuid}},x.log=c(),x.debug=c("debug"),x.info=c("info"),x.warn=c("warning"),x.warning=c("warning"),x.error=c("error"),x.critical=c("critical"),x.uncaughtError=o(function(e,r,t,n,o,i){if(i=i||null,o&&v.isType(o,"error"))return void this._log(this.options.uncaughtErrorLevel,e,o,i,null,!0);if(r&&v.isType(r,"error"))return void this._log(this.options.uncaughtErrorLevel,e,r,i,null,!0);var a={url:r||"",line:t};a.func=m.guessFunctionName(a.url,a.line),a.context=m.gatherContext(a.url,a.line);var s={mode:"onerror",message:o?String(o):e||"uncaught exception",url:document.location.href,stack:[a],useragent:navigator.userAgent},u=this._buildPayload(new Date,this.options.uncaughtErrorLevel,e,s,i);this._enqueuePayload(u,!0,[this.options.uncaughtErrorLevel,e,r,t,n,o])}),x.unhandledRejection=o(function(e,r){var t,n;if(e?(t=e.message||String(e),n=e._rollbarContext):t="unhandled rejection was null or undefined!",n=n||r._rollbarContext||null,e&&v.isType(e,"error"))return void this._log(this.options.uncaughtErrorLevel,t,e,n,null,!0);var o={url:"",line:0};o.func=m.guessFunctionName(o.url,o.line),o.context=m.gatherContext(o.url,o.line);var i={mode:"unhandledrejection",message:t,url:document.location.href,stack:[o],useragent:navigator.userAgent},a=this._buildPayload(new Date,this.options.uncaughtErrorLevel,t,i,n);this._enqueuePayload(a,!0,[this.options.uncaughtErrorLevel,t,o.url,o.line,0,e,r])}),x.global=o(function(e){e=e||{};var r={startTime:e.startTime,maxItems:e.maxItems,itemsPerMinute:e.itemsPerMinute};g(!0,window._globalRollbarOptions,r),void 0!==e.maxItems&&(T=0),void 0!==e.itemsPerMinute&&(R=0)}),x.configure=o(function(e,r){var t=g(!0,{},e);g(!r,this.options,t),this.global(t)}),x.scope=o(function(e){var r=new s(this);return g(!0,r.options.payload,e),r}),x.wrap=function(e,r){try{var t;if(t=v.isType(r,"function")?r:function(){return r||{}},!v.isType(e,"function"))return e;if(e._isWrap)return e;if(!e._wrapped){e._wrapped=function(){try{return e.apply(this,arguments)}catch(r){throw"string"==typeof r&&(r=new String(r)),r.stack||(r._savedStackTrace=m.parse(r)),r._rollbarContext=t()||{},r._rollbarContext._wrappedSource=e.toString(),window._rollbarWrappedError=r,r}},e._wrapped._isWrap=!0;for(var n in e)e.hasOwnProperty(n)&&(e._wrapped[n]=e[n])}return e._wrapped}catch(r){return e}},x.loadFull=function(){v.consoleError("[Rollbar]: Unexpected Rollbar.loadFull() called on a Notifier instance")},s.processPayloads=function(e){return e?void f():void i()};var L=(new Date).getTime(),T=0,R=0;e.exports={Notifier:s,setupJSON:n,topLevelNotifier:a}},function(e,r){"use strict";var t=Object.prototype.hasOwnProperty,n=Object.prototype.toString,o=function(e){return"function"==typeof Array.isArray?Array.isArray(e):"[object Array]"===n.call(e)},i=function(e){if(!e||"[object Object]"!==n.call(e))return!1;var r=t.call(e,"constructor"),o=e.constructor&&e.constructor.prototype&&t.call(e.constructor.prototype,"isPrototypeOf");if(e.constructor&&!r&&!o)return!1;var i;for(i in e);return"undefined"==typeof i||t.call(e,i)};e.exports=function e(){var r,t,n,a,s,u,c=arguments[0],l=1,p=arguments.length,f=!1;for("boolean"==typeof c?(f=c,c=arguments[1]||{},l=2):("object"!=typeof c&&"function"!=typeof c||null==c)&&(c={});l<p;++l)if(r=arguments[l],null!=r)for(t in r)n=c[t],a=r[t],c!==a&&(f&&a&&(i(a)||(s=o(a)))?(s?(s=!1,u=n&&o(n)?n:[]):u=n&&i(n)?n:{},c[t]=e(f,u,a)):"undefined"!=typeof a&&(c[t]=a));return c}},function(e,r,t){"use strict";function n(){return l}function o(){return null}function i(e){var r={};return r._stackFrame=e,r.url=e.fileName,r.line=e.lineNumber,r.func=e.functionName,r.column=e.columnNumber,r.args=e.args,r.context=o(r.url,r.line),r}function a(e){function r(){var r=[];try{r=c.parse(e)}catch(e){r=[]}for(var t=[],n=0;n<r.length;n++)t.push(new i(r[n]));return t}return{stack:r(),message:e.message,name:e.name}}function s(e){return new a(e)}function u(e){if(!e)return["Unknown error. There was no error message to display.",""];var r=e.match(p),t="(unknown)";return r&&(t=r[r.length-1],e=e.replace((r[r.length-2]||"")+t+":",""),e=e.replace(/(^[\s]+|[\s]+$)/g,"")),[t,e]}var c=t(6),l="?",p=new RegExp("^(([a-zA-Z0-9-_$ ]*): *)?(Uncaught )?([a-zA-Z0-9-_$ ]*): ");e.exports={guessFunctionName:n,guessErrorClass:u,gatherContext:o,parse:s,Stack:a,Frame:i}},function(e,r,t){var n,o,i;!function(a,s){"use strict";o=[t(7)],n=s,i="function"==typeof n?n.apply(r,o):n,!(void 0!==i&&(e.exports=i))}(this,function(e){"use strict";function r(e,r,t){if("function"==typeof Array.prototype.map)return e.map(r,t);for(var n=new Array(e.length),o=0;o<e.length;o++)n[o]=r.call(t,e[o]);return n}function t(e,r,t){if("function"==typeof Array.prototype.filter)return e.filter(r,t);for(var n=[],o=0;o<e.length;o++)r.call(t,e[o])&&n.push(e[o]);return n}var n=/(^|@)\S+\:\d+/,o=/^\s*at .*(\S+\:\d+|\(native\))/m,i=/^(eval@)?(\[native code\])?$/;return{parse:function(e){if("undefined"!=typeof e.stacktrace||"undefined"!=typeof e["opera#sourceloc"])return this.parseOpera(e);if(e.stack&&e.stack.match(o))return this.parseV8OrIE(e);if(e.stack)return this.parseFFOrSafari(e);throw new Error("Cannot parse given Error object")},extractLocation:function(e){if(e.indexOf(":")===-1)return[e];var r=e.replace(/[\(\)\s]/g,"").split(":"),t=r.pop(),n=r[r.length-1];if(!isNaN(parseFloat(n))&&isFinite(n)){var o=r.pop();return[r.join(":"),o,t]}return[r.join(":"),t,void 0]},parseV8OrIE:function(n){var i=t(n.stack.split("\n"),function(e){return!!e.match(o)},this);return r(i,function(r){r.indexOf("(eval ")>-1&&(r=r.replace(/eval code/g,"eval").replace(/(\(eval at [^\()]*)|(\)\,.*$)/g,""));var t=r.replace(/^\s+/,"").replace(/\(eval code/g,"(").split(/\s+/).slice(1),n=this.extractLocation(t.pop()),o=t.join(" ")||void 0,i="eval"===n[0]?void 0:n[0];return new e(o,void 0,i,n[1],n[2],r)},this)},parseFFOrSafari:function(n){var o=t(n.stack.split("\n"),function(e){return!e.match(i)},this);return r(o,function(r){if(r.indexOf(" > eval")>-1&&(r=r.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g,":$1")),r.indexOf("@")===-1&&r.indexOf(":")===-1)return new e(r);var t=r.split("@"),n=this.extractLocation(t.pop()),o=t.shift()||void 0;return new e(o,void 0,n[0],n[1],n[2],r)},this)},parseOpera:function(e){return!e.stacktrace||e.message.indexOf("\n")>-1&&e.message.split("\n").length>e.stacktrace.split("\n").length?this.parseOpera9(e):e.stack?this.parseOpera11(e):this.parseOpera10(e)},parseOpera9:function(r){for(var t=/Line (\d+).*script (?:in )?(\S+)/i,n=r.message.split("\n"),o=[],i=2,a=n.length;i<a;i+=2){var s=t.exec(n[i]);s&&o.push(new e(void 0,void 0,s[2],s[1],void 0,n[i]))}return o},parseOpera10:function(r){for(var t=/Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,n=r.stacktrace.split("\n"),o=[],i=0,a=n.length;i<a;i+=2){var s=t.exec(n[i]);s&&o.push(new e(s[3]||void 0,void 0,s[2],s[1],void 0,n[i]))}return o},parseOpera11:function(o){var i=t(o.stack.split("\n"),function(e){return!!e.match(n)&&!e.match(/^Error created at/)},this);return r(i,function(r){var t,n=r.split("@"),o=this.extractLocation(n.pop()),i=n.shift()||"",a=i.replace(/<anonymous function(: (\w+))?>/,"$2").replace(/\([^\)]*\)/g,"")||void 0;i.match(/\(([^\)]*)\)/)&&(t=i.replace(/^[^\(]+\(([^\)]*)\)$/,"$1"));var s=void 0===t||"[arguments not available]"===t?void 0:t.split(",");return new e(a,s,o[0],o[1],o[2],r)},this)}}})},function(e,r,t){var n,o,i;!function(t,a){"use strict";o=[],n=a,i="function"==typeof n?n.apply(r,o):n,!(void 0!==i&&(e.exports=i))}(this,function(){"use strict";function e(e){return!isNaN(parseFloat(e))&&isFinite(e)}function r(e,r,t,n,o,i){void 0!==e&&this.setFunctionName(e),void 0!==r&&this.setArgs(r),void 0!==t&&this.setFileName(t),void 0!==n&&this.setLineNumber(n),void 0!==o&&this.setColumnNumber(o),void 0!==i&&this.setSource(i)}return r.prototype={getFunctionName:function(){return this.functionName},setFunctionName:function(e){this.functionName=String(e)},getArgs:function(){return this.args},setArgs:function(e){if("[object Array]"!==Object.prototype.toString.call(e))throw new TypeError("Args must be an Array");this.args=e},getFileName:function(){return this.fileName},setFileName:function(e){this.fileName=String(e)},getLineNumber:function(){return this.lineNumber},setLineNumber:function(r){if(!e(r))throw new TypeError("Line Number must be a Number");this.lineNumber=Number(r)},getColumnNumber:function(){return this.columnNumber},setColumnNumber:function(r){if(!e(r))throw new TypeError("Column Number must be a Number");this.columnNumber=Number(r)},getSource:function(){return this.source},setSource:function(e){this.source=String(e)},toString:function(){var r=this.getFunctionName()||"{anonymous}",t="("+(this.getArgs()||[]).join(",")+")",n=this.getFileName()?"@"+this.getFileName():"",o=e(this.getLineNumber())?":"+this.getLineNumber():"",i=e(this.getColumnNumber())?":"+this.getColumnNumber():"";return r+t+n+o+i}},r})},function(e,r,t){"use strict";function n(e){v=e}function o(e){return{}.toString.call(e).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}function i(e,r){return o(e)===r}function a(e){if(!i(e,"string"))throw new Error("received invalid input");for(var r=w,t=r.parser[r.strictMode?"strict":"loose"].exec(e),n={},o=14;o--;)n[r.key[o]]=t[o]||"";return n[r.q.name]={},n[r.key[12]].replace(r.q.parser,function(e,t,o){t&&(n[r.q.name][t]=o)}),n}function s(e){var r=a(e);return""===r.anchor&&(r.source=r.source.replace("#","")),e=r.source.replace("?"+r.query,"")}function u(e,r){var t,n,o,a=i(e,"object"),s=i(e,"array"),c=[];if(a)for(t in e)e.hasOwnProperty(t)&&c.push(t);else if(s)for(o=0;o<e.length;++o)c.push(o);for(o=0;o<c.length;++o)t=c[o],n=e[t],a=i(n,"object"),s=i(n,"array"),a||s?e[t]=u(n,r):e[t]=r(t,n);return e}function c(e){return e=String(e),new Array(e.length+1).join("*")}function l(){var e=(new Date).getTime(),r="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(r){var t=(e+16*Math.random())%16|0;return e=Math.floor(e/16),("x"===r?t:7&t|8).toString(16)});return r}function p(e){return"function"!=typeof Object.create?function(e){var r=function(){};return function(e){if(null!==e&&e!==Object(e))throw TypeError("Argument must be an object, or null");r.prototype=e||{};var t=new r;return r.prototype=null,null===e&&(t.__proto__=null),t}}()(e):Object.create(e)}function f(){for(var e=[],r=0;r<arguments.length;r++){var t=arguments[r];"object"==typeof t?(t=v.stringify(t),t.length>500&&(t=t.substr(0,500)+"...")):"undefined"==typeof t&&(t="undefined"),e.push(t)}return e.join(" ")}function d(){m.ieVersion()<=8?console.error(f.apply(null,arguments)):console.error.apply(null,arguments)}function h(){m.ieVersion()<=8?console.info(f.apply(null,arguments)):console.info.apply(null,arguments)}function g(){m.ieVersion()<=8?console.log(f.apply(null,arguments)):console.log.apply(null,arguments)}t(9);var m=t(10),v=null,w={strictMode:!1,key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}},y={setupJSON:n,isType:i,parseUri:a,parseUriOptions:w,redact:c,sanitizeUrl:s,traverse:u,typeName:o,uuid4:l,objectCreate:p,consoleError:d,consoleInfo:h,consoleLog:g};e.exports=y},function(e,r){!function(e){"use strict";e.console||(e.console={});for(var r,t,n=e.console,o=function(){},i=["memory"],a="assert,clear,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn".split(",");r=i.pop();)n[r]||(n[r]={});for(;t=a.pop();)n[t]||(n[t]=o)}("undefined"==typeof window?this:window)},function(e,r){"use strict";function t(){for(var e,r=3,t=document.createElement("div"),n=t.getElementsByTagName("i");t.innerHTML="<!--[if gt IE "+ ++r+"]><i></i><![endif]-->",n[0];);return r>4?r:e}var n={ieVersion:t};e.exports=n},function(e,r,t){"use strict";function n(e){a=e}function o(e){this.name="Connection Error",this.message=e,this.stack=(new Error).stack}var i=t(8),a=null;o.prototype=i.objectCreate(Error.prototype),o.prototype.constructor=o;var s={XMLHttpFactories:[function(){return new XMLHttpRequest},function(){return new ActiveXObject("Msxml2.XMLHTTP")},function(){return new ActiveXObject("Msxml3.XMLHTTP")},function(){return new ActiveXObject("Microsoft.XMLHTTP")}],createXMLHTTPObject:function(){var e,r=!1,t=s.XMLHttpFactories,n=t.length;for(e=0;e<n;e++)try{r=t[e]();break}catch(e){}return r},post:function(e,r,t,n){if(!i.isType(t,"object"))throw new Error("Expected an object to POST");t=a.stringify(t),n=n||function(){};var u=s.createXMLHTTPObject();if(u)try{try{var c=function(){try{if(c&&4===u.readyState){c=void 0;var e=a.parse(u.responseText);200===u.status?n(null,e):i.isType(u.status,"number")&&u.status>=400&&u.status<600?(403==u.status&&i.consoleError("[Rollbar]:"+e.message),n(new Error(String(u.status)))):n(new o("XHR response had no status code (likely connection failure)"))}}catch(e){var r;r=e&&e.stack?e:new Error(e),n(r)}};u.open("POST",e,!0),u.setRequestHeader&&(u.setRequestHeader("Content-Type","application/json"),u.setRequestHeader("X-Rollbar-Access-Token",r)),u.onreadystatechange=c,u.send(t)}catch(r){if("undefined"!=typeof XDomainRequest){"http:"===window.location.href.substring(0,5)&&"https"===e.substring(0,5)&&(e="http"+e.substring(5));var l=function(){n(new o("Request timed out"))},p=function(){n(new Error("Error during request"))},f=function(){n(null,a.parse(u.responseText))};u=new XDomainRequest,u.onprogress=function(){},u.ontimeout=l,u.onerror=p,u.onload=f,u.open("POST",e,!0),u.send(t)}}}catch(e){n(e)}}};e.exports={XHR:s,setupJSON:n,ConnectionError:o}}])});

/***/ }),
/* 693 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function () {
    var /*
 * Rusha, a JavaScript implementation of the Secure Hash Algorithm, SHA-1,
 * as defined in FIPS PUB 180-1, tuned for high performance with large inputs.
 * (http://github.com/srijs/rusha)
 *
 * Inspired by Paul Johnstons implementation (http://pajhome.org.uk/crypt/md5).
 *
 * Copyright (c) 2013 Sam Rijs (http://awesam.de).
 * Released under the terms of the MIT license as follows:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
    util = {
        getDataType: function (data) {
            if (typeof data === 'string') {
                return 'string';
            }
            if (data instanceof Array) {
                return 'array';
            }
            if (typeof global !== 'undefined' && global.Buffer && global.Buffer.isBuffer(data)) {
                return 'buffer';
            }
            if (data instanceof ArrayBuffer) {
                return 'arraybuffer';
            }
            if (data.buffer instanceof ArrayBuffer) {
                return 'view';
            }
            if (data instanceof Blob) {
                return 'blob';
            }
            throw new Error('Unsupported data type.');
        }
    };
    function Rusha(chunkSize) {
        'use strict';
        var // Private object structure.
        self$2 = { fill: 0 };
        var // Calculate the length of buffer that the sha1 routine uses
        // including the padding.
        padlen = function (len) {
            for (len += 9; len % 64 > 0; len += 1);
            return len;
        };
        var padZeroes = function (bin, len) {
            var h8 = new Uint8Array(bin.buffer);
            var om = len % 4, align = len - om;
            switch (om) {
            case 0:
                h8[align + 3] = 0;
            case 1:
                h8[align + 2] = 0;
            case 2:
                h8[align + 1] = 0;
            case 3:
                h8[align + 0] = 0;
            }
            for (var i$2 = (len >> 2) + 1; i$2 < bin.length; i$2++)
                bin[i$2] = 0;
        };
        var padData = function (bin, chunkLen, msgLen) {
            bin[chunkLen >> 2] |= 128 << 24 - (chunkLen % 4 << 3);
            // To support msgLen >= 2 GiB, use a float division when computing the
            // high 32-bits of the big-endian message length in bits.
            bin[((chunkLen >> 2) + 2 & ~15) + 14] = msgLen / (1 << 29) | 0;
            bin[((chunkLen >> 2) + 2 & ~15) + 15] = msgLen << 3;
        };
        var // Convert a binary string and write it to the heap.
        // A binary string is expected to only contain char codes < 256.
        convStr = function (H8, H32, start, len, off) {
            var str = this, i$2, om = off % 4, lm = (len + om) % 4, j = len - lm;
            switch (om) {
            case 0:
                H8[off] = str.charCodeAt(start + 3);
            case 1:
                H8[off + 1 - (om << 1) | 0] = str.charCodeAt(start + 2);
            case 2:
                H8[off + 2 - (om << 1) | 0] = str.charCodeAt(start + 1);
            case 3:
                H8[off + 3 - (om << 1) | 0] = str.charCodeAt(start);
            }
            if (len < lm + om) {
                return;
            }
            for (i$2 = 4 - om; i$2 < j; i$2 = i$2 + 4 | 0) {
                H32[off + i$2 >> 2] = str.charCodeAt(start + i$2) << 24 | str.charCodeAt(start + i$2 + 1) << 16 | str.charCodeAt(start + i$2 + 2) << 8 | str.charCodeAt(start + i$2 + 3);
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);
            case 2:
                H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);
            case 1:
                H8[off + j + 3 | 0] = str.charCodeAt(start + j);
            }
        };
        var // Convert a buffer or array and write it to the heap.
        // The buffer or array is expected to only contain elements < 256.
        convBuf = function (H8, H32, start, len, off) {
            var buf = this, i$2, om = off % 4, lm = (len + om) % 4, j = len - lm;
            switch (om) {
            case 0:
                H8[off] = buf[start + 3];
            case 1:
                H8[off + 1 - (om << 1) | 0] = buf[start + 2];
            case 2:
                H8[off + 2 - (om << 1) | 0] = buf[start + 1];
            case 3:
                H8[off + 3 - (om << 1) | 0] = buf[start];
            }
            if (len < lm + om) {
                return;
            }
            for (i$2 = 4 - om; i$2 < j; i$2 = i$2 + 4 | 0) {
                H32[off + i$2 >> 2 | 0] = buf[start + i$2] << 24 | buf[start + i$2 + 1] << 16 | buf[start + i$2 + 2] << 8 | buf[start + i$2 + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[start + j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[start + j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[start + j];
            }
        };
        var convBlob = function (H8, H32, start, len, off) {
            var blob = this, i$2, om = off % 4, lm = (len + om) % 4, j = len - lm;
            var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
            switch (om) {
            case 0:
                H8[off] = buf[3];
            case 1:
                H8[off + 1 - (om << 1) | 0] = buf[2];
            case 2:
                H8[off + 2 - (om << 1) | 0] = buf[1];
            case 3:
                H8[off + 3 - (om << 1) | 0] = buf[0];
            }
            if (len < lm + om) {
                return;
            }
            for (i$2 = 4 - om; i$2 < j; i$2 = i$2 + 4 | 0) {
                H32[off + i$2 >> 2 | 0] = buf[i$2] << 24 | buf[i$2 + 1] << 16 | buf[i$2 + 2] << 8 | buf[i$2 + 3];
            }
            switch (lm) {
            case 3:
                H8[off + j + 1 | 0] = buf[j + 2];
            case 2:
                H8[off + j + 2 | 0] = buf[j + 1];
            case 1:
                H8[off + j + 3 | 0] = buf[j];
            }
        };
        var convFn = function (data) {
            switch (util.getDataType(data)) {
            case 'string':
                return convStr.bind(data);
            case 'array':
                return convBuf.bind(data);
            case 'buffer':
                return convBuf.bind(data);
            case 'arraybuffer':
                return convBuf.bind(new Uint8Array(data));
            case 'view':
                return convBuf.bind(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
            case 'blob':
                return convBlob.bind(data);
            }
        };
        var slice = function (data, offset) {
            switch (util.getDataType(data)) {
            case 'string':
                return data.slice(offset);
            case 'array':
                return data.slice(offset);
            case 'buffer':
                return data.slice(offset);
            case 'arraybuffer':
                return data.slice(offset);
            case 'view':
                return data.buffer.slice(offset);
            }
        };
        var // Precompute 00 - ff strings
        precomputedHex = new Array(256);
        for (var i = 0; i < 256; i++) {
            precomputedHex[i] = (i < 16 ? '0' : '') + i.toString(16);
        }
        var // Convert an ArrayBuffer into its hexadecimal string representation.
        hex = function (arrayBuffer) {
            var binarray = new Uint8Array(arrayBuffer);
            var res = new Array(arrayBuffer.byteLength);
            for (var i$2 = 0; i$2 < res.length; i$2++) {
                res[i$2] = precomputedHex[binarray[i$2]];
            }
            return res.join('');
        };
        var ceilHeapSize = function (v) {
            // The asm.js spec says:
            // The heap object's byteLength must be either
            // 2^n for n in [12, 24) or 2^24 * n for n  1.
            // Also, byteLengths smaller than 2^16 are deprecated.
            var p;
            if (// If v is smaller than 2^16, the smallest possible solution
                // is 2^16.
                v <= 65536)
                return 65536;
            if (// If v < 2^24, we round up to 2^n,
                // otherwise we round up to 2^24 * n.
                v < 16777216) {
                for (p = 1; p < v; p = p << 1);
            } else {
                for (p = 16777216; p < v; p += 16777216);
            }
            return p;
        };
        var // Initialize the internal data structures to a new capacity.
        init = function (size) {
            if (size % 64 > 0) {
                throw new Error('Chunk size must be a multiple of 128 bit');
            }
            self$2.offset = 0;
            self$2.maxChunkLen = size;
            self$2.padMaxChunkLen = padlen(size);
            // The size of the heap is the sum of:
            // 1. The padded input message size
            // 2. The extended space the algorithm needs (320 byte)
            // 3. The 160 bit state the algoritm uses
            self$2.heap = new ArrayBuffer(ceilHeapSize(self$2.padMaxChunkLen + 320 + 20));
            self$2.h32 = new Int32Array(self$2.heap);
            self$2.h8 = new Int8Array(self$2.heap);
            self$2.core = new Rusha._core({
                Int32Array: Int32Array,
                DataView: DataView
            }, {}, self$2.heap);
            self$2.buffer = null;
        };
        // Iinitializethe datastructures according
        // to a chunk siyze.
        init(chunkSize || 64 * 1024);
        var initState = function (heap, padMsgLen) {
            self$2.offset = 0;
            var io = new Int32Array(heap, padMsgLen + 320, 5);
            io[0] = 1732584193;
            io[1] = -271733879;
            io[2] = -1732584194;
            io[3] = 271733878;
            io[4] = -1009589776;
        };
        var padChunk = function (chunkLen, msgLen) {
            var padChunkLen = padlen(chunkLen);
            var view = new Int32Array(self$2.heap, 0, padChunkLen >> 2);
            padZeroes(view, chunkLen);
            padData(view, chunkLen, msgLen);
            return padChunkLen;
        };
        var // Write data to the heap.
        write = function (data, chunkOffset, chunkLen, off) {
            convFn(data)(self$2.h8, self$2.h32, chunkOffset, chunkLen, off || 0);
        };
        var // Initialize and call the RushaCore,
        // assuming an input buffer of length len * 4.
        coreCall = function (data, chunkOffset, chunkLen, msgLen, finalize) {
            var padChunkLen = chunkLen;
            write(data, chunkOffset, chunkLen);
            if (finalize) {
                padChunkLen = padChunk(chunkLen, msgLen);
            }
            self$2.core.hash(padChunkLen, self$2.padMaxChunkLen);
        };
        var getRawDigest = function (heap, padMaxChunkLen) {
            var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
            var out = new Int32Array(5);
            var arr = new DataView(out.buffer);
            arr.setInt32(0, io[0], false);
            arr.setInt32(4, io[1], false);
            arr.setInt32(8, io[2], false);
            arr.setInt32(12, io[3], false);
            arr.setInt32(16, io[4], false);
            return out;
        };
        var // Calculate the hash digest as an array of 5 32bit integers.
        rawDigest = this.rawDigest = function (str) {
            var msgLen = str.byteLength || str.length || str.size || 0;
            initState(self$2.heap, self$2.padMaxChunkLen);
            var chunkOffset = 0, chunkLen = self$2.maxChunkLen;
            for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
                coreCall(str, chunkOffset, chunkLen, msgLen, false);
            }
            coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
            return getRawDigest(self$2.heap, self$2.padMaxChunkLen);
        };
        // The digest and digestFrom* interface returns the hash digest
        // as a hex string.
        this.digest = this.digestFromString = this.digestFromBuffer = this.digestFromArrayBuffer = function (str) {
            return hex(rawDigest(str).buffer);
        };
        this.resetState = function () {
            initState(self$2.heap, self$2.padMaxChunkLen);
            return this;
        };
        this.append = function (chunk) {
            var chunkOffset = 0;
            var chunkLen = chunk.byteLength || chunk.length || chunk.size || 0;
            var turnOffset = self$2.offset % self$2.maxChunkLen;
            var inputLen;
            self$2.offset += chunkLen;
            while (chunkOffset < chunkLen) {
                inputLen = Math.min(chunkLen - chunkOffset, self$2.maxChunkLen - turnOffset);
                write(chunk, chunkOffset, inputLen, turnOffset);
                turnOffset += inputLen;
                chunkOffset += inputLen;
                if (turnOffset === self$2.maxChunkLen) {
                    self$2.core.hash(self$2.maxChunkLen, self$2.padMaxChunkLen);
                    turnOffset = 0;
                }
            }
            return this;
        };
        this.getState = function () {
            var turnOffset = self$2.offset % self$2.maxChunkLen;
            var heap;
            if (!turnOffset) {
                var io = new Int32Array(self$2.heap, self$2.padMaxChunkLen + 320, 5);
                heap = io.buffer.slice(io.byteOffset, io.byteOffset + io.byteLength);
            } else {
                heap = self$2.heap.slice(0);
            }
            return {
                offset: self$2.offset,
                heap: heap
            };
        };
        this.setState = function (state) {
            self$2.offset = state.offset;
            if (state.heap.byteLength === 20) {
                var io = new Int32Array(self$2.heap, self$2.padMaxChunkLen + 320, 5);
                io.set(new Int32Array(state.heap));
            } else {
                self$2.h32.set(new Int32Array(state.heap));
            }
            return this;
        };
        var rawEnd = this.rawEnd = function () {
            var msgLen = self$2.offset;
            var chunkLen = msgLen % self$2.maxChunkLen;
            var padChunkLen = padChunk(chunkLen, msgLen);
            self$2.core.hash(padChunkLen, self$2.padMaxChunkLen);
            var result = getRawDigest(self$2.heap, self$2.padMaxChunkLen);
            initState(self$2.heap, self$2.padMaxChunkLen);
            return result;
        };
        this.end = function () {
            return hex(rawEnd().buffer);
        };
    }
    ;
    // The low-level RushCore module provides the heart of Rusha,
    // a high-speed sha1 implementation working on an Int32Array heap.
    // At first glance, the implementation seems complicated, however
    // with the SHA1 spec at hand, it is obvious this almost a textbook
    // implementation that has a few functions hand-inlined and a few loops
    // hand-unrolled.
    Rusha._core = function RushaCore(stdlib, foreign, heap) {
        'use asm';
        var H = new stdlib.Int32Array(heap);
        function hash(k, x) {
            // k in bytes
            k = k | 0;
            x = x | 0;
            var i = 0, j = 0, y0 = 0, z0 = 0, y1 = 0, z1 = 0, y2 = 0, z2 = 0, y3 = 0, z3 = 0, y4 = 0, z4 = 0, t0 = 0, t1 = 0;
            y0 = H[x + 320 >> 2] | 0;
            y1 = H[x + 324 >> 2] | 0;
            y2 = H[x + 328 >> 2] | 0;
            y3 = H[x + 332 >> 2] | 0;
            y4 = H[x + 336 >> 2] | 0;
            for (i = 0; (i | 0) < (k | 0); i = i + 64 | 0) {
                z0 = y0;
                z1 = y1;
                z2 = y2;
                z3 = y3;
                z4 = y4;
                for (j = 0; (j | 0) < 64; j = j + 4 | 0) {
                    t1 = H[i + j >> 2] | 0;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[k + j >> 2] = t1;
                }
                for (j = k + 64 | 0; (j | 0) < (k + 80 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 80 | 0; (j | 0) < (k + 160 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) + 1859775393 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 160 | 0; (j | 0) < (k + 240 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | y1 & y3 | y2 & y3) | 0) + ((t1 + y4 | 0) - 1894007588 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                for (j = k + 240 | 0; (j | 0) < (k + 320 | 0); j = j + 4 | 0) {
                    t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                    t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) - 899497514 | 0) | 0;
                    y4 = y3;
                    y3 = y2;
                    y2 = y1 << 30 | y1 >>> 2;
                    y1 = y0;
                    y0 = t0;
                    H[j >> 2] = t1;
                }
                y0 = y0 + z0 | 0;
                y1 = y1 + z1 | 0;
                y2 = y2 + z2 | 0;
                y3 = y3 + z3 | 0;
                y4 = y4 + z4 | 0;
            }
            H[x + 320 >> 2] = y0;
            H[x + 324 >> 2] = y1;
            H[x + 328 >> 2] = y2;
            H[x + 332 >> 2] = y3;
            H[x + 336 >> 2] = y4;
        }
        return { hash: hash };
    };
    if (// If we'e running in Node.JS, export a module.
        true) {
        module.exports = Rusha;
    } else if (// If we're running in a DOM context, export
        // the Rusha object to toplevel.
        typeof window !== 'undefined') {
        window.Rusha = Rusha;
    }
    if (// If we're running in a webworker, accept
        // messages containing a jobid and a buffer
        // or blob object, and return the hash result.
        typeof FileReaderSync !== 'undefined') {
        var reader = new FileReaderSync();
        var hashData = function hash(hasher, data, cb) {
            try {
                return cb(null, hasher.digest(data));
            } catch (e) {
                return cb(e);
            }
        };
        var hashFile = function hashArrayBuffer(hasher, readTotal, blockSize, file, cb) {
            var reader$2 = new self.FileReader();
            reader$2.onloadend = function onloadend() {
                var buffer = reader$2.result;
                readTotal += reader$2.result.byteLength;
                try {
                    hasher.append(buffer);
                } catch (e) {
                    cb(e);
                    return;
                }
                if (readTotal < file.size) {
                    hashFile(hasher, readTotal, blockSize, file, cb);
                } else {
                    cb(null, hasher.end());
                }
            };
            reader$2.readAsArrayBuffer(file.slice(readTotal, readTotal + blockSize));
        };
        self.onmessage = function onMessage(event) {
            var data = event.data.data, file = event.data.file, id = event.data.id;
            if (typeof id === 'undefined')
                return;
            if (!file && !data)
                return;
            var blockSize = event.data.blockSize || 4 * 1024 * 1024;
            var hasher = new Rusha(blockSize);
            hasher.resetState();
            var done = function done$2(err, hash) {
                if (!err) {
                    self.postMessage({
                        id: id,
                        hash: hash
                    });
                } else {
                    self.postMessage({
                        id: id,
                        error: err.name
                    });
                }
            };
            if (data)
                hashData(hasher, data, done);
            if (file)
                hashFile(hasher, 0, blockSize, file, done);
        };
    }
}());
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))

/***/ }),
/* 694 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66), __webpack_require__(146)))

/***/ }),
/* 695 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};


/***/ }),
/* 696 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(694);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 697 */
/***/ (function(module, exports) {

var TINF_OK = 0;
var TINF_DATA_ERROR = -3;

function Tree() {
  this.table = new Uint16Array(16);   /* table of code length counts */
  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
}

function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  
  this.dest = dest;
  this.destLen = 0;
  
  this.ltree = new Tree();  /* dynamic length/symbol tree */
  this.dtree = new Tree();  /* dynamic distance tree */
}

/* --------------------------------------------------- *
 * -- uninitialized global data (static structures) -- *
 * --------------------------------------------------- */

var sltree = new Tree();
var sdtree = new Tree();

/* extra bits and base tables for length codes */
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);

/* extra bits and base tables for distance codes */
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);

/* special ordering of code length codes */
var clcidx = new Uint8Array([
  16, 17, 18, 0, 8, 7, 9, 6,
  10, 5, 11, 4, 12, 3, 13, 2,
  14, 1, 15
]);

/* used by tinf_decode_trees, avoids allocations every call */
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);

/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */

/* build extra bits and base tables */
function tinf_build_bits_base(bits, base, delta, first) {
  var i, sum;

  /* build bits table */
  for (i = 0; i < delta; ++i) bits[i] = 0;
  for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;

  /* build base table */
  for (sum = first, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}

/* build the fixed huffman trees */
function tinf_build_fixed_trees(lt, dt) {
  var i;

  /* build fixed length tree */
  for (i = 0; i < 7; ++i) lt.table[i] = 0;

  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;

  for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;
  for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;
  for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;
  for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;

  /* build fixed distance tree */
  for (i = 0; i < 5; ++i) dt.table[i] = 0;

  dt.table[5] = 32;

  for (i = 0; i < 32; ++i) dt.trans[i] = i;
}

/* given an array of code lengths, build a tree */
var offs = new Uint16Array(16);

function tinf_build_tree(t, lengths, off, num) {
  var i, sum;

  /* clear code length count table */
  for (i = 0; i < 16; ++i) t.table[i] = 0;

  /* scan symbol lengths, and sum code length counts */
  for (i = 0; i < num; ++i) t.table[lengths[off + i]]++;

  t.table[0] = 0;

  /* compute offset table for distribution sort */
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t.table[i];
  }

  /* create code->symbol translation table (symbols sorted by code) */
  for (i = 0; i < num; ++i) {
    if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i;
  }
}

/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */

/* get one bit from source stream */
function tinf_getbit(d) {
  /* check if tag is empty */
  if (!d.bitcount--) {
    /* load next tag */
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }

  /* shift bit out of tag */
  var bit = d.tag & 1;
  d.tag >>>= 1;

  return bit;
}

/* read a num bit value from a stream and add base */
function tinf_read_bits(d, num, base) {
  if (!num)
    return base;

  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }

  var val = d.tag & (0xffff >>> (16 - num));
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}

/* given a data stream and a tree, decode a symbol */
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;

  /* get more bits while code value is above sum */
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;

    sum += t.table[len];
    cur -= t.table[len];
  } while (cur >= 0);
  
  d.tag = tag;
  d.bitcount -= len;

  return t.trans[sum + cur];
}

/* given a data stream, decode dynamic trees from it */
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;

  /* get 5 bits HLIT (257-286) */
  hlit = tinf_read_bits(d, 5, 257);

  /* get 5 bits HDIST (1-32) */
  hdist = tinf_read_bits(d, 5, 1);

  /* get 4 bits HCLEN (4-19) */
  hclen = tinf_read_bits(d, 4, 4);

  for (i = 0; i < 19; ++i) lengths[i] = 0;

  /* read code lengths for code length alphabet */
  for (i = 0; i < hclen; ++i) {
    /* get 3 bits code length (0-7) */
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }

  /* build code length tree */
  tinf_build_tree(code_tree, lengths, 0, 19);

  /* decode code lengths for the dynamic trees */
  for (num = 0; num < hlit + hdist;) {
    var sym = tinf_decode_symbol(d, code_tree);

    switch (sym) {
      case 16:
        /* copy previous code length 3-6 times (read 2 bits) */
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        /* repeat code length 0 for 3-10 times (read 3 bits) */
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        /* repeat code length 0 for 11-138 times (read 7 bits) */
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        /* values 0-15 represent the actual code lengths */
        lengths[num++] = sym;
        break;
    }
  }

  /* build dynamic trees */
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}

/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */

/* given a stream and two trees, inflate a block of data */
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);

    /* check for end of block */
    if (sym === 256) {
      return TINF_OK;
    }

    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs;
      var i;

      sym -= 257;

      /* possibly get more bits from length code */
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

      dist = tinf_decode_symbol(d, dt);

      /* possibly get more bits from distance code */
      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

      /* copy match */
      for (i = offs; i < offs + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}

/* inflate an uncompressed block of data */
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;
  
  /* unread from bitbuffer */
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }

  /* get length */
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];

  /* get one's complement of length */
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

  /* check length */
  if (length !== (~invlength & 0x0000ffff))
    return TINF_DATA_ERROR;

  d.sourceIndex += 4;

  /* copy block */
  for (i = length; i; --i)
    d.dest[d.destLen++] = d.source[d.sourceIndex++];

  /* make sure we start next block on a byte boundary */
  d.bitcount = 0;

  return TINF_OK;
}

/* inflate stream from source to dest */
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;

  do {
    /* read final block flag */
    bfinal = tinf_getbit(d);

    /* read block type (2 bits) */
    btype = tinf_read_bits(d, 2, 0);

    /* decompress block */
    switch (btype) {
      case 0:
        /* decompress uncompressed block */
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        /* decompress block with fixed huffman trees */
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        /* decompress block with dynamic huffman trees */
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }

    if (res !== TINF_OK)
      throw new Error('Data error');

  } while (!bfinal);

  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === 'function')
      return d.dest.slice(0, d.destLen);
    else
      return d.dest.subarray(0, d.destLen);
  }
  
  return d.dest;
}

/* -------------------- *
 * -- initialization -- *
 * -------------------- */

/* build fixed huffman trees */
tinf_build_fixed_trees(sltree, sdtree);

/* build extra bits and base tables */
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);

/* fix a special case */
length_bits[28] = 0;
length_base[28] = 258;

module.exports = tinf_uncompress;


/***/ }),
/* 698 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// transit-js 0.8.838
// http://transit-format.org
// 
// Copyright 2014 Cognitect. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License..
var COMPILED = !0, goog = goog || {};
goog.global = this;
goog.isDef = function(a) {
  return void 0 !== a;
};
goog.exportPath_ = function(a, b, c) {
  a = a.split(".");
  c = c || goog.global;
  a[0] in c || !c.execScript || c.execScript("var " + a[0]);
  for (var d;a.length && (d = a.shift());) {
    !a.length && goog.isDef(b) ? c[d] = b : c = c[d] ? c[d] : c[d] = {};
  }
};
goog.define = function(a, b) {
  var c = b;
  COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, a) ? c = goog.global.CLOSURE_UNCOMPILED_DEFINES[a] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]));
  goog.exportPath_(a, c);
};
goog.DEBUG = !0;
goog.LOCALE = "en";
goog.TRUSTED_SITE = !0;
goog.STRICT_MODE_COMPATIBLE = !1;
goog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;
goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1;
goog.provide = function(a) {
  if (!COMPILED && goog.isProvided_(a)) {
    throw Error('Namespace "' + a + '" already declared.');
  }
  goog.constructNamespace_(a);
};
goog.constructNamespace_ = function(a, b) {
  if (!COMPILED) {
    delete goog.implicitNamespaces_[a];
    for (var c = a;(c = c.substring(0, c.lastIndexOf("."))) && !goog.getObjectByName(c);) {
      goog.implicitNamespaces_[c] = !0;
    }
  }
  goog.exportPath_(a, b);
};
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
goog.module = function(a) {
  if (!goog.isString(a) || !a || -1 == a.search(goog.VALID_MODULE_RE_)) {
    throw Error("Invalid module identifier");
  }
  if (!goog.isInModuleLoader_()) {
    throw Error("Module " + a + " has been loaded incorrectly.");
  }
  if (goog.moduleLoaderState_.moduleName) {
    throw Error("goog.module may only be called once per module.");
  }
  goog.moduleLoaderState_.moduleName = a;
  if (!COMPILED) {
    if (goog.isProvided_(a)) {
      throw Error('Namespace "' + a + '" already declared.');
    }
    delete goog.implicitNamespaces_[a];
  }
};
goog.module.get = function(a) {
  return goog.module.getInternal_(a);
};
goog.module.getInternal_ = function(a) {
  if (!COMPILED) {
    return goog.isProvided_(a) ? a in goog.loadedModules_ ? goog.loadedModules_[a] : goog.getObjectByName(a) : null;
  }
};
goog.moduleLoaderState_ = null;
goog.isInModuleLoader_ = function() {
  return null != goog.moduleLoaderState_;
};
goog.module.declareTestMethods = function() {
  if (!goog.isInModuleLoader_()) {
    throw Error("goog.module.declareTestMethods must be called from within a goog.module");
  }
  goog.moduleLoaderState_.declareTestMethods = !0;
};
goog.module.declareLegacyNamespace = function() {
  if (!COMPILED && !goog.isInModuleLoader_()) {
    throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");
  }
  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
    throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");
  }
  goog.moduleLoaderState_.declareLegacyNamespace = !0;
};
goog.setTestOnly = function(a) {
  if (goog.DISALLOW_TEST_ONLY_CODE) {
    throw a = a || "", Error("Importing test-only code into non-debug environment" + (a ? ": " + a : "."));
  }
};
goog.forwardDeclare = function(a) {
};
COMPILED || (goog.isProvided_ = function(a) {
  return a in goog.loadedModules_ || !goog.implicitNamespaces_[a] && goog.isDefAndNotNull(goog.getObjectByName(a));
}, goog.implicitNamespaces_ = {"goog.module":!0});
goog.getObjectByName = function(a, b) {
  for (var c = a.split("."), d = b || goog.global, e;e = c.shift();) {
    if (goog.isDefAndNotNull(d[e])) {
      d = d[e];
    } else {
      return null;
    }
  }
  return d;
};
goog.globalize = function(a, b) {
  var c = b || goog.global, d;
  for (d in a) {
    c[d] = a[d];
  }
};
goog.addDependency = function(a, b, c, d) {
  if (goog.DEPENDENCIES_ENABLED) {
    var e;
    a = a.replace(/\\/g, "/");
    for (var f = goog.dependencies_, g = 0;e = b[g];g++) {
      f.nameToPath[e] = a, f.pathIsModule[a] = !!d;
    }
    for (d = 0;b = c[d];d++) {
      a in f.requires || (f.requires[a] = {}), f.requires[a][b] = !0;
    }
  }
};
goog.ENABLE_DEBUG_LOADER = !0;
goog.logToConsole_ = function(a) {
  goog.global.console && goog.global.console.error(a);
};
goog.require = function(a) {
  if (!COMPILED) {
    goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_ && goog.maybeProcessDeferredDep_(a);
    if (goog.isProvided_(a)) {
      return goog.isInModuleLoader_() ? goog.module.getInternal_(a) : null;
    }
    if (goog.ENABLE_DEBUG_LOADER) {
      var b = goog.getPathFromDeps_(a);
      if (b) {
        return goog.included_[b] = !0, goog.writeScripts_(), null;
      }
    }
    a = "goog.require could not find: " + a;
    goog.logToConsole_(a);
    throw Error(a);
  }
};
goog.basePath = "";
goog.nullFunction = function() {
};
goog.abstractMethod = function() {
  throw Error("unimplemented abstract method");
};
goog.addSingletonGetter = function(a) {
  a.getInstance = function() {
    if (a.instance_) {
      return a.instance_;
    }
    goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
    return a.instance_ = new a;
  };
};
goog.instantiatedSingletons_ = [];
goog.LOAD_MODULE_USING_EVAL = !0;
goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
goog.loadedModules_ = {};
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = {pathIsModule:{}, nameToPath:{}, requires:{}, visited:{}, written:{}, deferred:{}}, goog.inHtmlDocument_ = function() {
  var a = goog.global.document;
  return "undefined" != typeof a && "write" in a;
}, goog.findBasePath_ = function() {
  if (goog.global.CLOSURE_BASE_PATH) {
    goog.basePath = goog.global.CLOSURE_BASE_PATH;
  } else {
    if (goog.inHtmlDocument_()) {
      for (var a = goog.global.document.getElementsByTagName("SCRIPT"), b = a.length - 1;0 <= b;--b) {
        var c = a[b].src, d = c.lastIndexOf("?"), d = -1 == d ? c.length : d;
        if ("base.js" == c.substr(d - 7, 7)) {
          goog.basePath = c.substr(0, d - 7);
          break;
        }
      }
    }
  }
}, goog.importScript_ = function(a, b) {
  (goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_)(a, b) && (goog.dependencies_.written[a] = !0);
}, goog.IS_OLD_IE_ = !goog.global.atob && goog.global.document && goog.global.document.all, goog.importModule_ = function(a) {
  goog.importScript_("", 'goog.retrieveAndExecModule_("' + a + '");') && (goog.dependencies_.written[a] = !0);
}, goog.queuedModules_ = [], goog.wrapModule_ = function(a, b) {
  return goog.LOAD_MODULE_USING_EVAL && goog.isDef(goog.global.JSON) ? "goog.loadModule(" + goog.global.JSON.stringify(b + "\n//# sourceURL=" + a + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + b + "\n;return exports});\n//# sourceURL=" + a + "\n";
}, goog.loadQueuedModules_ = function() {
  var a = goog.queuedModules_.length;
  if (0 < a) {
    var b = goog.queuedModules_;
    goog.queuedModules_ = [];
    for (var c = 0;c < a;c++) {
      goog.maybeProcessDeferredPath_(b[c]);
    }
  }
}, goog.maybeProcessDeferredDep_ = function(a) {
  goog.isDeferredModule_(a) && goog.allDepsAreAvailable_(a) && (a = goog.getPathFromDeps_(a), goog.maybeProcessDeferredPath_(goog.basePath + a));
}, goog.isDeferredModule_ = function(a) {
  return (a = goog.getPathFromDeps_(a)) && goog.dependencies_.pathIsModule[a] ? goog.basePath + a in goog.dependencies_.deferred : !1;
}, goog.allDepsAreAvailable_ = function(a) {
  if ((a = goog.getPathFromDeps_(a)) && a in goog.dependencies_.requires) {
    for (var b in goog.dependencies_.requires[a]) {
      if (!goog.isProvided_(b) && !goog.isDeferredModule_(b)) {
        return !1;
      }
    }
  }
  return !0;
}, goog.maybeProcessDeferredPath_ = function(a) {
  if (a in goog.dependencies_.deferred) {
    var b = goog.dependencies_.deferred[a];
    delete goog.dependencies_.deferred[a];
    goog.globalEval(b);
  }
}, goog.loadModule = function(a) {
  var b = goog.moduleLoaderState_;
  try {
    goog.moduleLoaderState_ = {moduleName:void 0, declareTestMethods:!1};
    var c;
    if (goog.isFunction(a)) {
      c = a.call(goog.global, {});
    } else {
      if (goog.isString(a)) {
        c = goog.loadModuleFromSource_.call(goog.global, a);
      } else {
        throw Error("Invalid module definition");
      }
    }
    var d = goog.moduleLoaderState_.moduleName;
    if (!goog.isString(d) || !d) {
      throw Error('Invalid module name "' + d + '"');
    }
    goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(d, c) : goog.SEAL_MODULE_EXPORTS && Object.seal && Object.seal(c);
    goog.loadedModules_[d] = c;
    if (goog.moduleLoaderState_.declareTestMethods) {
      for (var e in c) {
        if (0 === e.indexOf("test", 0) || "tearDown" == e || "setUp" == e || "setUpPage" == e || "tearDownPage" == e) {
          goog.global[e] = c[e];
        }
      }
    }
  } finally {
    goog.moduleLoaderState_ = b;
  }
}, goog.loadModuleFromSource_ = function(a) {
  eval(a);
  return {};
}, goog.writeScriptSrcNode_ = function(a) {
  goog.global.document.write('<script type="text/javascript" src="' + a + '">\x3c/script>');
}, goog.appendScriptSrcNode_ = function(a) {
  var b = goog.global.document, c = b.createElement("script");
  c.type = "text/javascript";
  c.src = a;
  c.defer = !1;
  c.async = !1;
  b.head.appendChild(c);
}, goog.writeScriptTag_ = function(a, b) {
  if (goog.inHtmlDocument_()) {
    var c = goog.global.document;
    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && "complete" == c.readyState) {
      if (/\bdeps.js$/.test(a)) {
        return !1;
      }
      throw Error('Cannot write "' + a + '" after document load');
    }
    var d = goog.IS_OLD_IE_;
    void 0 === b ? d ? (d = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ", c.write('<script type="text/javascript" src="' + a + '"' + d + ">\x3c/script>")) : goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING ? goog.appendScriptSrcNode_(a) : goog.writeScriptSrcNode_(a) : c.write('<script type="text/javascript">' + b + "\x3c/script>");
    return !0;
  }
  return !1;
}, goog.lastNonModuleScriptIndex_ = 0, goog.onScriptLoad_ = function(a, b) {
  "complete" == a.readyState && goog.lastNonModuleScriptIndex_ == b && goog.loadQueuedModules_();
  return !0;
}, goog.writeScripts_ = function() {
  function a(e) {
    if (!(e in d.written)) {
      if (!(e in d.visited) && (d.visited[e] = !0, e in d.requires)) {
        for (var f in d.requires[e]) {
          if (!goog.isProvided_(f)) {
            if (f in d.nameToPath) {
              a(d.nameToPath[f]);
            } else {
              throw Error("Undefined nameToPath for " + f);
            }
          }
        }
      }
      e in c || (c[e] = !0, b.push(e));
    }
  }
  var b = [], c = {}, d = goog.dependencies_, e;
  for (e in goog.included_) {
    d.written[e] || a(e);
  }
  for (var f = 0;f < b.length;f++) {
    e = b[f], goog.dependencies_.written[e] = !0;
  }
  var g = goog.moduleLoaderState_;
  goog.moduleLoaderState_ = null;
  for (f = 0;f < b.length;f++) {
    if (e = b[f]) {
      d.pathIsModule[e] ? goog.importModule_(goog.basePath + e) : goog.importScript_(goog.basePath + e);
    } else {
      throw goog.moduleLoaderState_ = g, Error("Undefined script input");
    }
  }
  goog.moduleLoaderState_ = g;
}, goog.getPathFromDeps_ = function(a) {
  return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;
}, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + "deps.js"));
goog.normalizePath_ = function(a) {
  a = a.split("/");
  for (var b = 0;b < a.length;) {
    "." == a[b] ? a.splice(b, 1) : b && ".." == a[b] && a[b - 1] && ".." != a[b - 1] ? a.splice(--b, 2) : b++;
  }
  return a.join("/");
};
goog.loadFileSync_ = function(a) {
  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
    return goog.global.CLOSURE_LOAD_FILE_SYNC(a);
  }
  var b = new goog.global.XMLHttpRequest;
  b.open("get", a, !1);
  b.send();
  return b.responseText;
};
goog.retrieveAndExecModule_ = function(a) {
  if (!COMPILED) {
    var b = a;
    a = goog.normalizePath_(a);
    var c = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_, d = goog.loadFileSync_(a);
    if (null != d) {
      d = goog.wrapModule_(a, d), goog.IS_OLD_IE_ ? (goog.dependencies_.deferred[b] = d, goog.queuedModules_.push(b)) : c(a, d);
    } else {
      throw Error("load of " + a + "failed");
    }
  }
};
goog.typeOf = function(a) {
  var b = typeof a;
  if ("object" == b) {
    if (a) {
      if (a instanceof Array) {
        return "array";
      }
      if (a instanceof Object) {
        return b;
      }
      var c = Object.prototype.toString.call(a);
      if ("[object Window]" == c) {
        return "object";
      }
      if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
        return "array";
      }
      if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
        return "function";
      }
    } else {
      return "null";
    }
  } else {
    if ("function" == b && "undefined" == typeof a.call) {
      return "object";
    }
  }
  return b;
};
goog.isNull = function(a) {
  return null === a;
};
goog.isDefAndNotNull = function(a) {
  return null != a;
};
goog.isArray = function(a) {
  return "array" == goog.typeOf(a);
};
goog.isArrayLike = function(a) {
  var b = goog.typeOf(a);
  return "array" == b || "object" == b && "number" == typeof a.length;
};
goog.isDateLike = function(a) {
  return goog.isObject(a) && "function" == typeof a.getFullYear;
};
goog.isString = function(a) {
  return "string" == typeof a;
};
goog.isBoolean = function(a) {
  return "boolean" == typeof a;
};
goog.isNumber = function(a) {
  return "number" == typeof a;
};
goog.isFunction = function(a) {
  return "function" == goog.typeOf(a);
};
goog.isObject = function(a) {
  var b = typeof a;
  return "object" == b && null != a || "function" == b;
};
goog.getUid = function(a) {
  return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};
goog.hasUid = function(a) {
  return !!a[goog.UID_PROPERTY_];
};
goog.removeUid = function(a) {
  "removeAttribute" in a && a.removeAttribute(goog.UID_PROPERTY_);
  try {
    delete a[goog.UID_PROPERTY_];
  } catch (b) {
  }
};
goog.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
goog.uidCounter_ = 0;
goog.getHashCode = goog.getUid;
goog.removeHashCode = goog.removeUid;
goog.cloneObject = function(a) {
  var b = goog.typeOf(a);
  if ("object" == b || "array" == b) {
    if (a.clone) {
      return a.clone();
    }
    var b = "array" == b ? [] : {}, c;
    for (c in a) {
      b[c] = goog.cloneObject(a[c]);
    }
    return b;
  }
  return a;
};
goog.bindNative_ = function(a, b, c) {
  return a.call.apply(a.bind, arguments);
};
goog.bindJs_ = function(a, b, c) {
  if (!a) {
    throw Error();
  }
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var c = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(c, d);
      return a.apply(b, c);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
};
goog.bind = function(a, b, c) {
  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
  return goog.bind.apply(null, arguments);
};
goog.partial = function(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var b = c.slice();
    b.push.apply(b, arguments);
    return a.apply(this, b);
  };
};
goog.mixin = function(a, b) {
  for (var c in b) {
    a[c] = b[c];
  }
};
goog.now = goog.TRUSTED_SITE && Date.now || function() {
  return +new Date;
};
goog.globalEval = function(a) {
  if (goog.global.execScript) {
    goog.global.execScript(a, "JavaScript");
  } else {
    if (goog.global.eval) {
      if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), "undefined" != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_) {
        goog.global.eval(a);
      } else {
        var b = goog.global.document, c = b.createElement("SCRIPT");
        c.type = "text/javascript";
        c.defer = !1;
        c.appendChild(b.createTextNode(a));
        b.body.appendChild(c);
        b.body.removeChild(c);
      }
    } else {
      throw Error("goog.globalEval not available");
    }
  }
};
goog.evalWorksForGlobals_ = null;
goog.getCssName = function(a, b) {
  var c = function(a) {
    return goog.cssNameMapping_[a] || a;
  }, d = function(a) {
    a = a.split("-");
    for (var b = [], d = 0;d < a.length;d++) {
      b.push(c(a[d]));
    }
    return b.join("-");
  }, d = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c : d : function(a) {
    return a;
  };
  return b ? a + "-" + d(b) : d(a);
};
goog.setCssNameMapping = function(a, b) {
  goog.cssNameMapping_ = a;
  goog.cssNameMappingStyle_ = b;
};
!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
goog.getMsg = function(a, b) {
  b && (a = a.replace(/\{\$([^}]+)}/g, function(a, d) {
    return d in b ? b[d] : a;
  }));
  return a;
};
goog.getMsgWithFallback = function(a, b) {
  return a;
};
goog.exportSymbol = function(a, b, c) {
  goog.exportPath_(a, b, c);
};
goog.exportProperty = function(a, b, c) {
  a[b] = c;
};
goog.inherits = function(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.superClass_ = b.prototype;
  a.prototype = new c;
  a.prototype.constructor = a;
  a.base = function(a, c, f) {
    for (var g = Array(arguments.length - 2), h = 2;h < arguments.length;h++) {
      g[h - 2] = arguments[h];
    }
    return b.prototype[c].apply(a, g);
  };
};
goog.base = function(a, b, c) {
  var d = arguments.callee.caller;
  if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !d) {
    throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
  }
  if (d.superClass_) {
    for (var e = Array(arguments.length - 1), f = 1;f < arguments.length;f++) {
      e[f - 1] = arguments[f];
    }
    return d.superClass_.constructor.apply(a, e);
  }
  e = Array(arguments.length - 2);
  for (f = 2;f < arguments.length;f++) {
    e[f - 2] = arguments[f];
  }
  for (var f = !1, g = a.constructor;g;g = g.superClass_ && g.superClass_.constructor) {
    if (g.prototype[b] === d) {
      f = !0;
    } else {
      if (f) {
        return g.prototype[b].apply(a, e);
      }
    }
  }
  if (a[b] === d) {
    return a.constructor.prototype[b].apply(a, e);
  }
  throw Error("goog.base called from a method of one name to a method of a different name");
};
goog.scope = function(a) {
  a.call(goog.global);
};
COMPILED || (goog.global.COMPILED = COMPILED);
goog.defineClass = function(a, b) {
  var c = b.constructor, d = b.statics;
  c && c != Object.prototype.constructor || (c = function() {
    throw Error("cannot instantiate an interface (no constructor defined).");
  });
  c = goog.defineClass.createSealingConstructor_(c, a);
  a && goog.inherits(c, a);
  delete b.constructor;
  delete b.statics;
  goog.defineClass.applyProperties_(c.prototype, b);
  null != d && (d instanceof Function ? d(c) : goog.defineClass.applyProperties_(c, d));
  return c;
};
goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;
goog.defineClass.createSealingConstructor_ = function(a, b) {
  if (goog.defineClass.SEAL_CLASS_INSTANCES && Object.seal instanceof Function) {
    if (b && b.prototype && b.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) {
      return a;
    }
    var c = function() {
      var b = a.apply(this, arguments) || this;
      b[goog.UID_PROPERTY_] = b[goog.UID_PROPERTY_];
      this.constructor === c && Object.seal(b);
      return b;
    };
    return c;
  }
  return a;
};
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
goog.defineClass.applyProperties_ = function(a, b) {
  for (var c in b) {
    Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
  }
  for (var d = 0;d < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++) {
    c = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d], Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
  }
};
goog.tagUnsealableClass = function(a) {
  !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0);
};
goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
goog.math = {};
goog.math.Long = function(a, b) {
  this.low_ = a | 0;
  this.high_ = b | 0;
};
goog.math.Long.IntCache_ = {};
goog.math.Long.fromInt = function(a) {
  if (-128 <= a && 128 > a) {
    var b = goog.math.Long.IntCache_[a];
    if (b) {
      return b;
    }
  }
  b = new goog.math.Long(a | 0, 0 > a ? -1 : 0);
  -128 <= a && 128 > a && (goog.math.Long.IntCache_[a] = b);
  return b;
};
goog.math.Long.fromNumber = function(a) {
  return isNaN(a) || !isFinite(a) ? goog.math.Long.getZero() : a <= -goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMinValue() : a + 1 >= goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMaxValue() : 0 > a ? goog.math.Long.fromNumber(-a).negate() : new goog.math.Long(a % goog.math.Long.TWO_PWR_32_DBL_ | 0, a / goog.math.Long.TWO_PWR_32_DBL_ | 0);
};
goog.math.Long.fromBits = function(a, b) {
  return new goog.math.Long(a, b);
};
goog.math.Long.fromString = function(a, b) {
  if (0 == a.length) {
    throw Error("number format error: empty string");
  }
  var c = b || 10;
  if (2 > c || 36 < c) {
    throw Error("radix out of range: " + c);
  }
  if ("-" == a.charAt(0)) {
    return goog.math.Long.fromString(a.substring(1), c).negate();
  }
  if (0 <= a.indexOf("-")) {
    throw Error('number format error: interior "-" character: ' + a);
  }
  for (var d = goog.math.Long.fromNumber(Math.pow(c, 8)), e = goog.math.Long.getZero(), f = 0;f < a.length;f += 8) {
    var g = Math.min(8, a.length - f), h = parseInt(a.substring(f, f + g), c);
    8 > g ? (g = goog.math.Long.fromNumber(Math.pow(c, g)), e = e.multiply(g).add(goog.math.Long.fromNumber(h))) : (e = e.multiply(d), e = e.add(goog.math.Long.fromNumber(h)));
  }
  return e;
};
goog.math.Long.TWO_PWR_16_DBL_ = 65536;
goog.math.Long.getTwoPwr24DBL_ = 16777216;
goog.math.Long.TWO_PWR_32_DBL_ = goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;
goog.math.Long.TWO_PWR_31_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ / 2;
goog.math.Long.TWO_PWR_48_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;
goog.math.Long.TWO_PWR_64_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;
goog.math.Long.TWO_PWR_63_DBL_ = goog.math.Long.TWO_PWR_64_DBL_ / 2;
goog.math.Long.getZero = function() {
  goog.math.Long.ZERO_ || (goog.math.Long.ZERO_ = goog.math.Long.fromInt(0));
  return goog.math.Long.ZERO_;
};
goog.math.Long.getOne = function() {
  goog.math.Long.ONE_ || (goog.math.Long.ONE_ = goog.math.Long.fromInt(1));
  return goog.math.Long.ONE_;
};
goog.math.Long.getNegOne = function() {
  goog.math.Long.NEG_ONE_ || (goog.math.Long.NEG_ONE_ = goog.math.Long.fromInt(-1));
  return goog.math.Long.NEG_ONE_;
};
goog.math.Long.getMaxValue = function() {
  goog.math.Long.MAX_VALUE_ || (goog.math.Long.MAX_VALUE_ = goog.math.Long.fromBits(-1, 2147483647));
  return goog.math.Long.MAX_VALUE_;
};
goog.math.Long.getMinValue = function() {
  goog.math.Long.MIN_VALUE_ || (goog.math.Long.MIN_VALUE_ = goog.math.Long.fromBits(0, -2147483648));
  return goog.math.Long.MIN_VALUE_;
};
goog.math.Long.getTwoPwr24 = function() {
  goog.math.Long.TWO_PWR_24_ || (goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(16777216));
  return goog.math.Long.TWO_PWR_24_;
};
goog.math.Long.prototype.toInt = function() {
  return this.low_;
};
goog.math.Long.prototype.toNumber = function() {
  return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
};
goog.math.Long.prototype.toString = function(a) {
  a = a || 10;
  if (2 > a || 36 < a) {
    throw Error("radix out of range: " + a);
  }
  if (this.isZero()) {
    return "0";
  }
  if (this.isNegative()) {
    if (this.equals(goog.math.Long.getMinValue())) {
      var b = goog.math.Long.fromNumber(a), c = this.div(b), b = c.multiply(b).subtract(this);
      return c.toString(a) + b.toInt().toString(a);
    }
    return "-" + this.negate().toString(a);
  }
  for (var c = goog.math.Long.fromNumber(Math.pow(a, 6)), b = this, d = "";;) {
    var e = b.div(c), f = b.subtract(e.multiply(c)).toInt().toString(a), b = e;
    if (b.isZero()) {
      return f + d;
    }
    for (;6 > f.length;) {
      f = "0" + f;
    }
    d = "" + f + d;
  }
};
goog.math.Long.prototype.getHighBits = function() {
  return this.high_;
};
goog.math.Long.prototype.getLowBits = function() {
  return this.low_;
};
goog.math.Long.prototype.getLowBitsUnsigned = function() {
  return 0 <= this.low_ ? this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
};
goog.math.Long.prototype.getNumBitsAbs = function() {
  if (this.isNegative()) {
    return this.equals(goog.math.Long.getMinValue()) ? 64 : this.negate().getNumBitsAbs();
  }
  for (var a = 0 != this.high_ ? this.high_ : this.low_, b = 31;0 < b && 0 == (a & 1 << b);b--) {
  }
  return 0 != this.high_ ? b + 33 : b + 1;
};
goog.math.Long.prototype.isZero = function() {
  return 0 == this.high_ && 0 == this.low_;
};
goog.math.Long.prototype.isNegative = function() {
  return 0 > this.high_;
};
goog.math.Long.prototype.isOdd = function() {
  return 1 == (this.low_ & 1);
};
goog.math.Long.prototype.equals = function(a) {
  return this.high_ == a.high_ && this.low_ == a.low_;
};
goog.math.Long.prototype.notEquals = function(a) {
  return this.high_ != a.high_ || this.low_ != a.low_;
};
goog.math.Long.prototype.lessThan = function(a) {
  return 0 > this.compare(a);
};
goog.math.Long.prototype.lessThanOrEqual = function(a) {
  return 0 >= this.compare(a);
};
goog.math.Long.prototype.greaterThan = function(a) {
  return 0 < this.compare(a);
};
goog.math.Long.prototype.greaterThanOrEqual = function(a) {
  return 0 <= this.compare(a);
};
goog.math.Long.prototype.compare = function(a) {
  if (this.equals(a)) {
    return 0;
  }
  var b = this.isNegative(), c = a.isNegative();
  return b && !c ? -1 : !b && c ? 1 : this.subtract(a).isNegative() ? -1 : 1;
};
goog.math.Long.prototype.negate = function() {
  return this.equals(goog.math.Long.getMinValue()) ? goog.math.Long.getMinValue() : this.not().add(goog.math.Long.getOne());
};
goog.math.Long.prototype.add = function(a) {
  var b = this.high_ >>> 16, c = this.high_ & 65535, d = this.low_ >>> 16, e = a.high_ >>> 16, f = a.high_ & 65535, g = a.low_ >>> 16, h;
  h = 0 + ((this.low_ & 65535) + (a.low_ & 65535));
  a = 0 + (h >>> 16);
  a += d + g;
  d = 0 + (a >>> 16);
  d += c + f;
  c = 0 + (d >>> 16);
  c = c + (b + e) & 65535;
  return goog.math.Long.fromBits((a & 65535) << 16 | h & 65535, c << 16 | d & 65535);
};
goog.math.Long.prototype.subtract = function(a) {
  return this.add(a.negate());
};
goog.math.Long.prototype.multiply = function(a) {
  if (this.isZero() || a.isZero()) {
    return goog.math.Long.getZero();
  }
  if (this.equals(goog.math.Long.getMinValue())) {
    return a.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();
  }
  if (a.equals(goog.math.Long.getMinValue())) {
    return this.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();
  }
  if (this.isNegative()) {
    return a.isNegative() ? this.negate().multiply(a.negate()) : this.negate().multiply(a).negate();
  }
  if (a.isNegative()) {
    return this.multiply(a.negate()).negate();
  }
  if (this.lessThan(goog.math.Long.getTwoPwr24()) && a.lessThan(goog.math.Long.getTwoPwr24())) {
    return goog.math.Long.fromNumber(this.toNumber() * a.toNumber());
  }
  var b = this.high_ >>> 16, c = this.high_ & 65535, d = this.low_ >>> 16, e = this.low_ & 65535, f = a.high_ >>> 16, g = a.high_ & 65535, h = a.low_ >>> 16;
  a = a.low_ & 65535;
  var m, k, l, n;
  n = 0 + e * a;
  l = 0 + (n >>> 16);
  l += d * a;
  k = 0 + (l >>> 16);
  l = (l & 65535) + e * h;
  k += l >>> 16;
  l &= 65535;
  k += c * a;
  m = 0 + (k >>> 16);
  k = (k & 65535) + d * h;
  m += k >>> 16;
  k &= 65535;
  k += e * g;
  m += k >>> 16;
  k &= 65535;
  m = m + (b * a + c * h + d * g + e * f) & 65535;
  return goog.math.Long.fromBits(l << 16 | n & 65535, m << 16 | k);
};
goog.math.Long.prototype.div = function(a) {
  if (a.isZero()) {
    throw Error("division by zero");
  }
  if (this.isZero()) {
    return goog.math.Long.getZero();
  }
  if (this.equals(goog.math.Long.getMinValue())) {
    if (a.equals(goog.math.Long.getOne()) || a.equals(goog.math.Long.getNegOne())) {
      return goog.math.Long.getMinValue();
    }
    if (a.equals(goog.math.Long.getMinValue())) {
      return goog.math.Long.getOne();
    }
    var b = this.shiftRight(1).div(a).shiftLeft(1);
    if (b.equals(goog.math.Long.getZero())) {
      return a.isNegative() ? goog.math.Long.getOne() : goog.math.Long.getNegOne();
    }
    var c = this.subtract(a.multiply(b));
    return b.add(c.div(a));
  }
  if (a.equals(goog.math.Long.getMinValue())) {
    return goog.math.Long.getZero();
  }
  if (this.isNegative()) {
    return a.isNegative() ? this.negate().div(a.negate()) : this.negate().div(a).negate();
  }
  if (a.isNegative()) {
    return this.div(a.negate()).negate();
  }
  for (var d = goog.math.Long.getZero(), c = this;c.greaterThanOrEqual(a);) {
    for (var b = Math.max(1, Math.floor(c.toNumber() / a.toNumber())), e = Math.ceil(Math.log(b) / Math.LN2), e = 48 >= e ? 1 : Math.pow(2, e - 48), f = goog.math.Long.fromNumber(b), g = f.multiply(a);g.isNegative() || g.greaterThan(c);) {
      b -= e, f = goog.math.Long.fromNumber(b), g = f.multiply(a);
    }
    f.isZero() && (f = goog.math.Long.getOne());
    d = d.add(f);
    c = c.subtract(g);
  }
  return d;
};
goog.math.Long.prototype.modulo = function(a) {
  return this.subtract(this.div(a).multiply(a));
};
goog.math.Long.prototype.not = function() {
  return goog.math.Long.fromBits(~this.low_, ~this.high_);
};
goog.math.Long.prototype.and = function(a) {
  return goog.math.Long.fromBits(this.low_ & a.low_, this.high_ & a.high_);
};
goog.math.Long.prototype.or = function(a) {
  return goog.math.Long.fromBits(this.low_ | a.low_, this.high_ | a.high_);
};
goog.math.Long.prototype.xor = function(a) {
  return goog.math.Long.fromBits(this.low_ ^ a.low_, this.high_ ^ a.high_);
};
goog.math.Long.prototype.shiftLeft = function(a) {
  a &= 63;
  if (0 == a) {
    return this;
  }
  var b = this.low_;
  return 32 > a ? goog.math.Long.fromBits(b << a, this.high_ << a | b >>> 32 - a) : goog.math.Long.fromBits(0, b << a - 32);
};
goog.math.Long.prototype.shiftRight = function(a) {
  a &= 63;
  if (0 == a) {
    return this;
  }
  var b = this.high_;
  return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >> a) : goog.math.Long.fromBits(b >> a - 32, 0 <= b ? 0 : -1);
};
goog.math.Long.prototype.shiftRightUnsigned = function(a) {
  a &= 63;
  if (0 == a) {
    return this;
  }
  var b = this.high_;
  return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >>> a) : 32 == a ? goog.math.Long.fromBits(b, 0) : goog.math.Long.fromBits(b >>> a - 32, 0);
};
goog.object = {};
goog.object.forEach = function(a, b, c) {
  for (var d in a) {
    b.call(c, a[d], d, a);
  }
};
goog.object.filter = function(a, b, c) {
  var d = {}, e;
  for (e in a) {
    b.call(c, a[e], e, a) && (d[e] = a[e]);
  }
  return d;
};
goog.object.map = function(a, b, c) {
  var d = {}, e;
  for (e in a) {
    d[e] = b.call(c, a[e], e, a);
  }
  return d;
};
goog.object.some = function(a, b, c) {
  for (var d in a) {
    if (b.call(c, a[d], d, a)) {
      return !0;
    }
  }
  return !1;
};
goog.object.every = function(a, b, c) {
  for (var d in a) {
    if (!b.call(c, a[d], d, a)) {
      return !1;
    }
  }
  return !0;
};
goog.object.getCount = function(a) {
  var b = 0, c;
  for (c in a) {
    b++;
  }
  return b;
};
goog.object.getAnyKey = function(a) {
  for (var b in a) {
    return b;
  }
};
goog.object.getAnyValue = function(a) {
  for (var b in a) {
    return a[b];
  }
};
goog.object.contains = function(a, b) {
  return goog.object.containsValue(a, b);
};
goog.object.getValues = function(a) {
  var b = [], c = 0, d;
  for (d in a) {
    b[c++] = a[d];
  }
  return b;
};
goog.object.getKeys = function(a) {
  var b = [], c = 0, d;
  for (d in a) {
    b[c++] = d;
  }
  return b;
};
goog.object.getValueByKeys = function(a, b) {
  for (var c = goog.isArrayLike(b), d = c ? b : arguments, c = c ? 0 : 1;c < d.length && (a = a[d[c]], goog.isDef(a));c++) {
  }
  return a;
};
goog.object.containsKey = function(a, b) {
  return b in a;
};
goog.object.containsValue = function(a, b) {
  for (var c in a) {
    if (a[c] == b) {
      return !0;
    }
  }
  return !1;
};
goog.object.findKey = function(a, b, c) {
  for (var d in a) {
    if (b.call(c, a[d], d, a)) {
      return d;
    }
  }
};
goog.object.findValue = function(a, b, c) {
  return (b = goog.object.findKey(a, b, c)) && a[b];
};
goog.object.isEmpty = function(a) {
  for (var b in a) {
    return !1;
  }
  return !0;
};
goog.object.clear = function(a) {
  for (var b in a) {
    delete a[b];
  }
};
goog.object.remove = function(a, b) {
  var c;
  (c = b in a) && delete a[b];
  return c;
};
goog.object.add = function(a, b, c) {
  if (b in a) {
    throw Error('The object already contains the key "' + b + '"');
  }
  goog.object.set(a, b, c);
};
goog.object.get = function(a, b, c) {
  return b in a ? a[b] : c;
};
goog.object.set = function(a, b, c) {
  a[b] = c;
};
goog.object.setIfUndefined = function(a, b, c) {
  return b in a ? a[b] : a[b] = c;
};
goog.object.setWithReturnValueIfNotSet = function(a, b, c) {
  if (b in a) {
    return a[b];
  }
  c = c();
  return a[b] = c;
};
goog.object.equals = function(a, b) {
  for (var c in a) {
    if (!(c in b) || a[c] !== b[c]) {
      return !1;
    }
  }
  for (c in b) {
    if (!(c in a)) {
      return !1;
    }
  }
  return !0;
};
goog.object.clone = function(a) {
  var b = {}, c;
  for (c in a) {
    b[c] = a[c];
  }
  return b;
};
goog.object.unsafeClone = function(a) {
  var b = goog.typeOf(a);
  if ("object" == b || "array" == b) {
    if (a.clone) {
      return a.clone();
    }
    var b = "array" == b ? [] : {}, c;
    for (c in a) {
      b[c] = goog.object.unsafeClone(a[c]);
    }
    return b;
  }
  return a;
};
goog.object.transpose = function(a) {
  var b = {}, c;
  for (c in a) {
    b[a[c]] = c;
  }
  return b;
};
goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
goog.object.extend = function(a, b) {
  for (var c, d, e = 1;e < arguments.length;e++) {
    d = arguments[e];
    for (c in d) {
      a[c] = d[c];
    }
    for (var f = 0;f < goog.object.PROTOTYPE_FIELDS_.length;f++) {
      c = goog.object.PROTOTYPE_FIELDS_[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
    }
  }
};
goog.object.create = function(a) {
  var b = arguments.length;
  if (1 == b && goog.isArray(arguments[0])) {
    return goog.object.create.apply(null, arguments[0]);
  }
  if (b % 2) {
    throw Error("Uneven number of arguments");
  }
  for (var c = {}, d = 0;d < b;d += 2) {
    c[arguments[d]] = arguments[d + 1];
  }
  return c;
};
goog.object.createSet = function(a) {
  var b = arguments.length;
  if (1 == b && goog.isArray(arguments[0])) {
    return goog.object.createSet.apply(null, arguments[0]);
  }
  for (var c = {}, d = 0;d < b;d++) {
    c[arguments[d]] = !0;
  }
  return c;
};
goog.object.createImmutableView = function(a) {
  var b = a;
  Object.isFrozen && !Object.isFrozen(a) && (b = Object.create(a), Object.freeze(b));
  return b;
};
goog.object.isImmutableView = function(a) {
  return !!Object.isFrozen && Object.isFrozen(a);
};
var com = {cognitect:{}};
com.cognitect.transit = {};
com.cognitect.transit.delimiters = {};
com.cognitect.transit.delimiters.ESC = "~";
com.cognitect.transit.delimiters.TAG = "#";
com.cognitect.transit.delimiters.SUB = "^";
com.cognitect.transit.delimiters.RES = "`";
com.cognitect.transit.delimiters.ESC_TAG = "~#";
com.cognitect.transit.caching = {};
com.cognitect.transit.caching.MIN_SIZE_CACHEABLE = 3;
com.cognitect.transit.caching.BASE_CHAR_IDX = 48;
com.cognitect.transit.caching.CACHE_CODE_DIGITS = 44;
com.cognitect.transit.caching.MAX_CACHE_ENTRIES = com.cognitect.transit.caching.CACHE_CODE_DIGITS * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
com.cognitect.transit.caching.MAX_CACHE_SIZE = 4096;
com.cognitect.transit.caching.isCacheable = function(a, b) {
  if (a.length > com.cognitect.transit.caching.MIN_SIZE_CACHEABLE) {
    if (b) {
      return !0;
    }
    var c = a.charAt(0), d = a.charAt(1);
    return c === com.cognitect.transit.delimiters.ESC ? ":" === d || "$" === d || "#" === d : !1;
  }
  return !1;
};
com.cognitect.transit.caching.idxToCode = function(a) {
  var b = Math.floor(a / com.cognitect.transit.caching.CACHE_CODE_DIGITS);
  a = String.fromCharCode(a % com.cognitect.transit.caching.CACHE_CODE_DIGITS + com.cognitect.transit.caching.BASE_CHAR_IDX);
  return 0 === b ? com.cognitect.transit.delimiters.SUB + a : com.cognitect.transit.delimiters.SUB + String.fromCharCode(b + com.cognitect.transit.caching.BASE_CHAR_IDX) + a;
};
com.cognitect.transit.caching.WriteCache = function() {
  this.cacheSize = this.gen = this.idx = 0;
  this.cache = {};
};
com.cognitect.transit.caching.WriteCache.prototype.write = function(a, b) {
  if (com.cognitect.transit.caching.isCacheable(a, b)) {
    this.cacheSize === com.cognitect.transit.caching.MAX_CACHE_SIZE ? (this.clear(), this.gen = 0, this.cache = {}) : this.idx === com.cognitect.transit.caching.MAX_CACHE_ENTRIES && this.clear();
    var c = this.cache[a];
    return null == c ? (this.cache[a] = [com.cognitect.transit.caching.idxToCode(this.idx), this.gen], this.idx++, a) : c[1] != this.gen ? (c[1] = this.gen, c[0] = com.cognitect.transit.caching.idxToCode(this.idx), this.idx++, a) : c[0];
  }
  return a;
};
com.cognitect.transit.caching.WriteCache.prototype.clear = function() {
  this.idx = 0;
  this.gen++;
};
com.cognitect.transit.caching.writeCache = function() {
  return new com.cognitect.transit.caching.WriteCache;
};
com.cognitect.transit.caching.isCacheCode = function(a) {
  return a.charAt(0) === com.cognitect.transit.delimiters.SUB && " " !== a.charAt(1);
};
com.cognitect.transit.caching.codeToIdx = function(a) {
  if (2 === a.length) {
    return a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX;
  }
  var b = (a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX) * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
  a = a.charCodeAt(2) - com.cognitect.transit.caching.BASE_CHAR_IDX;
  return b + a;
};
com.cognitect.transit.caching.ReadCache = function() {
  this.idx = 0;
  this.cache = [];
};
com.cognitect.transit.caching.ReadCache.prototype.write = function(a, b) {
  this.idx == com.cognitect.transit.caching.MAX_CACHE_ENTRIES && (this.idx = 0);
  this.cache[this.idx] = a;
  this.idx++;
  return a;
};
com.cognitect.transit.caching.ReadCache.prototype.read = function(a, b) {
  return this.cache[com.cognitect.transit.caching.codeToIdx(a)];
};
com.cognitect.transit.caching.ReadCache.prototype.clear = function() {
  this.idx = 0;
};
com.cognitect.transit.caching.readCache = function() {
  return new com.cognitect.transit.caching.ReadCache;
};
com.cognitect.transit.util = {};
com.cognitect.transit.util.objectKeys = "undefined" != typeof Object.keys ? function(a) {
  return Object.keys(a);
} : function(a) {
  return goog.object.getKeys(a);
};
com.cognitect.transit.util.isArray = "undefined" != typeof Array.isArray ? function(a) {
  return Array.isArray(a);
} : function(a) {
  return "array" === goog.typeOf(a);
};
com.cognitect.transit.util.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
com.cognitect.transit.util.randInt = function(a) {
  return Math.round(Math.random() * a);
};
com.cognitect.transit.util.randHex = function() {
  return com.cognitect.transit.util.randInt(15).toString(16);
};
com.cognitect.transit.util.randomUUID = function() {
  var a = (8 | 3 & com.cognitect.transit.util.randInt(14)).toString(16);
  return com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-4" + com.cognitect.transit.util.randHex() + 
  com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + a + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + 
  com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex();
};
com.cognitect.transit.util.btoa = function(a) {
  if ("undefined" != typeof btoa) {
    return btoa(a);
  }
  a = String(a);
  for (var b, c, d = 0, e = com.cognitect.transit.util.chars, f = "";a.charAt(d | 0) || (e = "=", d % 1);f += e.charAt(63 & b >> 8 - d % 1 * 8)) {
    c = a.charCodeAt(d += .75);
    if (255 < c) {
      throw Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
    }
    b = b << 8 | c;
  }
  return f;
};
com.cognitect.transit.util.atob = function(a) {
  if ("undefined" != typeof atob) {
    return atob(a);
  }
  a = String(a).replace(/=+$/, "");
  if (1 == a.length % 4) {
    throw Error("'atob' failed: The string to be decoded is not correctly encoded.");
  }
  for (var b = 0, c, d, e = 0, f = "";d = a.charAt(e++);~d && (c = b % 4 ? 64 * c + d : d, b++ % 4) ? f += String.fromCharCode(255 & c >> (-2 * b & 6)) : 0) {
    d = com.cognitect.transit.util.chars.indexOf(d);
  }
  return f;
};
com.cognitect.transit.util.Uint8ToBase64 = function(a) {
  for (var b = 0, c = a.length, d = "", e = null;b < c;) {
    e = a.subarray(b, Math.min(b + 32768, c)), d += String.fromCharCode.apply(null, e), b += 32768;
  }
  return com.cognitect.transit.util.btoa(d);
};
com.cognitect.transit.util.Base64ToUint8 = function(a) {
  a = com.cognitect.transit.util.atob(a);
  for (var b = a.length, c = new Uint8Array(b), d = 0;d < b;d++) {
    var e = a.charCodeAt(d);
    c[d] = e;
  }
  return c;
};
com.cognitect.transit.eq = {};
com.cognitect.transit.eq.hashCodeProperty = "transit$hashCode$";
com.cognitect.transit.eq.hashCodeCounter = 1;
com.cognitect.transit.eq.equals = function(a, b) {
  if (null == a) {
    return null == b;
  }
  if (a === b) {
    return !0;
  }
  if ("object" === typeof a) {
    if (com.cognitect.transit.util.isArray(a)) {
      if (com.cognitect.transit.util.isArray(b) && a.length === b.length) {
        for (var c = 0;c < a.length;c++) {
          if (!com.cognitect.transit.eq.equals(a[c], b[c])) {
            return !1;
          }
        }
        return !0;
      }
      return !1;
    }
    if (a.com$cognitect$transit$equals) {
      return a.com$cognitect$transit$equals(b);
    }
    if (null != b && "object" === typeof b) {
      if (b.com$cognitect$transit$equals) {
        return b.com$cognitect$transit$equals(a);
      }
      var c = 0, d = com.cognitect.transit.util.objectKeys(b).length, e;
      for (e in a) {
        if (a.hasOwnProperty(e) && (c++, !b.hasOwnProperty(e) || !com.cognitect.transit.eq.equals(a[e], b[e]))) {
          return !1;
        }
      }
      return c === d;
    }
  }
  return !1;
};
com.cognitect.transit.eq.hashCombine = function(a, b) {
  return a ^ b + 2654435769 + (a << 6) + (a >> 2);
};
com.cognitect.transit.eq.stringCodeCache = {};
com.cognitect.transit.eq.stringCodeCacheSize = 0;
com.cognitect.transit.eq.STR_CACHE_MAX = 256;
com.cognitect.transit.eq.hashString = function(a) {
  var b = com.cognitect.transit.eq.stringCodeCache[a];
  if (null != b) {
    return b;
  }
  for (var c = b = 0;c < a.length;++c) {
    b = 31 * b + a.charCodeAt(c), b %= 4294967296;
  }
  com.cognitect.transit.eq.stringCodeCacheSize++;
  com.cognitect.transit.eq.stringCodeCacheSize >= com.cognitect.transit.eq.STR_CACHE_MAX && (com.cognitect.transit.eq.stringCodeCache = {}, com.cognitect.transit.eq.stringCodeCacheSize = 1);
  return com.cognitect.transit.eq.stringCodeCache[a] = b;
};
com.cognitect.transit.eq.hashMapLike = function(a) {
  var b = 0;
  if (null != a.forEach) {
    a.forEach(function(a, c, d) {
      b = (b + (com.cognitect.transit.eq.hashCode(c) ^ com.cognitect.transit.eq.hashCode(a))) % 4503599627370496;
    });
  } else {
    for (var c = com.cognitect.transit.util.objectKeys(a), d = 0;d < c.length;d++) {
      var e = c[d], f = a[e], b = (b + (com.cognitect.transit.eq.hashCode(e) ^ com.cognitect.transit.eq.hashCode(f))) % 4503599627370496
    }
  }
  return b;
};
com.cognitect.transit.eq.hashArrayLike = function(a) {
  var b = 0;
  if (com.cognitect.transit.util.isArray(a)) {
    for (var c = 0;c < a.length;c++) {
      b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a[c]));
    }
  } else {
    a.forEach && a.forEach(function(a, c) {
      b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a));
    });
  }
  return b;
};
com.cognitect.transit.eq.hashCode = function(a) {
  if (null == a) {
    return 0;
  }
  switch(typeof a) {
    case "number":
      return a;
    case "boolean":
      return !0 === a ? 1 : 0;
    case "string":
      return com.cognitect.transit.eq.hashString(a);
    case "function":
      var b = a[com.cognitect.transit.eq.hashCodeProperty];
      b || (b = com.cognitect.transit.eq.hashCodeCounter, "undefined" != typeof Object.defineProperty ? Object.defineProperty(a, com.cognitect.transit.eq.hashCodeProperty, {value:b, enumerable:!1}) : a[com.cognitect.transit.eq.hashCodeProperty] = b, com.cognitect.transit.eq.hashCodeCounter++);
      return b;
    default:
      return a instanceof Date ? a.valueOf() : com.cognitect.transit.util.isArray(a) ? com.cognitect.transit.eq.hashArrayLike(a) : a.com$cognitect$transit$hashCode ? a.com$cognitect$transit$hashCode() : com.cognitect.transit.eq.hashMapLike(a);
  }
};
com.cognitect.transit.eq.extendToEQ = function(a, b) {
  a.com$cognitect$transit$hashCode = b.hashCode;
  a.com$cognitect$transit$equals = b.equals;
  return a;
};
com.cognitect.transit.types = {};
com.cognitect.transit.types.ITERATOR = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator";
com.cognitect.transit.types.TaggedValue = function(a, b) {
  this.tag = a;
  this.rep = b;
  this.hashCode = -1;
};
com.cognitect.transit.types.TaggedValue.prototype.toString = function() {
  return "[TaggedValue: " + this.tag + ", " + this.rep + "]";
};
com.cognitect.transit.types.TaggedValue.prototype.equiv = function(a) {
  return com.cognitect.transit.eq.equals(this, a);
};
com.cognitect.transit.types.TaggedValue.prototype.equiv = com.cognitect.transit.types.TaggedValue.prototype.equiv;
com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$equals = function(a) {
  return a instanceof com.cognitect.transit.types.TaggedValue ? this.tag === a.tag && com.cognitect.transit.eq.equals(this.rep, a.rep) : !1;
};
com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$hashCode = function() {
  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCombine(com.cognitect.transit.eq.hashCode(this.tag), com.cognitect.transit.eq.hashCode(this.rep)));
  return this.hashCode;
};
com.cognitect.transit.types.taggedValue = function(a, b) {
  return new com.cognitect.transit.types.TaggedValue(a, b);
};
com.cognitect.transit.types.isTaggedValue = function(a) {
  return a instanceof com.cognitect.transit.types.TaggedValue;
};
com.cognitect.transit.types.nullValue = function() {
  return null;
};
com.cognitect.transit.types.boolValue = function(a) {
  return "t" === a;
};
com.cognitect.transit.types.MAX_INT = goog.math.Long.fromString("9007199254740991");
com.cognitect.transit.types.MIN_INT = goog.math.Long.fromString("-9007199254740991");
com.cognitect.transit.types.intValue = function(a) {
  if ("number" === typeof a || a instanceof goog.math.Long) {
    return a;
  }
  a = goog.math.Long.fromString(a, 10);
  return a.greaterThan(com.cognitect.transit.types.MAX_INT) || a.lessThan(com.cognitect.transit.types.MIN_INT) ? a : a.toNumber();
};
goog.math.Long.prototype.equiv = function(a) {
  return com.cognitect.transit.eq.equals(this, a);
};
goog.math.Long.prototype.equiv = goog.math.Long.prototype.equiv;
goog.math.Long.prototype.com$cognitect$transit$equals = function(a) {
  return a instanceof goog.math.Long && this.equals(a);
};
goog.math.Long.prototype.com$cognitect$transit$hashCode = function() {
  return this.toInt();
};
com.cognitect.transit.types.isInteger = function(a) {
  return a instanceof goog.math.Long ? !0 : "number" === typeof a && !isNaN(a) && Infinity !== a && parseFloat(a) === parseInt(a, 10);
};
com.cognitect.transit.types.floatValue = function(a) {
  return parseFloat(a);
};
com.cognitect.transit.types.bigInteger = function(a) {
  return com.cognitect.transit.types.taggedValue("n", a);
};
com.cognitect.transit.types.isBigInteger = function(a) {
  return a instanceof com.cognitect.transit.types.TaggedValue && "n" === a.tag;
};
com.cognitect.transit.types.bigDecimalValue = function(a) {
  return com.cognitect.transit.types.taggedValue("f", a);
};
com.cognitect.transit.types.isBigDecimal = function(a) {
  return a instanceof com.cognitect.transit.types.TaggedValue && "f" === a.tag;
};
com.cognitect.transit.types.charValue = function(a) {
  return a;
};
com.cognitect.transit.types.Keyword = function(a) {
  this._name = a;
  this.hashCode = -1;
};
com.cognitect.transit.types.Keyword.prototype.toString = function() {
  return ":" + this._name;
};
com.cognitect.transit.types.Keyword.prototype.namespace = function() {
  var a = this._name.indexOf("/");
  return -1 != a ? this._name.substring(0, a) : null;
};
com.cognitect.transit.types.Keyword.prototype.name = function() {
  var a = this._name.indexOf("/");
  return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;
};
com.cognitect.transit.types.Keyword.prototype.equiv = function(a) {
  return com.cognitect.transit.eq.equals(this, a);
};
com.cognitect.transit.types.Keyword.prototype.equiv = com.cognitect.transit.types.Keyword.prototype.equiv;
com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$equals = function(a) {
  return a instanceof com.cognitect.transit.types.Keyword && this._name == a._name;
};
com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$hashCode = function() {
  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
  return this.hashCode;
};
com.cognitect.transit.types.keyword = function(a) {
  return new com.cognitect.transit.types.Keyword(a);
};
com.cognitect.transit.types.isKeyword = function(a) {
  return a instanceof com.cognitect.transit.types.Keyword;
};
com.cognitect.transit.types.Symbol = function(a) {
  this._name = a;
  this.hashCode = -1;
};
com.cognitect.transit.types.Symbol.prototype.namespace = function() {
  var a = this._name.indexOf("/");
  return -1 != a ? this._name.substring(0, a) : null;
};
com.cognitect.transit.types.Symbol.prototype.name = function() {
  var a = this._name.indexOf("/");
  return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;
};
com.cognitect.transit.types.Symbol.prototype.toString = function() {
  return this._name;
};
com.cognitect.transit.types.Symbol.prototype.equiv = function(a) {
  return com.cognitect.transit.eq.equals(this, a);
};
com.cognitect.transit.types.Symbol.prototype.equiv = com.cognitect.transit.types.Symbol.prototype.equiv;
com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$equals = function(a) {
  return a instanceof com.cognitect.transit.types.Symbol && this._name == a._name;
};
com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$hashCode = function() {
  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
  return this.hashCode;
};
com.cognitect.transit.types.symbol = function(a) {
  return new com.cognitect.transit.types.Symbol(a);
};
com.cognitect.transit.types.isSymbol = function(a) {
  return a instanceof com.cognitect.transit.types.Symbol;
};
com.cognitect.transit.types.hexFor = function(a, b, c) {
  var d = "";
  c = c || b + 1;
  for (var e = 8 * (7 - b), f = goog.math.Long.fromInt(255).shiftLeft(e);b < c;b++, e -= 8, f = f.shiftRightUnsigned(8)) {
    var g = a.and(f).shiftRightUnsigned(e).toString(16);
    1 == g.length && (g = "0" + g);
    d += g;
  }
  return d;
};
com.cognitect.transit.types.UUID = function(a, b) {
  this.high = a;
  this.low = b;
  this.hashCode = -1;
};
com.cognitect.transit.types.UUID.prototype.getLeastSignificantBits = function() {
  return this.low;
};
com.cognitect.transit.types.UUID.prototype.getMostSignificantBits = function() {
  return this.high;
};
com.cognitect.transit.types.UUID.prototype.toString = function() {
  var a, b = this.high, c = this.low;
  a = "" + (com.cognitect.transit.types.hexFor(b, 0, 4) + "-");
  a += com.cognitect.transit.types.hexFor(b, 4, 6) + "-";
  a += com.cognitect.transit.types.hexFor(b, 6, 8) + "-";
  a += com.cognitect.transit.types.hexFor(c, 0, 2) + "-";
  return a += com.cognitect.transit.types.hexFor(c, 2, 8);
};
com.cognitect.transit.types.UUID.prototype.equiv = function(a) {
  return com.cognitect.transit.eq.equals(this, a);
};
com.cognitect.transit.types.UUID.prototype.equiv = com.cognitect.transit.types.UUID.prototype.equiv;
com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$equals = function(a) {
  return a instanceof com.cognitect.transit.types.UUID && this.high.equals(a.high) && this.low.equals(a.low);
};
com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$hashCode = function() {
  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this.toString()));
  return this.hashCode;
};
com.cognitect.transit.types.UUIDfromString = function(a) {
  a = a.replace(/-/g, "");
  for (var b = null, c = null, d = c = 0, e = 24, f = 0, f = c = 0, e = 24;8 > f;f += 2, e -= 8) {
    c |= parseInt(a.substring(f, f + 2), 16) << e;
  }
  d = 0;
  f = 8;
  for (e = 24;16 > f;f += 2, e -= 8) {
    d |= parseInt(a.substring(f, f + 2), 16) << e;
  }
  b = goog.math.Long.fromBits(d, c);
  c = 0;
  f = 16;
  for (e = 24;24 > f;f += 2, e -= 8) {
    c |= parseInt(a.substring(f, f + 2), 16) << e;
  }
  d = 0;
  for (e = f = 24;32 > f;f += 2, e -= 8) {
    d |= parseInt(a.substring(f, f + 2), 16) << e;
  }
  c = goog.math.Long.fromBits(d, c);
  return new com.cognitect.transit.types.UUID(b, c);
};
com.cognitect.transit.types.uuid = function(a) {
  return com.cognitect.transit.types.UUIDfromString(a);
};
com.cognitect.transit.types.isUUID = function(a) {
  return a instanceof com.cognitect.transit.types.UUID;
};
com.cognitect.transit.types.date = function(a) {
  a = "number" === typeof a ? a : parseInt(a, 10);
  return new Date(a);
};
com.cognitect.transit.types.verboseDate = function(a) {
  return new Date(a);
};
Date.prototype.com$cognitect$transit$equals = function(a) {
  return a instanceof Date ? this.valueOf() === a.valueOf() : !1;
};
Date.prototype.com$cognitect$transit$hashCode = function() {
  return this.valueOf();
};
com.cognitect.transit.types.binary = function(a, b) {
  return b && !1 === b.preferBuffers || "undefined" == typeof Buffer ? "undefined" != typeof Uint8Array ? com.cognitect.transit.util.Base64ToUint8(a) : com.cognitect.transit.types.taggedValue("b", a) : new Buffer(a, "base64");
};
com.cognitect.transit.types.isBinary = function(a) {
  return "undefined" != typeof Buffer && a instanceof Buffer ? !0 : "undefined" != typeof Uint8Array && a instanceof Uint8Array ? !0 : a instanceof com.cognitect.transit.types.TaggedValue && "b" === a.tag;
};
com.cognitect.transit.types.uri = function(a) {
  return com.cognitect.transit.types.taggedValue("r", a);
};
com.cognitect.transit.types.isURI = function(a) {
  return a instanceof com.cognitect.transit.types.TaggedValue && "r" === a.tag;
};
com.cognitect.transit.types.KEYS = 0;
com.cognitect.transit.types.VALUES = 1;
com.cognitect.transit.types.ENTRIES = 2;
com.cognitect.transit.types.TransitArrayMapIterator = function(a, b) {
  this.entries = a;
  this.type = b || com.cognitect.transit.types.KEYS;
  this.idx = 0;
};
com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = function() {
  if (this.idx < this.entries.length) {
    var a = null, a = this.type === com.cognitect.transit.types.KEYS ? this.entries[this.idx] : this.type === com.cognitect.transit.types.VALUES ? this.entries[this.idx + 1] : [this.entries[this.idx], this.entries[this.idx + 1]], a = {value:a, done:!1};
    this.idx += 2;
    return a;
  }
  return {value:null, done:!0};
};
com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = com.cognitect.transit.types.TransitArrayMapIterator.prototype.next;
com.cognitect.transit.types.TransitArrayMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {
  return this;
};
com.cognitect.transit.types.TransitMapIterator = function(a, b) {
  this.map = a;
  this.type = b || com.cognitect.transit.types.KEYS;
  this.keys = this.map.getKeys();
  this.idx = 0;
  this.bucket = null;
  this.bucketIdx = 0;
};
com.cognitect.transit.types.TransitMapIterator.prototype.next = function() {
  if (this.idx < this.map.size) {
    null != this.bucket && this.bucketIdx < this.bucket.length || (this.bucket = this.map.map[this.keys[this.idx]], this.bucketIdx = 0);
    var a = null, a = this.type === com.cognitect.transit.types.KEYS ? this.bucket[this.bucketIdx] : this.type === com.cognitect.transit.types.VALUES ? this.bucket[this.bucketIdx + 1] : [this.bucket[this.bucketIdx], this.bucket[this.bucketIdx + 1]], a = {value:a, done:!1};
    this.idx++;
    this.bucketIdx += 2;
    return a;
  }
  return {value:null, done:!0};
};
com.cognitect.transit.types.TransitMapIterator.prototype.next = com.cognitect.transit.types.TransitMapIterator.prototype.next;
com.cognitect.transit.types.TransitMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function() {
  return this;
};
com.cognitect.transit.types.mapEquals = function(a, b) {
  if (a instanceof com.cognitect.transit.types.TransitMap && com.cognitect.transit.types.isMap(b)) {
    if (a.size !== b.size) {
      return !1;
    }
    for (var c in a.map) {
      for (var d = a.map[c], e = 0;e < d.length;e += 2) {
        if (!com.cognitect.transit.eq.equals(d[e + 1], b.get(d[e]))) {
          return !1;
        }
      }
    }
    return !0;
  }
  if (a instanceof com.cognitect.transit.types.TransitArrayMap && com.cognitect.transit.types.isMap(b)) {
    if (a.size !== b.size) {
      return !1;
    }
    c = a._entries;
    for (e = 0;e < c.length;e += 2) {
      if (!com.cognitect.transit.eq.equals(c[e + 1], b.get(c[e]))) {
        return !1;
      }
    }
    return !0;
  }
  if (null != b && "object" === typeof b && (e = com.cognitect.transit.util.objectKeys(b), c = e.length, a.size === c)) {
    for (d = 0;d < c;d++) {
      var f = e[d];
      if (!a.has(f) || !com.cognitect.transit.eq.equals(b[f], a.get(f))) {
        return !1;
      }
    }
    return !0;
  }
  return !1;
};
com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD = 8;
com.cognitect.transit.types.ARRAY_MAP_THRESHOLD = 32;
com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD = 32;
com.cognitect.transit.types.print = function(a) {
  return null == a ? "null" : goog.isArray(a) ? "[" + a.toString() + "]" : goog.isString(a) ? '"' + a + '"' : a.toString();
};
com.cognitect.transit.types.printMap = function(a) {
  var b = 0, c = "TransitMap {";
  a.forEach(function(d, e) {
    c += com.cognitect.transit.types.print(e) + " => " + com.cognitect.transit.types.print(d);
    b < a.size - 1 && (c += ", ");
    b++;
  });
  return c + "}";
};
com.cognitect.transit.types.printSet = function(a) {
  var b = 0, c = "TransitSet {";
  a.forEach(function(d) {
    c += com.cognitect.transit.types.print(d);
    b < a.size - 1 && (c += ", ");
    b++;
  });
  return c + "}";
};
com.cognitect.transit.types.TransitArrayMap = function(a) {
  this._entries = a;
  this.backingMap = null;
  this.hashCode = -1;
  this.size = a.length / 2;
  this.accesses = 0;
};
com.cognitect.transit.types.TransitArrayMap.prototype.toString = function() {
  return com.cognitect.transit.types.printMap(this);
};
com.cognitect.transit.types.TransitArrayMap.prototype.inspect = function() {
  return this.toString();
};
com.cognitect.transit.types.TransitArrayMap.prototype.convert = function() {
  if (this.backingMap) {
    throw Error("Invalid operation, already converted");
  }
  if (this.size < com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD) {
    return !1;
  }
  this.accesses++;
  return this.accesses > com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD ? (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = [], !0) : !1;
};
com.cognitect.transit.types.TransitArrayMap.prototype.clear = function() {
  this.hashCode = -1;
  this.backingMap ? this.backingMap.clear() : this._entries = [];
  this.size = 0;
};
com.cognitect.transit.types.TransitArrayMap.prototype.clear = com.cognitect.transit.types.TransitArrayMap.prototype.clear;
com.cognitect.transit.types.TransitArrayMap.prototype.keys = function() {
  return this.backingMap ? this.backingMap.keys() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.KEYS);
};
com.cognitect.transit.types.TransitArrayMap.prototype.keys = com.cognitect.transit.types.TransitArrayMap.prototype.keys;
com.cognitect.transit.types.TransitArrayMap.prototype.keySet = function() {
  if (this.backingMap) {
    return this.backingMap.keySet();
  }
  for (var a = [], b = 0, c = 0;c < this._entries.length;b++, c += 2) {
    a[b] = this._entries[c];
  }
  return a;
};
com.cognitect.transit.types.TransitArrayMap.prototype.keySet = com.cognitect.transit.types.TransitArrayMap.prototype.keySet;
com.cognitect.transit.types.TransitArrayMap.prototype.entries = function() {
  return this.backingMap ? this.backingMap.entries() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.ENTRIES);
};
com.cognitect.transit.types.TransitArrayMap.prototype.entries = com.cognitect.transit.types.TransitArrayMap.prototype.entries;
com.cognitect.transit.types.TransitArrayMap.prototype.values = function() {
  return this.backingMap ? this.backingMap.values() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.VALUES);
};
com.cognitect.transit.types.TransitArrayMap.prototype.values = com.cognitect.transit.types.TransitArrayMap.prototype.values;
com.cognitect.transit.types.TransitArrayMap.prototype.forEach = function(a) {
  if (this.backingMap) {
    this.backingMap.forEach(a);
  } else {
    for (var b = 0;b < this._entries.length;b += 2) {
      a(this._entries[b + 1], this._entries[b]);
    }
  }
};
com.cognitect.transit.types.TransitArrayMap.prototype.forEach = com.cognitect.transit.types.TransitArrayMap.prototype.forEach;
com.cognitect.transit.types.TransitArrayMap.prototype.get = function(a, b) {
  if (this.backingMap) {
    return this.backingMap.get(a);
  }
  if (this.convert()) {
    return this.get(a);
  }
  for (var c = 0;c < this._entries.length;c += 2) {
    if (com.cognitect.transit.eq.equals(this._entries[c], a)) {
      return this._entries[c + 1];
    }
  }
  return b;
};
com.cognitect.transit.types.TransitArrayMap.prototype.get = com.cognitect.transit.types.TransitArrayMap.prototype.get;
com.cognitect.transit.types.TransitArrayMap.prototype.has = function(a) {
  if (this.backingMap) {
    return this.backingMap.has(a);
  }
  if (this.convert()) {
    return this.has(a);
  }
  for (var b = 0;b < this._entries.length;b += 2) {
    if (com.cognitect.transit.eq.equals(this._entries[b], a)) {
      return !0;
    }
  }
  return !1;
};
com.cognitect.transit.types.TransitArrayMap.prototype.has = com.cognitect.transit.types.TransitArrayMap.prototype.has;
com.cognitect.transit.types.TransitArrayMap.prototype.set = function(a, b) {
  this.hashCode = -1;
  if (this.backingMap) {
    this.backingMap.set(a, b), this.size = this.backingMap.size;
  } else {
    for (var c = 0;c < this._entries.length;c += 2) {
      if (com.cognitect.transit.eq.equals(this._entries[c], a)) {
        this._entries[c + 1] = b;
        return;
      }
    }
    this._entries.push(a);
    this._entries.push(b);
    this.size++;
    this.size > com.cognitect.transit.types.ARRAY_MAP_THRESHOLD && (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = null);
  }
};
com.cognitect.transit.types.TransitArrayMap.prototype.set = com.cognitect.transit.types.TransitArrayMap.prototype.set;
com.cognitect.transit.types.TransitArrayMap.prototype["delete"] = function(a) {
  this.hashCode = -1;
  if (this.backingMap) {
    return a = this.backingMap["delete"](a), this.size = this.backingMap.size, a;
  }
  for (var b = 0;b < this._entries.length;b += 2) {
    if (com.cognitect.transit.eq.equals(this._entries[b], a)) {
      return a = this._entries[b + 1], this._entries.splice(b, 2), this.size--, a;
    }
  }
};
com.cognitect.transit.types.TransitArrayMap.prototype.clone = function() {
  var a = com.cognitect.transit.types.map();
  this.forEach(function(b, c) {
    a.set(c, b);
  });
  return a;
};
com.cognitect.transit.types.TransitArrayMap.prototype.clone = com.cognitect.transit.types.TransitArrayMap.prototype.clone;
com.cognitect.transit.types.TransitArrayMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {
  return this.entries();
};
com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$hashCode = function() {
  if (this.backingMap) {
    return this.backingMap.com$cognitect$transit$hashCode();
  }
  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
  return this.hashCode;
};
com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$equals = function(a) {
  return this.backingMap ? com.cognitect.transit.types.mapEquals(this.backingMap, a) : com.cognitect.transit.types.mapEquals(this, a);
};
com.cognitect.transit.types.TransitMap = function(a, b, c) {
  this.map = b || {};
  this._keys = a || [];
  this.size = c || 0;
  this.hashCode = -1;
};
com.cognitect.transit.types.TransitMap.prototype.toString = function() {
  return com.cognitect.transit.types.printMap(this);
};
com.cognitect.transit.types.TransitMap.prototype.inspect = function() {
  return this.toString();
};
com.cognitect.transit.types.TransitMap.prototype.clear = function() {
  this.hashCode = -1;
  this.map = {};
  this._keys = [];
  this.size = 0;
};
com.cognitect.transit.types.TransitMap.prototype.clear = com.cognitect.transit.types.TransitMap.prototype.clear;
com.cognitect.transit.types.TransitMap.prototype.getKeys = function() {
  return null != this._keys ? this._keys : com.cognitect.transit.util.objectKeys(this.map);
};
com.cognitect.transit.types.TransitMap.prototype["delete"] = function(a) {
  this.hashCode = -1;
  this._keys = null;
  for (var b = com.cognitect.transit.eq.hashCode(a), c = this.map[b], d = 0;d < c.length;d += 2) {
    if (com.cognitect.transit.eq.equals(a, c[d])) {
      return a = c[d + 1], c.splice(d, 2), 0 === c.length && delete this.map[b], this.size--, a;
    }
  }
};
com.cognitect.transit.types.TransitMap.prototype.entries = function() {
  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.ENTRIES);
};
com.cognitect.transit.types.TransitMap.prototype.entries = com.cognitect.transit.types.TransitMap.prototype.entries;
com.cognitect.transit.types.TransitMap.prototype.forEach = function(a) {
  for (var b = this.getKeys(), c = 0;c < b.length;c++) {
    for (var d = this.map[b[c]], e = 0;e < d.length;e += 2) {
      a(d[e + 1], d[e], this);
    }
  }
};
com.cognitect.transit.types.TransitMap.prototype.forEach = com.cognitect.transit.types.TransitMap.prototype.forEach;
com.cognitect.transit.types.TransitMap.prototype.get = function(a, b) {
  var c = com.cognitect.transit.eq.hashCode(a), c = this.map[c];
  if (null != c) {
    for (var d = 0;d < c.length;d += 2) {
      if (com.cognitect.transit.eq.equals(a, c[d])) {
        return c[d + 1];
      }
    }
  } else {
    return b;
  }
};
com.cognitect.transit.types.TransitMap.prototype.get = com.cognitect.transit.types.TransitMap.prototype.get;
com.cognitect.transit.types.TransitMap.prototype.has = function(a) {
  var b = com.cognitect.transit.eq.hashCode(a), b = this.map[b];
  if (null != b) {
    for (var c = 0;c < b.length;c += 2) {
      if (com.cognitect.transit.eq.equals(a, b[c])) {
        return !0;
      }
    }
  }
  return !1;
};
com.cognitect.transit.types.TransitMap.prototype.has = com.cognitect.transit.types.TransitMap.prototype.has;
com.cognitect.transit.types.TransitMap.prototype.keys = function() {
  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.KEYS);
};
com.cognitect.transit.types.TransitMap.prototype.keys = com.cognitect.transit.types.TransitMap.prototype.keys;
com.cognitect.transit.types.TransitMap.prototype.keySet = function() {
  for (var a = this.getKeys(), b = [], c = 0;c < a.length;c++) {
    for (var d = this.map[a[c]], e = 0;e < d.length;e += 2) {
      b.push(d[e]);
    }
  }
  return b;
};
com.cognitect.transit.types.TransitMap.prototype.keySet = com.cognitect.transit.types.TransitMap.prototype.keySet;
com.cognitect.transit.types.TransitMap.prototype.set = function(a, b) {
  this.hashCode = -1;
  var c = com.cognitect.transit.eq.hashCode(a), d = this.map[c];
  if (null == d) {
    this._keys && this._keys.push(c), this.map[c] = [a, b], this.size++;
  } else {
    for (var c = !0, e = 0;e < d.length;e += 2) {
      if (com.cognitect.transit.eq.equals(b, d[e])) {
        c = !1;
        d[e] = b;
        break;
      }
    }
    c && (d.push(a), d.push(b), this.size++);
  }
};
com.cognitect.transit.types.TransitMap.prototype.set = com.cognitect.transit.types.TransitMap.prototype.set;
com.cognitect.transit.types.TransitMap.prototype.values = function() {
  return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.VALUES);
};
com.cognitect.transit.types.TransitMap.prototype.values = com.cognitect.transit.types.TransitMap.prototype.values;
com.cognitect.transit.types.TransitMap.prototype.clone = function() {
  var a = com.cognitect.transit.types.map();
  this.forEach(function(b, c) {
    a.set(c, b);
  });
  return a;
};
com.cognitect.transit.types.TransitMap.prototype.clone = com.cognitect.transit.types.TransitMap.prototype.clone;
com.cognitect.transit.types.TransitMap.prototype[com.cognitect.transit.types.ITERATOR] = function() {
  return this.entries();
};
com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$hashCode = function() {
  -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
  return this.hashCode;
};
com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$equals = function(a) {
  return com.cognitect.transit.types.mapEquals(this, a);
};
com.cognitect.transit.types.map = function(a, b, c) {
  a = a || [];
  b = !1 === b ? b : !0;
  if ((!0 !== c || !c) && a.length <= 2 * com.cognitect.transit.types.ARRAY_MAP_THRESHOLD) {
    if (b) {
      var d = a;
      a = [];
      for (b = 0;b < d.length;b += 2) {
        var e = !1;
        for (c = 0;c < a.length;c += 2) {
          if (com.cognitect.transit.eq.equals(a[c], d[b])) {
            a[c + 1] = d[b + 1];
            e = !0;
            break;
          }
        }
        e || (a.push(d[b]), a.push(d[b + 1]));
      }
    }
    return new com.cognitect.transit.types.TransitArrayMap(a);
  }
  var d = {}, e = [], f = 0;
  for (b = 0;b < a.length;b += 2) {
    c = com.cognitect.transit.eq.hashCode(a[b]);
    var g = d[c];
    if (null == g) {
      e.push(c), d[c] = [a[b], a[b + 1]], f++;
    } else {
      var h = !0;
      for (c = 0;c < g.length;c += 2) {
        if (com.cognitect.transit.eq.equals(g[c], a[b])) {
          g[c + 1] = a[b + 1];
          h = !1;
          break;
        }
      }
      h && (g.push(a[b]), g.push(a[b + 1]), f++);
    }
  }
  return new com.cognitect.transit.types.TransitMap(e, d, f);
};
com.cognitect.transit.types.isArrayMap = function(a) {
  return a instanceof com.cognitect.transit.types.TransitArrayMap;
};
com.cognitect.transit.types.isMap = function(a) {
  return a instanceof com.cognitect.transit.types.TransitArrayMap || a instanceof com.cognitect.transit.types.TransitMap;
};
com.cognitect.transit.types.TransitSet = function(a) {
  this.map = a;
  this.size = a.size;
};
com.cognitect.transit.types.TransitSet.prototype.toString = function() {
  return com.cognitect.transit.types.printSet(this);
};
com.cognitect.transit.types.TransitSet.prototype.inspect = function() {
  return this.toString();
};
com.cognitect.transit.types.TransitSet.prototype.add = function(a) {
  this.map.set(a, a);
  this.size = this.map.size;
};
com.cognitect.transit.types.TransitSet.prototype.add = com.cognitect.transit.types.TransitSet.prototype.add;
com.cognitect.transit.types.TransitSet.prototype.clear = function() {
  this.map = new com.cognitect.transit.types.TransitMap;
  this.size = 0;
};
com.cognitect.transit.types.TransitSet.prototype.clear = com.cognitect.transit.types.TransitSet.prototype.clear;
com.cognitect.transit.types.TransitSet.prototype["delete"] = function(a) {
  a = this.map["delete"](a);
  this.size = this.map.size;
  return a;
};
com.cognitect.transit.types.TransitSet.prototype.entries = function() {
  return this.map.entries();
};
com.cognitect.transit.types.TransitSet.prototype.entries = com.cognitect.transit.types.TransitSet.prototype.entries;
com.cognitect.transit.types.TransitSet.prototype.forEach = function(a, b) {
  var c = this;
  this.map.forEach(function(b, e, f) {
    a(e, c);
  });
};
com.cognitect.transit.types.TransitSet.prototype.forEach = com.cognitect.transit.types.TransitSet.prototype.forEach;
com.cognitect.transit.types.TransitSet.prototype.has = function(a) {
  return this.map.has(a);
};
com.cognitect.transit.types.TransitSet.prototype.has = com.cognitect.transit.types.TransitSet.prototype.has;
com.cognitect.transit.types.TransitSet.prototype.keys = function() {
  return this.map.keys();
};
com.cognitect.transit.types.TransitSet.prototype.keys = com.cognitect.transit.types.TransitSet.prototype.keys;
com.cognitect.transit.types.TransitSet.prototype.keySet = function() {
  return this.map.keySet();
};
com.cognitect.transit.types.TransitSet.prototype.keySet = com.cognitect.transit.types.TransitSet.prototype.keySet;
com.cognitect.transit.types.TransitSet.prototype.values = function() {
  return this.map.values();
};
com.cognitect.transit.types.TransitSet.prototype.values = com.cognitect.transit.types.TransitSet.prototype.values;
com.cognitect.transit.types.TransitSet.prototype.clone = function() {
  var a = com.cognitect.transit.types.set();
  this.forEach(function(b) {
    a.add(b);
  });
  return a;
};
com.cognitect.transit.types.TransitSet.prototype.clone = com.cognitect.transit.types.TransitSet.prototype.clone;
com.cognitect.transit.types.TransitSet.prototype[com.cognitect.transit.types.ITERATOR] = function() {
  return this.values();
};
com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$equals = function(a) {
  if (a instanceof com.cognitect.transit.types.TransitSet) {
    if (this.size === a.size) {
      return com.cognitect.transit.eq.equals(this.map, a.map);
    }
  } else {
    return !1;
  }
};
com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$hashCode = function(a) {
  return com.cognitect.transit.eq.hashCode(this.map);
};
com.cognitect.transit.types.set = function(a) {
  a = a || [];
  for (var b = {}, c = [], d = 0, e = 0;e < a.length;e++) {
    var f = com.cognitect.transit.eq.hashCode(a[e]), g = b[f];
    if (null == g) {
      c.push(f), b[f] = [a[e], a[e]], d++;
    } else {
      for (var f = !0, h = 0;h < g.length;h += 2) {
        if (com.cognitect.transit.eq.equals(g[h], a[e])) {
          f = !1;
          break;
        }
      }
      f && (g.push(a[e]), g.push(a[e]), d++);
    }
  }
  return new com.cognitect.transit.types.TransitSet(new com.cognitect.transit.types.TransitMap(c, b, d));
};
com.cognitect.transit.types.isSet = function(a) {
  return a instanceof com.cognitect.transit.types.TransitSet;
};
com.cognitect.transit.types.quoted = function(a) {
  return com.cognitect.transit.types.taggedValue("'", a);
};
com.cognitect.transit.types.isQuoted = function(a) {
  return a instanceof com.cognitect.transit.types.TaggedValue && "'" === a.tag;
};
com.cognitect.transit.types.list = function(a) {
  return com.cognitect.transit.types.taggedValue("list", a);
};
com.cognitect.transit.types.isList = function(a) {
  return a instanceof com.cognitect.transit.types.TaggedValue && "list" === a.tag;
};
com.cognitect.transit.types.link = function(a) {
  return com.cognitect.transit.types.taggedValue("link", a);
};
com.cognitect.transit.types.isLink = function(a) {
  return a instanceof com.cognitect.transit.types.TaggedValue && "link" === a.tag;
};
com.cognitect.transit.types.specialDouble = function(a) {
  switch(a) {
    case "-INF":
      return -Infinity;
    case "INF":
      return Infinity;
    case "NaN":
      return NaN;
    default:
      throw Error("Invalid special double value " + a);;
  }
};
com.cognitect.transit.handlers = {};
com.cognitect.transit.handlers.ctorGuid = 0;
com.cognitect.transit.handlers.ctorGuidProperty = "transit$guid$" + com.cognitect.transit.util.randomUUID();
com.cognitect.transit.handlers.typeTag = function(a) {
  if (null == a) {
    return "null";
  }
  if (a === String) {
    return "string";
  }
  if (a === Boolean) {
    return "boolean";
  }
  if (a === Number) {
    return "number";
  }
  if (a === Array) {
    return "array";
  }
  if (a === Object) {
    return "map";
  }
  var b = a[com.cognitect.transit.handlers.ctorGuidProperty];
  null == b && ("undefined" != typeof Object.defineProperty ? (b = ++com.cognitect.transit.handlers.ctorGuid, Object.defineProperty(a, com.cognitect.transit.handlers.ctorGuidProperty, {value:b, enumerable:!1})) : a[com.cognitect.transit.handlers.ctorGuidProperty] = b = ++com.cognitect.transit.handlers.ctorGuid);
  return b;
};
com.cognitect.transit.handlers.constructor = function(a) {
  return null == a ? null : a.constructor;
};
com.cognitect.transit.handlers.padZeros = function(a, b) {
  for (var c = a.toString(), d = c.length;d < b;d++) {
    c = "0" + c;
  }
  return c;
};
com.cognitect.transit.handlers.stringableKeys = function(a) {
  a = com.cognitect.transit.util.objectKeys(a);
  for (var b = 0;b < a.length;b++) {
  }
  return !0;
};
com.cognitect.transit.handlers.NilHandler = function() {
};
com.cognitect.transit.handlers.NilHandler.prototype.tag = function(a) {
  return "_";
};
com.cognitect.transit.handlers.NilHandler.prototype.rep = function(a) {
  return null;
};
com.cognitect.transit.handlers.NilHandler.prototype.stringRep = function(a) {
  return "null";
};
com.cognitect.transit.handlers.StringHandler = function() {
};
com.cognitect.transit.handlers.StringHandler.prototype.tag = function(a) {
  return "s";
};
com.cognitect.transit.handlers.StringHandler.prototype.rep = function(a) {
  return a;
};
com.cognitect.transit.handlers.StringHandler.prototype.stringRep = function(a) {
  return a;
};
com.cognitect.transit.handlers.NumberHandler = function() {
};
com.cognitect.transit.handlers.NumberHandler.prototype.tag = function(a) {
  return "i";
};
com.cognitect.transit.handlers.NumberHandler.prototype.rep = function(a) {
  return a;
};
com.cognitect.transit.handlers.NumberHandler.prototype.stringRep = function(a) {
  return a.toString();
};
com.cognitect.transit.handlers.IntegerHandler = function() {
};
com.cognitect.transit.handlers.IntegerHandler.prototype.tag = function(a) {
  return "i";
};
com.cognitect.transit.handlers.IntegerHandler.prototype.rep = function(a) {
  return a.toString();
};
com.cognitect.transit.handlers.IntegerHandler.prototype.stringRep = function(a) {
  return a.toString();
};
com.cognitect.transit.handlers.BooleanHandler = function() {
};
com.cognitect.transit.handlers.BooleanHandler.prototype.tag = function(a) {
  return "?";
};
com.cognitect.transit.handlers.BooleanHandler.prototype.rep = function(a) {
  return a;
};
com.cognitect.transit.handlers.BooleanHandler.prototype.stringRep = function(a) {
  return a.toString();
};
com.cognitect.transit.handlers.ArrayHandler = function() {
};
com.cognitect.transit.handlers.ArrayHandler.prototype.tag = function(a) {
  return "array";
};
com.cognitect.transit.handlers.ArrayHandler.prototype.rep = function(a) {
  return a;
};
com.cognitect.transit.handlers.ArrayHandler.prototype.stringRep = function(a) {
  return null;
};
com.cognitect.transit.handlers.MapHandler = function() {
};
com.cognitect.transit.handlers.MapHandler.prototype.tag = function(a) {
  return "map";
};
com.cognitect.transit.handlers.MapHandler.prototype.rep = function(a) {
  return a;
};
com.cognitect.transit.handlers.MapHandler.prototype.stringRep = function(a) {
  return null;
};
com.cognitect.transit.handlers.VerboseDateHandler = function() {
};
com.cognitect.transit.handlers.VerboseDateHandler.prototype.tag = function(a) {
  return "t";
};
com.cognitect.transit.handlers.VerboseDateHandler.prototype.rep = function(a) {
  return a.getUTCFullYear() + "-" + com.cognitect.transit.handlers.padZeros(a.getUTCMonth() + 1, 2) + "-" + com.cognitect.transit.handlers.padZeros(a.getUTCDate(), 2) + "T" + com.cognitect.transit.handlers.padZeros(a.getUTCHours(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a.getUTCMinutes(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a.getUTCSeconds(), 2) + "." + com.cognitect.transit.handlers.padZeros(a.getUTCMilliseconds(), 3) + "Z";
};
com.cognitect.transit.handlers.VerboseDateHandler.prototype.stringRep = function(a, b) {
  return b.rep(a);
};
com.cognitect.transit.handlers.DateHandler = function() {
};
com.cognitect.transit.handlers.DateHandler.prototype.tag = function(a) {
  return "m";
};
com.cognitect.transit.handlers.DateHandler.prototype.rep = function(a) {
  return a.valueOf();
};
com.cognitect.transit.handlers.DateHandler.prototype.stringRep = function(a) {
  return a.valueOf().toString();
};
com.cognitect.transit.handlers.DateHandler.prototype.getVerboseHandler = function(a) {
  return new com.cognitect.transit.handlers.VerboseDateHandler;
};
com.cognitect.transit.handlers.UUIDHandler = function() {
};
com.cognitect.transit.handlers.UUIDHandler.prototype.tag = function(a) {
  return "u";
};
com.cognitect.transit.handlers.UUIDHandler.prototype.rep = function(a) {
  return a.toString();
};
com.cognitect.transit.handlers.UUIDHandler.prototype.stringRep = function(a) {
  return a.toString();
};
com.cognitect.transit.handlers.KeywordHandler = function() {
};
com.cognitect.transit.handlers.KeywordHandler.prototype.tag = function(a) {
  return ":";
};
com.cognitect.transit.handlers.KeywordHandler.prototype.rep = function(a) {
  return a._name;
};
com.cognitect.transit.handlers.KeywordHandler.prototype.stringRep = function(a, b) {
  return b.rep(a);
};
com.cognitect.transit.handlers.SymbolHandler = function() {
};
com.cognitect.transit.handlers.SymbolHandler.prototype.tag = function(a) {
  return "$";
};
com.cognitect.transit.handlers.SymbolHandler.prototype.rep = function(a) {
  return a._name;
};
com.cognitect.transit.handlers.SymbolHandler.prototype.stringRep = function(a, b) {
  return b.rep(a);
};
com.cognitect.transit.handlers.TaggedHandler = function() {
};
com.cognitect.transit.handlers.TaggedHandler.prototype.tag = function(a) {
  return a.tag;
};
com.cognitect.transit.handlers.TaggedHandler.prototype.rep = function(a) {
  return a.rep;
};
com.cognitect.transit.handlers.TaggedHandler.prototype.stringRep = function(a, b) {
  return null;
};
com.cognitect.transit.handlers.TransitSetHandler = function() {
};
com.cognitect.transit.handlers.TransitSetHandler.prototype.tag = function(a) {
  return "set";
};
com.cognitect.transit.handlers.TransitSetHandler.prototype.rep = function(a) {
  var b = [];
  a.forEach(function(a, d) {
    b.push(a);
  });
  return com.cognitect.transit.types.taggedValue("array", b);
};
com.cognitect.transit.handlers.TransitSetHandler.prototype.stringRep = function(a, b) {
  return null;
};
com.cognitect.transit.handlers.TransitArrayMapHandler = function() {
};
com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.tag = function(a) {
  return "map";
};
com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.rep = function(a) {
  return a;
};
com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.stringRep = function(a, b) {
  return null;
};
com.cognitect.transit.handlers.TransitMapHandler = function() {
};
com.cognitect.transit.handlers.TransitMapHandler.prototype.tag = function(a) {
  return "map";
};
com.cognitect.transit.handlers.TransitMapHandler.prototype.rep = function(a) {
  return a;
};
com.cognitect.transit.handlers.TransitMapHandler.prototype.stringRep = function(a, b) {
  return null;
};
com.cognitect.transit.handlers.BufferHandler = function() {
};
com.cognitect.transit.handlers.BufferHandler.prototype.tag = function(a) {
  return "b";
};
com.cognitect.transit.handlers.BufferHandler.prototype.rep = function(a) {
  return a.toString("base64");
};
com.cognitect.transit.handlers.BufferHandler.prototype.stringRep = function(a, b) {
  return null;
};
com.cognitect.transit.handlers.Uint8ArrayHandler = function() {
};
com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.tag = function(a) {
  return "b";
};
com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.rep = function(a) {
  return com.cognitect.transit.util.Uint8ToBase64(a);
};
com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.stringRep = function(a, b) {
  return null;
};
com.cognitect.transit.handlers.defaultHandlers = function(a) {
  a.set(null, new com.cognitect.transit.handlers.NilHandler);
  a.set(String, new com.cognitect.transit.handlers.StringHandler);
  a.set(Number, new com.cognitect.transit.handlers.NumberHandler);
  a.set(goog.math.Long, new com.cognitect.transit.handlers.IntegerHandler);
  a.set(Boolean, new com.cognitect.transit.handlers.BooleanHandler);
  a.set(Array, new com.cognitect.transit.handlers.ArrayHandler);
  a.set(Object, new com.cognitect.transit.handlers.MapHandler);
  a.set(Date, new com.cognitect.transit.handlers.DateHandler);
  a.set(com.cognitect.transit.types.UUID, new com.cognitect.transit.handlers.UUIDHandler);
  a.set(com.cognitect.transit.types.Keyword, new com.cognitect.transit.handlers.KeywordHandler);
  a.set(com.cognitect.transit.types.Symbol, new com.cognitect.transit.handlers.SymbolHandler);
  a.set(com.cognitect.transit.types.TaggedValue, new com.cognitect.transit.handlers.TaggedHandler);
  a.set(com.cognitect.transit.types.TransitSet, new com.cognitect.transit.handlers.TransitSetHandler);
  a.set(com.cognitect.transit.types.TransitArrayMap, new com.cognitect.transit.handlers.TransitArrayMapHandler);
  a.set(com.cognitect.transit.types.TransitMap, new com.cognitect.transit.handlers.TransitMapHandler);
  "undefined" != typeof Buffer && a.set(Buffer, new com.cognitect.transit.handlers.BufferHandler);
  "undefined" != typeof Uint8Array && a.set(Uint8Array, new com.cognitect.transit.handlers.Uint8ArrayHandler);
  return a;
};
com.cognitect.transit.handlers.Handlers = function() {
  this.handlers = {};
  com.cognitect.transit.handlers.defaultHandlers(this);
};
com.cognitect.transit.handlers.Handlers.prototype.get = function(a) {
  var b = null, b = "string" === typeof a ? this.handlers[a] : this.handlers[com.cognitect.transit.handlers.typeTag(a)];
  return null != b ? b : this.handlers["default"];
};
com.cognitect.transit.handlers.Handlers.prototype.get = com.cognitect.transit.handlers.Handlers.prototype.get;
com.cognitect.transit.handlers.validTag = function(a) {
  switch(a) {
    case "null":
    ;
    case "string":
    ;
    case "boolean":
    ;
    case "number":
    ;
    case "array":
    ;
    case "map":
      return !1;
  }
  return !0;
};
com.cognitect.transit.handlers.Handlers.prototype.set = function(a, b) {
  "string" === typeof a && com.cognitect.transit.handlers.validTag(a) ? this.handlers[a] = b : this.handlers[com.cognitect.transit.handlers.typeTag(a)] = b;
};
com.cognitect.transit.impl = {};
com.cognitect.transit.impl.decoder = {};
com.cognitect.transit.impl.decoder.Tag = function(a) {
  this.str = a;
};
com.cognitect.transit.impl.decoder.tag = function(a) {
  return new com.cognitect.transit.impl.decoder.Tag(a);
};
com.cognitect.transit.impl.decoder.isTag = function(a) {
  return a && a instanceof com.cognitect.transit.impl.decoder.Tag;
};
com.cognitect.transit.impl.decoder.isGroundHandler = function(a) {
  switch(a) {
    case "_":
    ;
    case "s":
    ;
    case "?":
    ;
    case "i":
    ;
    case "d":
    ;
    case "b":
    ;
    case "'":
    ;
    case "array":
    ;
    case "map":
      return !0;
  }
  return !1;
};
com.cognitect.transit.impl.decoder.Decoder = function(a) {
  this.options = a || {};
  this.handlers = {};
  for (var b in this.defaults.handlers) {
    this.handlers[b] = this.defaults.handlers[b];
  }
  for (b in this.options.handlers) {
    if (com.cognitect.transit.impl.decoder.isGroundHandler(b)) {
      throw Error('Cannot override handler for ground type "' + b + '"');
    }
    this.handlers[b] = this.options.handlers[b];
  }
  this.preferStrings = null != this.options.preferStrings ? this.options.preferStrings : this.defaults.preferStrings;
  this.preferBuffers = null != this.options.preferBuffers ? this.options.preferBuffers : this.defaults.preferBuffers;
  this.defaultHandler = this.options.defaultHandler || this.defaults.defaultHandler;
  this.mapBuilder = this.options.mapBuilder;
  this.arrayBuilder = this.options.arrayBuilder;
};
com.cognitect.transit.impl.decoder.Decoder.prototype.defaults = {handlers:{_:function(a, b) {
  return com.cognitect.transit.types.nullValue();
}, "?":function(a, b) {
  return com.cognitect.transit.types.boolValue(a);
}, b:function(a, b) {
  return com.cognitect.transit.types.binary(a, b);
}, i:function(a, b) {
  return com.cognitect.transit.types.intValue(a);
}, n:function(a, b) {
  return com.cognitect.transit.types.bigInteger(a);
}, d:function(a, b) {
  return com.cognitect.transit.types.floatValue(a);
}, f:function(a, b) {
  return com.cognitect.transit.types.bigDecimalValue(a);
}, c:function(a, b) {
  return com.cognitect.transit.types.charValue(a);
}, ":":function(a, b) {
  return com.cognitect.transit.types.keyword(a);
}, $:function(a, b) {
  return com.cognitect.transit.types.symbol(a);
}, r:function(a, b) {
  return com.cognitect.transit.types.uri(a);
}, z:function(a, b) {
  return com.cognitect.transit.types.specialDouble(a);
}, "'":function(a, b) {
  return a;
}, m:function(a, b) {
  return com.cognitect.transit.types.date(a);
}, t:function(a, b) {
  return com.cognitect.transit.types.verboseDate(a);
}, u:function(a, b) {
  return com.cognitect.transit.types.uuid(a);
}, set:function(a, b) {
  return com.cognitect.transit.types.set(a);
}, list:function(a, b) {
  return com.cognitect.transit.types.list(a);
}, link:function(a, b) {
  return com.cognitect.transit.types.link(a);
}, cmap:function(a, b) {
  return com.cognitect.transit.types.map(a, !1);
}}, defaultHandler:function(a, b) {
  return com.cognitect.transit.types.taggedValue(a, b);
}, preferStrings:!0, preferBuffers:!0};
com.cognitect.transit.impl.decoder.Decoder.prototype.decode = function(a, b, c, d) {
  if (null == a) {
    return null;
  }
  switch(typeof a) {
    case "string":
      return this.decodeString(a, b, c, d);
    case "object":
      return com.cognitect.transit.util.isArray(a) ? "^ " === a[0] ? this.decodeArrayHash(a, b, c, d) : this.decodeArray(a, b, c, d) : this.decodeHash(a, b, c, d);
  }
  return a;
};
com.cognitect.transit.impl.decoder.Decoder.prototype.decode = com.cognitect.transit.impl.decoder.Decoder.prototype.decode;
com.cognitect.transit.impl.decoder.Decoder.prototype.decodeString = function(a, b, c, d) {
  return com.cognitect.transit.caching.isCacheable(a, c) ? (a = this.parseString(a, b, !1), b && b.write(a, c), a) : com.cognitect.transit.caching.isCacheCode(a) ? b.read(a, c) : this.parseString(a, b, c);
};
com.cognitect.transit.impl.decoder.Decoder.prototype.decodeHash = function(a, b, c, d) {
  c = com.cognitect.transit.util.objectKeys(a);
  var e = c[0];
  d = 1 == c.length ? this.decode(e, b, !1, !1) : null;
  if (com.cognitect.transit.impl.decoder.isTag(d)) {
    return a = a[e], c = this.handlers[d.str], null != c ? c(this.decode(a, b, !1, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, !1, !1));
  }
  if (this.mapBuilder) {
    if (c.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD && this.mapBuilder.fromArray) {
      var f = [];
      for (d = 0;d < c.length;d++) {
        e = c[d], f.push(this.decode(e, b, !0, !1)), f.push(this.decode(a[e], b, !1, !1));
      }
      return this.mapBuilder.fromArray(f, a);
    }
    f = this.mapBuilder.init(a);
    for (d = 0;d < c.length;d++) {
      e = c[d], f = this.mapBuilder.add(f, this.decode(e, b, !0, !1), this.decode(a[e], b, !1, !1), a);
    }
    return this.mapBuilder.finalize(f, a);
  }
  f = [];
  for (d = 0;d < c.length;d++) {
    e = c[d], f.push(this.decode(e, b, !0, !1)), f.push(this.decode(a[e], b, !1, !1));
  }
  return com.cognitect.transit.types.map(f, !1);
};
com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArrayHash = function(a, b, c, d) {
  if (this.mapBuilder) {
    if (a.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD + 1 && this.mapBuilder.fromArray) {
      d = [];
      for (c = 1;c < a.length;c += 2) {
        d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));
      }
      return this.mapBuilder.fromArray(d, a);
    }
    d = this.mapBuilder.init(a);
    for (c = 1;c < a.length;c += 2) {
      d = this.mapBuilder.add(d, this.decode(a[c], b, !0, !1), this.decode(a[c + 1], b, !1, !1), a);
    }
    return this.mapBuilder.finalize(d, a);
  }
  d = [];
  for (c = 1;c < a.length;c += 2) {
    d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));
  }
  return com.cognitect.transit.types.map(d, !1);
};
com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArray = function(a, b, c, d) {
  if (d) {
    var e = [];
    for (d = 0;d < a.length;d++) {
      e.push(this.decode(a[d], b, c, !1));
    }
    return e;
  }
  e = b && b.idx;
  if (2 === a.length && "string" === typeof a[0] && (d = this.decode(a[0], b, !1, !1), com.cognitect.transit.impl.decoder.isTag(d))) {
    return a = a[1], e = this.handlers[d.str], null != e ? e = e(this.decode(a, b, c, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, c, !1));
  }
  b && e != b.idx && (b.idx = e);
  if (this.arrayBuilder) {
    if (32 >= a.length && this.arrayBuilder.fromArray) {
      e = [];
      for (d = 0;d < a.length;d++) {
        e.push(this.decode(a[d], b, c, !1));
      }
      return this.arrayBuilder.fromArray(e, a);
    }
    e = this.arrayBuilder.init(a);
    for (d = 0;d < a.length;d++) {
      e = this.arrayBuilder.add(e, this.decode(a[d], b, c, !1), a);
    }
    return this.arrayBuilder.finalize(e, a);
  }
  e = [];
  for (d = 0;d < a.length;d++) {
    e.push(this.decode(a[d], b, c, !1));
  }
  return e;
};
com.cognitect.transit.impl.decoder.Decoder.prototype.parseString = function(a, b, c) {
  if (a.charAt(0) === com.cognitect.transit.delimiters.ESC) {
    b = a.charAt(1);
    if (b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES) {
      return a.substring(1);
    }
    if (b === com.cognitect.transit.delimiters.TAG) {
      return com.cognitect.transit.impl.decoder.tag(a.substring(2));
    }
    c = this.handlers[b];
    return null == c ? this.defaultHandler(b, a.substring(2)) : c(a.substring(2), this);
  }
  return a;
};
com.cognitect.transit.impl.decoder.decoder = function(a) {
  return new com.cognitect.transit.impl.decoder.Decoder(a);
};
com.cognitect.transit.impl.reader = {};
com.cognitect.transit.impl.reader.JSONUnmarshaller = function(a) {
  this.decoder = new com.cognitect.transit.impl.decoder.Decoder(a);
};
com.cognitect.transit.impl.reader.JSONUnmarshaller.prototype.unmarshal = function(a, b) {
  return this.decoder.decode(JSON.parse(a), b);
};
com.cognitect.transit.impl.reader.Reader = function(a, b) {
  this.unmarshaller = a;
  this.options = b || {};
  this.cache = this.options.cache ? this.options.cache : new com.cognitect.transit.caching.ReadCache;
};
com.cognitect.transit.impl.reader.Reader.prototype.read = function(a) {
  a = this.unmarshaller.unmarshal(a, this.cache);
  this.cache.clear();
  return a;
};
com.cognitect.transit.impl.reader.Reader.prototype.read = com.cognitect.transit.impl.reader.Reader.prototype.read;
com.cognitect.transit.impl.writer = {};
com.cognitect.transit.impl.writer.escape = function(a) {
  if (0 < a.length) {
    var b = a.charAt(0);
    return b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES ? com.cognitect.transit.delimiters.ESC + a : a;
  }
  return a;
};
com.cognitect.transit.impl.writer.JSONMarshaller = function(a) {
  this.opts = a || {};
  this.preferStrings = null != this.opts.preferStrings ? this.opts.preferStrings : !0;
  this.objectBuilder = this.opts.objectBuilder || null;
  this.handlers = new com.cognitect.transit.handlers.Handlers;
  if (a = this.opts.handlers) {
    if (com.cognitect.transit.util.isArray(a) || !a.forEach) {
      throw Error('transit writer "handlers" option must be a map');
    }
    var b = this;
    a.forEach(function(a, d) {
      if (void 0 !== d) {
        b.handlers.set(d, a);
      } else {
        throw Error("Cannot create handler for JavaScript undefined");
      }
    });
  }
  this.handlerForForeign = this.opts.handlerForForeign;
  this.unpack = this.opts.unpack || function(a) {
    return com.cognitect.transit.types.isArrayMap(a) && null === a.backingMap ? a._entries : !1;
  };
  this.verbose = this.opts && this.opts.verbose || !1;
};
com.cognitect.transit.impl.writer.JSONMarshaller.prototype.handler = function(a) {
  var b = this.handlers.get(com.cognitect.transit.handlers.constructor(a));
  return null != b ? b : (a = a && a.transitTag) ? this.handlers.get(a) : null;
};
com.cognitect.transit.impl.writer.JSONMarshaller.prototype.registerHandler = function(a, b) {
  this.handlers.set(a, b);
};
com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitNil = function(a, b) {
  return a ? this.emitString(com.cognitect.transit.delimiters.ESC, "_", "", a, b) : null;
};
com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitString = function(a, b, c, d, e) {
  a = a + b + c;
  return e ? e.write(a, d) : a;
};
com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBoolean = function(a, b, c) {
  return b ? this.emitString(com.cognitect.transit.delimiters.ESC, "?", a.toString()[0], b, c) : a;
};
com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitInteger = function(a, b, c) {
  return Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "INF", b, c) : -Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "-INF", b, c) : isNaN(a) ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "NaN", b, c) : b || "string" === typeof a || a instanceof goog.math.Long ? this.emitString(com.cognitect.transit.delimiters.ESC, "i", a.toString(), b, c) : a;
};
com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitDouble = function(a, b, c) {
  return b ? this.emitString(a.ESC, "d", a, b, c) : a;
};
com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBinary = function(a, b, c) {
  return this.emitString(com.cognitect.transit.delimiters.ESC, "b", a, b, c);
};
com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitQuoted = function(a, b, c) {
  if (a.verbose) {
    a = {};
    var d = this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", !0, c);
    a[d] = com.cognitect.transit.impl.writer.marshal(this, b, !1, c);
    return a;
  }
  return [this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", !0, c), com.cognitect.transit.impl.writer.marshal(this, b, !1, c)];
};
com.cognitect.transit.impl.writer.emitObjects = function(a, b, c) {
  var d = [];
  if (com.cognitect.transit.util.isArray(b)) {
    for (var e = 0;e < b.length;e++) {
      d.push(com.cognitect.transit.impl.writer.marshal(a, b[e], !1, c));
    }
  } else {
    b.forEach(function(b, e) {
      d.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, c));
    });
  }
  return d;
};
com.cognitect.transit.impl.writer.emitArray = function(a, b, c, d) {
  return com.cognitect.transit.impl.writer.emitObjects(a, b, d);
};
com.cognitect.transit.impl.writer.isStringableKey = function(a, b) {
  if ("string" !== typeof b) {
    var c = a.handler(b);
    return c && 1 === c.tag(b).length;
  }
  return !0;
};
com.cognitect.transit.impl.writer.stringableKeys = function(a, b) {
  var c = a.unpack(b), d = !0;
  if (c) {
    for (var e = 0;e < c.length && (d = com.cognitect.transit.impl.writer.isStringableKey(a, c[e]), d);e += 2) {
    }
    return d;
  }
  if (b.keys && (c = b.keys(), e = null, c.next)) {
    for (e = c.next();!e.done;) {
      d = com.cognitect.transit.impl.writer.isStringableKey(a, e.value);
      if (!d) {
        break;
      }
      e = c.next();
    }
    return d;
  }
  if (b.forEach) {
    return b.forEach(function(b, c) {
      d = d && com.cognitect.transit.impl.writer.isStringableKey(a, c);
    }), d;
  }
  throw Error("Cannot walk keys of object type " + com.cognitect.transit.handlers.constructor(b).name);
};
com.cognitect.transit.impl.writer.isForeignObject = function(a) {
  if (a.constructor.transit$isObject) {
    return !0;
  }
  var b = a.constructor.toString(), b = b.substr(9), b = b.substr(0, b.indexOf("(")), b = "Object" == b;
  "undefined" != typeof Object.defineProperty ? Object.defineProperty(a.constructor, "transit$isObject", {value:b, enumerable:!1}) : a.constructor.transit$isObject = b;
  return b;
};
com.cognitect.transit.impl.writer.emitMap = function(a, b, c, d) {
  if (b.constructor === Object || null != b.forEach || a.handlerForForeign && com.cognitect.transit.impl.writer.isForeignObject(b)) {
    if (a.verbose) {
      if (null != b.forEach) {
        if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {
          var e = {};
          b.forEach(function(b, c) {
            e[com.cognitect.transit.impl.writer.marshal(a, c, !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b, !1, d);
          });
        } else {
          var f = a.unpack(b), g = [], h = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", !0, d);
          if (f) {
            for (c = 0;c < f.length;c += 2) {
              g.push(com.cognitect.transit.impl.writer.marshal(a, f[c], !0, !1)), g.push(com.cognitect.transit.impl.writer.marshal(a, f[c + 1], !1, d));
            }
          } else {
            b.forEach(function(b, c) {
              g.push(com.cognitect.transit.impl.writer.marshal(a, c, !0, !1));
              g.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
            });
          }
          e = {};
          e[h] = g;
        }
      } else {
        for (e = {}, f = com.cognitect.transit.util.objectKeys(b), c = 0;c < f.length;c++) {
          e[com.cognitect.transit.impl.writer.marshal(a, f[c], !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b[f[c]], !1, d);
        }
      }
      return e;
    }
    if (null != b.forEach) {
      if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {
        f = a.unpack(b);
        e = ["^ "];
        if (f) {
          for (c = 0;c < f.length;c += 2) {
            e.push(com.cognitect.transit.impl.writer.marshal(a, f[c], !0, d)), e.push(com.cognitect.transit.impl.writer.marshal(a, f[c + 1], !1, d));
          }
        } else {
          b.forEach(function(b, c) {
            e.push(com.cognitect.transit.impl.writer.marshal(a, c, !0, d));
            e.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
          });
        }
        return e;
      }
      f = a.unpack(b);
      g = [];
      h = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", !0, d);
      if (f) {
        for (c = 0;c < f.length;c += 2) {
          g.push(com.cognitect.transit.impl.writer.marshal(a, f[c], !0, d)), g.push(com.cognitect.transit.impl.writer.marshal(a, f[c + 1], !1, d));
        }
      } else {
        b.forEach(function(b, c) {
          g.push(com.cognitect.transit.impl.writer.marshal(a, c, !0, d));
          g.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
        });
      }
      return [h, g];
    }
    e = ["^ "];
    f = com.cognitect.transit.util.objectKeys(b);
    for (c = 0;c < f.length;c++) {
      e.push(com.cognitect.transit.impl.writer.marshal(a, f[c], !0, d)), e.push(com.cognitect.transit.impl.writer.marshal(a, b[f[c]], !1, d));
    }
    return e;
  }
  if (null != a.objectBuilder) {
    return a.objectBuilder(b, function(b) {
      return com.cognitect.transit.impl.writer.marshal(a, b, !0, d);
    }, function(b) {
      return com.cognitect.transit.impl.writer.marshal(a, b, !1, d);
    });
  }
  c = com.cognitect.transit.handlers.constructor(b).name;
  f = Error("Cannot write " + c);
  f.data = {obj:b, type:c};
  throw f;
};
com.cognitect.transit.impl.writer.emitTaggedMap = function(a, b, c, d, e) {
  return a.verbose ? (d = {}, d[a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, "", !0, e)] = com.cognitect.transit.impl.writer.marshal(a, c, !1, e), d) : [a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, "", !0, e), com.cognitect.transit.impl.writer.marshal(a, c, !1, e)];
};
com.cognitect.transit.impl.writer.emitEncoded = function(a, b, c, d, e, f, g) {
  if (1 === c.length) {
    if ("string" === typeof d) {
      return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);
    }
    if (f || a.preferStrings) {
      (d = a.verbose && b.getVerboseHandler()) ? (c = d.tag(e), d = d.stringRep(e, d)) : d = b.stringRep(e, b);
      if (null !== d) {
        return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);
      }
      a = Error('Tag "' + c + '" cannot be encoded as string');
      a.data = {tag:c, rep:d, obj:e};
      throw a;
    }
  }
  return com.cognitect.transit.impl.writer.emitTaggedMap(a, c, d, f, g);
};
com.cognitect.transit.impl.writer.marshal = function(a, b, c, d) {
  var e = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null), f = e ? e.tag(b) : null, g = e ? e.rep(b) : null;
  if (null != e && null != f) {
    switch(f) {
      case "_":
        return a.emitNil(c, d);
      case "s":
        return a.emitString("", "", com.cognitect.transit.impl.writer.escape(g), c, d);
      case "?":
        return a.emitBoolean(g, c, d);
      case "i":
        return a.emitInteger(g, c, d);
      case "d":
        return a.emitDouble(g, c, d);
      case "b":
        return a.emitBinary(g, c, d);
      case "'":
        return a.emitQuoted(a, g, d);
      case "array":
        return com.cognitect.transit.impl.writer.emitArray(a, g, c, d);
      case "map":
        return com.cognitect.transit.impl.writer.emitMap(a, g, c, d);
      default:
        return com.cognitect.transit.impl.writer.emitEncoded(a, e, f, g, b, c, d);
    }
  } else {
    throw a = com.cognitect.transit.handlers.constructor(b).name, c = Error("Cannot write " + a), c.data = {obj:b, type:a}, c;
  }
};
com.cognitect.transit.impl.writer.maybeQuoted = function(a, b) {
  var c = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null);
  if (null != c) {
    return 1 === c.tag(b).length ? com.cognitect.transit.types.quoted(b) : b;
  }
  var c = com.cognitect.transit.handlers.constructor(b).name, d = Error("Cannot write " + c);
  d.data = {obj:b, type:c};
  throw d;
};
com.cognitect.transit.impl.writer.marshalTop = function(a, b, c, d) {
  return JSON.stringify(com.cognitect.transit.impl.writer.marshal(a, com.cognitect.transit.impl.writer.maybeQuoted(a, b), c, d));
};
com.cognitect.transit.impl.writer.Writer = function(a, b) {
  this._marshaller = a;
  this.options = b || {};
  this.cache = !1 === this.options.cache ? null : this.options.cache ? this.options.cache : new com.cognitect.transit.caching.WriteCache;
};
com.cognitect.transit.impl.writer.Writer.prototype.marshaller = function() {
  return this._marshaller;
};
com.cognitect.transit.impl.writer.Writer.prototype.marshaller = com.cognitect.transit.impl.writer.Writer.prototype.marshaller;
com.cognitect.transit.impl.writer.Writer.prototype.write = function(a, b) {
  var c = null, c = b || {}, d = c.asMapKey || !1, e = this._marshaller.verbose ? !1 : this.cache, c = !1 === c.marshalTop ? com.cognitect.transit.impl.writer.marshal(this._marshaller, a, d, e) : com.cognitect.transit.impl.writer.marshalTop(this._marshaller, a, d, e);
  null != this.cache && this.cache.clear();
  return c;
};
com.cognitect.transit.impl.writer.Writer.prototype.write = com.cognitect.transit.impl.writer.Writer.prototype.write;
com.cognitect.transit.impl.writer.Writer.prototype.register = function(a, b) {
  this._marshaller.registerHandler(a, b);
};
com.cognitect.transit.impl.writer.Writer.prototype.register = com.cognitect.transit.impl.writer.Writer.prototype.register;
var TRANSIT_DEV = !0, TRANSIT_NODE_TARGET = !0, TRANSIT_BROWSER_TARGET = !1, TRANSIT_BROWSER_AMD_TARGET = !1;
com.cognitect.transit.reader = function(a, b) {
  if ("json" === a || "json-verbose" === a || null == a) {
    var c = new com.cognitect.transit.impl.reader.JSONUnmarshaller(b);
    return new com.cognitect.transit.impl.reader.Reader(c, b);
  }
  throw Error("Cannot create reader of type " + a);
};
com.cognitect.transit.writer = function(a, b) {
  if ("json" === a || "json-verbose" === a || null == a) {
    "json-verbose" === a && (null == b && (b = {}), b.verbose = !0);
    var c = new com.cognitect.transit.impl.writer.JSONMarshaller(b);
    return new com.cognitect.transit.impl.writer.Writer(c, b);
  }
  c = Error('Type must be "json"');
  c.data = {type:a};
  throw c;
};
com.cognitect.transit.makeWriteHandler = function(a) {
  var b = function() {
  };
  b.prototype.tag = a.tag;
  b.prototype.rep = a.rep;
  b.prototype.stringRep = a.stringRep;
  b.prototype.getVerboseHandler = a.getVerboseHandler;
  return new b;
};
com.cognitect.transit.makeBuilder = function(a) {
  var b = function() {
  };
  b.prototype.init = a.init;
  b.prototype.add = a.add;
  b.prototype.finalize = a.finalize;
  b.prototype.fromArray = a.fromArray;
  return new b;
};
com.cognitect.transit.date = com.cognitect.transit.types.date;
com.cognitect.transit.integer = com.cognitect.transit.types.intValue;
com.cognitect.transit.isInteger = com.cognitect.transit.types.isInteger;
com.cognitect.transit.uuid = com.cognitect.transit.types.uuid;
com.cognitect.transit.isUUID = com.cognitect.transit.types.isUUID;
com.cognitect.transit.bigInt = com.cognitect.transit.types.bigInteger;
com.cognitect.transit.isBigInt = com.cognitect.transit.types.isBigInteger;
com.cognitect.transit.bigDec = com.cognitect.transit.types.bigDecimalValue;
com.cognitect.transit.isBigDec = com.cognitect.transit.types.isBigDecimal;
com.cognitect.transit.keyword = com.cognitect.transit.types.keyword;
com.cognitect.transit.isKeyword = com.cognitect.transit.types.isKeyword;
com.cognitect.transit.symbol = com.cognitect.transit.types.symbol;
com.cognitect.transit.isSymbol = com.cognitect.transit.types.isSymbol;
com.cognitect.transit.binary = com.cognitect.transit.types.binary;
com.cognitect.transit.isBinary = com.cognitect.transit.types.isBinary;
com.cognitect.transit.uri = com.cognitect.transit.types.uri;
com.cognitect.transit.isURI = com.cognitect.transit.types.isURI;
com.cognitect.transit.map = com.cognitect.transit.types.map;
com.cognitect.transit.isMap = com.cognitect.transit.types.isMap;
com.cognitect.transit.set = com.cognitect.transit.types.set;
com.cognitect.transit.isSet = com.cognitect.transit.types.isSet;
com.cognitect.transit.list = com.cognitect.transit.types.list;
com.cognitect.transit.isList = com.cognitect.transit.types.isList;
com.cognitect.transit.quoted = com.cognitect.transit.types.quoted;
com.cognitect.transit.isQuoted = com.cognitect.transit.types.isQuoted;
com.cognitect.transit.tagged = com.cognitect.transit.types.taggedValue;
com.cognitect.transit.isTaggedValue = com.cognitect.transit.types.isTaggedValue;
com.cognitect.transit.link = com.cognitect.transit.types.link;
com.cognitect.transit.isLink = com.cognitect.transit.types.isLink;
com.cognitect.transit.hash = com.cognitect.transit.eq.hashCode;
com.cognitect.transit.hashMapLike = com.cognitect.transit.eq.hashMapLike;
com.cognitect.transit.hashArrayLike = com.cognitect.transit.eq.hashArrayLike;
com.cognitect.transit.equals = com.cognitect.transit.eq.equals;
com.cognitect.transit.extendToEQ = com.cognitect.transit.eq.extendToEQ;
com.cognitect.transit.mapToObject = function(a) {
  var b = {};
  a.forEach(function(a, d) {
    if ("string" !== typeof d) {
      throw Error("Cannot convert map with non-string keys");
    }
    b[d] = a;
  });
  return b;
};
com.cognitect.transit.objectToMap = function(a) {
  var b = com.cognitect.transit.map(), c;
  for (c in a) {
    a.hasOwnProperty(c) && b.set(c, a[c]);
  }
  return b;
};
com.cognitect.transit.decoder = com.cognitect.transit.impl.decoder.decoder;
com.cognitect.transit.readCache = com.cognitect.transit.caching.readCache;
com.cognitect.transit.writeCache = com.cognitect.transit.caching.writeCache;
com.cognitect.transit.UUIDfromString = com.cognitect.transit.types.UUIDfromString;
com.cognitect.transit.randomUUID = com.cognitect.transit.util.randomUUID;
com.cognitect.transit.stringableKeys = com.cognitect.transit.impl.writer.stringableKeys;
TRANSIT_BROWSER_TARGET && (goog.exportSymbol("transit.reader", com.cognitect.transit.reader), goog.exportSymbol("transit.writer", com.cognitect.transit.writer), goog.exportSymbol("transit.makeBuilder", com.cognitect.transit.makeBuilder), goog.exportSymbol("transit.makeWriteHandler", com.cognitect.transit.makeWriteHandler), goog.exportSymbol("transit.date", com.cognitect.transit.types.date), goog.exportSymbol("transit.integer", com.cognitect.transit.types.intValue), goog.exportSymbol("transit.isInteger", 
com.cognitect.transit.types.isInteger), goog.exportSymbol("transit.uuid", com.cognitect.transit.types.uuid), goog.exportSymbol("transit.isUUID", com.cognitect.transit.types.isUUID), goog.exportSymbol("transit.bigInt", com.cognitect.transit.types.bigInteger), goog.exportSymbol("transit.isBigInt", com.cognitect.transit.types.isBigInteger), goog.exportSymbol("transit.bigDec", com.cognitect.transit.types.bigDecimalValue), goog.exportSymbol("transit.isBigDec", com.cognitect.transit.types.isBigDecimal), 
goog.exportSymbol("transit.keyword", com.cognitect.transit.types.keyword), goog.exportSymbol("transit.isKeyword", com.cognitect.transit.types.isKeyword), goog.exportSymbol("transit.symbol", com.cognitect.transit.types.symbol), goog.exportSymbol("transit.isSymbol", com.cognitect.transit.types.isSymbol), goog.exportSymbol("transit.binary", com.cognitect.transit.types.binary), goog.exportSymbol("transit.isBinary", com.cognitect.transit.types.isBinary), goog.exportSymbol("transit.uri", com.cognitect.transit.types.uri), 
goog.exportSymbol("transit.isURI", com.cognitect.transit.types.isURI), goog.exportSymbol("transit.map", com.cognitect.transit.types.map), goog.exportSymbol("transit.isMap", com.cognitect.transit.types.isMap), goog.exportSymbol("transit.set", com.cognitect.transit.types.set), goog.exportSymbol("transit.isSet", com.cognitect.transit.types.isSet), goog.exportSymbol("transit.list", com.cognitect.transit.types.list), goog.exportSymbol("transit.isList", com.cognitect.transit.types.isList), goog.exportSymbol("transit.quoted", 
com.cognitect.transit.types.quoted), goog.exportSymbol("transit.isQuoted", com.cognitect.transit.types.isQuoted), goog.exportSymbol("transit.tagged", com.cognitect.transit.types.taggedValue), goog.exportSymbol("transit.isTaggedValue", com.cognitect.transit.types.isTaggedValue), goog.exportSymbol("transit.link", com.cognitect.transit.types.link), goog.exportSymbol("transit.isLink", com.cognitect.transit.types.isLink), goog.exportSymbol("transit.hash", com.cognitect.transit.eq.hashCode), goog.exportSymbol("transit.hashMapLike", 
com.cognitect.transit.eq.hashMapLike), goog.exportSymbol("transit.hashArrayLike", com.cognitect.transit.eq.hashArrayLike), goog.exportSymbol("transit.equals", com.cognitect.transit.eq.equals), goog.exportSymbol("transit.extendToEQ", com.cognitect.transit.eq.extendToEQ), goog.exportSymbol("transit.mapToObject", com.cognitect.transit.mapToObject), goog.exportSymbol("transit.objectToMap", com.cognitect.transit.objectToMap), goog.exportSymbol("transit.decoder", com.cognitect.transit.impl.decoder.decoder), 
goog.exportSymbol("transit.UUIDfromString", com.cognitect.transit.types.UUIDfromString), goog.exportSymbol("transit.randomUUID", com.cognitect.transit.util.randomUUID), goog.exportSymbol("transit.stringableKeys", com.cognitect.transit.impl.writer.stringableKeys), goog.exportSymbol("transit.readCache", com.cognitect.transit.caching.readCache), goog.exportSymbol("transit.writeCache", com.cognitect.transit.caching.writeCache));
TRANSIT_NODE_TARGET && (module.exports = {reader:com.cognitect.transit.reader, writer:com.cognitect.transit.writer, makeBuilder:com.cognitect.transit.makeBuilder, makeWriteHandler:com.cognitect.transit.makeWriteHandler, date:com.cognitect.transit.types.date, integer:com.cognitect.transit.types.intValue, isInteger:com.cognitect.transit.types.isInteger, uuid:com.cognitect.transit.types.uuid, isUUID:com.cognitect.transit.types.isUUID, bigInt:com.cognitect.transit.types.bigInteger, isBigInt:com.cognitect.transit.types.isBigInteger, 
bigDec:com.cognitect.transit.types.bigDecimalValue, isBigDec:com.cognitect.transit.types.isBigDecimal, keyword:com.cognitect.transit.types.keyword, isKeyword:com.cognitect.transit.types.isKeyword, symbol:com.cognitect.transit.types.symbol, isSymbol:com.cognitect.transit.types.isSymbol, binary:com.cognitect.transit.types.binary, isBinary:com.cognitect.transit.types.isBinary, uri:com.cognitect.transit.types.uri, isURI:com.cognitect.transit.types.isURI, map:com.cognitect.transit.types.map, isMap:com.cognitect.transit.types.isMap, 
set:com.cognitect.transit.types.set, isSet:com.cognitect.transit.types.isSet, list:com.cognitect.transit.types.list, isList:com.cognitect.transit.types.isList, quoted:com.cognitect.transit.types.quoted, isQuoted:com.cognitect.transit.types.isQuoted, tagged:com.cognitect.transit.types.taggedValue, isTaggedValue:com.cognitect.transit.types.isTaggedValue, link:com.cognitect.transit.types.link, isLink:com.cognitect.transit.types.isLink, hash:com.cognitect.transit.eq.hashCode, hashArrayLike:com.cognitect.transit.eq.hashArrayLike, 
hashMapLike:com.cognitect.transit.eq.hashMapLike, equals:com.cognitect.transit.eq.equals, extendToEQ:com.cognitect.transit.eq.extendToEQ, mapToObject:com.cognitect.transit.mapToObject, objectToMap:com.cognitect.transit.objectToMap, decoder:com.cognitect.transit.impl.decoder.decoder, UUIDfromString:com.cognitect.transit.types.UUIDfromString, randomUUID:com.cognitect.transit.util.randomUUID, stringableKeys:com.cognitect.transit.impl.writer.stringableKeys, readCache:com.cognitect.transit.caching.readCache, 
writeCache:com.cognitect.transit.caching.writeCache});


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(99).Buffer))

/***/ }),
/* 699 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;


/***/ }),
/* 700 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))

/***/ }),
/* 701 */
/***/ (function(module, exports) {

module.exports = {"name":"webvr-polyfill","version":"0.9.36","homepage":"https://github.com/googlevr/webvr-polyfill","authors":["Boris Smus <boris@smus.com>","Brandon Jones <tojiro@gmail.com>","Jordan Santell <jordan@jsantell.com>"],"description":"Use WebVR today, on mobile or desktop, without requiring a special browser build.","devDependencies":{"chai":"^3.5.0","jsdom":"^9.12.0","mocha":"^3.2.0","semver":"^5.3.0","webpack":"^2.6.1","webpack-dev-server":"^2.4.5"},"main":"src/node-entry","keywords":["vr","webvr"],"license":"Apache-2.0","scripts":{"start":"npm run watch","watch":"webpack-dev-server","build":"webpack","test":"mocha"},"repository":"googlevr/webvr-polyfill","bugs":{"url":"https://github.com/googlevr/webvr-polyfill/issues"}}

/***/ }),
/* 702 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var CardboardUI = __webpack_require__(312);
var Util = __webpack_require__(23);
var WGLUPreserveGLState = __webpack_require__(313);

var distortionVS = [
  'attribute vec2 position;',
  'attribute vec3 texCoord;',

  'varying vec2 vTexCoord;',

  'uniform vec4 viewportOffsetScale[2];',

  'void main() {',
  '  vec4 viewport = viewportOffsetScale[int(texCoord.z)];',
  '  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;',
  '  gl_Position = vec4( position, 1.0, 1.0 );',
  '}',
].join('\n');

var distortionFS = [
  'precision mediump float;',
  'uniform sampler2D diffuse;',

  'varying vec2 vTexCoord;',

  'void main() {',
  '  gl_FragColor = texture2D(diffuse, vTexCoord);',
  '}',
].join('\n');

/**
 * A mesh-based distorter.
 */
function CardboardDistorter(gl) {
  this.gl = gl;
  this.ctxAttribs = gl.getContextAttributes();

  this.meshWidth = 20;
  this.meshHeight = 20;

  this.bufferScale = window.WebVRConfig.BUFFER_SCALE;

  this.bufferWidth = gl.drawingBufferWidth;
  this.bufferHeight = gl.drawingBufferHeight;

  // Patching support
  this.realBindFramebuffer = gl.bindFramebuffer;
  this.realEnable = gl.enable;
  this.realDisable = gl.disable;
  this.realColorMask = gl.colorMask;
  this.realClearColor = gl.clearColor;
  this.realViewport = gl.viewport;

  if (!Util.isIOS()) {
    this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'width');
    this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'height');
  }

  this.isPatched = false;

  // State tracking
  this.lastBoundFramebuffer = null;
  this.cullFace = false;
  this.depthTest = false;
  this.blend = false;
  this.scissorTest = false;
  this.stencilTest = false;
  this.viewport = [0, 0, 0, 0];
  this.colorMask = [true, true, true, true];
  this.clearColor = [0, 0, 0, 0];

  this.attribs = {
    position: 0,
    texCoord: 1
  };
  this.program = Util.linkProgram(gl, distortionVS, distortionFS, this.attribs);
  this.uniforms = Util.getProgramUniforms(gl, this.program);

  this.viewportOffsetScale = new Float32Array(8);
  this.setTextureBounds();

  this.vertexBuffer = gl.createBuffer();
  this.indexBuffer = gl.createBuffer();
  this.indexCount = 0;

  this.renderTarget = gl.createTexture();
  this.framebuffer = gl.createFramebuffer();

  this.depthStencilBuffer = null;
  this.depthBuffer = null;
  this.stencilBuffer = null;

  if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
    this.depthStencilBuffer = gl.createRenderbuffer();
  } else if (this.ctxAttribs.depth) {
    this.depthBuffer = gl.createRenderbuffer();
  } else if (this.ctxAttribs.stencil) {
    this.stencilBuffer = gl.createRenderbuffer();
  }

  this.patch();

  this.onResize();

  if (!window.WebVRConfig.CARDBOARD_UI_DISABLED) {
    this.cardboardUI = new CardboardUI(gl);
  }
};

/**
 * Tears down all the resources created by the distorter and removes any
 * patches.
 */
CardboardDistorter.prototype.destroy = function() {
  var gl = this.gl;

  this.unpatch();

  gl.deleteProgram(this.program);
  gl.deleteBuffer(this.vertexBuffer);
  gl.deleteBuffer(this.indexBuffer);
  gl.deleteTexture(this.renderTarget);
  gl.deleteFramebuffer(this.framebuffer);
  if (this.depthStencilBuffer) {
    gl.deleteRenderbuffer(this.depthStencilBuffer);
  }
  if (this.depthBuffer) {
    gl.deleteRenderbuffer(this.depthBuffer);
  }
  if (this.stencilBuffer) {
    gl.deleteRenderbuffer(this.stencilBuffer);
  }

  if (this.cardboardUI) {
    this.cardboardUI.destroy();
  }
};


/**
 * Resizes the backbuffer to match the canvas width and height.
 */
CardboardDistorter.prototype.onResize = function() {
  var gl = this.gl;
  var self = this;

  var glState = [
    gl.RENDERBUFFER_BINDING,
    gl.TEXTURE_BINDING_2D, gl.TEXTURE0
  ];

  WGLUPreserveGLState(gl, glState, function(gl) {
    // Bind real backbuffer and clear it once. We don't need to clear it again
    // after that because we're overwriting the same area every frame.
    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);

    // Put things in a good state
    if (self.scissorTest) { self.realDisable.call(gl, gl.SCISSOR_TEST); }
    self.realColorMask.call(gl, true, true, true, true);
    self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    self.realClearColor.call(gl, 0, 0, 0, 1);

    gl.clear(gl.COLOR_BUFFER_BIT);

    // Now bind and resize the fake backbuffer
    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.framebuffer);

    gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);
    gl.texImage2D(gl.TEXTURE_2D, 0, self.ctxAttribs.alpha ? gl.RGBA : gl.RGB,
        self.bufferWidth, self.bufferHeight, 0,
        self.ctxAttribs.alpha ? gl.RGBA : gl.RGB, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, self.renderTarget, 0);

    if (self.ctxAttribs.depth && self.ctxAttribs.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthStencilBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,
          self.bufferWidth, self.bufferHeight);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT,
          gl.RENDERBUFFER, self.depthStencilBuffer);
    } else if (self.ctxAttribs.depth) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
          self.bufferWidth, self.bufferHeight);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
          gl.RENDERBUFFER, self.depthBuffer);
    } else if (self.ctxAttribs.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, self.stencilBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8,
          self.bufferWidth, self.bufferHeight);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT,
          gl.RENDERBUFFER, self.stencilBuffer);
    }

    if (!gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
      console.error('Framebuffer incomplete!');
    }

    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);

    if (self.scissorTest) { self.realEnable.call(gl, gl.SCISSOR_TEST); }

    self.realColorMask.apply(gl, self.colorMask);
    self.realViewport.apply(gl, self.viewport);
    self.realClearColor.apply(gl, self.clearColor);
  });

  if (this.cardboardUI) {
    this.cardboardUI.onResize();
  }
};

CardboardDistorter.prototype.patch = function() {
  if (this.isPatched) {
    return;
  }

  var self = this;
  var canvas = this.gl.canvas;
  var gl = this.gl;

  if (!Util.isIOS()) {
    canvas.width = Util.getScreenWidth() * this.bufferScale;
    canvas.height = Util.getScreenHeight() * this.bufferScale;

    Object.defineProperty(canvas, 'width', {
      configurable: true,
      enumerable: true,
      get: function() {
        return self.bufferWidth;
      },
      set: function(value) {
        self.bufferWidth = value;
        self.realCanvasWidth.set.call(canvas, value);
        self.onResize();
      }
    });

    Object.defineProperty(canvas, 'height', {
      configurable: true,
      enumerable: true,
      get: function() {
        return self.bufferHeight;
      },
      set: function(value) {
        self.bufferHeight = value;
        self.realCanvasHeight.set.call(canvas, value);
        self.onResize();
      }
    });
  }

  this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);

  if (this.lastBoundFramebuffer == null) {
    this.lastBoundFramebuffer = this.framebuffer;
    this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
  }

  this.gl.bindFramebuffer = function(target, framebuffer) {
    self.lastBoundFramebuffer = framebuffer ? framebuffer : self.framebuffer;
    // Silently make calls to bind the default framebuffer bind ours instead.
    self.realBindFramebuffer.call(gl, target, self.lastBoundFramebuffer);
  };

  this.cullFace = gl.getParameter(gl.CULL_FACE);
  this.depthTest = gl.getParameter(gl.DEPTH_TEST);
  this.blend = gl.getParameter(gl.BLEND);
  this.scissorTest = gl.getParameter(gl.SCISSOR_TEST);
  this.stencilTest = gl.getParameter(gl.STENCIL_TEST);

  gl.enable = function(pname) {
    switch (pname) {
      case gl.CULL_FACE: self.cullFace = true; break;
      case gl.DEPTH_TEST: self.depthTest = true; break;
      case gl.BLEND: self.blend = true; break;
      case gl.SCISSOR_TEST: self.scissorTest = true; break;
      case gl.STENCIL_TEST: self.stencilTest = true; break;
    }
    self.realEnable.call(gl, pname);
  };

  gl.disable = function(pname) {
    switch (pname) {
      case gl.CULL_FACE: self.cullFace = false; break;
      case gl.DEPTH_TEST: self.depthTest = false; break;
      case gl.BLEND: self.blend = false; break;
      case gl.SCISSOR_TEST: self.scissorTest = false; break;
      case gl.STENCIL_TEST: self.stencilTest = false; break;
    }
    self.realDisable.call(gl, pname);
  };

  this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK);
  gl.colorMask = function(r, g, b, a) {
    self.colorMask[0] = r;
    self.colorMask[1] = g;
    self.colorMask[2] = b;
    self.colorMask[3] = a;
    self.realColorMask.call(gl, r, g, b, a);
  };

  this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
  gl.clearColor = function(r, g, b, a) {
    self.clearColor[0] = r;
    self.clearColor[1] = g;
    self.clearColor[2] = b;
    self.clearColor[3] = a;
    self.realClearColor.call(gl, r, g, b, a);
  };

  this.viewport = gl.getParameter(gl.VIEWPORT);
  gl.viewport = function(x, y, w, h) {
    self.viewport[0] = x;
    self.viewport[1] = y;
    self.viewport[2] = w;
    self.viewport[3] = h;
    self.realViewport.call(gl, x, y, w, h);
  };

  this.isPatched = true;
  Util.safariCssSizeWorkaround(canvas);
};

CardboardDistorter.prototype.unpatch = function() {
  if (!this.isPatched) {
    return;
  }

  var gl = this.gl;
  var canvas = this.gl.canvas;

  if (!Util.isIOS()) {
    Object.defineProperty(canvas, 'width', this.realCanvasWidth);
    Object.defineProperty(canvas, 'height', this.realCanvasHeight);
  }
  canvas.width = this.bufferWidth;
  canvas.height = this.bufferHeight;

  gl.bindFramebuffer = this.realBindFramebuffer;
  gl.enable = this.realEnable;
  gl.disable = this.realDisable;
  gl.colorMask = this.realColorMask;
  gl.clearColor = this.realClearColor;
  gl.viewport = this.realViewport;

  // Check to see if our fake backbuffer is bound and bind the real backbuffer
  // if that's the case.
  if (this.lastBoundFramebuffer == this.framebuffer) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  this.isPatched = false;

  setTimeout(function() {
    Util.safariCssSizeWorkaround(canvas);
  }, 1);
};

CardboardDistorter.prototype.setTextureBounds = function(leftBounds, rightBounds) {
  if (!leftBounds) {
    leftBounds = [0, 0, 0.5, 1];
  }

  if (!rightBounds) {
    rightBounds = [0.5, 0, 0.5, 1];
  }

  // Left eye
  this.viewportOffsetScale[0] = leftBounds[0]; // X
  this.viewportOffsetScale[1] = leftBounds[1]; // Y
  this.viewportOffsetScale[2] = leftBounds[2]; // Width
  this.viewportOffsetScale[3] = leftBounds[3]; // Height

  // Right eye
  this.viewportOffsetScale[4] = rightBounds[0]; // X
  this.viewportOffsetScale[5] = rightBounds[1]; // Y
  this.viewportOffsetScale[6] = rightBounds[2]; // Width
  this.viewportOffsetScale[7] = rightBounds[3]; // Height
};

/**
 * Performs distortion pass on the injected backbuffer, rendering it to the real
 * backbuffer.
 */
CardboardDistorter.prototype.submitFrame = function() {
  var gl = this.gl;
  var self = this;

  var glState = [];

  if (!window.WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
    glState.push(
      gl.CURRENT_PROGRAM,
      gl.ARRAY_BUFFER_BINDING,
      gl.ELEMENT_ARRAY_BUFFER_BINDING,
      gl.TEXTURE_BINDING_2D, gl.TEXTURE0
    );
  }

  WGLUPreserveGLState(gl, glState, function(gl) {
    // Bind the real default framebuffer
    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);

    // Make sure the GL state is in a good place
    if (self.cullFace) { self.realDisable.call(gl, gl.CULL_FACE); }
    if (self.depthTest) { self.realDisable.call(gl, gl.DEPTH_TEST); }
    if (self.blend) { self.realDisable.call(gl, gl.BLEND); }
    if (self.scissorTest) { self.realDisable.call(gl, gl.SCISSOR_TEST); }
    if (self.stencilTest) { self.realDisable.call(gl, gl.STENCIL_TEST); }
    self.realColorMask.call(gl, true, true, true, true);
    self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

    // If the backbuffer has an alpha channel clear every frame so the page
    // doesn't show through.
    if (self.ctxAttribs.alpha || Util.isIOS()) {
      self.realClearColor.call(gl, 0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
    }

    // Bind distortion program and mesh
    gl.useProgram(self.program);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);

    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
    gl.enableVertexAttribArray(self.attribs.position);
    gl.enableVertexAttribArray(self.attribs.texCoord);
    gl.vertexAttribPointer(self.attribs.position, 2, gl.FLOAT, false, 20, 0);
    gl.vertexAttribPointer(self.attribs.texCoord, 3, gl.FLOAT, false, 20, 8);

    gl.activeTexture(gl.TEXTURE0);
    gl.uniform1i(self.uniforms.diffuse, 0);
    gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);

    gl.uniform4fv(self.uniforms.viewportOffsetScale, self.viewportOffsetScale);

    // Draws both eyes
    gl.drawElements(gl.TRIANGLES, self.indexCount, gl.UNSIGNED_SHORT, 0);

    if (self.cardboardUI) {
      self.cardboardUI.renderNoState();
    }

    // Bind the fake default framebuffer again
    self.realBindFramebuffer.call(self.gl, gl.FRAMEBUFFER, self.framebuffer);

    // If preserveDrawingBuffer == false clear the framebuffer
    if (!self.ctxAttribs.preserveDrawingBuffer) {
      self.realClearColor.call(gl, 0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
    }

    if (!window.WebVRConfig.DIRTY_SUBMIT_FRAME_BINDINGS) {
      self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);
    }

    // Restore state
    if (self.cullFace) { self.realEnable.call(gl, gl.CULL_FACE); }
    if (self.depthTest) { self.realEnable.call(gl, gl.DEPTH_TEST); }
    if (self.blend) { self.realEnable.call(gl, gl.BLEND); }
    if (self.scissorTest) { self.realEnable.call(gl, gl.SCISSOR_TEST); }
    if (self.stencilTest) { self.realEnable.call(gl, gl.STENCIL_TEST); }

    self.realColorMask.apply(gl, self.colorMask);
    self.realViewport.apply(gl, self.viewport);
    if (self.ctxAttribs.alpha || !self.ctxAttribs.preserveDrawingBuffer) {
      self.realClearColor.apply(gl, self.clearColor);
    }
  });

  // Workaround for the fact that Safari doesn't allow us to patch the canvas
  // width and height correctly. After each submit frame check to see what the
  // real backbuffer size has been set to and resize the fake backbuffer size
  // to match.
  if (Util.isIOS()) {
    var canvas = gl.canvas;
    if (canvas.width != self.bufferWidth || canvas.height != self.bufferHeight) {
      self.bufferWidth = canvas.width;
      self.bufferHeight = canvas.height;
      self.onResize();
    }
  }
};

/**
 * Call when the deviceInfo has changed. At this point we need
 * to re-calculate the distortion mesh.
 */
CardboardDistorter.prototype.updateDeviceInfo = function(deviceInfo) {
  var gl = this.gl;
  var self = this;

  var glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
  WGLUPreserveGLState(gl, glState, function(gl) {
    var vertices = self.computeMeshVertices_(self.meshWidth, self.meshHeight, deviceInfo);
    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    // Indices don't change based on device parameters, so only compute once.
    if (!self.indexCount) {
      var indices = self.computeMeshIndices_(self.meshWidth, self.meshHeight);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
      self.indexCount = indices.length;
    }
  });
};

/**
 * Build the distortion mesh vertices.
 * Based on code from the Unity cardboard plugin.
 */
CardboardDistorter.prototype.computeMeshVertices_ = function(width, height, deviceInfo) {
  var vertices = new Float32Array(2 * width * height * 5);

  var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
  var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
  var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
  var vidx = 0;
  var iidx = 0;
  for (var e = 0; e < 2; e++) {
    for (var j = 0; j < height; j++) {
      for (var i = 0; i < width; i++, vidx++) {
        var u = i / (width - 1);
        var v = j / (height - 1);

        // Grid points regularly spaced in StreoScreen, and barrel distorted in
        // the mesh.
        var s = u;
        var t = v;
        var x = Util.lerp(lensFrustum[0], lensFrustum[2], u);
        var y = Util.lerp(lensFrustum[3], lensFrustum[1], v);
        var d = Math.sqrt(x * x + y * y);
        var r = deviceInfo.distortion.distortInverse(d);
        var p = x * r / d;
        var q = y * r / d;
        u = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
        v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);

        // Convert u,v to mesh screen coordinates.
        var aspect = deviceInfo.device.widthMeters / deviceInfo.device.heightMeters;

        // FIXME: The original Unity plugin multiplied U by the aspect ratio
        // and didn't multiply either value by 2, but that seems to get it
        // really close to correct looking for me. I hate this kind of "Don't
        // know why it works" code though, and wold love a more logical
        // explanation of what needs to happen here.
        u = (viewport.x + u * viewport.width - 0.5) * 2.0; //* aspect;
        v = (viewport.y + v * viewport.height - 0.5) * 2.0;

        vertices[(vidx * 5) + 0] = u; // position.x
        vertices[(vidx * 5) + 1] = v; // position.y
        vertices[(vidx * 5) + 2] = s; // texCoord.x
        vertices[(vidx * 5) + 3] = t; // texCoord.y
        vertices[(vidx * 5) + 4] = e; // texCoord.z (viewport index)
      }
    }
    var w = lensFrustum[2] - lensFrustum[0];
    lensFrustum[0] = -(w + lensFrustum[0]);
    lensFrustum[2] = w - lensFrustum[2];
    w = noLensFrustum[2] - noLensFrustum[0];
    noLensFrustum[0] = -(w + noLensFrustum[0]);
    noLensFrustum[2] = w - noLensFrustum[2];
    viewport.x = 1 - (viewport.x + viewport.width);
  }
  return vertices;
}

/**
 * Build the distortion mesh indices.
 * Based on code from the Unity cardboard plugin.
 */
CardboardDistorter.prototype.computeMeshIndices_ = function(width, height) {
  var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6);
  var halfwidth = width / 2;
  var halfheight = height / 2;
  var vidx = 0;
  var iidx = 0;
  for (var e = 0; e < 2; e++) {
    for (var j = 0; j < height; j++) {
      for (var i = 0; i < width; i++, vidx++) {
        if (i == 0 || j == 0)
          continue;
        // Build a quad.  Lower right and upper left quadrants have quads with
        // the triangle diagonal flipped to get the vignette to interpolate
        // correctly.
        if ((i <= halfwidth) == (j <= halfheight)) {
          // Quad diagonal lower left to upper right.
          indices[iidx++] = vidx;
          indices[iidx++] = vidx - width - 1;
          indices[iidx++] = vidx - width;
          indices[iidx++] = vidx - width - 1;
          indices[iidx++] = vidx;
          indices[iidx++] = vidx - 1;
        } else {
          // Quad diagonal upper left to lower right.
          indices[iidx++] = vidx - 1;
          indices[iidx++] = vidx - width;
          indices[iidx++] = vidx;
          indices[iidx++] = vidx - width;
          indices[iidx++] = vidx - 1;
          indices[iidx++] = vidx - width - 1;
        }
      }
    }
  }
  return indices;
};

CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function(proto, attrName) {
  var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
  // In some cases (ahem... Safari), the descriptor returns undefined get and
  // set fields. In this case, we need to create a synthetic property
  // descriptor. This works around some of the issues in
  // https://github.com/borismus/webvr-polyfill/issues/46
  if (descriptor.get === undefined || descriptor.set === undefined) {
    descriptor.configurable = true;
    descriptor.enumerable = true;
    descriptor.get = function() {
      return this.getAttribute(attrName);
    };
    descriptor.set = function(val) {
      this.setAttribute(attrName, val);
    };
  }
  return descriptor;
};

module.exports = CardboardDistorter;


/***/ }),
/* 703 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var CardboardDistorter = __webpack_require__(702);
var CardboardUI = __webpack_require__(312);
var DeviceInfo = __webpack_require__(314);
var Dpdb = __webpack_require__(705);
var FusionPoseSensor = __webpack_require__(712);
var RotateInstructions = __webpack_require__(710);
var ViewerSelector = __webpack_require__(716);
var VRDisplay = __webpack_require__(55).VRDisplay;
var Util = __webpack_require__(23);

var Eye = {
  LEFT: 'left',
  RIGHT: 'right'
};

/**
 * VRDisplay based on mobile device parameters and DeviceMotion APIs.
 */
function CardboardVRDisplay() {
  this.displayName = 'Cardboard VRDisplay (webvr-polyfill)';

  this.capabilities.hasOrientation = true;
  this.capabilities.canPresent = true;

  // "Private" members.
  this.bufferScale_ = window.WebVRConfig.BUFFER_SCALE;
  this.poseSensor_ = new FusionPoseSensor();
  this.distorter_ = null;
  this.cardboardUI_ = null;

  this.dpdb_ = new Dpdb(true, this.onDeviceParamsUpdated_.bind(this));
  this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams());

  this.viewerSelector_ = new ViewerSelector();
  this.viewerSelector_.onChange(this.onViewerChanged_.bind(this));

  // Set the correct initial viewer.
  this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());

  if (!window.WebVRConfig.ROTATE_INSTRUCTIONS_DISABLED) {
    this.rotateInstructions_ = new RotateInstructions();
  }

  if (Util.isIOS()) {
    // Listen for resize events to workaround this awful Safari bug.
    window.addEventListener('resize', this.onResize_.bind(this));
  }
}
CardboardVRDisplay.prototype = new VRDisplay();

CardboardVRDisplay.prototype.getImmediatePose = function() {
  return {
    position: this.poseSensor_.getPosition(),
    orientation: this.poseSensor_.getOrientation(),
    linearVelocity: null,
    linearAcceleration: null,
    angularVelocity: null,
    angularAcceleration: null
  };
};

CardboardVRDisplay.prototype.resetPose = function() {
  this.poseSensor_.resetPose();
};

CardboardVRDisplay.prototype.getEyeParameters = function(whichEye) {
  var offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0.0, 0.0];
  var fieldOfView;

  // TODO: FoV can be a little expensive to compute. Cache when device params change.
  if (whichEye == Eye.LEFT) {
    offset[0] *= -1.0;
    fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
  } else if (whichEye == Eye.RIGHT) {
    fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
  } else {
    console.error('Invalid eye provided: %s', whichEye);
    return null;
  }

  return {
    fieldOfView: fieldOfView,
    offset: offset,
    // TODO: Should be able to provide better values than these.
    renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
    renderHeight: this.deviceInfo_.device.height * this.bufferScale_,
  };
};

CardboardVRDisplay.prototype.onDeviceParamsUpdated_ = function(newParams) {
  if (Util.isDebug()) {
    console.log('DPDB reported that device params were updated.');
  }
  this.deviceInfo_.updateDeviceParams(newParams);

  if (this.distorter_) {
    this.distorter_.updateDeviceInfo(this.deviceInfo_);
  }
};

CardboardVRDisplay.prototype.updateBounds_ = function () {
  if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
    this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
  }
};

CardboardVRDisplay.prototype.beginPresent_ = function() {
  var gl = this.layer_.source.getContext('webgl');
  if (!gl)
    gl = this.layer_.source.getContext('experimental-webgl');
  if (!gl)
    gl = this.layer_.source.getContext('webgl2');

  if (!gl)
    return; // Can't do distortion without a WebGL context.

  // Provides a way to opt out of distortion
  if (this.layer_.predistorted) {
    if (!window.WebVRConfig.CARDBOARD_UI_DISABLED) {
      gl.canvas.width = Util.getScreenWidth() * this.bufferScale_;
      gl.canvas.height = Util.getScreenHeight() * this.bufferScale_;
      this.cardboardUI_ = new CardboardUI(gl);
    }
  } else {
    // Create a new distorter for the target context
    this.distorter_ = new CardboardDistorter(gl);
    this.distorter_.updateDeviceInfo(this.deviceInfo_);
    this.cardboardUI_ = this.distorter_.cardboardUI;
  }

  if (this.cardboardUI_) {
    this.cardboardUI_.listen(function(e) {
      // Options clicked.
      this.viewerSelector_.show(this.layer_.source.parentElement);
      e.stopPropagation();
      e.preventDefault();
    }.bind(this), function(e) {
      // Back clicked.
      this.exitPresent();
      e.stopPropagation();
      e.preventDefault();
    }.bind(this));
  }

  if (this.rotateInstructions_) {
    if (Util.isLandscapeMode() && Util.isMobile()) {
      // In landscape mode, temporarily show the "put into Cardboard"
      // interstitial. Otherwise, do the default thing.
      this.rotateInstructions_.showTemporarily(3000, this.layer_.source.parentElement);
    } else {
      this.rotateInstructions_.update();
    }
  }

  // Listen for orientation change events in order to show interstitial.
  this.orientationHandler = this.onOrientationChange_.bind(this);
  window.addEventListener('orientationchange', this.orientationHandler);

  // Listen for present display change events in order to update distorter dimensions
  this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
  window.addEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);

  // Fire this event initially, to give geometry-distortion clients the chance
  // to do something custom.
  this.fireVRDisplayDeviceParamsChange_();
};

CardboardVRDisplay.prototype.endPresent_ = function() {
  if (this.distorter_) {
    this.distorter_.destroy();
    this.distorter_ = null;
  }
  if (this.cardboardUI_) {
    this.cardboardUI_.destroy();
    this.cardboardUI_ = null;
  }

  if (this.rotateInstructions_) {
    this.rotateInstructions_.hide();
  }
  this.viewerSelector_.hide();

  window.removeEventListener('orientationchange', this.orientationHandler);
  window.removeEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);
};

CardboardVRDisplay.prototype.submitFrame = function(pose) {
  if (this.distorter_) {
    this.updateBounds_();
    this.distorter_.submitFrame();
  } else if (this.cardboardUI_ && this.layer_) {
    // Hack for predistorted: true.
    var canvas = this.layer_.source.getContext('webgl').canvas;
    if (canvas.width != this.lastWidth || canvas.height != this.lastHeight) {
      this.cardboardUI_.onResize();
    }
    this.lastWidth = canvas.width;
    this.lastHeight = canvas.height;

    // Render the Cardboard UI.
    this.cardboardUI_.render();
  }
};

CardboardVRDisplay.prototype.onOrientationChange_ = function(e) {
  // Hide the viewer selector.
  this.viewerSelector_.hide();

  // Update the rotate instructions.
  if (this.rotateInstructions_) {
    this.rotateInstructions_.update();
  }

  this.onResize_();
};

CardboardVRDisplay.prototype.onResize_ = function(e) {
  if (this.layer_) {
    var gl = this.layer_.source.getContext('webgl');
    // Size the CSS canvas.
    // Added padding on right and bottom because iPhone 5 will not
    // hide the URL bar unless content is bigger than the screen.
    // This will not be visible as long as the container element (e.g. body)
    // is set to 'overflow: hidden'.
    // Additionally, 'box-sizing: content-box' ensures renderWidth = width + padding.
    // This is required when 'box-sizing: border-box' is used elsewhere in the page.
    var cssProperties = [
      'position: absolute',
      'top: 0',
      'left: 0',
      'width: ' + Math.max(screen.width, screen.height) + 'px',
      'height: ' + Math.min(screen.height, screen.width) + 'px',
      'border: 0',
      'margin: 0',
      'padding: 0 10px 10px 0',
      'box-sizing: content-box',
    ];
    gl.canvas.setAttribute('style', cssProperties.join('; ') + ';');

    Util.safariCssSizeWorkaround(gl.canvas);
  }
};

CardboardVRDisplay.prototype.onViewerChanged_ = function(viewer) {
  this.deviceInfo_.setViewer(viewer);

  if (this.distorter_) {
    // Update the distortion appropriately.
    this.distorter_.updateDeviceInfo(this.deviceInfo_);
  }

  // Fire a new event containing viewer and device parameters for clients that
  // want to implement their own geometry-based distortion.
  this.fireVRDisplayDeviceParamsChange_();
};

CardboardVRDisplay.prototype.fireVRDisplayDeviceParamsChange_ = function() {
  var event = new CustomEvent('vrdisplaydeviceparamschange', {
    detail: {
      vrdisplay: this,
      deviceInfo: this.deviceInfo_,
    }
  });
  window.dispatchEvent(event);
};

module.exports = CardboardVRDisplay;


/***/ }),
/* 704 */
/***/ (function(module, exports) {

/**
 * TODO(smus): Implement coefficient inversion.
 */
function Distortion(coefficients) {
  this.coefficients = coefficients;
}

/**
 * Calculates the inverse distortion for a radius.
 * </p><p>
 * Allows to compute the original undistorted radius from a distorted one.
 * See also getApproximateInverseDistortion() for a faster but potentially
 * less accurate method.
 *
 * @param {Number} radius Distorted radius from the lens center in tan-angle units.
 * @return {Number} The undistorted radius in tan-angle units.
 */
Distortion.prototype.distortInverse = function(radius) {
  // Secant method.
  var r0 = 0;
  var r1 = 1;
  var dr0 = radius - this.distort(r0);
  while (Math.abs(r1 - r0) > 0.0001 /** 0.1mm */) {
    var dr1 = radius - this.distort(r1);
    var r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
    r0 = r1;
    r1 = r2;
    dr0 = dr1;
  }
  return r1;
};

/**
 * Distorts a radius by its distortion factor from the center of the lenses.
 *
 * @param {Number} radius Radius from the lens center in tan-angle units.
 * @return {Number} The distorted radius in tan-angle units.
 */
Distortion.prototype.distort = function(radius) {
  var r2 = radius * radius;
  var ret = 0;
  for (var i = 0; i < this.coefficients.length; i++) {
    ret = r2 * (ret + this.coefficients[i]);
  }
  return (ret + 1) * radius;
};

module.exports = Distortion;


/***/ }),
/* 705 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Offline cache of the DPDB, to be used until we load the online one (and
// as a fallback in case we can't load the online one).
var DPDB_CACHE = __webpack_require__(706);
var Util = __webpack_require__(23);

// Online DPDB URL.
var ONLINE_DPDB_URL =
  'https://dpdb.webvr.rocks/dpdb.json';

/**
 * Calculates device parameters based on the DPDB (Device Parameter Database).
 * Initially, uses the cached DPDB values.
 *
 * If fetchOnline == true, then this object tries to fetch the online version
 * of the DPDB and updates the device info if a better match is found.
 * Calls the onDeviceParamsUpdated callback when there is an update to the
 * device information.
 */
function Dpdb(fetchOnline, onDeviceParamsUpdated) {
  // Start with the offline DPDB cache while we are loading the real one.
  this.dpdb = DPDB_CACHE;

  // Calculate device params based on the offline version of the DPDB.
  this.recalculateDeviceParams_();

  // XHR to fetch online DPDB file, if requested.
  if (fetchOnline) {
    // Set the callback.
    this.onDeviceParamsUpdated = onDeviceParamsUpdated;

    var xhr = new XMLHttpRequest();
    var obj = this;
    xhr.open('GET', ONLINE_DPDB_URL, true);
    xhr.addEventListener('load', function() {
      obj.loading = false;
      if (xhr.status >= 200 && xhr.status <= 299) {
        // Success.
        obj.dpdb = JSON.parse(xhr.response);
        obj.recalculateDeviceParams_();
      } else {
        // Error loading the DPDB.
        console.error('Error loading online DPDB!');
      }
    });
    xhr.send();
  }
}

// Returns the current device parameters.
Dpdb.prototype.getDeviceParams = function() {
  return this.deviceParams;
};

// Recalculates this device's parameters based on the DPDB.
Dpdb.prototype.recalculateDeviceParams_ = function() {
  var newDeviceParams = this.calcDeviceParams_();
  if (newDeviceParams) {
    this.deviceParams = newDeviceParams;
    // Invoke callback, if it is set.
    if (this.onDeviceParamsUpdated) {
      this.onDeviceParamsUpdated(this.deviceParams);
    }
  } else {
    console.error('Failed to recalculate device parameters.');
  }
};

// Returns a DeviceParams object that represents the best guess as to this
// device's parameters. Can return null if the device does not match any
// known devices.
Dpdb.prototype.calcDeviceParams_ = function() {
  var db = this.dpdb; // shorthand
  if (!db) {
    console.error('DPDB not available.');
    return null;
  }
  if (db.format != 1) {
    console.error('DPDB has unexpected format version.');
    return null;
  }
  if (!db.devices || !db.devices.length) {
    console.error('DPDB does not have a devices section.');
    return null;
  }

  // Get the actual user agent and screen dimensions in pixels.
  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
  var width = Util.getScreenWidth();
  var height = Util.getScreenHeight();

  if (!db.devices) {
    console.error('DPDB has no devices section.');
    return null;
  }

  for (var i = 0; i < db.devices.length; i++) {
    var device = db.devices[i];
    if (!device.rules) {
      console.warn('Device[' + i + '] has no rules section.');
      continue;
    }

    if (device.type != 'ios' && device.type != 'android') {
      console.warn('Device[' + i + '] has invalid type.');
      continue;
    }

    // See if this device is of the appropriate type.
    if (Util.isIOS() != (device.type == 'ios')) continue;

    // See if this device matches any of the rules:
    var matched = false;
    for (var j = 0; j < device.rules.length; j++) {
      var rule = device.rules[j];
      if (this.matchRule_(rule, userAgent, width, height)) {
        matched = true;
        break;
      }
    }
    if (!matched) continue;

    // device.dpi might be an array of [ xdpi, ydpi] or just a scalar.
    var xdpi = device.dpi[0] || device.dpi;
    var ydpi = device.dpi[1] || device.dpi;

    return new DeviceParams({ xdpi: xdpi, ydpi: ydpi, bevelMm: device.bw });
  }

  console.warn('No DPDB device match.');
  return null;
};

Dpdb.prototype.matchRule_ = function(rule, ua, screenWidth, screenHeight) {
  // We can only match 'ua' and 'res' rules, not other types like 'mdmh'
  // (which are meant for native platforms).
  if (!rule.ua && !rule.res) return false;

  // If our user agent string doesn't contain the indicated user agent string,
  // the match fails.
  if (rule.ua && ua.indexOf(rule.ua) < 0) return false;

  // If the rule specifies screen dimensions that don't correspond to ours,
  // the match fails.
  if (rule.res) {
    if (!rule.res[0] || !rule.res[1]) return false;
    var resX = rule.res[0];
    var resY = rule.res[1];
    // Compare min and max so as to make the order not matter, i.e., it should
    // be true that 640x480 == 480x640.
    if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) ||
        (Math.max(screenWidth, screenHeight) != Math.max(resX, resY))) {
      return false;
    }
  }

  return true;
}

function DeviceParams(params) {
  this.xdpi = params.xdpi;
  this.ydpi = params.ydpi;
  this.bevelMm = params.bevelMm;
}

module.exports = Dpdb;


/***/ }),
/* 706 */
/***/ (function(module, exports) {

module.exports = {"format":1,"last_updated":"2017-06-01T22:33:42Z","devices":[{"type":"android","rules":[{"mdmh":"asus/*/Nexus 7/*"},{"ua":"Nexus 7"}],"dpi":[320.8,323],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"asus/*/ASUS_Z00AD/*"},{"ua":"ASUS_Z00AD"}],"dpi":[403,404.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Google/*/Pixel XL/*"},{"ua":"Pixel XL"}],"dpi":[537.9,533],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Google/*/Pixel/*"},{"ua":"Pixel"}],"dpi":[432.6,436.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"HTC/*/HTC6435LVW/*"},{"ua":"HTC6435LVW"}],"dpi":[449.7,443.3],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One XL/*"},{"ua":"HTC One XL"}],"dpi":[315.3,314.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"htc/*/Nexus 9/*"},{"ua":"Nexus 9"}],"dpi":289,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One M9/*"},{"ua":"HTC One M9"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One_M8/*"},{"ua":"HTC One_M8"}],"dpi":[449.7,447.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One/*"},{"ua":"HTC One"}],"dpi":472.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Huawei/*/Nexus 6P/*"},{"ua":"Nexus 6P"}],"dpi":[515.1,518],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 5X/*"},{"ua":"Nexus 5X"}],"dpi":[422,419.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGMS345/*"},{"ua":"LGMS345"}],"dpi":[221.7,219.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/LG-D800/*"},{"ua":"LG-D800"}],"dpi":[422,424.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/LG-D850/*"},{"ua":"LG-D850"}],"dpi":[537.9,541.9],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/VS985 4G/*"},{"ua":"VS985 4G"}],"dpi":[537.9,535.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 5/*"},{"ua":"Nexus 5 B"}],"dpi":[442.4,444.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 4/*"},{"ua":"Nexus 4"}],"dpi":[319.8,318.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LG-P769/*"},{"ua":"LG-P769"}],"dpi":[240.6,247.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGMS323/*"},{"ua":"LGMS323"}],"dpi":[206.6,204.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGLS996/*"},{"ua":"LGLS996"}],"dpi":[403.4,401.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/4560MMX/*"},{"ua":"4560MMX"}],"dpi":[240,219.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/A250/*"},{"ua":"Micromax A250"}],"dpi":[480,446.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/Micromax AQ4501/*"},{"ua":"Micromax AQ4501"}],"dpi":240,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/DROID RAZR/*"},{"ua":"DROID RAZR"}],"dpi":[368.1,256.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT830C/*"},{"ua":"XT830C"}],"dpi":[254,255.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1021/*"},{"ua":"XT1021"}],"dpi":[254,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1023/*"},{"ua":"XT1023"}],"dpi":[254,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1028/*"},{"ua":"XT1028"}],"dpi":[326.6,327.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1034/*"},{"ua":"XT1034"}],"dpi":[326.6,328.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1053/*"},{"ua":"XT1053"}],"dpi":[315.3,316.1],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1562/*"},{"ua":"XT1562"}],"dpi":[403.4,402.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/Nexus 6/*"},{"ua":"Nexus 6 B"}],"dpi":[494.3,489.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1063/*"},{"ua":"XT1063"}],"dpi":[295,296.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1064/*"},{"ua":"XT1064"}],"dpi":[295,295.6],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1092/*"},{"ua":"XT1092"}],"dpi":[422,424.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1095/*"},{"ua":"XT1095"}],"dpi":[422,423.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/G4/*"},{"ua":"Moto G (4)"}],"dpi":401,"bw":4,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/A0001/*"},{"ua":"A0001"}],"dpi":[403.4,401],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE E1005/*"},{"ua":"ONE E1005"}],"dpi":[442.4,441.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE A2005/*"},{"ua":"ONE A2005"}],"dpi":[391.9,405.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OPPO/*/X909/*"},{"ua":"X909"}],"dpi":[442.4,444.1],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9082/*"},{"ua":"GT-I9082"}],"dpi":[184.7,185.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G360P/*"},{"ua":"SM-G360P"}],"dpi":[196.7,205.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/Nexus S/*"},{"ua":"Nexus S"}],"dpi":[234.5,229.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300/*"},{"ua":"GT-I9300"}],"dpi":[304.8,303.9],"bw":5,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-T230NU/*"},{"ua":"SM-T230NU"}],"dpi":216,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SGH-T399/*"},{"ua":"SGH-T399"}],"dpi":[217.7,231.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SGH-M919/*"},{"ua":"SGH-M919"}],"dpi":[440.8,437.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N9005/*"},{"ua":"SM-N9005"}],"dpi":[386.4,387],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SAMSUNG-SM-N900A/*"},{"ua":"SAMSUNG-SM-N900A"}],"dpi":[386.4,387.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9500/*"},{"ua":"GT-I9500"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9505/*"},{"ua":"GT-I9505"}],"dpi":439.4,"bw":4,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G900F/*"},{"ua":"SM-G900F"}],"dpi":[415.6,431.6],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G900M/*"},{"ua":"SM-G900M"}],"dpi":[415.6,431.6],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G800F/*"},{"ua":"SM-G800F"}],"dpi":326.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G906S/*"},{"ua":"SM-G906S"}],"dpi":[562.7,572.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300/*"},{"ua":"GT-I9300"}],"dpi":[306.7,304.8],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-T535/*"},{"ua":"SM-T535"}],"dpi":[142.6,136.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N920C/*"},{"ua":"SM-N920C"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N920W8/*"},{"ua":"SM-N920W8"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300I/*"},{"ua":"GT-I9300I"}],"dpi":[304.8,305.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9195/*"},{"ua":"GT-I9195"}],"dpi":[249.4,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SPH-L520/*"},{"ua":"SPH-L520"}],"dpi":[249.4,255.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SAMSUNG-SGH-I717/*"},{"ua":"SAMSUNG-SGH-I717"}],"dpi":285.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SPH-D710/*"},{"ua":"SPH-D710"}],"dpi":[217.7,204.2],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-N7100/*"},{"ua":"GT-N7100"}],"dpi":265.1,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SCH-I605/*"},{"ua":"SCH-I605"}],"dpi":265.1,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/Galaxy Nexus/*"},{"ua":"Galaxy Nexus"}],"dpi":[315.3,314.2],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N910H/*"},{"ua":"SM-N910H"}],"dpi":[515.1,518],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N910C/*"},{"ua":"SM-N910C"}],"dpi":[515.2,520.2],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G130M/*"},{"ua":"SM-G130M"}],"dpi":[165.9,164.8],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G928I/*"},{"ua":"SM-G928I"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G920F/*"},{"ua":"SM-G920F"}],"dpi":580.6,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G920P/*"},{"ua":"SM-G920P"}],"dpi":[522.5,577],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G925F/*"},{"ua":"SM-G925F"}],"dpi":580.6,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G925V/*"},{"ua":"SM-G925V"}],"dpi":[522.5,576.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G930F/*"},{"ua":"SM-G930F"}],"dpi":576.6,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G935F/*"},{"ua":"SM-G935F"}],"dpi":533,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"Sony/*/C6903/*"},{"ua":"C6903"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"Sony/*/D6653/*"},{"ua":"D6653"}],"dpi":[428.6,427.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/E6653/*"},{"ua":"E6653"}],"dpi":[428.6,425.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/E6853/*"},{"ua":"E6853"}],"dpi":[403.4,401.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/SGP321/*"},{"ua":"SGP321"}],"dpi":[224.7,224.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"TCT/*/ALCATEL ONE TOUCH Fierce/*"},{"ua":"ALCATEL ONE TOUCH Fierce"}],"dpi":[240,247.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"THL/*/thl 5000/*"},{"ua":"thl 5000"}],"dpi":[480,443.3],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"ZTE/*/ZTE Blade L2/*"},{"ua":"ZTE Blade L2"}],"dpi":240,"bw":3,"ac":500},{"type":"ios","rules":[{"res":[640,960]}],"dpi":[325.1,328.4],"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[640,1136]}],"dpi":[317.1,320.2],"bw":3,"ac":1000},{"type":"ios","rules":[{"res":[750,1334]}],"dpi":326.4,"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[1242,2208]}],"dpi":[453.6,458.4],"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[1125,2001]}],"dpi":[410.9,415.4],"bw":4,"ac":1000}]}

/***/ }),
/* 707 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Util = __webpack_require__(23);
var WebVRPolyfill = __webpack_require__(718).WebVRPolyfill;

// Initialize a WebVRConfig just in case.
window.WebVRConfig = Util.extend({
  // Forces availability of VR mode, even for non-mobile devices.
  FORCE_ENABLE_VR: false,

  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
  K_FILTER: 0.98,

  // How far into the future to predict during fast motion (in seconds).
  PREDICTION_TIME_S: 0.040,

  // Flag to enable touch panner. In case you have your own touch controls.
  TOUCH_PANNER_DISABLED: true,

  // Flag to disabled the UI in VR Mode.
  CARDBOARD_UI_DISABLED: false, // Default: false

  // Flag to disable the instructions to rotate your device.
  ROTATE_INSTRUCTIONS_DISABLED: false, // Default: false.

  // Enable yaw panning only, disabling roll and pitch. This can be useful
  // for panoramas with nothing interesting above or below.
  YAW_ONLY: false,

  // To disable keyboard and mouse controls, if you want to use your own
  // implementation.
  MOUSE_KEYBOARD_CONTROLS_DISABLED: false,

  // Prevent the polyfill from initializing immediately. Requires the app
  // to call InitializeWebVRPolyfill() before it can be used.
  DEFER_INITIALIZATION: false,

  // Enable the deprecated version of the API (navigator.getVRDevices).
  ENABLE_DEPRECATED_API: false,

  // Scales the recommended buffer size reported by WebVR, which can improve
  // performance.
  // UPDATE(2016-05-03): Setting this to 0.5 by default since 1.0 does not
  // perform well on many mobile devices.
  BUFFER_SCALE: 0.5,

  // Allow VRDisplay.submitFrame to change gl bindings, which is more
  // efficient if the application code will re-bind its resources on the
  // next frame anyway. This has been seen to cause rendering glitches with
  // THREE.js.
  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
  // and gl.TEXTURE_BINDING_2D for texture unit 0.
  DIRTY_SUBMIT_FRAME_BINDINGS: false,

  // When set to true, this will cause a polyfilled VRDisplay to always be
  // appended to the list returned by navigator.getVRDisplays(), even if that
  // list includes a native VRDisplay.
  ALWAYS_APPEND_POLYFILL_DISPLAY: false,

  // There are versions of Chrome (M58-M60?) where the native WebVR API exists,
  // and instead of returning 0 VR displays when none are detected,
  // `navigator.getVRDisplays()`'s promise never resolves. This results
  // in the polyfill hanging and not being able to provide fallback
  // displays, so set a timeout in milliseconds to stop waiting for a response
  // and just use polyfilled displays.
  // https://bugs.chromium.org/p/chromium/issues/detail?id=727969
  GET_VR_DISPLAYS_TIMEOUT: 1000,
}, window.WebVRConfig);

if (!window.WebVRConfig.DEFER_INITIALIZATION) {
  new WebVRPolyfill();
} else {
  window.InitializeWebVRPolyfill = function() {
    new WebVRPolyfill();
  }
}

window.WebVRPolyfill = WebVRPolyfill;


/***/ }),
/* 708 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var VRDisplay = __webpack_require__(55).VRDisplay;
var MathUtil = __webpack_require__(96);
var Util = __webpack_require__(23);

// How much to rotate per key stroke.
var KEY_SPEED = 0.15;
var KEY_ANIMATION_DURATION = 80;

// How much to rotate for mouse events.
var MOUSE_SPEED_X = 0.5;
var MOUSE_SPEED_Y = 0.3;

/**
 * VRDisplay based on mouse and keyboard input. Designed for desktops/laptops
 * where orientation events aren't supported. Cannot present.
 */
function MouseKeyboardVRDisplay() {
  this.displayName = 'Mouse and Keyboard VRDisplay (webvr-polyfill)';

  this.capabilities.hasOrientation = true;

  // Attach to mouse and keyboard events.
  window.addEventListener('keydown', this.onKeyDown_.bind(this));
  window.addEventListener('mousemove', this.onMouseMove_.bind(this));
  window.addEventListener('mousedown', this.onMouseDown_.bind(this));
  window.addEventListener('mouseup', this.onMouseUp_.bind(this));

  // "Private" members.
  this.phi_ = 0;
  this.theta_ = 0;

  // Variables for keyboard-based rotation animation.
  this.targetAngle_ = null;
  this.angleAnimation_ = null;

  // State variables for calculations.
  this.orientation_ = new MathUtil.Quaternion();

  // Variables for mouse-based rotation.
  this.rotateStart_ = new MathUtil.Vector2();
  this.rotateEnd_ = new MathUtil.Vector2();
  this.rotateDelta_ = new MathUtil.Vector2();
  this.isDragging_ = false;

  this.orientationOut_ = new Float32Array(4);
}
MouseKeyboardVRDisplay.prototype = new VRDisplay();

MouseKeyboardVRDisplay.prototype.getImmediatePose = function() {
  this.orientation_.setFromEulerYXZ(this.phi_, this.theta_, 0);

  this.orientationOut_[0] = this.orientation_.x;
  this.orientationOut_[1] = this.orientation_.y;
  this.orientationOut_[2] = this.orientation_.z;
  this.orientationOut_[3] = this.orientation_.w;

  return {
    position: null,
    orientation: this.orientationOut_,
    linearVelocity: null,
    linearAcceleration: null,
    angularVelocity: null,
    angularAcceleration: null
  };
};

MouseKeyboardVRDisplay.prototype.onKeyDown_ = function(e) {
  // Track WASD and arrow keys.
  if (e.keyCode == 38) { // Up key.
    this.animatePhi_(this.phi_ + KEY_SPEED);
  } else if (e.keyCode == 39) { // Right key.
    this.animateTheta_(this.theta_ - KEY_SPEED);
  } else if (e.keyCode == 40) { // Down key.
    this.animatePhi_(this.phi_ - KEY_SPEED);
  } else if (e.keyCode == 37) { // Left key.
    this.animateTheta_(this.theta_ + KEY_SPEED);
  }
};

MouseKeyboardVRDisplay.prototype.animateTheta_ = function(targetAngle) {
  this.animateKeyTransitions_('theta_', targetAngle);
};

MouseKeyboardVRDisplay.prototype.animatePhi_ = function(targetAngle) {
  // Prevent looking too far up or down.
  targetAngle = Util.clamp(targetAngle, -Math.PI/2, Math.PI/2);
  this.animateKeyTransitions_('phi_', targetAngle);
};

/**
 * Start an animation to transition an angle from one value to another.
 */
MouseKeyboardVRDisplay.prototype.animateKeyTransitions_ = function(angleName, targetAngle) {
  // If an animation is currently running, cancel it.
  if (this.angleAnimation_) {
    cancelAnimationFrame(this.angleAnimation_);
  }
  var startAngle = this[angleName];
  var startTime = new Date();
  // Set up an interval timer to perform the animation.
  this.angleAnimation_ = requestAnimationFrame(function animate() {
    // Once we're finished the animation, we're done.
    var elapsed = new Date() - startTime;
    if (elapsed >= KEY_ANIMATION_DURATION) {
      this[angleName] = targetAngle;
      cancelAnimationFrame(this.angleAnimation_);
      return;
    }
    // loop with requestAnimationFrame
    this.angleAnimation_ = requestAnimationFrame(animate.bind(this))
    // Linearly interpolate the angle some amount.
    var percent = elapsed / KEY_ANIMATION_DURATION;
    this[angleName] = startAngle + (targetAngle - startAngle) * percent;
  }.bind(this));
};

MouseKeyboardVRDisplay.prototype.onMouseDown_ = function(e) {
  this.rotateStart_.set(e.clientX, e.clientY);
  this.isDragging_ = true;
};

// Very similar to https://gist.github.com/mrflix/8351020
MouseKeyboardVRDisplay.prototype.onMouseMove_ = function(e) {
  if (!this.isDragging_ && !this.isPointerLocked_()) {
    return;
  }
  // Support pointer lock API.
  if (this.isPointerLocked_()) {
    var movementX = e.movementX || e.mozMovementX || 0;
    var movementY = e.movementY || e.mozMovementY || 0;
    this.rotateEnd_.set(this.rotateStart_.x - movementX, this.rotateStart_.y - movementY);
  } else {
    this.rotateEnd_.set(e.clientX, e.clientY);
  }
  // Calculate how much we moved in mouse space.
  this.rotateDelta_.subVectors(this.rotateEnd_, this.rotateStart_);
  this.rotateStart_.copy(this.rotateEnd_);

  // Keep track of the cumulative euler angles.
  this.phi_ += 2 * Math.PI * this.rotateDelta_.y / screen.height * MOUSE_SPEED_Y;
  this.theta_ += 2 * Math.PI * this.rotateDelta_.x / screen.width * MOUSE_SPEED_X;

  // Prevent looking too far up or down.
  this.phi_ = Util.clamp(this.phi_, -Math.PI/2, Math.PI/2);
};

MouseKeyboardVRDisplay.prototype.onMouseUp_ = function(e) {
  this.isDragging_ = false;
};

MouseKeyboardVRDisplay.prototype.isPointerLocked_ = function() {
  var el = document.pointerLockElement || document.mozPointerLockElement ||
      document.webkitPointerLockElement;
  return el !== undefined;
};

MouseKeyboardVRDisplay.prototype.resetPose = function() {
  this.phi_ = 0;
  this.theta_ = 0;
};

module.exports = MouseKeyboardVRDisplay;


/***/ }),
/* 709 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// This is the entry point if requiring/importing via node, or
// a build tool that uses package.json entry (like browserify, webpack).
// If running in node with a window mock available, globalize its members
// if needed. Otherwise, just continue to `./main`
if (typeof global !== 'undefined' && global.window) {
  global.document = global.window.document;
  global.navigator = global.window.navigator;
}

__webpack_require__(707);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))

/***/ }),
/* 710 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = __webpack_require__(23);

function RotateInstructions() {
  this.loadIcon_();

  var overlay = document.createElement('div');
  var s = overlay.style;
  s.position = 'fixed';
  s.top = 0;
  s.right = 0;
  s.bottom = 0;
  s.left = 0;
  s.backgroundColor = 'gray';
  s.fontFamily = 'sans-serif';
  // Force this to be above the fullscreen canvas, which is at zIndex: 999999.
  s.zIndex = 1000000;

  var img = document.createElement('img');
  img.src = this.icon;
  var s = img.style;
  s.marginLeft = '25%';
  s.marginTop = '25%';
  s.width = '50%';
  overlay.appendChild(img);

  var text = document.createElement('div');
  var s = text.style;
  s.textAlign = 'center';
  s.fontSize = '16px';
  s.lineHeight = '24px';
  s.margin = '24px 25%';
  s.width = '50%';
  text.innerHTML = 'Place your phone into your Cardboard viewer.';
  overlay.appendChild(text);

  var snackbar = document.createElement('div');
  var s = snackbar.style;
  s.backgroundColor = '#CFD8DC';
  s.position = 'fixed';
  s.bottom = 0;
  s.width = '100%';
  s.height = '48px';
  s.padding = '14px 24px';
  s.boxSizing = 'border-box';
  s.color = '#656A6B';
  overlay.appendChild(snackbar);

  var snackbarText = document.createElement('div');
  snackbarText.style.float = 'left';
  snackbarText.innerHTML = 'No Cardboard viewer?';

  var snackbarButton = document.createElement('a');
  snackbarButton.href = 'https://www.google.com/get/cardboard/get-cardboard/';
  snackbarButton.innerHTML = 'get one';
  snackbarButton.target = '_blank';
  var s = snackbarButton.style;
  s.float = 'right';
  s.fontWeight = 600;
  s.textTransform = 'uppercase';
  s.borderLeft = '1px solid gray';
  s.paddingLeft = '24px';
  s.textDecoration = 'none';
  s.color = '#656A6B';

  snackbar.appendChild(snackbarText);
  snackbar.appendChild(snackbarButton);

  this.overlay = overlay;
  this.text = text;

  this.hide();
}

RotateInstructions.prototype.show = function(parent) {
  if (!parent && !this.overlay.parentElement) {
    document.body.appendChild(this.overlay);
  } else if (parent) {
    if (this.overlay.parentElement && this.overlay.parentElement != parent)
      this.overlay.parentElement.removeChild(this.overlay);

    parent.appendChild(this.overlay);
  }

  this.overlay.style.display = 'block';

  var img = this.overlay.querySelector('img');
  var s = img.style;

  if (Util.isLandscapeMode()) {
    s.width = '20%';
    s.marginLeft = '40%';
    s.marginTop = '3%';
  } else {
    s.width = '50%';
    s.marginLeft = '25%';
    s.marginTop = '25%';
  }
};

RotateInstructions.prototype.hide = function() {
  this.overlay.style.display = 'none';
};

RotateInstructions.prototype.showTemporarily = function(ms, parent) {
  this.show(parent);
  this.timer = setTimeout(this.hide.bind(this), ms);
};

RotateInstructions.prototype.disableShowTemporarily = function() {
  clearTimeout(this.timer);
};

RotateInstructions.prototype.update = function() {
  this.disableShowTemporarily();
  // In portrait VR mode, tell the user to rotate to landscape. Otherwise, hide
  // the instructions.
  if (!Util.isLandscapeMode() && Util.isMobile()) {
    this.show();
  } else {
    this.hide();
  }
};

RotateInstructions.prototype.loadIcon_ = function() {
  // Encoded asset_src/rotate-instructions.svg
  this.icon = Util.base64('image/svg+xml', 'PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE5OHB4IiBoZWlnaHQ9IjI0MHB4IiB2aWV3Qm94PSIwIDAgMTk4IDI0MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWxuczpza2V0Y2g9Imh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaC9ucyI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDMuMy4zICgxMjA4MSkgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+dHJhbnNpdGlvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHNrZXRjaDp0eXBlPSJNU1BhZ2UiPgogICAgICAgIDxnIGlkPSJ0cmFuc2l0aW9uIiBza2V0Y2g6dHlwZT0iTVNBcnRib2FyZEdyb3VwIj4KICAgICAgICAgICAgPGcgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTQtKy1JbXBvcnRlZC1MYXllcnMtQ29weS0rLUltcG9ydGVkLUxheWVycy1Db3B5LTItQ29weSIgc2tldGNoOnR5cGU9Ik1TTGF5ZXJHcm91cCI+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHktNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwNy4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjYyNSwyLjUyNyBDMTQ5LjYyNSwyLjUyNyAxNTUuODA1LDYuMDk2IDE1Ni4zNjIsNi40MTggTDE1Ni4zNjIsNy4zMDQgQzE1Ni4zNjIsNy40ODEgMTU2LjM3NSw3LjY2NCAxNTYuNCw3Ljg1MyBDMTU2LjQxLDcuOTM0IDE1Ni40Miw4LjAxNSAxNTYuNDI3LDguMDk1IEMxNTYuNTY3LDkuNTEgMTU3LjQwMSwxMS4wOTMgMTU4LjUzMiwxMi4wOTQgTDE2NC4yNTIsMTcuMTU2IEwxNjQuMzMzLDE3LjA2NiBDMTY0LjMzMywxNy4wNjYgMTY4LjcxNSwxNC41MzYgMTY5LjU2OCwxNC4wNDIgQzE3MS4wMjUsMTQuODgzIDE5NS41MzgsMjkuMDM1IDE5NS41MzgsMjkuMDM1IEwxOTUuNTM4LDgzLjAzNiBDMTk1LjUzOCw4My44MDcgMTk1LjE1Miw4NC4yNTMgMTk0LjU5LDg0LjI1MyBDMTk0LjM1Nyw4NC4yNTMgMTk0LjA5NSw4NC4xNzcgMTkzLjgxOCw4NC4wMTcgTDE2OS44NTEsNzAuMTc5IEwxNjkuODM3LDcwLjIwMyBMMTQyLjUxNSw4NS45NzggTDE0MS42NjUsODQuNjU1IEMxMzYuOTM0LDgzLjEyNiAxMzEuOTE3LDgxLjkxNSAxMjYuNzE0LDgxLjA0NSBDMTI2LjcwOSw4MS4wNiAxMjYuNzA3LDgxLjA2OSAxMjYuNzA3LDgxLjA2OSBMMTIxLjY0LDk4LjAzIEwxMTMuNzQ5LDEwMi41ODYgTDExMy43MTIsMTAyLjUyMyBMMTEzLjcxMiwxMzAuMTEzIEMxMTMuNzEyLDEzMC44ODUgMTEzLjMyNiwxMzEuMzMgMTEyLjc2NCwxMzEuMzMgQzExMi41MzIsMTMxLjMzIDExMi4yNjksMTMxLjI1NCAxMTEuOTkyLDEzMS4wOTQgTDY5LjUxOSwxMDYuNTcyIEM2OC41NjksMTA2LjAyMyA2Ny43OTksMTA0LjY5NSA2Ny43OTksMTAzLjYwNSBMNjcuNzk5LDEwMi41NyBMNjcuNzc4LDEwMi42MTcgQzY3LjI3LDEwMi4zOTMgNjYuNjQ4LDEwMi4yNDkgNjUuOTYyLDEwMi4yMTggQzY1Ljg3NSwxMDIuMjE0IDY1Ljc4OCwxMDIuMjEyIDY1LjcwMSwxMDIuMjEyIEM2NS42MDYsMTAyLjIxMiA2NS41MTEsMTAyLjIxNSA2NS40MTYsMTAyLjIxOSBDNjUuMTk1LDEwMi4yMjkgNjQuOTc0LDEwMi4yMzUgNjQuNzU0LDEwMi4yMzUgQzY0LjMzMSwxMDIuMjM1IDYzLjkxMSwxMDIuMjE2IDYzLjQ5OCwxMDIuMTc4IEM2MS44NDMsMTAyLjAyNSA2MC4yOTgsMTAxLjU3OCA1OS4wOTQsMTAwLjg4MiBMMTIuNTE4LDczLjk5MiBMMTIuNTIzLDc0LjAwNCBMMi4yNDUsNTUuMjU0IEMxLjI0NCw1My40MjcgMi4wMDQsNTEuMDM4IDMuOTQzLDQ5LjkxOCBMNTkuOTU0LDE3LjU3MyBDNjAuNjI2LDE3LjE4NSA2MS4zNSwxNy4wMDEgNjIuMDUzLDE3LjAwMSBDNjMuMzc5LDE3LjAwMSA2NC42MjUsMTcuNjYgNjUuMjgsMTguODU0IEw2NS4yODUsMTguODUxIEw2NS41MTIsMTkuMjY0IEw2NS41MDYsMTkuMjY4IEM2NS45MDksMjAuMDAzIDY2LjQwNSwyMC42OCA2Ni45ODMsMjEuMjg2IEw2Ny4yNiwyMS41NTYgQzY5LjE3NCwyMy40MDYgNzEuNzI4LDI0LjM1NyA3NC4zNzMsMjQuMzU3IEM3Ni4zMjIsMjQuMzU3IDc4LjMyMSwyMy44NCA4MC4xNDgsMjIuNzg1IEM4MC4xNjEsMjIuNzg1IDg3LjQ2NywxOC41NjYgODcuNDY3LDE4LjU2NiBDODguMTM5LDE4LjE3OCA4OC44NjMsMTcuOTk0IDg5LjU2NiwxNy45OTQgQzkwLjg5MiwxNy45OTQgOTIuMTM4LDE4LjY1MiA5Mi43OTIsMTkuODQ3IEw5Ni4wNDIsMjUuNzc1IEw5Ni4wNjQsMjUuNzU3IEwxMDIuODQ5LDI5LjY3NCBMMTAyLjc0NCwyOS40OTIgTDE0OS42MjUsMi41MjcgTTE0OS42MjUsMC44OTIgQzE0OS4zNDMsMC44OTIgMTQ5LjA2MiwwLjk2NSAxNDguODEsMS4xMSBMMTAyLjY0MSwyNy42NjYgTDk3LjIzMSwyNC41NDIgTDk0LjIyNiwxOS4wNjEgQzkzLjMxMywxNy4zOTQgOTEuNTI3LDE2LjM1OSA4OS41NjYsMTYuMzU4IEM4OC41NTUsMTYuMzU4IDg3LjU0NiwxNi42MzIgODYuNjQ5LDE3LjE1IEM4My44NzgsMTguNzUgNzkuNjg3LDIxLjE2OSA3OS4zNzQsMjEuMzQ1IEM3OS4zNTksMjEuMzUzIDc5LjM0NSwyMS4zNjEgNzkuMzMsMjEuMzY5IEM3Ny43OTgsMjIuMjU0IDc2LjA4NCwyMi43MjIgNzQuMzczLDIyLjcyMiBDNzIuMDgxLDIyLjcyMiA2OS45NTksMjEuODkgNjguMzk3LDIwLjM4IEw2OC4xNDUsMjAuMTM1IEM2Ny43MDYsMTkuNjcyIDY3LjMyMywxOS4xNTYgNjcuMDA2LDE4LjYwMSBDNjYuOTg4LDE4LjU1OSA2Ni45NjgsMTguNTE5IDY2Ljk0NiwxOC40NzkgTDY2LjcxOSwxOC4wNjUgQzY2LjY5LDE4LjAxMiA2Ni42NTgsMTcuOTYgNjYuNjI0LDE3LjkxMSBDNjUuNjg2LDE2LjMzNyA2My45NTEsMTUuMzY2IDYyLjA1MywxNS4zNjYgQzYxLjA0MiwxNS4zNjYgNjAuMDMzLDE1LjY0IDU5LjEzNiwxNi4xNTggTDMuMTI1LDQ4LjUwMiBDMC40MjYsNTAuMDYxIC0wLjYxMyw1My40NDIgMC44MTEsNTYuMDQgTDExLjA4OSw3NC43OSBDMTEuMjY2LDc1LjExMyAxMS41MzcsNzUuMzUzIDExLjg1LDc1LjQ5NCBMNTguMjc2LDEwMi4yOTggQzU5LjY3OSwxMDMuMTA4IDYxLjQzMywxMDMuNjMgNjMuMzQ4LDEwMy44MDYgQzYzLjgxMiwxMDMuODQ4IDY0LjI4NSwxMDMuODcgNjQuNzU0LDEwMy44NyBDNjUsMTAzLjg3IDY1LjI0OSwxMDMuODY0IDY1LjQ5NCwxMDMuODUyIEM2NS41NjMsMTAzLjg0OSA2NS42MzIsMTAzLjg0NyA2NS43MDEsMTAzLjg0NyBDNjUuNzY0LDEwMy44NDcgNjUuODI4LDEwMy44NDkgNjUuODksMTAzLjg1MiBDNjUuOTg2LDEwMy44NTYgNjYuMDgsMTAzLjg2MyA2Ni4xNzMsMTAzLjg3NCBDNjYuMjgyLDEwNS40NjcgNjcuMzMyLDEwNy4xOTcgNjguNzAyLDEwNy45ODggTDExMS4xNzQsMTMyLjUxIEMxMTEuNjk4LDEzMi44MTIgMTEyLjIzMiwxMzIuOTY1IDExMi43NjQsMTMyLjk2NSBDMTE0LjI2MSwxMzIuOTY1IDExNS4zNDcsMTMxLjc2NSAxMTUuMzQ3LDEzMC4xMTMgTDExNS4zNDcsMTAzLjU1MSBMMTIyLjQ1OCw5OS40NDYgQzEyMi44MTksOTkuMjM3IDEyMy4wODcsOTguODk4IDEyMy4yMDcsOTguNDk4IEwxMjcuODY1LDgyLjkwNSBDMTMyLjI3OSw4My43MDIgMTM2LjU1Nyw4NC43NTMgMTQwLjYwNyw4Ni4wMzMgTDE0MS4xNCw4Ni44NjIgQzE0MS40NTEsODcuMzQ2IDE0MS45NzcsODcuNjEzIDE0Mi41MTYsODcuNjEzIEMxNDIuNzk0LDg3LjYxMyAxNDMuMDc2LDg3LjU0MiAxNDMuMzMzLDg3LjM5MyBMMTY5Ljg2NSw3Mi4wNzYgTDE5Myw4NS40MzMgQzE5My41MjMsODUuNzM1IDE5NC4wNTgsODUuODg4IDE5NC41OSw4NS44ODggQzE5Ni4wODcsODUuODg4IDE5Ny4xNzMsODQuNjg5IDE5Ny4xNzMsODMuMDM2IEwxOTcuMTczLDI5LjAzNSBDMTk3LjE3MywyOC40NTEgMTk2Ljg2MSwyNy45MTEgMTk2LjM1NSwyNy42MTkgQzE5Ni4zNTUsMjcuNjE5IDE3MS44NDMsMTMuNDY3IDE3MC4zODUsMTIuNjI2IEMxNzAuMTMyLDEyLjQ4IDE2OS44NSwxMi40MDcgMTY5LjU2OCwxMi40MDcgQzE2OS4yODUsMTIuNDA3IDE2OS4wMDIsMTIuNDgxIDE2OC43NDksMTIuNjI3IEMxNjguMTQzLDEyLjk3OCAxNjUuNzU2LDE0LjM1NyAxNjQuNDI0LDE1LjEyNSBMMTU5LjYxNSwxMC44NyBDMTU4Ljc5NiwxMC4xNDUgMTU4LjE1NCw4LjkzNyAxNTguMDU0LDcuOTM0IEMxNTguMDQ1LDcuODM3IDE1OC4wMzQsNy43MzkgMTU4LjAyMSw3LjY0IEMxNTguMDA1LDcuNTIzIDE1Ny45OTgsNy40MSAxNTcuOTk4LDcuMzA0IEwxNTcuOTk4LDYuNDE4IEMxNTcuOTk4LDUuODM0IDE1Ny42ODYsNS4yOTUgMTU3LjE4MSw1LjAwMiBDMTU2LjYyNCw0LjY4IDE1MC40NDIsMS4xMTEgMTUwLjQ0MiwxLjExMSBDMTUwLjE4OSwwLjk2NSAxNDkuOTA3LDAuODkyIDE0OS42MjUsMC44OTIiIGlkPSJGaWxsLTEiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTYuMDI3LDI1LjYzNiBMMTQyLjYwMyw1Mi41MjcgQzE0My44MDcsNTMuMjIyIDE0NC41ODIsNTQuMTE0IDE0NC44NDUsNTUuMDY4IEwxNDQuODM1LDU1LjA3NSBMNjMuNDYxLDEwMi4wNTcgTDYzLjQ2LDEwMi4wNTcgQzYxLjgwNiwxMDEuOTA1IDYwLjI2MSwxMDEuNDU3IDU5LjA1NywxMDAuNzYyIEwxMi40ODEsNzMuODcxIEw5Ni4wMjcsMjUuNjM2IiBpZD0iRmlsbC0yIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYzLjQ2MSwxMDIuMTc0IEM2My40NTMsMTAyLjE3NCA2My40NDYsMTAyLjE3NCA2My40MzksMTAyLjE3MiBDNjEuNzQ2LDEwMi4wMTYgNjAuMjExLDEwMS41NjMgNTguOTk4LDEwMC44NjMgTDEyLjQyMiw3My45NzMgQzEyLjM4Niw3My45NTIgMTIuMzY0LDczLjkxNCAxMi4zNjQsNzMuODcxIEMxMi4zNjQsNzMuODMgMTIuMzg2LDczLjc5MSAxMi40MjIsNzMuNzcgTDk1Ljk2OCwyNS41MzUgQzk2LjAwNCwyNS41MTQgOTYuMDQ5LDI1LjUxNCA5Ni4wODUsMjUuNTM1IEwxNDIuNjYxLDUyLjQyNiBDMTQzLjg4OCw1My4xMzQgMTQ0LjY4Miw1NC4wMzggMTQ0Ljk1Nyw1NS4wMzcgQzE0NC45Nyw1NS4wODMgMTQ0Ljk1Myw1NS4xMzMgMTQ0LjkxNSw1NS4xNjEgQzE0NC45MTEsNTUuMTY1IDE0NC44OTgsNTUuMTc0IDE0NC44OTQsNTUuMTc3IEw2My41MTksMTAyLjE1OCBDNjMuNTAxLDEwMi4xNjkgNjMuNDgxLDEwMi4xNzQgNjMuNDYxLDEwMi4xNzQgTDYzLjQ2MSwxMDIuMTc0IFogTTEyLjcxNCw3My44NzEgTDU5LjExNSwxMDAuNjYxIEM2MC4yOTMsMTAxLjM0MSA2MS43ODYsMTAxLjc4MiA2My40MzUsMTAxLjkzNyBMMTQ0LjcwNyw1NS4wMTUgQzE0NC40MjgsNTQuMTA4IDE0My42ODIsNTMuMjg1IDE0Mi41NDQsNTIuNjI4IEw5Ni4wMjcsMjUuNzcxIEwxMi43MTQsNzMuODcxIEwxMi43MTQsNzMuODcxIFoiIGlkPSJGaWxsLTMiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ4LjMyNyw1OC40NzEgQzE0OC4xNDUsNTguNDggMTQ3Ljk2Miw1OC40OCAxNDcuNzgxLDU4LjQ3MiBDMTQ1Ljg4Nyw1OC4zODkgMTQ0LjQ3OSw1Ny40MzQgMTQ0LjYzNiw1Ni4zNCBDMTQ0LjY4OSw1NS45NjcgMTQ0LjY2NCw1NS41OTcgMTQ0LjU2NCw1NS4yMzUgTDYzLjQ2MSwxMDIuMDU3IEM2NC4wODksMTAyLjExNSA2NC43MzMsMTAyLjEzIDY1LjM3OSwxMDIuMDk5IEM2NS41NjEsMTAyLjA5IDY1Ljc0MywxMDIuMDkgNjUuOTI1LDEwMi4wOTggQzY3LjgxOSwxMDIuMTgxIDY5LjIyNywxMDMuMTM2IDY5LjA3LDEwNC4yMyBMMTQ4LjMyNyw1OC40NzEiIGlkPSJGaWxsLTQiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNjkuMDcsMTA0LjM0NyBDNjkuMDQ4LDEwNC4zNDcgNjkuMDI1LDEwNC4zNCA2OS4wMDUsMTA0LjMyNyBDNjguOTY4LDEwNC4zMDEgNjguOTQ4LDEwNC4yNTcgNjguOTU1LDEwNC4yMTMgQzY5LDEwMy44OTYgNjguODk4LDEwMy41NzYgNjguNjU4LDEwMy4yODggQzY4LjE1MywxMDIuNjc4IDY3LjEwMywxMDIuMjY2IDY1LjkyLDEwMi4yMTQgQzY1Ljc0MiwxMDIuMjA2IDY1LjU2MywxMDIuMjA3IDY1LjM4NSwxMDIuMjE1IEM2NC43NDIsMTAyLjI0NiA2NC4wODcsMTAyLjIzMiA2My40NSwxMDIuMTc0IEM2My4zOTksMTAyLjE2OSA2My4zNTgsMTAyLjEzMiA2My4zNDcsMTAyLjA4MiBDNjMuMzM2LDEwMi4wMzMgNjMuMzU4LDEwMS45ODEgNjMuNDAyLDEwMS45NTYgTDE0NC41MDYsNTUuMTM0IEMxNDQuNTM3LDU1LjExNiAxNDQuNTc1LDU1LjExMyAxNDQuNjA5LDU1LjEyNyBDMTQ0LjY0Miw1NS4xNDEgMTQ0LjY2OCw1NS4xNyAxNDQuNjc3LDU1LjIwNCBDMTQ0Ljc4MSw1NS41ODUgMTQ0LjgwNiw1NS45NzIgMTQ0Ljc1MSw1Ni4zNTcgQzE0NC43MDYsNTYuNjczIDE0NC44MDgsNTYuOTk0IDE0NS4wNDcsNTcuMjgyIEMxNDUuNTUzLDU3Ljg5MiAxNDYuNjAyLDU4LjMwMyAxNDcuNzg2LDU4LjM1NSBDMTQ3Ljk2NCw1OC4zNjMgMTQ4LjE0Myw1OC4zNjMgMTQ4LjMyMSw1OC4zNTQgQzE0OC4zNzcsNTguMzUyIDE0OC40MjQsNTguMzg3IDE0OC40MzksNTguNDM4IEMxNDguNDU0LDU4LjQ5IDE0OC40MzIsNTguNTQ1IDE0OC4zODUsNTguNTcyIEw2OS4xMjksMTA0LjMzMSBDNjkuMTExLDEwNC4zNDIgNjkuMDksMTA0LjM0NyA2OS4wNywxMDQuMzQ3IEw2OS4wNywxMDQuMzQ3IFogTTY1LjY2NSwxMDEuOTc1IEM2NS43NTQsMTAxLjk3NSA2NS44NDIsMTAxLjk3NyA2NS45MywxMDEuOTgxIEM2Ny4xOTYsMTAyLjAzNyA2OC4yODMsMTAyLjQ2OSA2OC44MzgsMTAzLjEzOSBDNjkuMDY1LDEwMy40MTMgNjkuMTg4LDEwMy43MTQgNjkuMTk4LDEwNC4wMjEgTDE0Ny44ODMsNTguNTkyIEMxNDcuODQ3LDU4LjU5MiAxNDcuODExLDU4LjU5MSAxNDcuNzc2LDU4LjU4OSBDMTQ2LjUwOSw1OC41MzMgMTQ1LjQyMiw1OC4xIDE0NC44NjcsNTcuNDMxIEMxNDQuNTg1LDU3LjA5MSAxNDQuNDY1LDU2LjcwNyAxNDQuNTIsNTYuMzI0IEMxNDQuNTYzLDU2LjAyMSAxNDQuNTUyLDU1LjcxNiAxNDQuNDg4LDU1LjQxNCBMNjMuODQ2LDEwMS45NyBDNjQuMzUzLDEwMi4wMDIgNjQuODY3LDEwMi4wMDYgNjUuMzc0LDEwMS45ODIgQzY1LjQ3MSwxMDEuOTc3IDY1LjU2OCwxMDEuOTc1IDY1LjY2NSwxMDEuOTc1IEw2NS42NjUsMTAxLjk3NSBaIiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTIuMjA4LDU1LjEzNCBDMS4yMDcsNTMuMzA3IDEuOTY3LDUwLjkxNyAzLjkwNiw0OS43OTcgTDU5LjkxNywxNy40NTMgQzYxLjg1NiwxNi4zMzMgNjQuMjQxLDE2LjkwNyA2NS4yNDMsMTguNzM0IEw2NS40NzUsMTkuMTQ0IEM2NS44NzIsMTkuODgyIDY2LjM2OCwyMC41NiA2Ni45NDUsMjEuMTY1IEw2Ny4yMjMsMjEuNDM1IEM3MC41NDgsMjQuNjQ5IDc1LjgwNiwyNS4xNTEgODAuMTExLDIyLjY2NSBMODcuNDMsMTguNDQ1IEM4OS4zNywxNy4zMjYgOTEuNzU0LDE3Ljg5OSA5Mi43NTUsMTkuNzI3IEw5Ni4wMDUsMjUuNjU1IEwxMi40ODYsNzMuODg0IEwyLjIwOCw1NS4xMzQgWiIgaWQ9IkZpbGwtNiIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMi40ODYsNzQuMDAxIEMxMi40NzYsNzQuMDAxIDEyLjQ2NSw3My45OTkgMTIuNDU1LDczLjk5NiBDMTIuNDI0LDczLjk4OCAxMi4zOTksNzMuOTY3IDEyLjM4NCw3My45NCBMMi4xMDYsNTUuMTkgQzEuMDc1LDUzLjMxIDEuODU3LDUwLjg0NSAzLjg0OCw0OS42OTYgTDU5Ljg1OCwxNy4zNTIgQzYwLjUyNSwxNi45NjcgNjEuMjcxLDE2Ljc2NCA2Mi4wMTYsMTYuNzY0IEM2My40MzEsMTYuNzY0IDY0LjY2NiwxNy40NjYgNjUuMzI3LDE4LjY0NiBDNjUuMzM3LDE4LjY1NCA2NS4zNDUsMTguNjYzIDY1LjM1MSwxOC42NzQgTDY1LjU3OCwxOS4wODggQzY1LjU4NCwxOS4xIDY1LjU4OSwxOS4xMTIgNjUuNTkxLDE5LjEyNiBDNjUuOTg1LDE5LjgzOCA2Ni40NjksMjAuNDk3IDY3LjAzLDIxLjA4NSBMNjcuMzA1LDIxLjM1MSBDNjkuMTUxLDIzLjEzNyA3MS42NDksMjQuMTIgNzQuMzM2LDI0LjEyIEM3Ni4zMTMsMjQuMTIgNzguMjksMjMuNTgyIDgwLjA1MywyMi41NjMgQzgwLjA2NCwyMi41NTcgODAuMDc2LDIyLjU1MyA4MC4wODgsMjIuNTUgTDg3LjM3MiwxOC4zNDQgQzg4LjAzOCwxNy45NTkgODguNzg0LDE3Ljc1NiA4OS41MjksMTcuNzU2IEM5MC45NTYsMTcuNzU2IDkyLjIwMSwxOC40NzIgOTIuODU4LDE5LjY3IEw5Ni4xMDcsMjUuNTk5IEM5Ni4xMzgsMjUuNjU0IDk2LjExOCwyNS43MjQgOTYuMDYzLDI1Ljc1NiBMMTIuNTQ1LDczLjk4NSBDMTIuNTI2LDczLjk5NiAxMi41MDYsNzQuMDAxIDEyLjQ4Niw3NC4wMDEgTDEyLjQ4Niw3NC4wMDEgWiBNNjIuMDE2LDE2Ljk5NyBDNjEuMzEyLDE2Ljk5NyA2MC42MDYsMTcuMTkgNTkuOTc1LDE3LjU1NCBMMy45NjUsNDkuODk5IEMyLjA4Myw1MC45ODUgMS4zNDEsNTMuMzA4IDIuMzEsNTUuMDc4IEwxMi41MzEsNzMuNzIzIEw5NS44NDgsMjUuNjExIEw5Mi42NTMsMTkuNzgyIEM5Mi4wMzgsMTguNjYgOTAuODcsMTcuOTkgODkuNTI5LDE3Ljk5IEM4OC44MjUsMTcuOTkgODguMTE5LDE4LjE4MiA4Ny40ODksMTguNTQ3IEw4MC4xNzIsMjIuNzcyIEM4MC4xNjEsMjIuNzc4IDgwLjE0OSwyMi43ODIgODAuMTM3LDIyLjc4NSBDNzguMzQ2LDIzLjgxMSA3Ni4zNDEsMjQuMzU0IDc0LjMzNiwyNC4zNTQgQzcxLjU4OCwyNC4zNTQgNjkuMDMzLDIzLjM0NyA2Ny4xNDIsMjEuNTE5IEw2Ni44NjQsMjEuMjQ5IEM2Ni4yNzcsMjAuNjM0IDY1Ljc3NCwxOS45NDcgNjUuMzY3LDE5LjIwMyBDNjUuMzYsMTkuMTkyIDY1LjM1NiwxOS4xNzkgNjUuMzU0LDE5LjE2NiBMNjUuMTYzLDE4LjgxOSBDNjUuMTU0LDE4LjgxMSA2NS4xNDYsMTguODAxIDY1LjE0LDE4Ljc5IEM2NC41MjUsMTcuNjY3IDYzLjM1NywxNi45OTcgNjIuMDE2LDE2Ljk5NyBMNjIuMDE2LDE2Ljk5NyBaIiBpZD0iRmlsbC03IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTQyLjQzNCw0OC44MDggTDQyLjQzNCw0OC44MDggQzM5LjkyNCw0OC44MDcgMzcuNzM3LDQ3LjU1IDM2LjU4Miw0NS40NDMgQzM0Ljc3MSw0Mi4xMzkgMzYuMTQ0LDM3LjgwOSAzOS42NDEsMzUuNzg5IEw1MS45MzIsMjguNjkxIEM1My4xMDMsMjguMDE1IDU0LjQxMywyNy42NTggNTUuNzIxLDI3LjY1OCBDNTguMjMxLDI3LjY1OCA2MC40MTgsMjguOTE2IDYxLjU3MywzMS4wMjMgQzYzLjM4NCwzNC4zMjcgNjIuMDEyLDM4LjY1NyA1OC41MTQsNDAuNjc3IEw0Ni4yMjMsNDcuNzc1IEM0NS4wNTMsNDguNDUgNDMuNzQyLDQ4LjgwOCA0Mi40MzQsNDguODA4IEw0Mi40MzQsNDguODA4IFogTTU1LjcyMSwyOC4xMjUgQzU0LjQ5NSwyOC4xMjUgNTMuMjY1LDI4LjQ2MSA1Mi4xNjYsMjkuMDk2IEwzOS44NzUsMzYuMTk0IEMzNi41OTYsMzguMDg3IDM1LjMwMiw0Mi4xMzYgMzYuOTkyLDQ1LjIxOCBDMzguMDYzLDQ3LjE3MyA0MC4wOTgsNDguMzQgNDIuNDM0LDQ4LjM0IEM0My42NjEsNDguMzQgNDQuODksNDguMDA1IDQ1Ljk5LDQ3LjM3IEw1OC4yODEsNDAuMjcyIEM2MS41NiwzOC4zNzkgNjIuODUzLDM0LjMzIDYxLjE2NCwzMS4yNDggQzYwLjA5MiwyOS4yOTMgNTguMDU4LDI4LjEyNSA1NS43MjEsMjguMTI1IEw1NS43MjEsMjguMTI1IFoiIGlkPSJGaWxsLTgiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTQ5LjU4OCwyLjQwNyBDMTQ5LjU4OCwyLjQwNyAxNTUuNzY4LDUuOTc1IDE1Ni4zMjUsNi4yOTcgTDE1Ni4zMjUsNy4xODQgQzE1Ni4zMjUsNy4zNiAxNTYuMzM4LDcuNTQ0IDE1Ni4zNjIsNy43MzMgQzE1Ni4zNzMsNy44MTQgMTU2LjM4Miw3Ljg5NCAxNTYuMzksNy45NzUgQzE1Ni41Myw5LjM5IDE1Ny4zNjMsMTAuOTczIDE1OC40OTUsMTEuOTc0IEwxNjUuODkxLDE4LjUxOSBDMTY2LjA2OCwxOC42NzUgMTY2LjI0OSwxOC44MTQgMTY2LjQzMiwxOC45MzQgQzE2OC4wMTEsMTkuOTc0IDE2OS4zODIsMTkuNCAxNjkuNDk0LDE3LjY1MiBDMTY5LjU0MywxNi44NjggMTY5LjU1MSwxNi4wNTcgMTY5LjUxNywxNS4yMjMgTDE2OS41MTQsMTUuMDYzIEwxNjkuNTE0LDEzLjkxMiBDMTcwLjc4LDE0LjY0MiAxOTUuNTAxLDI4LjkxNSAxOTUuNTAxLDI4LjkxNSBMMTk1LjUwMSw4Mi45MTUgQzE5NS41MDEsODQuMDA1IDE5NC43MzEsODQuNDQ1IDE5My43ODEsODMuODk3IEwxNTEuMzA4LDU5LjM3NCBDMTUwLjM1OCw1OC44MjYgMTQ5LjU4OCw1Ny40OTcgMTQ5LjU4OCw1Ni40MDggTDE0OS41ODgsMjIuMzc1IiBpZD0iRmlsbC05IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE5NC41NTMsODQuMjUgQzE5NC4yOTYsODQuMjUgMTk0LjAxMyw4NC4xNjUgMTkzLjcyMiw4My45OTcgTDE1MS4yNSw1OS40NzYgQzE1MC4yNjksNTguOTA5IDE0OS40NzEsNTcuNTMzIDE0OS40NzEsNTYuNDA4IEwxNDkuNDcxLDIyLjM3NSBMMTQ5LjcwNSwyMi4zNzUgTDE0OS43MDUsNTYuNDA4IEMxNDkuNzA1LDU3LjQ1OSAxNTAuNDUsNTguNzQ0IDE1MS4zNjYsNTkuMjc0IEwxOTMuODM5LDgzLjc5NSBDMTk0LjI2Myw4NC4wNCAxOTQuNjU1LDg0LjA4MyAxOTQuOTQyLDgzLjkxNyBDMTk1LjIyNyw4My43NTMgMTk1LjM4NCw4My4zOTcgMTk1LjM4NCw4Mi45MTUgTDE5NS4zODQsMjguOTgyIEMxOTQuMTAyLDI4LjI0MiAxNzIuMTA0LDE1LjU0MiAxNjkuNjMxLDE0LjExNCBMMTY5LjYzNCwxNS4yMiBDMTY5LjY2OCwxNi4wNTIgMTY5LjY2LDE2Ljg3NCAxNjkuNjEsMTcuNjU5IEMxNjkuNTU2LDE4LjUwMyAxNjkuMjE0LDE5LjEyMyAxNjguNjQ3LDE5LjQwNSBDMTY4LjAyOCwxOS43MTQgMTY3LjE5NywxOS41NzggMTY2LjM2NywxOS4wMzIgQzE2Ni4xODEsMTguOTA5IDE2NS45OTUsMTguNzY2IDE2NS44MTQsMTguNjA2IEwxNTguNDE3LDEyLjA2MiBDMTU3LjI1OSwxMS4wMzYgMTU2LjQxOCw5LjQzNyAxNTYuMjc0LDcuOTg2IEMxNTYuMjY2LDcuOTA3IDE1Ni4yNTcsNy44MjcgMTU2LjI0Nyw3Ljc0OCBDMTU2LjIyMSw3LjU1NSAxNTYuMjA5LDcuMzY1IDE1Ni4yMDksNy4xODQgTDE1Ni4yMDksNi4zNjQgQzE1NS4zNzUsNS44ODMgMTQ5LjUyOSwyLjUwOCAxNDkuNTI5LDIuNTA4IEwxNDkuNjQ2LDIuMzA2IEMxNDkuNjQ2LDIuMzA2IDE1NS44MjcsNS44NzQgMTU2LjM4NCw2LjE5NiBMMTU2LjQ0Miw2LjIzIEwxNTYuNDQyLDcuMTg0IEMxNTYuNDQyLDcuMzU1IDE1Ni40NTQsNy41MzUgMTU2LjQ3OCw3LjcxNyBDMTU2LjQ4OSw3LjggMTU2LjQ5OSw3Ljg4MiAxNTYuNTA3LDcuOTYzIEMxNTYuNjQ1LDkuMzU4IDE1Ny40NTUsMTAuODk4IDE1OC41NzIsMTEuODg2IEwxNjUuOTY5LDE4LjQzMSBDMTY2LjE0MiwxOC41ODQgMTY2LjMxOSwxOC43MiAxNjYuNDk2LDE4LjgzNyBDMTY3LjI1NCwxOS4zMzYgMTY4LDE5LjQ2NyAxNjguNTQzLDE5LjE5NiBDMTY5LjAzMywxOC45NTMgMTY5LjMyOSwxOC40MDEgMTY5LjM3NywxNy42NDUgQzE2OS40MjcsMTYuODY3IDE2OS40MzQsMTYuMDU0IDE2OS40MDEsMTUuMjI4IEwxNjkuMzk3LDE1LjA2NSBMMTY5LjM5NywxMy43MSBMMTY5LjU3MiwxMy44MSBDMTcwLjgzOSwxNC41NDEgMTk1LjU1OSwyOC44MTQgMTk1LjU1OSwyOC44MTQgTDE5NS42MTgsMjguODQ3IEwxOTUuNjE4LDgyLjkxNSBDMTk1LjYxOCw4My40ODQgMTk1LjQyLDgzLjkxMSAxOTUuMDU5LDg0LjExOSBDMTk0LjkwOCw4NC4yMDYgMTk0LjczNyw4NC4yNSAxOTQuNTUzLDg0LjI1IiBpZD0iRmlsbC0xMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDUuNjg1LDU2LjE2MSBMMTY5LjgsNzAuMDgzIEwxNDMuODIyLDg1LjA4MSBMMTQyLjM2LDg0Ljc3NCBDMTM1LjgyNiw4Mi42MDQgMTI4LjczMiw4MS4wNDYgMTIxLjM0MSw4MC4xNTggQzExNi45NzYsNzkuNjM0IDExMi42NzgsODEuMjU0IDExMS43NDMsODMuNzc4IEMxMTEuNTA2LDg0LjQxNCAxMTEuNTAzLDg1LjA3MSAxMTEuNzMyLDg1LjcwNiBDMTEzLjI3LDg5Ljk3MyAxMTUuOTY4LDk0LjA2OSAxMTkuNzI3LDk3Ljg0MSBMMTIwLjI1OSw5OC42ODYgQzEyMC4yNiw5OC42ODUgOTQuMjgyLDExMy42ODMgOTQuMjgyLDExMy42ODMgTDcwLjE2Nyw5OS43NjEgTDE0NS42ODUsNTYuMTYxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik05NC4yODIsMTEzLjgxOCBMOTQuMjIzLDExMy43ODUgTDY5LjkzMyw5OS43NjEgTDcwLjEwOCw5OS42NiBMMTQ1LjY4NSw1Ni4wMjYgTDE0NS43NDMsNTYuMDU5IEwxNzAuMDMzLDcwLjA4MyBMMTQzLjg0Miw4NS4yMDUgTDE0My43OTcsODUuMTk1IEMxNDMuNzcyLDg1LjE5IDE0Mi4zMzYsODQuODg4IDE0Mi4zMzYsODQuODg4IEMxMzUuNzg3LDgyLjcxNCAxMjguNzIzLDgxLjE2MyAxMjEuMzI3LDgwLjI3NCBDMTIwLjc4OCw4MC4yMDkgMTIwLjIzNiw4MC4xNzcgMTE5LjY4OSw4MC4xNzcgQzExNS45MzEsODAuMTc3IDExMi42MzUsODEuNzA4IDExMS44NTIsODMuODE5IEMxMTEuNjI0LDg0LjQzMiAxMTEuNjIxLDg1LjA1MyAxMTEuODQyLDg1LjY2NyBDMTEzLjM3Nyw4OS45MjUgMTE2LjA1OCw5My45OTMgMTE5LjgxLDk3Ljc1OCBMMTE5LjgyNiw5Ny43NzkgTDEyMC4zNTIsOTguNjE0IEMxMjAuMzU0LDk4LjYxNyAxMjAuMzU2LDk4LjYyIDEyMC4zNTgsOTguNjI0IEwxMjAuNDIyLDk4LjcyNiBMMTIwLjMxNyw5OC43ODcgQzEyMC4yNjQsOTguODE4IDk0LjU5OSwxMTMuNjM1IDk0LjM0LDExMy43ODUgTDk0LjI4MiwxMTMuODE4IEw5NC4yODIsMTEzLjgxOCBaIE03MC40MDEsOTkuNzYxIEw5NC4yODIsMTEzLjU0OSBMMTE5LjA4NCw5OS4yMjkgQzExOS42Myw5OC45MTQgMTE5LjkzLDk4Ljc0IDEyMC4xMDEsOTguNjU0IEwxMTkuNjM1LDk3LjkxNCBDMTE1Ljg2NCw5NC4xMjcgMTEzLjE2OCw5MC4wMzMgMTExLjYyMiw4NS43NDYgQzExMS4zODIsODUuMDc5IDExMS4zODYsODQuNDA0IDExMS42MzMsODMuNzM4IEMxMTIuNDQ4LDgxLjUzOSAxMTUuODM2LDc5Ljk0MyAxMTkuNjg5LDc5Ljk0MyBDMTIwLjI0Niw3OS45NDMgMTIwLjgwNiw3OS45NzYgMTIxLjM1NSw4MC4wNDIgQzEyOC43NjcsODAuOTMzIDEzNS44NDYsODIuNDg3IDE0Mi4zOTYsODQuNjYzIEMxNDMuMjMyLDg0LjgzOCAxNDMuNjExLDg0LjkxNyAxNDMuNzg2LDg0Ljk2NyBMMTY5LjU2Niw3MC4wODMgTDE0NS42ODUsNTYuMjk1IEw3MC40MDEsOTkuNzYxIEw3MC40MDEsOTkuNzYxIFoiIGlkPSJGaWxsLTEyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2Ny4yMywxOC45NzkgTDE2Ny4yMyw2OS44NSBMMTM5LjkwOSw4NS42MjMgTDEzMy40NDgsNzEuNDU2IEMxMzIuNTM4LDY5LjQ2IDEzMC4wMiw2OS43MTggMTI3LjgyNCw3Mi4wMyBDMTI2Ljc2OSw3My4xNCAxMjUuOTMxLDc0LjU4NSAxMjUuNDk0LDc2LjA0OCBMMTE5LjAzNCw5Ny42NzYgTDkxLjcxMiwxMTMuNDUgTDkxLjcxMiw2Mi41NzkgTDE2Ny4yMywxOC45NzkiIGlkPSJGaWxsLTEzIiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTkxLjcxMiwxMTMuNTY3IEM5MS42OTIsMTEzLjU2NyA5MS42NzIsMTEzLjU2MSA5MS42NTMsMTEzLjU1MSBDOTEuNjE4LDExMy41MyA5MS41OTUsMTEzLjQ5MiA5MS41OTUsMTEzLjQ1IEw5MS41OTUsNjIuNTc5IEM5MS41OTUsNjIuNTM3IDkxLjYxOCw2Mi40OTkgOTEuNjUzLDYyLjQ3OCBMMTY3LjE3MiwxOC44NzggQzE2Ny4yMDgsMTguODU3IDE2Ny4yNTIsMTguODU3IDE2Ny4yODgsMTguODc4IEMxNjcuMzI0LDE4Ljg5OSAxNjcuMzQ3LDE4LjkzNyAxNjcuMzQ3LDE4Ljk3OSBMMTY3LjM0Nyw2OS44NSBDMTY3LjM0Nyw2OS44OTEgMTY3LjMyNCw2OS45MyAxNjcuMjg4LDY5Ljk1IEwxMzkuOTY3LDg1LjcyNSBDMTM5LjkzOSw4NS43NDEgMTM5LjkwNSw4NS43NDUgMTM5Ljg3Myw4NS43MzUgQzEzOS44NDIsODUuNzI1IDEzOS44MTYsODUuNzAyIDEzOS44MDIsODUuNjcyIEwxMzMuMzQyLDcxLjUwNCBDMTMyLjk2Nyw3MC42ODIgMTMyLjI4LDcwLjIyOSAxMzEuNDA4LDcwLjIyOSBDMTMwLjMxOSw3MC4yMjkgMTI5LjA0NCw3MC45MTUgMTI3LjkwOCw3Mi4xMSBDMTI2Ljg3NCw3My4yIDEyNi4wMzQsNzQuNjQ3IDEyNS42MDYsNzYuMDgyIEwxMTkuMTQ2LDk3LjcwOSBDMTE5LjEzNyw5Ny43MzggMTE5LjExOCw5Ny43NjIgMTE5LjA5Miw5Ny43NzcgTDkxLjc3LDExMy41NTEgQzkxLjc1MiwxMTMuNTYxIDkxLjczMiwxMTMuNTY3IDkxLjcxMiwxMTMuNTY3IEw5MS43MTIsMTEzLjU2NyBaIE05MS44MjksNjIuNjQ3IEw5MS44MjksMTEzLjI0OCBMMTE4LjkzNSw5Ny41OTggTDEyNS4zODIsNzYuMDE1IEMxMjUuODI3LDc0LjUyNSAxMjYuNjY0LDczLjA4MSAxMjcuNzM5LDcxLjk1IEMxMjguOTE5LDcwLjcwOCAxMzAuMjU2LDY5Ljk5NiAxMzEuNDA4LDY5Ljk5NiBDMTMyLjM3Nyw2OS45OTYgMTMzLjEzOSw3MC40OTcgMTMzLjU1NCw3MS40MDcgTDEzOS45NjEsODUuNDU4IEwxNjcuMTEzLDY5Ljc4MiBMMTY3LjExMywxOS4xODEgTDkxLjgyOSw2Mi42NDcgTDkxLjgyOSw2Mi42NDcgWiIgaWQ9IkZpbGwtMTQiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTY4LjU0MywxOS4yMTMgTDE2OC41NDMsNzAuMDgzIEwxNDEuMjIxLDg1Ljg1NyBMMTM0Ljc2MSw3MS42ODkgQzEzMy44NTEsNjkuNjk0IDEzMS4zMzMsNjkuOTUxIDEyOS4xMzcsNzIuMjYzIEMxMjguMDgyLDczLjM3NCAxMjcuMjQ0LDc0LjgxOSAxMjYuODA3LDc2LjI4MiBMMTIwLjM0Niw5Ny45MDkgTDkzLjAyNSwxMTMuNjgzIEw5My4wMjUsNjIuODEzIEwxNjguNTQzLDE5LjIxMyIgaWQ9IkZpbGwtMTUiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTMuMDI1LDExMy44IEM5My4wMDUsMTEzLjggOTIuOTg0LDExMy43OTUgOTIuOTY2LDExMy43ODUgQzkyLjkzMSwxMTMuNzY0IDkyLjkwOCwxMTMuNzI1IDkyLjkwOCwxMTMuNjg0IEw5Mi45MDgsNjIuODEzIEM5Mi45MDgsNjIuNzcxIDkyLjkzMSw2Mi43MzMgOTIuOTY2LDYyLjcxMiBMMTY4LjQ4NCwxOS4xMTIgQzE2OC41MiwxOS4wOSAxNjguNTY1LDE5LjA5IDE2OC42MDEsMTkuMTEyIEMxNjguNjM3LDE5LjEzMiAxNjguNjYsMTkuMTcxIDE2OC42NiwxOS4yMTIgTDE2OC42Niw3MC4wODMgQzE2OC42Niw3MC4xMjUgMTY4LjYzNyw3MC4xNjQgMTY4LjYwMSw3MC4xODQgTDE0MS4yOCw4NS45NTggQzE0MS4yNTEsODUuOTc1IDE0MS4yMTcsODUuOTc5IDE0MS4xODYsODUuOTY4IEMxNDEuMTU0LDg1Ljk1OCAxNDEuMTI5LDg1LjkzNiAxNDEuMTE1LDg1LjkwNiBMMTM0LjY1NSw3MS43MzggQzEzNC4yOCw3MC45MTUgMTMzLjU5Myw3MC40NjMgMTMyLjcyLDcwLjQ2MyBDMTMxLjYzMiw3MC40NjMgMTMwLjM1Nyw3MS4xNDggMTI5LjIyMSw3Mi4zNDQgQzEyOC4xODYsNzMuNDMzIDEyNy4zNDcsNzQuODgxIDEyNi45MTksNzYuMzE1IEwxMjAuNDU4LDk3Ljk0MyBDMTIwLjQ1LDk3Ljk3MiAxMjAuNDMxLDk3Ljk5NiAxMjAuNDA1LDk4LjAxIEw5My4wODMsMTEzLjc4NSBDOTMuMDY1LDExMy43OTUgOTMuMDQ1LDExMy44IDkzLjAyNSwxMTMuOCBMOTMuMDI1LDExMy44IFogTTkzLjE0Miw2Mi44ODEgTDkzLjE0MiwxMTMuNDgxIEwxMjAuMjQ4LDk3LjgzMiBMMTI2LjY5NSw3Ni4yNDggQzEyNy4xNCw3NC43NTggMTI3Ljk3Nyw3My4zMTUgMTI5LjA1Miw3Mi4xODMgQzEzMC4yMzEsNzAuOTQyIDEzMS41NjgsNzAuMjI5IDEzMi43Miw3MC4yMjkgQzEzMy42ODksNzAuMjI5IDEzNC40NTIsNzAuNzMxIDEzNC44NjcsNzEuNjQxIEwxNDEuMjc0LDg1LjY5MiBMMTY4LjQyNiw3MC4wMTYgTDE2OC40MjYsMTkuNDE1IEw5My4xNDIsNjIuODgxIEw5My4xNDIsNjIuODgxIFoiIGlkPSJGaWxsLTE2IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS44LDcwLjA4MyBMMTQyLjQ3OCw4NS44NTcgTDEzNi4wMTgsNzEuNjg5IEMxMzUuMTA4LDY5LjY5NCAxMzIuNTksNjkuOTUxIDEzMC4zOTMsNzIuMjYzIEMxMjkuMzM5LDczLjM3NCAxMjguNSw3NC44MTkgMTI4LjA2NCw3Ni4yODIgTDEyMS42MDMsOTcuOTA5IEw5NC4yODIsMTEzLjY4MyBMOTQuMjgyLDYyLjgxMyBMMTY5LjgsMTkuMjEzIEwxNjkuOCw3MC4wODMgWiIgaWQ9IkZpbGwtMTciIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNOTQuMjgyLDExMy45MTcgQzk0LjI0MSwxMTMuOTE3IDk0LjIwMSwxMTMuOTA3IDk0LjE2NSwxMTMuODg2IEM5NC4wOTMsMTEzLjg0NSA5NC4wNDgsMTEzLjc2NyA5NC4wNDgsMTEzLjY4NCBMOTQuMDQ4LDYyLjgxMyBDOTQuMDQ4LDYyLjczIDk0LjA5Myw2Mi42NTIgOTQuMTY1LDYyLjYxMSBMMTY5LjY4MywxOS4wMSBDMTY5Ljc1NSwxOC45NjkgMTY5Ljg0NCwxOC45NjkgMTY5LjkxNywxOS4wMSBDMTY5Ljk4OSwxOS4wNTIgMTcwLjAzMywxOS4xMjkgMTcwLjAzMywxOS4yMTIgTDE3MC4wMzMsNzAuMDgzIEMxNzAuMDMzLDcwLjE2NiAxNjkuOTg5LDcwLjI0NCAxNjkuOTE3LDcwLjI4NSBMMTQyLjU5NSw4Ni4wNiBDMTQyLjUzOCw4Ni4wOTIgMTQyLjQ2OSw4Ni4xIDE0Mi40MDcsODYuMDggQzE0Mi4zNDQsODYuMDYgMTQyLjI5Myw4Ni4wMTQgMTQyLjI2Niw4NS45NTQgTDEzNS44MDUsNzEuNzg2IEMxMzUuNDQ1LDcwLjk5NyAxMzQuODEzLDcwLjU4IDEzMy45NzcsNzAuNTggQzEzMi45MjEsNzAuNTggMTMxLjY3Niw3MS4yNTIgMTMwLjU2Miw3Mi40MjQgQzEyOS41NCw3My41MDEgMTI4LjcxMSw3NC45MzEgMTI4LjI4Nyw3Ni4zNDggTDEyMS44MjcsOTcuOTc2IEMxMjEuODEsOTguMDM0IDEyMS43NzEsOTguMDgyIDEyMS43Miw5OC4xMTIgTDk0LjM5OCwxMTMuODg2IEM5NC4zNjIsMTEzLjkwNyA5NC4zMjIsMTEzLjkxNyA5NC4yODIsMTEzLjkxNyBMOTQuMjgyLDExMy45MTcgWiBNOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDExMy4yNzkgTDEyMS40MDYsOTcuNzU0IEwxMjcuODQsNzYuMjE1IEMxMjguMjksNzQuNzA4IDEyOS4xMzcsNzMuMjQ3IDEzMC4yMjQsNzIuMTAzIEMxMzEuNDI1LDcwLjgzOCAxMzIuNzkzLDcwLjExMiAxMzMuOTc3LDcwLjExMiBDMTM0Ljk5NSw3MC4xMTIgMTM1Ljc5NSw3MC42MzggMTM2LjIzLDcxLjU5MiBMMTQyLjU4NCw4NS41MjYgTDE2OS41NjYsNjkuOTQ4IEwxNjkuNTY2LDE5LjYxNyBMOTQuNTE1LDYyLjk0OCBMOTQuNTE1LDYyLjk0OCBaIiBpZD0iRmlsbC0xOCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMDkuODk0LDkyLjk0MyBMMTA5Ljg5NCw5Mi45NDMgQzEwOC4xMiw5Mi45NDMgMTA2LjY1Myw5Mi4yMTggMTA1LjY1LDkwLjgyMyBDMTA1LjU4Myw5MC43MzEgMTA1LjU5Myw5MC42MSAxMDUuNjczLDkwLjUyOSBDMTA1Ljc1Myw5MC40NDggMTA1Ljg4LDkwLjQ0IDEwNS45NzQsOTAuNTA2IEMxMDYuNzU0LDkxLjA1MyAxMDcuNjc5LDkxLjMzMyAxMDguNzI0LDkxLjMzMyBDMTEwLjA0Nyw5MS4zMzMgMTExLjQ3OCw5MC44OTQgMTEyLjk4LDkwLjAyNyBDMTE4LjI5MSw4Ni45NiAxMjIuNjExLDc5LjUwOSAxMjIuNjExLDczLjQxNiBDMTIyLjYxMSw3MS40ODkgMTIyLjE2OSw2OS44NTYgMTIxLjMzMyw2OC42OTIgQzEyMS4yNjYsNjguNiAxMjEuMjc2LDY4LjQ3MyAxMjEuMzU2LDY4LjM5MiBDMTIxLjQzNiw2OC4zMTEgMTIxLjU2Myw2OC4yOTkgMTIxLjY1Niw2OC4zNjUgQzEyMy4zMjcsNjkuNTM3IDEyNC4yNDcsNzEuNzQ2IDEyNC4yNDcsNzQuNTg0IEMxMjQuMjQ3LDgwLjgyNiAxMTkuODIxLDg4LjQ0NyAxMTQuMzgyLDkxLjU4NyBDMTEyLjgwOCw5Mi40OTUgMTExLjI5OCw5Mi45NDMgMTA5Ljg5NCw5Mi45NDMgTDEwOS44OTQsOTIuOTQzIFogTTEwNi45MjUsOTEuNDAxIEMxMDcuNzM4LDkyLjA1MiAxMDguNzQ1LDkyLjI3OCAxMDkuODkzLDkyLjI3OCBMMTA5Ljg5NCw5Mi4yNzggQzExMS4yMTUsOTIuMjc4IDExMi42NDcsOTEuOTUxIDExNC4xNDgsOTEuMDg0IEMxMTkuNDU5LDg4LjAxNyAxMjMuNzgsODAuNjIxIDEyMy43OCw3NC41MjggQzEyMy43OCw3Mi41NDkgMTIzLjMxNyw3MC45MjkgMTIyLjQ1NCw2OS43NjcgQzEyMi44NjUsNzAuODAyIDEyMy4wNzksNzIuMDQyIDEyMy4wNzksNzMuNDAyIEMxMjMuMDc5LDc5LjY0NSAxMTguNjUzLDg3LjI4NSAxMTMuMjE0LDkwLjQyNSBDMTExLjY0LDkxLjMzNCAxMTAuMTMsOTEuNzQyIDEwOC43MjQsOTEuNzQyIEMxMDguMDgzLDkxLjc0MiAxMDcuNDgxLDkxLjU5MyAxMDYuOTI1LDkxLjQwMSBMMTA2LjkyNSw5MS40MDEgWiIgaWQ9IkZpbGwtMTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjA5Nyw5MC4yMyBDMTE4LjQ4MSw4Ny4xMjIgMTIyLjg0NSw3OS41OTQgMTIyLjg0NSw3My40MTYgQzEyMi44NDUsNzEuMzY1IDEyMi4zNjIsNjkuNzI0IDEyMS41MjIsNjguNTU2IEMxMTkuNzM4LDY3LjMwNCAxMTcuMTQ4LDY3LjM2MiAxMTQuMjY1LDY5LjAyNiBDMTA4Ljg4MSw3Mi4xMzQgMTA0LjUxNyw3OS42NjIgMTA0LjUxNyw4NS44NCBDMTA0LjUxNyw4Ny44OTEgMTA1LDg5LjUzMiAxMDUuODQsOTAuNyBDMTA3LjYyNCw5MS45NTIgMTEwLjIxNCw5MS44OTQgMTEzLjA5Nyw5MC4yMyIgaWQ9IkZpbGwtMjAiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTA4LjcyNCw5MS42MTQgTDEwOC43MjQsOTEuNjE0IEMxMDcuNTgyLDkxLjYxNCAxMDYuNTY2LDkxLjQwMSAxMDUuNzA1LDkwLjc5NyBDMTA1LjY4NCw5MC43ODMgMTA1LjY2NSw5MC44MTEgMTA1LjY1LDkwLjc5IEMxMDQuNzU2LDg5LjU0NiAxMDQuMjgzLDg3Ljg0MiAxMDQuMjgzLDg1LjgxNyBDMTA0LjI4Myw3OS41NzUgMTA4LjcwOSw3MS45NTMgMTE0LjE0OCw2OC44MTIgQzExNS43MjIsNjcuOTA0IDExNy4yMzIsNjcuNDQ5IDExOC42MzgsNjcuNDQ5IEMxMTkuNzgsNjcuNDQ5IDEyMC43OTYsNjcuNzU4IDEyMS42NTYsNjguMzYyIEMxMjEuNjc4LDY4LjM3NyAxMjEuNjk3LDY4LjM5NyAxMjEuNzEyLDY4LjQxOCBDMTIyLjYwNiw2OS42NjIgMTIzLjA3OSw3MS4zOSAxMjMuMDc5LDczLjQxNSBDMTIzLjA3OSw3OS42NTggMTE4LjY1Myw4Ny4xOTggMTEzLjIxNCw5MC4zMzggQzExMS42NCw5MS4yNDcgMTEwLjEzLDkxLjYxNCAxMDguNzI0LDkxLjYxNCBMMTA4LjcyNCw5MS42MTQgWiBNMTA2LjAwNiw5MC41MDUgQzEwNi43OCw5MS4wMzcgMTA3LjY5NCw5MS4yODEgMTA4LjcyNCw5MS4yODEgQzExMC4wNDcsOTEuMjgxIDExMS40NzgsOTAuODY4IDExMi45OCw5MC4wMDEgQzExOC4yOTEsODYuOTM1IDEyMi42MTEsNzkuNDk2IDEyMi42MTEsNzMuNDAzIEMxMjIuNjExLDcxLjQ5NCAxMjIuMTc3LDY5Ljg4IDEyMS4zNTYsNjguNzE4IEMxMjAuNTgyLDY4LjE4NSAxMTkuNjY4LDY3LjkxOSAxMTguNjM4LDY3LjkxOSBDMTE3LjMxNSw2Ny45MTkgMTE1Ljg4Myw2OC4zNiAxMTQuMzgyLDY5LjIyNyBDMTA5LjA3MSw3Mi4yOTMgMTA0Ljc1MSw3OS43MzMgMTA0Ljc1MSw4NS44MjYgQzEwNC43NTEsODcuNzM1IDEwNS4xODUsODkuMzQzIDEwNi4wMDYsOTAuNTA1IEwxMDYuMDA2LDkwLjUwNSBaIiBpZD0iRmlsbC0yMSIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNDkuMzE4LDcuMjYyIEwxMzkuMzM0LDE2LjE0IEwxNTUuMjI3LDI3LjE3MSBMMTYwLjgxNiwyMS4wNTkgTDE0OS4zMTgsNy4yNjIiIGlkPSJGaWxsLTIyIiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2OS42NzYsMTMuODQgTDE1OS45MjgsMTkuNDY3IEMxNTYuMjg2LDIxLjU3IDE1MC40LDIxLjU4IDE0Ni43ODEsMTkuNDkxIEMxNDMuMTYxLDE3LjQwMiAxNDMuMTgsMTQuMDAzIDE0Ni44MjIsMTEuOSBMMTU2LjMxNyw2LjI5MiBMMTQ5LjU4OCwyLjQwNyBMNjcuNzUyLDQ5LjQ3OCBMMTEzLjY3NSw3NS45OTIgTDExNi43NTYsNzQuMjEzIEMxMTcuMzg3LDczLjg0OCAxMTcuNjI1LDczLjMxNSAxMTcuMzc0LDcyLjgyMyBDMTE1LjAxNyw2OC4xOTEgMTE0Ljc4MSw2My4yNzcgMTE2LjY5MSw1OC41NjEgQzEyMi4zMjksNDQuNjQxIDE0MS4yLDMzLjc0NiAxNjUuMzA5LDMwLjQ5MSBDMTczLjQ3OCwyOS4zODggMTgxLjk4OSwyOS41MjQgMTkwLjAxMywzMC44ODUgQzE5MC44NjUsMzEuMDMgMTkxLjc4OSwzMC44OTMgMTkyLjQyLDMwLjUyOCBMMTk1LjUwMSwyOC43NSBMMTY5LjY3NiwxMy44NCIgaWQ9IkZpbGwtMjMiIGZpbGw9IiNGQUZBRkEiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3Ni40NTkgQzExMy41OTQsNzYuNDU5IDExMy41MTQsNzYuNDM4IDExMy40NDIsNzYuMzk3IEw2Ny41MTgsNDkuODgyIEM2Ny4zNzQsNDkuNzk5IDY3LjI4NCw0OS42NDUgNjcuMjg1LDQ5LjQ3OCBDNjcuMjg1LDQ5LjMxMSA2Ny4zNzQsNDkuMTU3IDY3LjUxOSw0OS4wNzMgTDE0OS4zNTUsMi4wMDIgQzE0OS40OTksMS45MTkgMTQ5LjY3NywxLjkxOSAxNDkuODIxLDIuMDAyIEwxNTYuNTUsNS44ODcgQzE1Ni43NzQsNi4wMTcgMTU2Ljg1LDYuMzAyIDE1Ni43MjIsNi41MjYgQzE1Ni41OTIsNi43NDkgMTU2LjMwNyw2LjgyNiAxNTYuMDgzLDYuNjk2IEwxNDkuNTg3LDIuOTQ2IEw2OC42ODcsNDkuNDc5IEwxMTMuNjc1LDc1LjQ1MiBMMTE2LjUyMyw3My44MDggQzExNi43MTUsNzMuNjk3IDExNy4xNDMsNzMuMzk5IDExNi45NTgsNzMuMDM1IEMxMTQuNTQyLDY4LjI4NyAxMTQuMyw2My4yMjEgMTE2LjI1OCw1OC4zODUgQzExOS4wNjQsNTEuNDU4IDEyNS4xNDMsNDUuMTQzIDEzMy44NCw0MC4xMjIgQzE0Mi40OTcsMzUuMTI0IDE1My4zNTgsMzEuNjMzIDE2NS4yNDcsMzAuMDI4IEMxNzMuNDQ1LDI4LjkyMSAxODIuMDM3LDI5LjA1OCAxOTAuMDkxLDMwLjQyNSBDMTkwLjgzLDMwLjU1IDE5MS42NTIsMzAuNDMyIDE5Mi4xODYsMzAuMTI0IEwxOTQuNTY3LDI4Ljc1IEwxNjkuNDQyLDE0LjI0NCBDMTY5LjIxOSwxNC4xMTUgMTY5LjE0MiwxMy44MjkgMTY5LjI3MSwxMy42MDYgQzE2OS40LDEzLjM4MiAxNjkuNjg1LDEzLjMwNiAxNjkuOTA5LDEzLjQzNSBMMTk1LjczNCwyOC4zNDUgQzE5NS44NzksMjguNDI4IDE5NS45NjgsMjguNTgzIDE5NS45NjgsMjguNzUgQzE5NS45NjgsMjguOTE2IDE5NS44NzksMjkuMDcxIDE5NS43MzQsMjkuMTU0IEwxOTIuNjUzLDMwLjkzMyBDMTkxLjkzMiwzMS4zNSAxOTAuODksMzEuNTA4IDE4OS45MzUsMzEuMzQ2IEMxODEuOTcyLDI5Ljk5NSAxNzMuNDc4LDI5Ljg2IDE2NS4zNzIsMzAuOTU0IEMxNTMuNjAyLDMyLjU0MyAxNDIuODYsMzUuOTkzIDEzNC4zMDcsNDAuOTMxIEMxMjUuNzkzLDQ1Ljg0NyAxMTkuODUxLDUyLjAwNCAxMTcuMTI0LDU4LjczNiBDMTE1LjI3LDYzLjMxNCAxMTUuNTAxLDY4LjExMiAxMTcuNzksNzIuNjExIEMxMTguMTYsNzMuMzM2IDExNy44NDUsNzQuMTI0IDExNi45OSw3NC42MTcgTDExMy45MDksNzYuMzk3IEMxMTMuODM2LDc2LjQzOCAxMTMuNzU2LDc2LjQ1OSAxMTMuNjc1LDc2LjQ1OSIgaWQ9IkZpbGwtMjQiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUzLjMxNiwyMS4yNzkgQzE1MC45MDMsMjEuMjc5IDE0OC40OTUsMjAuNzUxIDE0Ni42NjQsMTkuNjkzIEMxNDQuODQ2LDE4LjY0NCAxNDMuODQ0LDE3LjIzMiAxNDMuODQ0LDE1LjcxOCBDMTQzLjg0NCwxNC4xOTEgMTQ0Ljg2LDEyLjc2MyAxNDYuNzA1LDExLjY5OCBMMTU2LjE5OCw2LjA5MSBDMTU2LjMwOSw2LjAyNSAxNTYuNDUyLDYuMDYyIDE1Ni41MTgsNi4xNzMgQzE1Ni41ODMsNi4yODQgMTU2LjU0Nyw2LjQyNyAxNTYuNDM2LDYuNDkzIEwxNDYuOTQsMTIuMTAyIEMxNDUuMjQ0LDEzLjA4MSAxNDQuMzEyLDE0LjM2NSAxNDQuMzEyLDE1LjcxOCBDMTQ0LjMxMiwxNy4wNTggMTQ1LjIzLDE4LjMyNiAxNDYuODk3LDE5LjI4OSBDMTUwLjQ0NiwyMS4zMzggMTU2LjI0LDIxLjMyNyAxNTkuODExLDE5LjI2NSBMMTY5LjU1OSwxMy42MzcgQzE2OS42NywxMy41NzMgMTY5LjgxMywxMy42MTEgMTY5Ljg3OCwxMy43MjMgQzE2OS45NDMsMTMuODM0IDE2OS45MDQsMTMuOTc3IDE2OS43OTMsMTQuMDQyIEwxNjAuMDQ1LDE5LjY3IEMxNTguMTg3LDIwLjc0MiAxNTUuNzQ5LDIxLjI3OSAxNTMuMzE2LDIxLjI3OSIgaWQ9IkZpbGwtMjUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEzLjY3NSw3NS45OTIgTDY3Ljc2Miw0OS40ODQiIGlkPSJGaWxsLTI2IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMy42NzUsNzYuMzQyIEMxMTMuNjE1LDc2LjM0MiAxMTMuNTU1LDc2LjMyNyAxMTMuNSw3Ni4yOTUgTDY3LjU4Nyw0OS43ODcgQzY3LjQxOSw0OS42OSA2Ny4zNjIsNDkuNDc2IDY3LjQ1OSw0OS4zMDkgQzY3LjU1Niw0OS4xNDEgNjcuNzcsNDkuMDgzIDY3LjkzNyw0OS4xOCBMMTEzLjg1LDc1LjY4OCBDMTE0LjAxOCw3NS43ODUgMTE0LjA3NSw3NiAxMTMuOTc4LDc2LjE2NyBDMTEzLjkxNCw3Ni4yNzkgMTEzLjc5Niw3Ni4zNDIgMTEzLjY3NSw3Ni4zNDIiIGlkPSJGaWxsLTI3IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY3Ljc2Miw0OS40ODQgTDY3Ljc2MiwxMDMuNDg1IEM2Ny43NjIsMTA0LjU3NSA2OC41MzIsMTA1LjkwMyA2OS40ODIsMTA2LjQ1MiBMMTExLjk1NSwxMzAuOTczIEMxMTIuOTA1LDEzMS41MjIgMTEzLjY3NSwxMzEuMDgzIDExMy42NzUsMTI5Ljk5MyBMMTEzLjY3NSw3NS45OTIiIGlkPSJGaWxsLTI4IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTExMi43MjcsMTMxLjU2MSBDMTEyLjQzLDEzMS41NjEgMTEyLjEwNywxMzEuNDY2IDExMS43OCwxMzEuMjc2IEw2OS4zMDcsMTA2Ljc1NSBDNjguMjQ0LDEwNi4xNDIgNjcuNDEyLDEwNC43MDUgNjcuNDEyLDEwMy40ODUgTDY3LjQxMiw0OS40ODQgQzY3LjQxMiw0OS4yOSA2Ny41NjksNDkuMTM0IDY3Ljc2Miw0OS4xMzQgQzY3Ljk1Niw0OS4xMzQgNjguMTEzLDQ5LjI5IDY4LjExMyw0OS40ODQgTDY4LjExMywxMDMuNDg1IEM2OC4xMTMsMTA0LjQ0NSA2OC44MiwxMDUuNjY1IDY5LjY1NywxMDYuMTQ4IEwxMTIuMTMsMTMwLjY3IEMxMTIuNDc0LDEzMC44NjggMTEyLjc5MSwxMzAuOTEzIDExMywxMzAuNzkyIEMxMTMuMjA2LDEzMC42NzMgMTEzLjMyNSwxMzAuMzgxIDExMy4zMjUsMTI5Ljk5MyBMMTEzLjMyNSw3NS45OTIgQzExMy4zMjUsNzUuNzk4IDExMy40ODIsNzUuNjQxIDExMy42NzUsNzUuNjQxIEMxMTMuODY5LDc1LjY0MSAxMTQuMDI1LDc1Ljc5OCAxMTQuMDI1LDc1Ljk5MiBMMTE0LjAyNSwxMjkuOTkzIEMxMTQuMDI1LDEzMC42NDggMTEzLjc4NiwxMzEuMTQ3IDExMy4zNSwxMzEuMzk5IEMxMTMuMTYyLDEzMS41MDcgMTEyLjk1MiwxMzEuNTYxIDExMi43MjcsMTMxLjU2MSIgaWQ9IkZpbGwtMjkiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTEyLjg2LDQwLjUxMiBDMTEyLjg2LDQwLjUxMiAxMTIuODYsNDAuNTEyIDExMi44NTksNDAuNTEyIEMxMTAuNTQxLDQwLjUxMiAxMDguMzYsMzkuOTkgMTA2LjcxNywzOS4wNDEgQzEwNS4wMTIsMzguMDU3IDEwNC4wNzQsMzYuNzI2IDEwNC4wNzQsMzUuMjkyIEMxMDQuMDc0LDMzLjg0NyAxMDUuMDI2LDMyLjUwMSAxMDYuNzU0LDMxLjUwNCBMMTE4Ljc5NSwyNC41NTEgQzEyMC40NjMsMjMuNTg5IDEyMi42NjksMjMuMDU4IDEyNS4wMDcsMjMuMDU4IEMxMjcuMzI1LDIzLjA1OCAxMjkuNTA2LDIzLjU4MSAxMzEuMTUsMjQuNTMgQzEzMi44NTQsMjUuNTE0IDEzMy43OTMsMjYuODQ1IDEzMy43OTMsMjguMjc4IEMxMzMuNzkzLDI5LjcyNCAxMzIuODQxLDMxLjA2OSAxMzEuMTEzLDMyLjA2NyBMMTE5LjA3MSwzOS4wMTkgQzExNy40MDMsMzkuOTgyIDExNS4xOTcsNDAuNTEyIDExMi44Niw0MC41MTIgTDExMi44Niw0MC41MTIgWiBNMTI1LjAwNywyMy43NTkgQzEyMi43OSwyMy43NTkgMTIwLjcwOSwyNC4yNTYgMTE5LjE0NiwyNS4xNTggTDEwNy4xMDQsMzIuMTEgQzEwNS42MDIsMzIuOTc4IDEwNC43NzQsMzQuMTA4IDEwNC43NzQsMzUuMjkyIEMxMDQuNzc0LDM2LjQ2NSAxMDUuNTg5LDM3LjU4MSAxMDcuMDY3LDM4LjQzNCBDMTA4LjYwNSwzOS4zMjMgMTEwLjY2MywzOS44MTIgMTEyLjg1OSwzOS44MTIgTDExMi44NiwzOS44MTIgQzExNS4wNzYsMzkuODEyIDExNy4xNTgsMzkuMzE1IDExOC43MjEsMzguNDEzIEwxMzAuNzYyLDMxLjQ2IEMxMzIuMjY0LDMwLjU5MyAxMzMuMDkyLDI5LjQ2MyAxMzMuMDkyLDI4LjI3OCBDMTMzLjA5MiwyNy4xMDYgMTMyLjI3OCwyNS45OSAxMzAuOCwyNS4xMzYgQzEyOS4yNjEsMjQuMjQ4IDEyNy4yMDQsMjMuNzU5IDEyNS4wMDcsMjMuNzU5IEwxMjUuMDA3LDIzLjc1OSBaIiBpZD0iRmlsbC0zMCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNjUuNjMsMTYuMjE5IEwxNTkuODk2LDE5LjUzIEMxNTYuNzI5LDIxLjM1OCAxNTEuNjEsMjEuMzY3IDE0OC40NjMsMTkuNTUgQzE0NS4zMTYsMTcuNzMzIDE0NS4zMzIsMTQuNzc4IDE0OC40OTksMTIuOTQ5IEwxNTQuMjMzLDkuNjM5IEwxNjUuNjMsMTYuMjE5IiBpZD0iRmlsbC0zMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNTQuMjMzLDEwLjQ0OCBMMTY0LjIyOCwxNi4yMTkgTDE1OS41NDYsMTguOTIzIEMxNTguMTEyLDE5Ljc1IDE1Ni4xOTQsMjAuMjA2IDE1NC4xNDcsMjAuMjA2IEMxNTIuMTE4LDIwLjIwNiAxNTAuMjI0LDE5Ljc1NyAxNDguODE0LDE4Ljk0MyBDMTQ3LjUyNCwxOC4xOTkgMTQ2LjgxNCwxNy4yNDkgMTQ2LjgxNCwxNi4yNjkgQzE0Ni44MTQsMTUuMjc4IDE0Ny41MzcsMTQuMzE0IDE0OC44NSwxMy41NTYgTDE1NC4yMzMsMTAuNDQ4IE0xNTQuMjMzLDkuNjM5IEwxNDguNDk5LDEyLjk0OSBDMTQ1LjMzMiwxNC43NzggMTQ1LjMxNiwxNy43MzMgMTQ4LjQ2MywxOS41NSBDMTUwLjAzMSwyMC40NTUgMTUyLjA4NiwyMC45MDcgMTU0LjE0NywyMC45MDcgQzE1Ni4yMjQsMjAuOTA3IDE1OC4zMDYsMjAuNDQ3IDE1OS44OTYsMTkuNTMgTDE2NS42MywxNi4yMTkgTDE1NC4yMzMsOS42MzkiIGlkPSJGaWxsLTMyIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NS40NDUsNzIuNjY3IEwxNDUuNDQ1LDcyLjY2NyBDMTQzLjY3Miw3Mi42NjcgMTQyLjIwNCw3MS44MTcgMTQxLjIwMiw3MC40MjIgQzE0MS4xMzUsNzAuMzMgMTQxLjE0NSw3MC4xNDcgMTQxLjIyNSw3MC4wNjYgQzE0MS4zMDUsNjkuOTg1IDE0MS40MzIsNjkuOTQ2IDE0MS41MjUsNzAuMDExIEMxNDIuMzA2LDcwLjU1OSAxNDMuMjMxLDcwLjgyMyAxNDQuMjc2LDcwLjgyMiBDMTQ1LjU5OCw3MC44MjIgMTQ3LjAzLDcwLjM3NiAxNDguNTMyLDY5LjUwOSBDMTUzLjg0Miw2Ni40NDMgMTU4LjE2Myw1OC45ODcgMTU4LjE2Myw1Mi44OTQgQzE1OC4xNjMsNTAuOTY3IDE1Ny43MjEsNDkuMzMyIDE1Ni44ODQsNDguMTY4IEMxNTYuODE4LDQ4LjA3NiAxNTYuODI4LDQ3Ljk0OCAxNTYuOTA4LDQ3Ljg2NyBDMTU2Ljk4OCw0Ny43ODYgMTU3LjExNCw0Ny43NzQgMTU3LjIwOCw0Ny44NCBDMTU4Ljg3OCw0OS4wMTIgMTU5Ljc5OCw1MS4yMiAxNTkuNzk4LDU0LjA1OSBDMTU5Ljc5OCw2MC4zMDEgMTU1LjM3Myw2OC4wNDYgMTQ5LjkzMyw3MS4xODYgQzE0OC4zNiw3Mi4wOTQgMTQ2Ljg1LDcyLjY2NyAxNDUuNDQ1LDcyLjY2NyBMMTQ1LjQ0NSw3Mi42NjcgWiBNMTQyLjQ3Niw3MSBDMTQzLjI5LDcxLjY1MSAxNDQuMjk2LDcyLjAwMiAxNDUuNDQ1LDcyLjAwMiBDMTQ2Ljc2Nyw3Mi4wMDIgMTQ4LjE5OCw3MS41NSAxNDkuNyw3MC42ODIgQzE1NS4wMSw2Ny42MTcgMTU5LjMzMSw2MC4xNTkgMTU5LjMzMSw1NC4wNjUgQzE1OS4zMzEsNTIuMDg1IDE1OC44NjgsNTAuNDM1IDE1OC4wMDYsNDkuMjcyIEMxNTguNDE3LDUwLjMwNyAxNTguNjMsNTEuNTMyIDE1OC42Myw1Mi44OTIgQzE1OC42Myw1OS4xMzQgMTU0LjIwNSw2Ni43NjcgMTQ4Ljc2NSw2OS45MDcgQzE0Ny4xOTIsNzAuODE2IDE0NS42ODEsNzEuMjgzIDE0NC4yNzYsNzEuMjgzIEMxNDMuNjM0LDcxLjI4MyAxNDMuMDMzLDcxLjE5MiAxNDIuNDc2LDcxIEwxNDIuNDc2LDcxIFoiIGlkPSJGaWxsLTMzIiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0OC42NDgsNjkuNzA0IEMxNTQuMDMyLDY2LjU5NiAxNTguMzk2LDU5LjA2OCAxNTguMzk2LDUyLjg5MSBDMTU4LjM5Niw1MC44MzkgMTU3LjkxMyw0OS4xOTggMTU3LjA3NCw0OC4wMyBDMTU1LjI4OSw0Ni43NzggMTUyLjY5OSw0Ni44MzYgMTQ5LjgxNiw0OC41MDEgQzE0NC40MzMsNTEuNjA5IDE0MC4wNjgsNTkuMTM3IDE0MC4wNjgsNjUuMzE0IEMxNDAuMDY4LDY3LjM2NSAxNDAuNTUyLDY5LjAwNiAxNDEuMzkxLDcwLjE3NCBDMTQzLjE3Niw3MS40MjcgMTQ1Ljc2NSw3MS4zNjkgMTQ4LjY0OCw2OS43MDQiIGlkPSJGaWxsLTM0IiBmaWxsPSIjRkFGQUZBIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTE0NC4yNzYsNzEuMjc2IEwxNDQuMjc2LDcxLjI3NiBDMTQzLjEzMyw3MS4yNzYgMTQyLjExOCw3MC45NjkgMTQxLjI1Nyw3MC4zNjUgQzE0MS4yMzYsNzAuMzUxIDE0MS4yMTcsNzAuMzMyIDE0MS4yMDIsNzAuMzExIEMxNDAuMzA3LDY5LjA2NyAxMzkuODM1LDY3LjMzOSAxMzkuODM1LDY1LjMxNCBDMTM5LjgzNSw1OS4wNzMgMTQ0LjI2LDUxLjQzOSAxNDkuNyw0OC4yOTggQzE1MS4yNzMsNDcuMzkgMTUyLjc4NCw0Ni45MjkgMTU0LjE4OSw0Ni45MjkgQzE1NS4zMzIsNDYuOTI5IDE1Ni4zNDcsNDcuMjM2IDE1Ny4yMDgsNDcuODM5IEMxNTcuMjI5LDQ3Ljg1NCAxNTcuMjQ4LDQ3Ljg3MyAxNTcuMjYzLDQ3Ljg5NCBDMTU4LjE1Nyw0OS4xMzggMTU4LjYzLDUwLjg2NSAxNTguNjMsNTIuODkxIEMxNTguNjMsNTkuMTMyIDE1NC4yMDUsNjYuNzY2IDE0OC43NjUsNjkuOTA3IEMxNDcuMTkyLDcwLjgxNSAxNDUuNjgxLDcxLjI3NiAxNDQuMjc2LDcxLjI3NiBMMTQ0LjI3Niw3MS4yNzYgWiBNMTQxLjU1OCw3MC4xMDQgQzE0Mi4zMzEsNzAuNjM3IDE0My4yNDUsNzEuMDA1IDE0NC4yNzYsNzEuMDA1IEMxNDUuNTk4LDcxLjAwNSAxNDcuMDMsNzAuNDY3IDE0OC41MzIsNjkuNiBDMTUzLjg0Miw2Ni41MzQgMTU4LjE2Myw1OS4wMzMgMTU4LjE2Myw1Mi45MzkgQzE1OC4xNjMsNTEuMDMxIDE1Ny43MjksNDkuMzg1IDE1Ni45MDcsNDguMjIzIEMxNTYuMTMzLDQ3LjY5MSAxNTUuMjE5LDQ3LjQwOSAxNTQuMTg5LDQ3LjQwOSBDMTUyLjg2Nyw0Ny40MDkgMTUxLjQzNSw0Ny44NDIgMTQ5LjkzMyw0OC43MDkgQzE0NC42MjMsNTEuNzc1IDE0MC4zMDIsNTkuMjczIDE0MC4zMDIsNjUuMzY2IEMxNDAuMzAyLDY3LjI3NiAxNDAuNzM2LDY4Ljk0MiAxNDEuNTU4LDcwLjEwNCBMMTQxLjU1OCw3MC4xMDQgWiIgaWQ9IkZpbGwtMzUiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTUwLjcyLDY1LjM2MSBMMTUwLjM1Nyw2NS4wNjYgQzE1MS4xNDcsNjQuMDkyIDE1MS44NjksNjMuMDQgMTUyLjUwNSw2MS45MzggQzE1My4zMTMsNjAuNTM5IDE1My45NzgsNTkuMDY3IDE1NC40ODIsNTcuNTYzIEwxNTQuOTI1LDU3LjcxMiBDMTU0LjQxMiw1OS4yNDUgMTUzLjczMyw2MC43NDUgMTUyLjkxLDYyLjE3MiBDMTUyLjI2Miw2My4yOTUgMTUxLjUyNSw2NC4zNjggMTUwLjcyLDY1LjM2MSIgaWQ9IkZpbGwtMzYiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE1LjkxNyw4NC41MTQgTDExNS41NTQsODQuMjIgQzExNi4zNDQsODMuMjQ1IDExNy4wNjYsODIuMTk0IDExNy43MDIsODEuMDkyIEMxMTguNTEsNzkuNjkyIDExOS4xNzUsNzguMjIgMTE5LjY3OCw3Ni43MTcgTDEyMC4xMjEsNzYuODY1IEMxMTkuNjA4LDc4LjM5OCAxMTguOTMsNzkuODk5IDExOC4xMDYsODEuMzI2IEMxMTcuNDU4LDgyLjQ0OCAxMTYuNzIyLDgzLjUyMSAxMTUuOTE3LDg0LjUxNCIgaWQ9IkZpbGwtMzciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTE0LDEzMC40NzYgTDExNCwxMzAuMDA4IEwxMTQsNzYuMDUyIEwxMTQsNzUuNTg0IEwxMTQsNzYuMDUyIEwxMTQsMTMwLjAwOCBMMTE0LDEzMC40NzYiIGlkPSJGaWxsLTM4IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyBpZD0iSW1wb3J0ZWQtTGF5ZXJzLUNvcHkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYyLjAwMDAwMCwgMC4wMDAwMDApIiBza2V0Y2g6dHlwZT0iTVNTaGFwZUdyb3VwIj4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTkuODIyLDM3LjQ3NCBDMTkuODM5LDM3LjMzOSAxOS43NDcsMzcuMTk0IDE5LjU1NSwzNy4wODIgQzE5LjIyOCwzNi44OTQgMTguNzI5LDM2Ljg3MiAxOC40NDYsMzcuMDM3IEwxMi40MzQsNDAuNTA4IEMxMi4zMDMsNDAuNTg0IDEyLjI0LDQwLjY4NiAxMi4yNDMsNDAuNzkzIEMxMi4yNDUsNDAuOTI1IDEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQxLjM3MSBMMTIuMjQ1LDQxLjQxNCBMMTIuMjM4LDQxLjU0MiBDOC4xNDgsNDMuODg3IDUuNjQ3LDQ1LjMyMSA1LjY0Nyw0NS4zMjEgQzUuNjQ2LDQ1LjMyMSAzLjU3LDQ2LjM2NyAyLjg2LDUwLjUxMyBDMi44Niw1MC41MTMgMS45NDgsNTcuNDc0IDEuOTYyLDcwLjI1OCBDMS45NzcsODIuODI4IDIuNTY4LDg3LjMyOCAzLjEyOSw5MS42MDkgQzMuMzQ5LDkzLjI5MyA2LjEzLDkzLjczNCA2LjEzLDkzLjczNCBDNi40NjEsOTMuNzc0IDYuODI4LDkzLjcwNyA3LjIxLDkzLjQ4NiBMODIuNDgzLDQ5LjkzNSBDODQuMjkxLDQ4Ljg2NiA4NS4xNSw0Ni4yMTYgODUuNTM5LDQzLjY1MSBDODYuNzUyLDM1LjY2MSA4Ny4yMTQsMTAuNjczIDg1LjI2NCwzLjc3MyBDODUuMDY4LDMuMDggODQuNzU0LDIuNjkgODQuMzk2LDIuNDkxIEw4Mi4zMSwxLjcwMSBDODEuNTgzLDEuNzI5IDgwLjg5NCwyLjE2OCA4MC43NzYsMi4yMzYgQzgwLjYzNiwyLjMxNyA0MS44MDcsMjQuNTg1IDIwLjAzMiwzNy4wNzIgTDE5LjgyMiwzNy40NzQiIGlkPSJGaWxsLTEiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNODIuMzExLDEuNzAxIEw4NC4zOTYsMi40OTEgQzg0Ljc1NCwyLjY5IDg1LjA2OCwzLjA4IDg1LjI2NCwzLjc3MyBDODcuMjEzLDEwLjY3MyA4Ni43NTEsMzUuNjYgODUuNTM5LDQzLjY1MSBDODUuMTQ5LDQ2LjIxNiA4NC4yOSw0OC44NjYgODIuNDgzLDQ5LjkzNSBMNy4yMSw5My40ODYgQzYuODk3LDkzLjY2NyA2LjU5NSw5My43NDQgNi4zMTQsOTMuNzQ0IEw2LjEzMSw5My43MzMgQzYuMTMxLDkzLjczNCAzLjM0OSw5My4yOTMgMy4xMjgsOTEuNjA5IEMyLjU2OCw4Ny4zMjcgMS45NzcsODIuODI4IDEuOTYzLDcwLjI1OCBDMS45NDgsNTcuNDc0IDIuODYsNTAuNTEzIDIuODYsNTAuNTEzIEMzLjU3LDQ2LjM2NyA1LjY0Nyw0NS4zMjEgNS42NDcsNDUuMzIxIEM1LjY0Nyw0NS4zMjEgOC4xNDgsNDMuODg3IDEyLjIzOCw0MS41NDIgTDEyLjI0NSw0MS40MTQgTDEyLjI0NSw0MS4zNzEgQzEyLjI0NSw0MS4yNTQgMTIuMjQ1LDQwLjkyNSAxMi4yNDMsNDAuNzkzIEMxMi4yNCw0MC42ODYgMTIuMzAyLDQwLjU4MyAxMi40MzQsNDAuNTA4IEwxOC40NDYsMzcuMDM2IEMxOC41NzQsMzYuOTYyIDE4Ljc0NiwzNi45MjYgMTguOTI3LDM2LjkyNiBDMTkuMTQ1LDM2LjkyNiAxOS4zNzYsMzYuOTc5IDE5LjU1NCwzNy4wODIgQzE5Ljc0NywzNy4xOTQgMTkuODM5LDM3LjM0IDE5LjgyMiwzNy40NzQgTDIwLjAzMywzNy4wNzIgQzQxLjgwNiwyNC41ODUgODAuNjM2LDIuMzE4IDgwLjc3NywyLjIzNiBDODAuODk0LDIuMTY4IDgxLjU4MywxLjcyOSA4Mi4zMTEsMS43MDEgTTgyLjMxMSwwLjcwNCBMODIuMjcyLDAuNzA1IEM4MS42NTQsMC43MjggODAuOTg5LDAuOTQ5IDgwLjI5OCwxLjM2MSBMODAuMjc3LDEuMzczIEM4MC4xMjksMS40NTggNTkuNzY4LDEzLjEzNSAxOS43NTgsMzYuMDc5IEMxOS41LDM1Ljk4MSAxOS4yMTQsMzUuOTI5IDE4LjkyNywzNS45MjkgQzE4LjU2MiwzNS45MjkgMTguMjIzLDM2LjAxMyAxNy45NDcsMzYuMTczIEwxMS45MzUsMzkuNjQ0IEMxMS40OTMsMzkuODk5IDExLjIzNiw0MC4zMzQgMTEuMjQ2LDQwLjgxIEwxMS4yNDcsNDAuOTYgTDUuMTY3LDQ0LjQ0NyBDNC43OTQsNDQuNjQ2IDIuNjI1LDQ1Ljk3OCAxLjg3Nyw1MC4zNDUgTDEuODcxLDUwLjM4NCBDMS44NjIsNTAuNDU0IDAuOTUxLDU3LjU1NyAwLjk2NSw3MC4yNTkgQzAuOTc5LDgyLjg3OSAxLjU2OCw4Ny4zNzUgMi4xMzcsOTEuNzI0IEwyLjEzOSw5MS43MzkgQzIuNDQ3LDk0LjA5NCA1LjYxNCw5NC42NjIgNS45NzUsOTQuNzE5IEw2LjAwOSw5NC43MjMgQzYuMTEsOTQuNzM2IDYuMjEzLDk0Ljc0MiA2LjMxNCw5NC43NDIgQzYuNzksOTQuNzQyIDcuMjYsOTQuNjEgNy43MSw5NC4zNSBMODIuOTgzLDUwLjc5OCBDODQuNzk0LDQ5LjcyNyA4NS45ODIsNDcuMzc1IDg2LjUyNSw0My44MDEgQzg3LjcxMSwzNS45ODcgODguMjU5LDEwLjcwNSA4Ni4yMjQsMy41MDIgQzg1Ljk3MSwyLjYwOSA4NS41MiwxLjk3NSA4NC44ODEsMS42MiBMODQuNzQ5LDEuNTU4IEw4Mi42NjQsMC43NjkgQzgyLjU1MSwwLjcyNSA4Mi40MzEsMC43MDQgODIuMzExLDAuNzA0IiBpZD0iRmlsbC0yIiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTY2LjI2NywxMS41NjUgTDY3Ljc2MiwxMS45OTkgTDExLjQyMyw0NC4zMjUiIGlkPSJGaWxsLTMiIGZpbGw9IiNGRkZGRkYiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMjAyLDkwLjU0NSBDMTIuMDI5LDkwLjU0NSAxMS44NjIsOTAuNDU1IDExLjc2OSw5MC4yOTUgQzExLjYzMiw5MC4wNTcgMTEuNzEzLDg5Ljc1MiAxMS45NTIsODkuNjE0IEwzMC4zODksNzguOTY5IEMzMC42MjgsNzguODMxIDMwLjkzMyw3OC45MTMgMzEuMDcxLDc5LjE1MiBDMzEuMjA4LDc5LjM5IDMxLjEyNyw3OS42OTYgMzAuODg4LDc5LjgzMyBMMTIuNDUxLDkwLjQ3OCBMMTIuMjAyLDkwLjU0NSIgaWQ9IkZpbGwtNCIgZmlsbD0iIzYwN0Q4QiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMy43NjQsNDIuNjU0IEwxMy42NTYsNDIuNTkyIEwxMy43MDIsNDIuNDIxIEwxOC44MzcsMzkuNDU3IEwxOS4wMDcsMzkuNTAyIEwxOC45NjIsMzkuNjczIEwxMy44MjcsNDIuNjM3IEwxMy43NjQsNDIuNjU0IiBpZD0iRmlsbC01IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTguNTIsOTAuMzc1IEw4LjUyLDQ2LjQyMSBMOC41ODMsNDYuMzg1IEw3NS44NCw3LjU1NCBMNzUuODQsNTEuNTA4IEw3NS43NzgsNTEuNTQ0IEw4LjUyLDkwLjM3NSBMOC41Miw5MC4zNzUgWiBNOC43Nyw0Ni41NjQgTDguNzcsODkuOTQ0IEw3NS41OTEsNTEuMzY1IEw3NS41OTEsNy45ODUgTDguNzcsNDYuNTY0IEw4Ljc3LDQ2LjU2NCBaIiBpZD0iRmlsbC02IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTI0Ljk4Niw4My4xODIgQzI0Ljc1Niw4My4zMzEgMjQuMzc0LDgzLjU2NiAyNC4xMzcsODMuNzA1IEwxMi42MzIsOTAuNDA2IEMxMi4zOTUsOTAuNTQ1IDEyLjQyNiw5MC42NTggMTIuNyw5MC42NTggTDEzLjI2NSw5MC42NTggQzEzLjU0LDkwLjY1OCAxMy45NTgsOTAuNTQ1IDE0LjE5NSw5MC40MDYgTDI1LjcsODMuNzA1IEMyNS45MzcsODMuNTY2IDI2LjEyOCw4My40NTIgMjYuMTI1LDgzLjQ0OSBDMjYuMTIyLDgzLjQ0NyAyNi4xMTksODMuMjIgMjYuMTE5LDgyLjk0NiBDMjYuMTE5LDgyLjY3MiAyNS45MzEsODIuNTY5IDI1LjcwMSw4Mi43MTkgTDI0Ljk4Niw4My4xODIiIGlkPSJGaWxsLTciIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTMuMjY2LDkwLjc4MiBMMTIuNyw5MC43ODIgQzEyLjUsOTAuNzgyIDEyLjM4NCw5MC43MjYgMTIuMzU0LDkwLjYxNiBDMTIuMzI0LDkwLjUwNiAxMi4zOTcsOTAuMzk5IDEyLjU2OSw5MC4yOTkgTDI0LjA3NCw4My41OTcgQzI0LjMxLDgzLjQ1OSAyNC42ODksODMuMjI2IDI0LjkxOCw4My4wNzggTDI1LjYzMyw4Mi42MTQgQzI1LjcyMyw4Mi41NTUgMjUuODEzLDgyLjUyNSAyNS44OTksODIuNTI1IEMyNi4wNzEsODIuNTI1IDI2LjI0NCw4Mi42NTUgMjYuMjQ0LDgyLjk0NiBDMjYuMjQ0LDgzLjE2IDI2LjI0NSw4My4zMDkgMjYuMjQ3LDgzLjM4MyBMMjYuMjUzLDgzLjM4NyBMMjYuMjQ5LDgzLjQ1NiBDMjYuMjQ2LDgzLjUzMSAyNi4yNDYsODMuNTMxIDI1Ljc2Myw4My44MTIgTDE0LjI1OCw5MC41MTQgQzE0LDkwLjY2NSAxMy41NjQsOTAuNzgyIDEzLjI2Niw5MC43ODIgTDEzLjI2Niw5MC43ODIgWiBNMTIuNjY2LDkwLjUzMiBMMTIuNyw5MC41MzMgTDEzLjI2Niw5MC41MzMgQzEzLjUxOCw5MC41MzMgMTMuOTE1LDkwLjQyNSAxNC4xMzIsOTAuMjk5IEwyNS42MzcsODMuNTk3IEMyNS44MDUsODMuNDk5IDI1LjkzMSw4My40MjQgMjUuOTk4LDgzLjM4MyBDMjUuOTk0LDgzLjI5OSAyNS45OTQsODMuMTY1IDI1Ljk5NCw4Mi45NDYgTDI1Ljg5OSw4Mi43NzUgTDI1Ljc2OCw4Mi44MjQgTDI1LjA1NCw4My4yODcgQzI0LjgyMiw4My40MzcgMjQuNDM4LDgzLjY3MyAyNC4yLDgzLjgxMiBMMTIuNjk1LDkwLjUxNCBMMTIuNjY2LDkwLjUzMiBMMTIuNjY2LDkwLjUzMiBaIiBpZD0iRmlsbC04IiBmaWxsPSIjNjA3RDhCIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEzLjI2Niw4OS44NzEgTDEyLjcsODkuODcxIEMxMi41LDg5Ljg3MSAxMi4zODQsODkuODE1IDEyLjM1NCw4OS43MDUgQzEyLjMyNCw4OS41OTUgMTIuMzk3LDg5LjQ4OCAxMi41NjksODkuMzg4IEwyNC4wNzQsODIuNjg2IEMyNC4zMzIsODIuNTM1IDI0Ljc2OCw4Mi40MTggMjUuMDY3LDgyLjQxOCBMMjUuNjMyLDgyLjQxOCBDMjUuODMyLDgyLjQxOCAyNS45NDgsODIuNDc0IDI1Ljk3OCw4Mi41ODQgQzI2LjAwOCw4Mi42OTQgMjUuOTM1LDgyLjgwMSAyNS43NjMsODIuOTAxIEwxNC4yNTgsODkuNjAzIEMxNCw4OS43NTQgMTMuNTY0LDg5Ljg3MSAxMy4yNjYsODkuODcxIEwxMy4yNjYsODkuODcxIFogTTEyLjY2Niw4OS42MjEgTDEyLjcsODkuNjIyIEwxMy4yNjYsODkuNjIyIEMxMy41MTgsODkuNjIyIDEzLjkxNSw4OS41MTUgMTQuMTMyLDg5LjM4OCBMMjUuNjM3LDgyLjY4NiBMMjUuNjY3LDgyLjY2OCBMMjUuNjMyLDgyLjY2NyBMMjUuMDY3LDgyLjY2NyBDMjQuODE1LDgyLjY2NyAyNC40MTgsODIuNzc1IDI0LjIsODIuOTAxIEwxMi42OTUsODkuNjAzIEwxMi42NjYsODkuNjIxIEwxMi42NjYsODkuNjIxIFoiIGlkPSJGaWxsLTkiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTIuMzcsOTAuODAxIEwxMi4zNyw4OS41NTQgTDEyLjM3LDkwLjgwMSIgaWQ9IkZpbGwtMTAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNi4xMyw5My45MDEgQzUuMzc5LDkzLjgwOCA0LjgxNiw5My4xNjQgNC42OTEsOTIuNTI1IEMzLjg2LDg4LjI4NyAzLjU0LDgzLjc0MyAzLjUyNiw3MS4xNzMgQzMuNTExLDU4LjM4OSA0LjQyMyw1MS40MjggNC40MjMsNTEuNDI4IEM1LjEzNCw0Ny4yODIgNy4yMSw0Ni4yMzYgNy4yMSw0Ni4yMzYgQzcuMjEsNDYuMjM2IDgxLjY2NywzLjI1IDgyLjA2OSwzLjAxNyBDODIuMjkyLDIuODg4IDg0LjU1NiwxLjQzMyA4NS4yNjQsMy45NCBDODcuMjE0LDEwLjg0IDg2Ljc1MiwzNS44MjcgODUuNTM5LDQzLjgxOCBDODUuMTUsNDYuMzgzIDg0LjI5MSw0OS4wMzMgODIuNDgzLDUwLjEwMSBMNy4yMSw5My42NTMgQzYuODI4LDkzLjg3NCA2LjQ2MSw5My45NDEgNi4xMyw5My45MDEgQzYuMTMsOTMuOTAxIDMuMzQ5LDkzLjQ2IDMuMTI5LDkxLjc3NiBDMi41NjgsODcuNDk1IDEuOTc3LDgyLjk5NSAxLjk2Miw3MC40MjUgQzEuOTQ4LDU3LjY0MSAyLjg2LDUwLjY4IDIuODYsNTAuNjggQzMuNTcsNDYuNTM0IDUuNjQ3LDQ1LjQ4OSA1LjY0Nyw0NS40ODkgQzUuNjQ2LDQ1LjQ4OSA4LjA2NSw0NC4wOTIgMTIuMjQ1LDQxLjY3OSBMMTMuMTE2LDQxLjU2IEwxOS43MTUsMzcuNzMgTDE5Ljc2MSwzNy4yNjkgTDYuMTMsOTMuOTAxIiBpZD0iRmlsbC0xMSIgZmlsbD0iI0ZBRkFGQSI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjMxNyw5NC4xNjEgTDYuMTAyLDk0LjE0OCBMNi4xMDEsOTQuMTQ4IEw1Ljg1Nyw5NC4xMDEgQzUuMTM4LDkzLjk0NSAzLjA4NSw5My4zNjUgMi44ODEsOTEuODA5IEMyLjMxMyw4Ny40NjkgMS43MjcsODIuOTk2IDEuNzEzLDcwLjQyNSBDMS42OTksNTcuNzcxIDIuNjA0LDUwLjcxOCAyLjYxMyw1MC42NDggQzMuMzM4LDQ2LjQxNyA1LjQ0NSw0NS4zMSA1LjUzNSw0NS4yNjYgTDEyLjE2Myw0MS40MzkgTDEzLjAzMyw0MS4zMiBMMTkuNDc5LDM3LjU3OCBMMTkuNTEzLDM3LjI0NCBDMTkuNTI2LDM3LjEwNyAxOS42NDcsMzcuMDA4IDE5Ljc4NiwzNy4wMjEgQzE5LjkyMiwzNy4wMzQgMjAuMDIzLDM3LjE1NiAyMC4wMDksMzcuMjkzIEwxOS45NSwzNy44ODIgTDEzLjE5OCw0MS44MDEgTDEyLjMyOCw0MS45MTkgTDUuNzcyLDQ1LjcwNCBDNS43NDEsNDUuNzIgMy43ODIsNDYuNzcyIDMuMTA2LDUwLjcyMiBDMy4wOTksNTAuNzgyIDIuMTk4LDU3LjgwOCAyLjIxMiw3MC40MjQgQzIuMjI2LDgyLjk2MyAyLjgwOSw4Ny40MiAzLjM3Myw5MS43MjkgQzMuNDY0LDkyLjQyIDQuMDYyLDkyLjg4MyA0LjY4Miw5My4xODEgQzQuNTY2LDkyLjk4NCA0LjQ4Niw5Mi43NzYgNC40NDYsOTIuNTcyIEMzLjY2NSw4OC41ODggMy4yOTEsODQuMzcgMy4yNzYsNzEuMTczIEMzLjI2Miw1OC41MiA0LjE2Nyw1MS40NjYgNC4xNzYsNTEuMzk2IEM0LjkwMSw0Ny4xNjUgNy4wMDgsNDYuMDU5IDcuMDk4LDQ2LjAxNCBDNy4wOTQsNDYuMDE1IDgxLjU0MiwzLjAzNCA4MS45NDQsMi44MDIgTDgxLjk3MiwyLjc4NSBDODIuODc2LDIuMjQ3IDgzLjY5MiwyLjA5NyA4NC4zMzIsMi4zNTIgQzg0Ljg4NywyLjU3MyA4NS4yODEsMy4wODUgODUuNTA0LDMuODcyIEM4Ny41MTgsMTEgODYuOTY0LDM2LjA5MSA4NS43ODUsNDMuODU1IEM4NS4yNzgsNDcuMTk2IDg0LjIxLDQ5LjM3IDgyLjYxLDUwLjMxNyBMNy4zMzUsOTMuODY5IEM2Ljk5OSw5NC4wNjMgNi42NTgsOTQuMTYxIDYuMzE3LDk0LjE2MSBMNi4zMTcsOTQuMTYxIFogTTYuMTcsOTMuNjU0IEM2LjQ2Myw5My42OSA2Ljc3NCw5My42MTcgNy4wODUsOTMuNDM3IEw4Mi4zNTgsNDkuODg2IEM4NC4xODEsNDguODA4IDg0Ljk2LDQ1Ljk3MSA4NS4yOTIsNDMuNzggQzg2LjQ2NiwzNi4wNDkgODcuMDIzLDExLjA4NSA4NS4wMjQsNC4wMDggQzg0Ljg0NiwzLjM3NyA4NC41NTEsMi45NzYgODQuMTQ4LDIuODE2IEM4My42NjQsMi42MjMgODIuOTgyLDIuNzY0IDgyLjIyNywzLjIxMyBMODIuMTkzLDMuMjM0IEM4MS43OTEsMy40NjYgNy4zMzUsNDYuNDUyIDcuMzM1LDQ2LjQ1MiBDNy4zMDQsNDYuNDY5IDUuMzQ2LDQ3LjUyMSA0LjY2OSw1MS40NzEgQzQuNjYyLDUxLjUzIDMuNzYxLDU4LjU1NiAzLjc3NSw3MS4xNzMgQzMuNzksODQuMzI4IDQuMTYxLDg4LjUyNCA0LjkzNiw5Mi40NzYgQzUuMDI2LDkyLjkzNyA1LjQxMiw5My40NTkgNS45NzMsOTMuNjE1IEM2LjA4Nyw5My42NCA2LjE1OCw5My42NTIgNi4xNjksOTMuNjU0IEw2LjE3LDkzLjY1NCBMNi4xNyw5My42NTQgWiIgaWQ9IkZpbGwtMTIiIGZpbGw9IiM0NTVBNjQiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4zMTcsNjguOTgyIEM3LjgwNiw2OC43MDEgOC4yMDIsNjguOTI2IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNi44MjksNzEuMjk0IDYuNDMzLDcxLjA2OSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIiBpZD0iRmlsbC0xMyIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik02LjkyLDcxLjEzMyBDNi42MzEsNzEuMTMzIDYuNDMzLDcwLjkwNSA2LjQzMyw3MC41MDggQzYuNDMzLDY5Ljk0OCA2LjgyOSw2OS4yNjUgNy4zMTcsNjguOTgyIEM3LjQ2LDY4LjkgNy41OTUsNjguODYxIDcuNzE0LDY4Ljg2MSBDOC4wMDMsNjguODYxIDguMjAyLDY5LjA5IDguMjAyLDY5LjQ4NyBDOC4yMDIsNzAuMDQ3IDcuODA2LDcwLjczIDcuMzE3LDcxLjAxMiBDNy4xNzQsNzEuMDk0IDcuMDM5LDcxLjEzMyA2LjkyLDcxLjEzMyBNNy43MTQsNjguNjc0IEM3LjU1Nyw2OC42NzQgNy4zOTIsNjguNzIzIDcuMjI0LDY4LjgyMSBDNi42NzYsNjkuMTM4IDYuMjQ2LDY5Ljg3OSA2LjI0Niw3MC41MDggQzYuMjQ2LDcwLjk5NCA2LjUxNyw3MS4zMiA2LjkyLDcxLjMyIEM3LjA3OCw3MS4zMiA3LjI0Myw3MS4yNzEgNy40MTEsNzEuMTc0IEM3Ljk1OSw3MC44NTcgOC4zODksNzAuMTE3IDguMzg5LDY5LjQ4NyBDOC4zODksNjkuMDAxIDguMTE3LDY4LjY3NCA3LjcxNCw2OC42NzQiIGlkPSJGaWxsLTE0IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTYuOTIsNzAuOTQ3IEM2LjY0OSw3MC45NDcgNi42MjEsNzAuNjQgNi42MjEsNzAuNTA4IEM2LjYyMSw3MC4wMTcgNi45ODIsNjkuMzkyIDcuNDExLDY5LjE0NSBDNy41MjEsNjkuMDgyIDcuNjI1LDY5LjA0OSA3LjcxNCw2OS4wNDkgQzcuOTg2LDY5LjA0OSA4LjAxNSw2OS4zNTUgOC4wMTUsNjkuNDg3IEM4LjAxNSw2OS45NzggNy42NTIsNzAuNjAzIDcuMjI0LDcwLjg1MSBDNy4xMTUsNzAuOTE0IDcuMDEsNzAuOTQ3IDYuOTIsNzAuOTQ3IE03LjcxNCw2OC44NjEgQzcuNTk1LDY4Ljg2MSA3LjQ2LDY4LjkgNy4zMTcsNjguOTgyIEM2LjgyOSw2OS4yNjUgNi40MzMsNjkuOTQ4IDYuNDMzLDcwLjUwOCBDNi40MzMsNzAuOTA1IDYuNjMxLDcxLjEzMyA2LjkyLDcxLjEzMyBDNy4wMzksNzEuMTMzIDcuMTc0LDcxLjA5NCA3LjMxNyw3MS4wMTIgQzcuODA2LDcwLjczIDguMjAyLDcwLjA0NyA4LjIwMiw2OS40ODcgQzguMjAyLDY5LjA5IDguMDAzLDY4Ljg2MSA3LjcxNCw2OC44NjEiIGlkPSJGaWxsLTE1IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTcuNDQ0LDg1LjM1IEM3LjcwOCw4NS4xOTggNy45MjEsODUuMzE5IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuOTI1IDcuNzA4LDg2LjI5MiA3LjQ0NCw4Ni40NDQgQzcuMTgxLDg2LjU5NyA2Ljk2Nyw4Ni40NzUgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IiBpZD0iRmlsbC0xNiIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik03LjIzLDg2LjUxIEM3LjA3NCw4Ni41MSA2Ljk2Nyw4Ni4zODcgNi45NjcsODYuMTczIEM2Ljk2Nyw4NS44NzEgNy4xODEsODUuNTAyIDcuNDQ0LDg1LjM1IEM3LjUyMSw4NS4zMDUgNy41OTQsODUuMjg0IDcuNjU4LDg1LjI4NCBDNy44MTQsODUuMjg0IDcuOTIxLDg1LjQwOCA3LjkyMSw4NS42MjIgQzcuOTIxLDg1LjkyNSA3LjcwOCw4Ni4yOTIgNy40NDQsODYuNDQ0IEM3LjM2Nyw4Ni40ODkgNy4yOTQsODYuNTEgNy4yMyw4Ni41MSBNNy42NTgsODUuMDk4IEM3LjU1OCw4NS4wOTggNy40NTUsODUuMTI3IDcuMzUxLDg1LjE4OCBDNy4wMzEsODUuMzczIDYuNzgxLDg1LjgwNiA2Ljc4MSw4Ni4xNzMgQzYuNzgxLDg2LjQ4MiA2Ljk2Niw4Ni42OTcgNy4yMyw4Ni42OTcgQzcuMzMsODYuNjk3IDcuNDMzLDg2LjY2NiA3LjUzOCw4Ni42MDcgQzcuODU4LDg2LjQyMiA4LjEwOCw4NS45ODkgOC4xMDgsODUuNjIyIEM4LjEwOCw4NS4zMTMgNy45MjMsODUuMDk4IDcuNjU4LDg1LjA5OCIgaWQ9IkZpbGwtMTciIGZpbGw9IiM4MDk3QTIiPjwvcGF0aD4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNNy4yMyw4Ni4zMjIgTDcuMTU0LDg2LjE3MyBDNy4xNTQsODUuOTM4IDcuMzMzLDg1LjYyOSA3LjUzOCw4NS41MTIgTDcuNjU4LDg1LjQ3MSBMNy43MzQsODUuNjIyIEM3LjczNCw4NS44NTYgNy41NTUsODYuMTY0IDcuMzUxLDg2LjI4MiBMNy4yMyw4Ni4zMjIgTTcuNjU4LDg1LjI4NCBDNy41OTQsODUuMjg0IDcuNTIxLDg1LjMwNSA3LjQ0NCw4NS4zNSBDNy4xODEsODUuNTAyIDYuOTY3LDg1Ljg3MSA2Ljk2Nyw4Ni4xNzMgQzYuOTY3LDg2LjM4NyA3LjA3NCw4Ni41MSA3LjIzLDg2LjUxIEM3LjI5NCw4Ni41MSA3LjM2Nyw4Ni40ODkgNy40NDQsODYuNDQ0IEM3LjcwOCw4Ni4yOTIgNy45MjEsODUuOTI1IDcuOTIxLDg1LjYyMiBDNy45MjEsODUuNDA4IDcuODE0LDg1LjI4NCA3LjY1OCw4NS4yODQiIGlkPSJGaWxsLTE4IiBmaWxsPSIjODA5N0EyIj48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTc3LjI3OCw3Ljc2OSBMNzcuMjc4LDUxLjQzNiBMMTAuMjA4LDkwLjE2IEwxMC4yMDgsNDYuNDkzIEw3Ny4yNzgsNy43NjkiIGlkPSJGaWxsLTE5IiBmaWxsPSIjNDU1QTY0Ij48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwLjA4Myw5MC4zNzUgTDEwLjA4Myw0Ni40MjEgTDEwLjE0Niw0Ni4zODUgTDc3LjQwMyw3LjU1NCBMNzcuNDAzLDUxLjUwOCBMNzcuMzQxLDUxLjU0NCBMMTAuMDgzLDkwLjM3NSBMMTAuMDgzLDkwLjM3NSBaIE0xMC4zMzMsNDYuNTY0IEwxMC4zMzMsODkuOTQ0IEw3Ny4xNTQsNTEuMzY1IEw3Ny4xNTQsNy45ODUgTDEwLjMzMyw0Ni41NjQgTDEwLjMzMyw0Ni41NjQgWiIgaWQ9IkZpbGwtMjAiIGZpbGw9IiM2MDdEOEIiPjwvcGF0aD4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMjUuNzM3LDg4LjY0NyBMMTE4LjA5OCw5MS45ODEgTDExOC4wOTgsODQgTDEwNi42MzksODguNzEzIEwxMDYuNjM5LDk2Ljk4MiBMOTksMTAwLjMxNSBMMTEyLjM2OSwxMDMuOTYxIEwxMjUuNzM3LDg4LjY0NyIgaWQ9IkltcG9ydGVkLUxheWVycy1Db3B5LTIiIGZpbGw9IiM0NTVBNjQiIHNrZXRjaDp0eXBlPSJNU1NoYXBlR3JvdXAiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+');
};

module.exports = RotateInstructions;


/***/ }),
/* 711 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SensorSample = __webpack_require__(714);
var MathUtil = __webpack_require__(96);
var Util = __webpack_require__(23);

/**
 * An implementation of a simple complementary filter, which fuses gyroscope and
 * accelerometer data from the 'devicemotion' event.
 *
 * Accelerometer data is very noisy, but stable over the long term.
 * Gyroscope data is smooth, but tends to drift over the long term.
 *
 * This fusion is relatively simple:
 * 1. Get orientation estimates from accelerometer by applying a low-pass filter
 *    on that data.
 * 2. Get orientation estimates from gyroscope by integrating over time.
 * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
 *    short term.
 */
function ComplementaryFilter(kFilter) {
  this.kFilter = kFilter;

  // Raw sensor measurements.
  this.currentAccelMeasurement = new SensorSample();
  this.currentGyroMeasurement = new SensorSample();
  this.previousGyroMeasurement = new SensorSample();

  // Set default look direction to be in the correct direction.
  if (Util.isIOS()) {
    this.filterQ = new MathUtil.Quaternion(-1, 0, 0, 1);
  } else {
    this.filterQ = new MathUtil.Quaternion(1, 0, 0, 1);
  }
  this.previousFilterQ = new MathUtil.Quaternion();
  this.previousFilterQ.copy(this.filterQ);

  // Orientation based on the accelerometer.
  this.accelQ = new MathUtil.Quaternion();
  // Whether or not the orientation has been initialized.
  this.isOrientationInitialized = false;
  // Running estimate of gravity based on the current orientation.
  this.estimatedGravity = new MathUtil.Vector3();
  // Measured gravity based on accelerometer.
  this.measuredGravity = new MathUtil.Vector3();

  // Debug only quaternion of gyro-based orientation.
  this.gyroIntegralQ = new MathUtil.Quaternion();
}

ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
  this.currentAccelMeasurement.set(vector, timestampS);
};

ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
  this.currentGyroMeasurement.set(vector, timestampS);

  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
  if (Util.isTimestampDeltaValid(deltaT)) {
    this.run_();
  }

  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
};

ComplementaryFilter.prototype.run_ = function() {

  if (!this.isOrientationInitialized) {
    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
    this.previousFilterQ.copy(this.accelQ);
    this.isOrientationInitialized = true;
    return;
  }

  var deltaT = this.currentGyroMeasurement.timestampS -
      this.previousGyroMeasurement.timestampS;

  // Convert gyro rotation vector to a quaternion delta.
  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
  this.gyroIntegralQ.multiply(gyroDeltaQ);

  // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
  this.filterQ.copy(this.previousFilterQ);
  this.filterQ.multiply(gyroDeltaQ);

  // Calculate the delta between the current estimated gravity and the real
  // gravity vector from accelerometer.
  var invFilterQ = new MathUtil.Quaternion();
  invFilterQ.copy(this.filterQ);
  invFilterQ.inverse();

  this.estimatedGravity.set(0, 0, -1);
  this.estimatedGravity.applyQuaternion(invFilterQ);
  this.estimatedGravity.normalize();

  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
  this.measuredGravity.normalize();

  // Compare estimated gravity with measured gravity, get the delta quaternion
  // between the two.
  var deltaQ = new MathUtil.Quaternion();
  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
  deltaQ.inverse();

  if (Util.isDebug()) {
    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)',
                MathUtil.radToDeg * Util.getQuaternionAngle(deltaQ),
                (this.estimatedGravity.x).toFixed(1),
                (this.estimatedGravity.y).toFixed(1),
                (this.estimatedGravity.z).toFixed(1),
                (this.measuredGravity.x).toFixed(1),
                (this.measuredGravity.y).toFixed(1),
                (this.measuredGravity.z).toFixed(1));
  }

  // Calculate the SLERP target: current orientation plus the measured-estimated
  // quaternion delta.
  var targetQ = new MathUtil.Quaternion();
  targetQ.copy(this.filterQ);
  targetQ.multiply(deltaQ);

  // SLERP factor: 0 is pure gyro, 1 is pure accel.
  this.filterQ.slerp(targetQ, 1 - this.kFilter);

  this.previousFilterQ.copy(this.filterQ);
};

ComplementaryFilter.prototype.getOrientation = function() {
  return this.filterQ;
};

ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
  var normAccel = new MathUtil.Vector3();
  normAccel.copy(accel);
  normAccel.normalize();
  var quat = new MathUtil.Quaternion();
  quat.setFromUnitVectors(new MathUtil.Vector3(0, 0, -1), normAccel);
  quat.inverse();
  return quat;
};

ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
  // Extract axis and angle from the gyroscope data.
  var quat = new MathUtil.Quaternion();
  var axis = new MathUtil.Vector3();
  axis.copy(gyro);
  axis.normalize();
  quat.setFromAxisAngle(axis, gyro.length() * dt);
  return quat;
};


module.exports = ComplementaryFilter;


/***/ }),
/* 712 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ComplementaryFilter = __webpack_require__(711);
var PosePredictor = __webpack_require__(713);
var TouchPanner = __webpack_require__(715);
var MathUtil = __webpack_require__(96);
var Util = __webpack_require__(23);

/**
 * The pose sensor, implemented using DeviceMotion APIs.
 */
function FusionPoseSensor() {
  this.deviceId = 'webvr-polyfill:fused';
  this.deviceName = 'VR Position Device (webvr-polyfill:fused)';

  this.accelerometer = new MathUtil.Vector3();
  this.gyroscope = new MathUtil.Vector3();

  this.start();

  this.filter = new ComplementaryFilter(window.WebVRConfig.K_FILTER);
  this.posePredictor = new PosePredictor(window.WebVRConfig.PREDICTION_TIME_S);
  this.touchPanner = new TouchPanner();

  this.filterToWorldQ = new MathUtil.Quaternion();

  // Set the filter to world transform, depending on OS.
  if (Util.isIOS()) {
    this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), Math.PI / 2);
  } else {
    this.filterToWorldQ.setFromAxisAngle(new MathUtil.Vector3(1, 0, 0), -Math.PI / 2);
  }

  this.inverseWorldToScreenQ = new MathUtil.Quaternion();
  this.worldToScreenQ = new MathUtil.Quaternion();
  this.originalPoseAdjustQ = new MathUtil.Quaternion();
  this.originalPoseAdjustQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1),
                                           -window.orientation * Math.PI / 180);

  this.setScreenTransform_();
  // Adjust this filter for being in landscape mode.
  if (Util.isLandscapeMode()) {
    this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
  }

  // Keep track of a reset transform for resetSensor.
  this.resetQ = new MathUtil.Quaternion();

  this.isFirefoxAndroid = Util.isFirefoxAndroid();
  this.isIOS = Util.isIOS();

  this.orientationOut_ = new Float32Array(4);
}

FusionPoseSensor.prototype.getPosition = function() {
  // This PoseSensor doesn't support position
  return null;
};

FusionPoseSensor.prototype.getOrientation = function() {
  // Convert from filter space to the the same system used by the
  // deviceorientation event.
  var orientation = this.filter.getOrientation();

  // Predict orientation.
  this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);

  // Convert to THREE coordinate system: -Z forward, Y up, X right.
  var out = new MathUtil.Quaternion();
  out.copy(this.filterToWorldQ);
  out.multiply(this.resetQ);
  if (!window.WebVRConfig.TOUCH_PANNER_DISABLED) {
    out.multiply(this.touchPanner.getOrientation());
  }
  out.multiply(this.predictedQ);
  out.multiply(this.worldToScreenQ);

  // Handle the yaw-only case.
  if (window.WebVRConfig.YAW_ONLY) {
    // Make a quaternion that only turns around the Y-axis.
    out.x = 0;
    out.z = 0;
    out.normalize();
  }

  this.orientationOut_[0] = out.x;
  this.orientationOut_[1] = out.y;
  this.orientationOut_[2] = out.z;
  this.orientationOut_[3] = out.w;
  return this.orientationOut_;
};

FusionPoseSensor.prototype.resetPose = function() {
  // Reduce to inverted yaw-only.
  this.resetQ.copy(this.filter.getOrientation());
  this.resetQ.x = 0;
  this.resetQ.y = 0;
  this.resetQ.z *= -1;
  this.resetQ.normalize();

  // Take into account extra transformations in landscape mode.
  if (Util.isLandscapeMode()) {
    this.resetQ.multiply(this.inverseWorldToScreenQ);
  }

  // Take into account original pose.
  this.resetQ.multiply(this.originalPoseAdjustQ);

  if (!window.WebVRConfig.TOUCH_PANNER_DISABLED) {
    this.touchPanner.resetSensor();
  }
};

FusionPoseSensor.prototype.onDeviceMotion_ = function(deviceMotion) {
  this.updateDeviceMotion_(deviceMotion);
};

FusionPoseSensor.prototype.updateDeviceMotion_ = function(deviceMotion) {
  var accGravity = deviceMotion.accelerationIncludingGravity;
  var rotRate = deviceMotion.rotationRate;
  var timestampS = deviceMotion.timeStamp / 1000;

  var deltaS = timestampS - this.previousTimestampS;
  if (deltaS <= Util.MIN_TIMESTEP || deltaS > Util.MAX_TIMESTEP) {
    console.warn('Invalid timestamps detected. Time step between successive ' +
                 'gyroscope sensor samples is very small or not monotonic');
    this.previousTimestampS = timestampS;
    return;
  }
  this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
  this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);

  // With iOS and Firefox Android, rotationRate is reported in degrees,
  // so we first convert to radians.
  if (this.isIOS || this.isFirefoxAndroid) {
    this.gyroscope.multiplyScalar(Math.PI / 180);
  }

  this.filter.addAccelMeasurement(this.accelerometer, timestampS);
  this.filter.addGyroMeasurement(this.gyroscope, timestampS);

  this.previousTimestampS = timestampS;
};

FusionPoseSensor.prototype.onOrientationChange_ = function(screenOrientation) {
  this.setScreenTransform_();
};

/**
 * This is only needed if we are in an cross origin iframe on iOS to work around
 * this issue: https://bugs.webkit.org/show_bug.cgi?id=152299.
 */
FusionPoseSensor.prototype.onMessage_ = function(event) {
  var message = event.data;

  // If there's no message type, ignore it.
  if (!message || !message.type) {
    return;
  }

  // Ignore all messages that aren't devicemotion.
  var type = message.type.toLowerCase();
  if (type !== 'devicemotion') {
    return;
  }

  // Update device motion.
  this.updateDeviceMotion_(message.deviceMotionEvent);
};

FusionPoseSensor.prototype.setScreenTransform_ = function() {
  this.worldToScreenQ.set(0, 0, 0, 1);
  switch (window.orientation) {
    case 0:
      break;
    case 90:
      this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), -Math.PI / 2);
      break;
    case -90:
      this.worldToScreenQ.setFromAxisAngle(new MathUtil.Vector3(0, 0, 1), Math.PI / 2);
      break;
    case 180:
      // TODO.
      break;
  }
  this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
  this.inverseWorldToScreenQ.inverse();
};

FusionPoseSensor.prototype.start = function() {
  this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this);
  this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this);
  this.onMessageCallback_ = this.onMessage_.bind(this);

  // Only listen for postMessages if we're in an iOS and embedded inside a cross
  // domain IFrame. In this case, the polyfill can still work if the containing
  // page sends synthetic devicemotion events. For an example of this, see
  // iframe-message-sender.js in VR View: https://goo.gl/XDtvFZ
  if (Util.isIOS() && Util.isInsideCrossDomainIFrame()) {
    window.addEventListener('message', this.onMessageCallback_);
  }
  window.addEventListener('orientationchange', this.onOrientationChangeCallback_);
  window.addEventListener('devicemotion', this.onDeviceMotionCallback_);
};

FusionPoseSensor.prototype.stop = function() {
  window.removeEventListener('devicemotion', this.onDeviceMotionCallback_);
  window.removeEventListener('orientationchange', this.onOrientationChangeCallback_);
  window.removeEventListener('message', this.onMessageCallback_);
};

module.exports = FusionPoseSensor;


/***/ }),
/* 713 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MathUtil = __webpack_require__(96);
var Util = __webpack_require__(23);

/**
 * Given an orientation and the gyroscope data, predicts the future orientation
 * of the head. This makes rendering appear faster.
 *
 * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
 *
 * @param {Number} predictionTimeS time from head movement to the appearance of
 * the corresponding image.
 */
function PosePredictor(predictionTimeS) {
  this.predictionTimeS = predictionTimeS;

  // The quaternion corresponding to the previous state.
  this.previousQ = new MathUtil.Quaternion();
  // Previous time a prediction occurred.
  this.previousTimestampS = null;

  // The delta quaternion that adjusts the current pose.
  this.deltaQ = new MathUtil.Quaternion();
  // The output quaternion.
  this.outQ = new MathUtil.Quaternion();
}

PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
  if (!this.previousTimestampS) {
    this.previousQ.copy(currentQ);
    this.previousTimestampS = timestampS;
    return currentQ;
  }

  // Calculate axis and angle based on gyroscope rotation rate data.
  var axis = new MathUtil.Vector3();
  axis.copy(gyro);
  axis.normalize();

  var angularSpeed = gyro.length();

  // If we're rotating slowly, don't do prediction.
  if (angularSpeed < MathUtil.degToRad * 20) {
    if (Util.isDebug()) {
      console.log('Moving slowly, at %s deg/s: no prediction',
                  (MathUtil.radToDeg * angularSpeed).toFixed(1));
    }
    this.outQ.copy(currentQ);
    this.previousQ.copy(currentQ);
    return this.outQ;
  }

  // Get the predicted angle based on the time delta and latency.
  var deltaT = timestampS - this.previousTimestampS;
  var predictAngle = angularSpeed * this.predictionTimeS;

  this.deltaQ.setFromAxisAngle(axis, predictAngle);
  this.outQ.copy(this.previousQ);
  this.outQ.multiply(this.deltaQ);

  this.previousQ.copy(currentQ);
  this.previousTimestampS = timestampS;

  return this.outQ;
};


module.exports = PosePredictor;


/***/ }),
/* 714 */
/***/ (function(module, exports) {

function SensorSample(sample, timestampS) {
  this.set(sample, timestampS);
};

SensorSample.prototype.set = function(sample, timestampS) {
  this.sample = sample;
  this.timestampS = timestampS;
};

SensorSample.prototype.copy = function(sensorSample) {
  this.set(sensorSample.sample, sensorSample.timestampS);
};

module.exports = SensorSample;


/***/ }),
/* 715 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MathUtil = __webpack_require__(96);
var Util = __webpack_require__(23);

var ROTATE_SPEED = 0.5;
/**
 * Provides a quaternion responsible for pre-panning the scene before further
 * transformations due to device sensors.
 */
function TouchPanner() {
  window.addEventListener('touchstart', this.onTouchStart_.bind(this));
  window.addEventListener('touchmove', this.onTouchMove_.bind(this));
  window.addEventListener('touchend', this.onTouchEnd_.bind(this));

  this.isTouching = false;
  this.rotateStart = new MathUtil.Vector2();
  this.rotateEnd = new MathUtil.Vector2();
  this.rotateDelta = new MathUtil.Vector2();

  this.theta = 0;
  this.orientation = new MathUtil.Quaternion();
}

TouchPanner.prototype.getOrientation = function() {
  this.orientation.setFromEulerXYZ(0, 0, this.theta);
  return this.orientation;
};

TouchPanner.prototype.resetSensor = function() {
  this.theta = 0;
};

TouchPanner.prototype.onTouchStart_ = function(e) {
  // Only respond if there is exactly one touch.
  // Note that the Daydream controller passes in a `touchstart` event with
  // no `touches` property, so we must check for that case too.
  if (!e.touches || e.touches.length != 1) {
    return;
  }
  this.rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);
  this.isTouching = true;
};

TouchPanner.prototype.onTouchMove_ = function(e) {
  if (!this.isTouching) {
    return;
  }
  this.rotateEnd.set(e.touches[0].pageX, e.touches[0].pageY);
  this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
  this.rotateStart.copy(this.rotateEnd);

  // On iOS, direction is inverted.
  if (Util.isIOS()) {
    this.rotateDelta.x *= -1;
  }

  var element = document.body;
  this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * ROTATE_SPEED;
};

TouchPanner.prototype.onTouchEnd_ = function(e) {
  this.isTouching = false;
};

module.exports = TouchPanner;


/***/ }),
/* 716 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DeviceInfo = __webpack_require__(314);
var Util = __webpack_require__(23);

var DEFAULT_VIEWER = 'CardboardV1';
var VIEWER_KEY = 'WEBVR_CARDBOARD_VIEWER';
var CLASS_NAME = 'webvr-polyfill-viewer-selector';

/**
 * Creates a viewer selector with the options specified. Supports being shown
 * and hidden. Generates events when viewer parameters change. Also supports
 * saving the currently selected index in localStorage.
 */
function ViewerSelector() {
  // Try to load the selected key from local storage.
  try {
    this.selectedKey = localStorage.getItem(VIEWER_KEY);
  } catch (error) {
    console.error('Failed to load viewer profile: %s', error);
  }

  //If none exists, or if localstorage is unavailable, use the default key.
  if (!this.selectedKey) {
    this.selectedKey = DEFAULT_VIEWER;
  }

  this.dialog = this.createDialog_(DeviceInfo.Viewers);
  this.root = null;
  this.onChangeCallbacks_ = [];
}

ViewerSelector.prototype.show = function(root) {
  this.root = root;

  root.appendChild(this.dialog);

  // Ensure the currently selected item is checked.
  var selected = this.dialog.querySelector('#' + this.selectedKey);
  selected.checked = true;

  // Show the UI.
  this.dialog.style.display = 'block';
};

ViewerSelector.prototype.hide = function() {
  if (this.root && this.root.contains(this.dialog)) {
    this.root.removeChild(this.dialog);
  }
  this.dialog.style.display = 'none';
};

ViewerSelector.prototype.getCurrentViewer = function() {
  return DeviceInfo.Viewers[this.selectedKey];
};

ViewerSelector.prototype.getSelectedKey_ = function() {
  var input = this.dialog.querySelector('input[name=field]:checked');
  if (input) {
    return input.id;
  }
  return null;
};

ViewerSelector.prototype.onChange = function(cb) {
  this.onChangeCallbacks_.push(cb);
};

ViewerSelector.prototype.fireOnChange_ = function(viewer) {
  for (var i = 0; i < this.onChangeCallbacks_.length; i++) {
    this.onChangeCallbacks_[i](viewer);
  }
};

ViewerSelector.prototype.onSave_ = function() {
  this.selectedKey = this.getSelectedKey_();
  if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
    console.error('ViewerSelector.onSave_: this should never happen!');
    return;
  }

  this.fireOnChange_(DeviceInfo.Viewers[this.selectedKey]);

  // Attempt to save the viewer profile, but fails in private mode.
  try {
    localStorage.setItem(VIEWER_KEY, this.selectedKey);
  } catch(error) {
    console.error('Failed to save viewer profile: %s', error);
  }
  this.hide();
};

/**
 * Creates the dialog.
 */
ViewerSelector.prototype.createDialog_ = function(options) {
  var container = document.createElement('div');
  container.classList.add(CLASS_NAME);
  container.style.display = 'none';
  // Create an overlay that dims the background, and which goes away when you
  // tap it.
  var overlay = document.createElement('div');
  var s = overlay.style;
  s.position = 'fixed';
  s.left = 0;
  s.top = 0;
  s.width = '100%';
  s.height = '100%';
  s.background = 'rgba(0, 0, 0, 0.3)';
  overlay.addEventListener('click', this.hide.bind(this));

  var width = 280;
  var dialog = document.createElement('div');
  var s = dialog.style;
  s.boxSizing = 'border-box';
  s.position = 'fixed';
  s.top = '24px';
  s.left = '50%';
  s.marginLeft = (-width/2) + 'px';
  s.width = width + 'px';
  s.padding = '24px';
  s.overflow = 'hidden';
  s.background = '#fafafa';
  s.fontFamily = "'Roboto', sans-serif";
  s.boxShadow = '0px 5px 20px #666';

  dialog.appendChild(this.createH1_('Select your viewer'));
  for (var id in options) {
    dialog.appendChild(this.createChoice_(id, options[id].label));
  }
  dialog.appendChild(this.createButton_('Save', this.onSave_.bind(this)));

  container.appendChild(overlay);
  container.appendChild(dialog);

  return container;
};

ViewerSelector.prototype.createH1_ = function(name) {
  var h1 = document.createElement('h1');
  var s = h1.style;
  s.color = 'black';
  s.fontSize = '20px';
  s.fontWeight = 'bold';
  s.marginTop = 0;
  s.marginBottom = '24px';
  h1.innerHTML = name;
  return h1;
};

ViewerSelector.prototype.createChoice_ = function(id, name) {
  /*
  <div class="choice">
  <input id="v1" type="radio" name="field" value="v1">
  <label for="v1">Cardboard V1</label>
  </div>
  */
  var div = document.createElement('div');
  div.style.marginTop = '8px';
  div.style.color = 'black';

  var input = document.createElement('input');
  input.style.fontSize = '30px';
  input.setAttribute('id', id);
  input.setAttribute('type', 'radio');
  input.setAttribute('value', id);
  input.setAttribute('name', 'field');

  var label = document.createElement('label');
  label.style.marginLeft = '4px';
  label.setAttribute('for', id);
  label.innerHTML = name;

  div.appendChild(input);
  div.appendChild(label);

  return div;
};

ViewerSelector.prototype.createButton_ = function(label, onclick) {
  var button = document.createElement('button');
  button.innerHTML = label;
  var s = button.style;
  s.float = 'right';
  s.textTransform = 'uppercase';
  s.color = '#1094f7';
  s.fontSize = '14px';
  s.letterSpacing = 0;
  s.border = 0;
  s.background = 'none';
  s.marginTop = '16px';

  button.addEventListener('click', onclick);

  return button;
};

module.exports = ViewerSelector;


/***/ }),
/* 717 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = __webpack_require__(23);

/**
 * Android and iOS compatible wakelock implementation.
 *
 * Refactored thanks to dkovalev@.
 */
function AndroidWakeLock() {
  var video = document.createElement('video');
  video.setAttribute('loop', '');

  function addSourceToVideo(element, type, dataURI) {
    var source = document.createElement('source');
    source.src = dataURI;
    source.type = 'video/' + type;
    element.appendChild(source);
  }

  addSourceToVideo(video,'webm', Util.base64('video/webm', 'GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA='));
  addSourceToVideo(video, 'mp4', Util.base64('video/mp4', 'AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAAG21kYXQAAAGzABAHAAABthADAowdbb9/AAAC6W1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAAAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIVdHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAIAAAACAAAAAABsW1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAAA+gAAAAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAVxtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAEcc3RibAAAALhzdHNkAAAAAAAAAAEAAACobXA0dgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIAAgASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAAFJlc2RzAAAAAANEAAEABDwgEQAAAAADDUAAAAAABS0AAAGwAQAAAbWJEwAAAQAAAAEgAMSNiB9FAEQBFGMAAAGyTGF2YzUyLjg3LjQGAQIAAAAYc3R0cwAAAAAAAAABAAAAAQAAAAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAAEwAAAAEAAAAUc3RjbwAAAAAAAAABAAAALAAAAGB1ZHRhAAAAWG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAK2lsc3QAAAAjqXRvbwAAABtkYXRhAAAAAQAAAABMYXZmNTIuNzguMw=='));

  this.request = function() {
    if (video.paused) {
      video.play();
    }
  };

  this.release = function() {
    video.pause();
  };
}

function iOSWakeLock() {
  var timer = null;

  this.request = function() {
    if (!timer) {
      timer = setInterval(function() {
        window.location = window.location;
        setTimeout(window.stop, 0);
      }, 30000);
    }
  }

  this.release = function() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
}


function getWakeLock() {
  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
  if (userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
    return iOSWakeLock;
  } else {
    return AndroidWakeLock;
  }
}

module.exports = getWakeLock();

/***/ }),
/* 718 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = __webpack_require__(23);
var CardboardVRDisplay = __webpack_require__(703);
var MouseKeyboardVRDisplay = __webpack_require__(708);
// Uncomment to add positional tracking via webcam.
//var WebcamPositionSensorVRDevice = require('./webcam-position-sensor-vr-device.js');
var VRDisplay = __webpack_require__(55).VRDisplay;
var VRFrameData = __webpack_require__(55).VRFrameData;
var HMDVRDevice = __webpack_require__(55).HMDVRDevice;
var PositionSensorVRDevice = __webpack_require__(55).PositionSensorVRDevice;
var VRDisplayHMDDevice = __webpack_require__(315).VRDisplayHMDDevice;
var VRDisplayPositionSensorDevice = __webpack_require__(315).VRDisplayPositionSensorDevice;
var version = __webpack_require__(701).version;

function WebVRPolyfill() {
  this.displays = [];
  this.devices = []; // For deprecated objects
  this.devicesPopulated = false;
  this.nativeWebVRAvailable = this.isWebVRAvailable();
  this.nativeLegacyWebVRAvailable = this.isDeprecatedWebVRAvailable();
  this.nativeGetVRDisplaysFunc = this.nativeWebVRAvailable ?
                                 navigator.getVRDisplays :
                                 null;

  if (!this.nativeLegacyWebVRAvailable) {
    this.enablePolyfill();
    if (window.WebVRConfig.ENABLE_DEPRECATED_API) {
      this.enableDeprecatedPolyfill();
    }
  }

  // Put a shim in place to update the API to 1.1 if needed.
  InstallWebVRSpecShim();
}

WebVRPolyfill.prototype.isWebVRAvailable = function() {
  return ('getVRDisplays' in navigator);
};

WebVRPolyfill.prototype.isDeprecatedWebVRAvailable = function() {
  return ('getVRDevices' in navigator) || ('mozGetVRDevices' in navigator);
};

WebVRPolyfill.prototype.connectDisplay = function(vrDisplay) {
  vrDisplay.fireVRDisplayConnect_();
  this.displays.push(vrDisplay);
};

WebVRPolyfill.prototype.populateDevices = function() {
  if (this.devicesPopulated) {
    return;
  }

  // Initialize our virtual VR devices.
  var vrDisplay = null;

  // Add a Cardboard VRDisplay on compatible mobile devices
  if (this.isCardboardCompatible()) {
    vrDisplay = new CardboardVRDisplay();

    this.connectDisplay(vrDisplay);

    // For backwards compatibility
    if (window.WebVRConfig.ENABLE_DEPRECATED_API) {
      this.devices.push(new VRDisplayHMDDevice(vrDisplay));
      this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
    }
  }

  // Add a Mouse and Keyboard driven VRDisplay for desktops/laptops
  if (!this.isMobile() && !window.WebVRConfig.MOUSE_KEYBOARD_CONTROLS_DISABLED) {
    vrDisplay = new MouseKeyboardVRDisplay();
    this.connectDisplay(vrDisplay);

    // For backwards compatibility
    if (window.WebVRConfig.ENABLE_DEPRECATED_API) {
      this.devices.push(new VRDisplayHMDDevice(vrDisplay));
      this.devices.push(new VRDisplayPositionSensorDevice(vrDisplay));
    }
  }

  // Uncomment to add positional tracking via webcam.
  //if (!this.isMobile() && window.WebVRConfig.ENABLE_DEPRECATED_API) {
  //  positionDevice = new WebcamPositionSensorVRDevice();
  //  this.devices.push(positionDevice);
  //}

  this.devicesPopulated = true;
};

WebVRPolyfill.prototype.enablePolyfill = function() {
  // Provide navigator.getVRDisplays.
  navigator.getVRDisplays = this.getVRDisplays.bind(this);

  // Polyfill native VRDisplay.getFrameData
  if (this.nativeWebVRAvailable && window.VRFrameData) {
    var NativeVRFrameData = window.VRFrameData;
    var nativeFrameData = new window.VRFrameData();
    var nativeGetFrameData = window.VRDisplay.prototype.getFrameData;
    window.VRFrameData = VRFrameData;

    window.VRDisplay.prototype.getFrameData = function(frameData) {
      if (frameData instanceof NativeVRFrameData) {
        nativeGetFrameData.call(this, frameData);
        return;
      }

      /*
      Copy frame data from the native object into the polyfilled object.
      */

      nativeGetFrameData.call(this, nativeFrameData);
      frameData.pose = nativeFrameData.pose;
      Util.copyArray(nativeFrameData.leftProjectionMatrix, frameData.leftProjectionMatrix);
      Util.copyArray(nativeFrameData.rightProjectionMatrix, frameData.rightProjectionMatrix);
      Util.copyArray(nativeFrameData.leftViewMatrix, frameData.leftViewMatrix);
      Util.copyArray(nativeFrameData.rightViewMatrix, frameData.rightViewMatrix);
      //todo: copy
    };
  }

  // Provide the `VRDisplay` object.
  window.VRDisplay = VRDisplay;

  // Provide the `navigator.vrEnabled` property.
  if (navigator && !navigator.vrEnabled) {
    var self = this;
    Object.defineProperty(navigator, 'vrEnabled', {
      get: function () {
        return self.isCardboardCompatible() &&
            (self.isFullScreenAvailable() || Util.isIOS());
      }
    });
  }

  if (!('VRFrameData' in window)) {
    // Provide the VRFrameData object.
    window.VRFrameData = VRFrameData;
  }
};

WebVRPolyfill.prototype.enableDeprecatedPolyfill = function() {
  // Provide navigator.getVRDevices.
  navigator.getVRDevices = this.getVRDevices.bind(this);

  // Provide the CardboardHMDVRDevice and PositionSensorVRDevice objects.
  window.HMDVRDevice = HMDVRDevice;
  window.PositionSensorVRDevice = PositionSensorVRDevice;
};

WebVRPolyfill.prototype.getVRDisplays = function() {
  this.populateDevices();
  var polyfillDisplays = this.displays;

  if (!this.nativeWebVRAvailable) {
    return Promise.resolve(polyfillDisplays);
  }

  // Set up a race condition if this browser has a bug where
  // `navigator.getVRDisplays()` never resolves.
  var timeoutId;
  var vrDisplaysNative = this.nativeGetVRDisplaysFunc.call(navigator);
  var timeoutPromise = new Promise(function(resolve) {
    timeoutId = setTimeout(function() {
      console.warn('Native WebVR implementation detected, but `getVRDisplays()` failed to resolve. Falling back to polyfill.');
      resolve([]);
    }, window.WebVRConfig.GET_VR_DISPLAYS_TIMEOUT);
  });

  return Util.race([
    vrDisplaysNative,
    timeoutPromise
  ]).then(function(nativeDisplays) {
    clearTimeout(timeoutId);
    if (window.WebVRConfig.ALWAYS_APPEND_POLYFILL_DISPLAY) {
      return nativeDisplays.concat(polyfillDisplays);
    } else {
      return nativeDisplays.length > 0 ? nativeDisplays : polyfillDisplays;
    }
  });
};

WebVRPolyfill.prototype.getVRDevices = function() {
  console.warn('getVRDevices is deprecated. Please update your code to use getVRDisplays instead.');
  var self = this;
  return new Promise(function(resolve, reject) {
    try {
      if (!self.devicesPopulated) {
        if (self.nativeWebVRAvailable) {
          return navigator.getVRDisplays(function(displays) {
            for (var i = 0; i < displays.length; ++i) {
              self.devices.push(new VRDisplayHMDDevice(displays[i]));
              self.devices.push(new VRDisplayPositionSensorDevice(displays[i]));
            }
            self.devicesPopulated = true;
            resolve(self.devices);
          }, reject);
        }

        if (self.nativeLegacyWebVRAvailable) {
          return (navigator.getVRDDevices || navigator.mozGetVRDevices)(function(devices) {
            for (var i = 0; i < devices.length; ++i) {
              if (devices[i] instanceof HMDVRDevice) {
                self.devices.push(devices[i]);
              }
              if (devices[i] instanceof PositionSensorVRDevice) {
                self.devices.push(devices[i]);
              }
            }
            self.devicesPopulated = true;
            resolve(self.devices);
          }, reject);
        }
      }

      self.populateDevices();
      resolve(self.devices);
    } catch (e) {
      reject(e);
    }
  });
};

WebVRPolyfill.prototype.NativeVRFrameData = window.VRFrameData;

/**
 * Determine if a device is mobile.
 */
WebVRPolyfill.prototype.isMobile = function() {
  return /Android/i.test(navigator.userAgent) ||
      /iPhone|iPad|iPod/i.test(navigator.userAgent);
};

WebVRPolyfill.prototype.isCardboardCompatible = function() {
  // For now, support all iOS and Android devices.
  // Also enable the WebVRConfig.FORCE_VR flag for debugging.
  return this.isMobile() || window.WebVRConfig.FORCE_ENABLE_VR;
};

WebVRPolyfill.prototype.isFullScreenAvailable = function() {
  return (document.fullscreenEnabled ||
          document.mozFullScreenEnabled ||
          document.webkitFullscreenEnabled ||
          false);
};

// Installs a shim that updates a WebVR 1.0 spec implementation to WebVR 1.1
function InstallWebVRSpecShim() {
  if ('VRDisplay' in window && !('VRFrameData' in window)) {
    // Provide the VRFrameData object.
    window.VRFrameData = VRFrameData;

    // A lot of Chrome builds don't have depthNear and depthFar, even
    // though they're in the WebVR 1.0 spec. Patch them in if they're not present.
    if(!('depthNear' in window.VRDisplay.prototype)) {
      window.VRDisplay.prototype.depthNear = 0.01;
    }

    if(!('depthFar' in window.VRDisplay.prototype)) {
      window.VRDisplay.prototype.depthFar = 10000.0;
    }

    window.VRDisplay.prototype.getFrameData = function(frameData) {
      return Util.frameDataFromPose(frameData, this.getPose(), this);
    }
  }
};

WebVRPolyfill.InstallWebVRSpecShim = InstallWebVRSpecShim;
WebVRPolyfill.version = version;

module.exports.WebVRPolyfill = WebVRPolyfill;


/***/ }),
/* 719 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 720 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(316);


/***/ })
/******/ ]);
});
//# sourceMappingURL=claraplayer-2.3.41.js.map
